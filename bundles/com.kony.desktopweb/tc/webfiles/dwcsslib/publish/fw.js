/* FILE PATH :: 'jslib/tparty/requirejs/require.js' */
/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.2.0 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/requirejs/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.2.0',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, multi, multiText, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 120,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2], null, {
                            enabled: true
                        });
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                          if (isWebWorker) {
                          	requireMod = getModule(makeModuleMap(null, relMap));
                          	requireMod.init([id], function(){}, function(){}, {
                          	enabled: true
                          	});
                          }else{
                            context.completeLoad(id);
                            if(!defined[id]){
                              return onError(makeError('notloaded', 'Module name "' +
                                                        id +
                                                        '" has not been loaded yet for context: ' +
                                                        contextName +
                                                        (relMap ? '' : '. Use require([])')));
                            }
                            /*

                            */
                          }
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;

            head.appendChild(node);

            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                //setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));


/* FILE PATH :: 'jslib/tparty/crypto/cryptojslib.js' */
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/

//AES Algo (aes.js)
var CryptoJS = CryptoJS || function (u, p) {
    var d = {}, l = d.lib = {}, s = function () { }, t = l.Base = { extend: function (a) { s.prototype = this; var c = new s; a && c.mixIn(a); c.hasOwnProperty("init") || (c.init = function () { c.$super.init.apply(this, arguments) }); c.init.prototype = c; c.$super = this; return c }, create: function () { var a = this.extend(); a.init.apply(a, arguments); return a }, init: function () { }, mixIn: function (a) { for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]); a.hasOwnProperty("toString") && (this.toString = a.toString) }, clone: function () { return this.init.prototype.extend(this) } },
    r = l.WordArray = t.extend({
        init: function (a, c) { a = this.words = a || []; this.sigBytes = c != p ? c : 4 * a.length }, toString: function (a) { return (a || v).stringify(this) }, concat: function (a) { var c = this.words, e = a.words, j = this.sigBytes; a = a.sigBytes; this.clamp(); if (j % 4) for (var k = 0; k < a; k++)c[j + k >>> 2] |= (e[k >>> 2] >>> 24 - 8 * (k % 4) & 255) << 24 - 8 * ((j + k) % 4); else if (65535 < e.length) for (k = 0; k < a; k += 4)c[j + k >>> 2] = e[k >>> 2]; else c.push.apply(c, e); this.sigBytes += a; return this }, clamp: function () {
            var a = this.words, c = this.sigBytes; a[c >>> 2] &= 4294967295 <<
                32 - 8 * (c % 4); a.length = u.ceil(c / 4)
        }, clone: function () { var a = t.clone.call(this); a.words = this.words.slice(0); return a }, random: function (a) { for (var c = [], e = 0; e < a; e += 4)c.push(4294967296 * u.random() | 0); return new r.init(c, a) }
    }), w = d.enc = {}, v = w.Hex = {
        stringify: function (a) { var c = a.words; a = a.sigBytes; for (var e = [], j = 0; j < a; j++) { var k = c[j >>> 2] >>> 24 - 8 * (j % 4) & 255; e.push((k >>> 4).toString(16)); e.push((k & 15).toString(16)) } return e.join("") }, parse: function (a) {
            for (var c = a.length, e = [], j = 0; j < c; j += 2)e[j >>> 3] |= parseInt(a.substr(j,
                2), 16) << 24 - 4 * (j % 8); return new r.init(e, c / 2)
        }
    }, b = w.Latin1 = { stringify: function (a) { var c = a.words; a = a.sigBytes; for (var e = [], j = 0; j < a; j++)e.push(String.fromCharCode(c[j >>> 2] >>> 24 - 8 * (j % 4) & 255)); return e.join("") }, parse: function (a) { for (var c = a.length, e = [], j = 0; j < c; j++)e[j >>> 2] |= (a.charCodeAt(j) & 255) << 24 - 8 * (j % 4); return new r.init(e, c) } }, x = w.Utf8 = { stringify: function (a) { try { return decodeURIComponent(escape(b.stringify(a))) } catch (c) { throw Error("Malformed UTF-8 data"); } }, parse: function (a) { return b.parse(unescape(encodeURIComponent(a))) } },
    q = l.BufferedBlockAlgorithm = t.extend({
        reset: function () { this._data = new r.init; this._nDataBytes = 0 }, _append: function (a) { "string" == typeof a && (a = x.parse(a)); this._data.concat(a); this._nDataBytes += a.sigBytes }, _process: function (a) { var c = this._data, e = c.words, j = c.sigBytes, k = this.blockSize, b = j / (4 * k), b = a ? u.ceil(b) : u.max((b | 0) - this._minBufferSize, 0); a = b * k; j = u.min(4 * a, j); if (a) { for (var q = 0; q < a; q += k)this._doProcessBlock(e, q); q = e.splice(0, a); c.sigBytes -= j } return new r.init(q, j) }, clone: function () {
            var a = t.clone.call(this);
            a._data = this._data.clone(); return a
        }, _minBufferSize: 0
    }); l.Hasher = q.extend({
        cfg: t.extend(), init: function (a) { this.cfg = this.cfg.extend(a); this.reset() }, reset: function () { q.reset.call(this); this._doReset() }, update: function (a) { this._append(a); this._process(); return this }, finalize: function (a) { a && this._append(a); return this._doFinalize() }, blockSize: 16, _createHelper: function (a) { return function (b, e) { return (new a.init(e)).finalize(b) } }, _createHmacHelper: function (a) {
            return function (b, e) {
                return (new n.HMAC.init(a,
                    e)).finalize(b)
            }
        }
    }); var n = d.algo = {}; return d
}(Math);
(function () {
    var u = CryptoJS, p = u.lib.WordArray; u.enc.Base64 = {
        stringify: function (d) { var l = d.words, p = d.sigBytes, t = this._map; d.clamp(); d = []; for (var r = 0; r < p; r += 3)for (var w = (l[r >>> 2] >>> 24 - 8 * (r % 4) & 255) << 16 | (l[r + 1 >>> 2] >>> 24 - 8 * ((r + 1) % 4) & 255) << 8 | l[r + 2 >>> 2] >>> 24 - 8 * ((r + 2) % 4) & 255, v = 0; 4 > v && r + 0.75 * v < p; v++)d.push(t.charAt(w >>> 6 * (3 - v) & 63)); if (l = t.charAt(64)) for (; d.length % 4;)d.push(l); return d.join("") }, parse: function (d) {
            var l = d.length, s = this._map, t = s.charAt(64); t && (t = d.indexOf(t), -1 != t && (l = t)); for (var t = [], r = 0, w = 0; w <
                l; w++)if (w % 4) { var v = s.indexOf(d.charAt(w - 1)) << 2 * (w % 4), b = s.indexOf(d.charAt(w)) >>> 6 - 2 * (w % 4); t[r >>> 2] |= (v | b) << 24 - 8 * (r % 4); r++ } return p.create(t, r)
        }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    }
})();
(function (u) {
    function p(b, n, a, c, e, j, k) { b = b + (n & a | ~n & c) + e + k; return (b << j | b >>> 32 - j) + n } function d(b, n, a, c, e, j, k) { b = b + (n & c | a & ~c) + e + k; return (b << j | b >>> 32 - j) + n } function l(b, n, a, c, e, j, k) { b = b + (n ^ a ^ c) + e + k; return (b << j | b >>> 32 - j) + n } function s(b, n, a, c, e, j, k) { b = b + (a ^ (n | ~c)) + e + k; return (b << j | b >>> 32 - j) + n } for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 > x; x++)b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0; r = r.MD5 = v.extend({
        _doReset: function () { this._hash = new w.init([1732584193, 4023233417, 2562383102, 271733878]) },
        _doProcessBlock: function (q, n) {
            for (var a = 0; 16 > a; a++) { var c = n + a, e = q[c]; q[c] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360 } var a = this._hash.words, c = q[n + 0], e = q[n + 1], j = q[n + 2], k = q[n + 3], z = q[n + 4], r = q[n + 5], t = q[n + 6], w = q[n + 7], v = q[n + 8], A = q[n + 9], B = q[n + 10], C = q[n + 11], u = q[n + 12], D = q[n + 13], E = q[n + 14], x = q[n + 15], f = a[0], m = a[1], g = a[2], h = a[3], f = p(f, m, g, h, c, 7, b[0]), h = p(h, f, m, g, e, 12, b[1]), g = p(g, h, f, m, j, 17, b[2]), m = p(m, g, h, f, k, 22, b[3]), f = p(f, m, g, h, z, 7, b[4]), h = p(h, f, m, g, r, 12, b[5]), g = p(g, h, f, m, t, 17, b[6]), m = p(m, g, h, f, w, 22, b[7]),
                f = p(f, m, g, h, v, 7, b[8]), h = p(h, f, m, g, A, 12, b[9]), g = p(g, h, f, m, B, 17, b[10]), m = p(m, g, h, f, C, 22, b[11]), f = p(f, m, g, h, u, 7, b[12]), h = p(h, f, m, g, D, 12, b[13]), g = p(g, h, f, m, E, 17, b[14]), m = p(m, g, h, f, x, 22, b[15]), f = d(f, m, g, h, e, 5, b[16]), h = d(h, f, m, g, t, 9, b[17]), g = d(g, h, f, m, C, 14, b[18]), m = d(m, g, h, f, c, 20, b[19]), f = d(f, m, g, h, r, 5, b[20]), h = d(h, f, m, g, B, 9, b[21]), g = d(g, h, f, m, x, 14, b[22]), m = d(m, g, h, f, z, 20, b[23]), f = d(f, m, g, h, A, 5, b[24]), h = d(h, f, m, g, E, 9, b[25]), g = d(g, h, f, m, k, 14, b[26]), m = d(m, g, h, f, v, 20, b[27]), f = d(f, m, g, h, D, 5, b[28]), h = d(h, f,
                    m, g, j, 9, b[29]), g = d(g, h, f, m, w, 14, b[30]), m = d(m, g, h, f, u, 20, b[31]), f = l(f, m, g, h, r, 4, b[32]), h = l(h, f, m, g, v, 11, b[33]), g = l(g, h, f, m, C, 16, b[34]), m = l(m, g, h, f, E, 23, b[35]), f = l(f, m, g, h, e, 4, b[36]), h = l(h, f, m, g, z, 11, b[37]), g = l(g, h, f, m, w, 16, b[38]), m = l(m, g, h, f, B, 23, b[39]), f = l(f, m, g, h, D, 4, b[40]), h = l(h, f, m, g, c, 11, b[41]), g = l(g, h, f, m, k, 16, b[42]), m = l(m, g, h, f, t, 23, b[43]), f = l(f, m, g, h, A, 4, b[44]), h = l(h, f, m, g, u, 11, b[45]), g = l(g, h, f, m, x, 16, b[46]), m = l(m, g, h, f, j, 23, b[47]), f = s(f, m, g, h, c, 6, b[48]), h = s(h, f, m, g, w, 10, b[49]), g = s(g, h, f, m,
                        E, 15, b[50]), m = s(m, g, h, f, r, 21, b[51]), f = s(f, m, g, h, u, 6, b[52]), h = s(h, f, m, g, k, 10, b[53]), g = s(g, h, f, m, B, 15, b[54]), m = s(m, g, h, f, e, 21, b[55]), f = s(f, m, g, h, v, 6, b[56]), h = s(h, f, m, g, x, 10, b[57]), g = s(g, h, f, m, t, 15, b[58]), m = s(m, g, h, f, D, 21, b[59]), f = s(f, m, g, h, z, 6, b[60]), h = s(h, f, m, g, C, 10, b[61]), g = s(g, h, f, m, j, 15, b[62]), m = s(m, g, h, f, A, 21, b[63]); a[0] = a[0] + f | 0; a[1] = a[1] + m | 0; a[2] = a[2] + g | 0; a[3] = a[3] + h | 0
        }, _doFinalize: function () {
            var b = this._data, n = b.words, a = 8 * this._nDataBytes, c = 8 * b.sigBytes; n[c >>> 5] |= 128 << 24 - c % 32; var e = u.floor(a /
                4294967296); n[(c + 64 >>> 9 << 4) + 15] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360; n[(c + 64 >>> 9 << 4) + 14] = (a << 8 | a >>> 24) & 16711935 | (a << 24 | a >>> 8) & 4278255360; b.sigBytes = 4 * (n.length + 1); this._process(); b = this._hash; n = b.words; for (a = 0; 4 > a; a++)c = n[a], n[a] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360; return b
        }, clone: function () { var b = v.clone.call(this); b._hash = this._hash.clone(); return b }
    }); t.MD5 = v._createHelper(r); t.HmacMD5 = v._createHmacHelper(r)
})(Math);
(function () {
    var u = CryptoJS, p = u.lib, d = p.Base, l = p.WordArray, p = u.algo, s = p.EvpKDF = d.extend({ cfg: d.extend({ keySize: 4, hasher: p.MD5, iterations: 1 }), init: function (d) { this.cfg = this.cfg.extend(d) }, compute: function (d, r) { for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length < q;) { n && s.update(n); var n = s.update(d).finalize(r); s.reset(); for (var a = 1; a < p; a++)n = s.finalize(n), s.reset(); b.concat(n) } b.sigBytes = 4 * q; return b } }); u.EvpKDF = function (d, l, p) {
        return s.create(p).compute(d,
            l)
    }
})();
CryptoJS.lib.Cipher || function (u) {
    var p = CryptoJS, d = p.lib, l = d.Base, s = d.WordArray, t = d.BufferedBlockAlgorithm, r = p.enc.Base64, w = p.algo.EvpKDF, v = d.Cipher = t.extend({
        cfg: l.extend(), createEncryptor: function (e, a) { return this.create(this._ENC_XFORM_MODE, e, a) }, createDecryptor: function (e, a) { return this.create(this._DEC_XFORM_MODE, e, a) }, init: function (e, a, b) { this.cfg = this.cfg.extend(b); this._xformMode = e; this._key = a; this.reset() }, reset: function () { t.reset.call(this); this._doReset() }, process: function (e) { this._append(e); return this._process() },
        finalize: function (e) { e && this._append(e); return this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function (e) { return { encrypt: function (b, k, d) { return ("string" == typeof k ? c : a).encrypt(e, b, k, d) }, decrypt: function (b, k, d) { return ("string" == typeof k ? c : a).decrypt(e, b, k, d) } } }
    }); d.StreamCipher = v.extend({ _doFinalize: function () { return this._process(!0) }, blockSize: 1 }); var b = p.mode = {}, x = function (e, a, b) {
        var c = this._iv; c ? this._iv = u : c = this._prevBlock; for (var d = 0; d < b; d++)e[a + d] ^=
            c[d]
    }, q = (d.BlockCipherMode = l.extend({ createEncryptor: function (e, a) { return this.Encryptor.create(e, a) }, createDecryptor: function (e, a) { return this.Decryptor.create(e, a) }, init: function (e, a) { this._cipher = e; this._iv = a } })).extend(); q.Encryptor = q.extend({ processBlock: function (e, a) { var b = this._cipher, c = b.blockSize; x.call(this, e, a, c); b.encryptBlock(e, a); this._prevBlock = e.slice(a, a + c) } }); q.Decryptor = q.extend({
        processBlock: function (e, a) {
            var b = this._cipher, c = b.blockSize, d = e.slice(a, a + c); b.decryptBlock(e, a); x.call(this,
                e, a, c); this._prevBlock = d
        }
    }); b = b.CBC = q; q = (p.pad = {}).Pkcs7 = { pad: function (a, b) { for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, l = [], n = 0; n < c; n += 4)l.push(d); c = s.create(l, c); a.concat(c) }, unpad: function (a) { a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255 } }; d.BlockCipher = v.extend({
        cfg: v.cfg.extend({ mode: b, padding: q }), reset: function () {
            v.reset.call(this); var a = this.cfg, b = a.iv, a = a.mode; if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor; else c = a.createDecryptor, this._minBufferSize = 1; this._mode = c.call(a,
                this, b && b.words)
        }, _doProcessBlock: function (a, b) { this._mode.processBlock(a, b) }, _doFinalize: function () { var a = this.cfg.padding; if (this._xformMode == this._ENC_XFORM_MODE) { a.pad(this._data, this.blockSize); var b = this._process(!0) } else b = this._process(!0), a.unpad(b); return b }, blockSize: 4
    }); var n = d.CipherParams = l.extend({ init: function (a) { this.mixIn(a) }, toString: function (a) { return (a || this.formatter).stringify(this) } }), b = (p.format = {}).OpenSSL = {
        stringify: function (a) {
            var b = a.ciphertext; a = a.salt; return (a ? s.create([1398893684,
                1701076831]).concat(a).concat(b) : b).toString(r)
        }, parse: function (a) { a = r.parse(a); var b = a.words; if (1398893684 == b[0] && 1701076831 == b[1]) { var c = s.create(b.slice(2, 4)); b.splice(0, 4); a.sigBytes -= 16 } return n.create({ ciphertext: a, salt: c }) }
    }, a = d.SerializableCipher = l.extend({
        cfg: l.extend({ format: b }), encrypt: function (a, b, c, d) { d = this.cfg.extend(d); var l = a.createEncryptor(c, d); b = l.finalize(b); l = l.cfg; return n.create({ ciphertext: b, key: c, iv: l.iv, algorithm: a, mode: l.mode, padding: l.padding, blockSize: a.blockSize, formatter: d.format }) },
        decrypt: function (a, b, c, d) { d = this.cfg.extend(d); b = this._parse(b, d.format); return a.createDecryptor(c, d).finalize(b.ciphertext) }, _parse: function (a, b) { return "string" == typeof a ? b.parse(a, this) : a }
    }), p = (p.kdf = {}).OpenSSL = { execute: function (a, b, c, d) { d || (d = s.random(8)); a = w.create({ keySize: b + c }).compute(a, d); c = s.create(a.words.slice(b), 4 * c); a.sigBytes = 4 * b; return n.create({ key: a, iv: c, salt: d }) } }, c = d.PasswordBasedCipher = a.extend({
        cfg: a.cfg.extend({ kdf: p }), encrypt: function (b, c, d, l) {
            l = this.cfg.extend(l); d = l.kdf.execute(d,
                b.keySize, b.ivSize); l.iv = d.iv; b = a.encrypt.call(this, b, c, d.key, l); b.mixIn(d); return b
        }, decrypt: function (b, c, d, l) { l = this.cfg.extend(l); c = this._parse(c, l.format); d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt); l.iv = d.iv; return a.decrypt.call(this, b, c, d.key, l) }
    })
}();
(function () {
    for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 > c; c++)a[c] = 128 > c ? c << 1 : c << 1 ^ 283; for (var e = 0, j = 0, c = 0; 256 > c; c++) { var k = j ^ j << 1 ^ j << 2 ^ j << 3 ^ j << 4, k = k >>> 8 ^ k & 255 ^ 99; l[e] = k; s[k] = e; var z = a[e], F = a[z], G = a[F], y = 257 * a[k] ^ 16843008 * k; t[e] = y << 24 | y >>> 8; r[e] = y << 16 | y >>> 16; w[e] = y << 8 | y >>> 24; v[e] = y; y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e; b[k] = y << 24 | y >>> 8; x[k] = y << 16 | y >>> 16; q[k] = y << 8 | y >>> 24; n[k] = y; e ? (e = z ^ a[a[a[G ^ z]]], j ^= a[a[j]]) : e = j = 1 } var H = [0, 1, 2, 4, 8,
        16, 32, 64, 128, 27, 54], d = d.AES = p.extend({
            _doReset: function () {
                for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; j < a; j++)if (j < d) e[j] = c[j]; else { var k = e[j - 1]; j % d ? 6 < d && 4 == j % d && (k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255]) : (k = k << 8 | k >>> 24, k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255], k ^= H[j / d | 0] << 24); e[j] = e[j - d] ^ k } c = this._invKeySchedule = []; for (d = 0; d < a; d++)j = a - d, k = d % 4 ? e[j] : e[j - 4], c[d] = 4 > d || 4 >= j ? k : b[l[k >>> 24]] ^ x[l[k >>> 16 & 255]] ^ q[l[k >>>
                    8 & 255]] ^ n[l[k & 255]]
            }, encryptBlock: function (a, b) { this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l) }, decryptBlock: function (a, c) { var d = a[c + 1]; a[c + 1] = a[c + 3]; a[c + 3] = d; this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s); d = a[c + 1]; a[c + 1] = a[c + 3]; a[c + 3] = d }, _doCryptBlock: function (a, b, c, d, e, j, l, f) {
                for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; r < m; r++)var q = d[g >>> 24] ^ e[h >>> 16 & 255] ^ j[k >>> 8 & 255] ^ l[n & 255] ^ c[p++], s = d[h >>> 24] ^ e[k >>> 16 & 255] ^ j[n >>> 8 & 255] ^ l[g & 255] ^ c[p++], t =
                    d[k >>> 24] ^ e[n >>> 16 & 255] ^ j[g >>> 8 & 255] ^ l[h & 255] ^ c[p++], n = d[n >>> 24] ^ e[g >>> 16 & 255] ^ j[h >>> 8 & 255] ^ l[k & 255] ^ c[p++], g = q, h = s, k = t; q = (f[g >>> 24] << 24 | f[h >>> 16 & 255] << 16 | f[k >>> 8 & 255] << 8 | f[n & 255]) ^ c[p++]; s = (f[h >>> 24] << 24 | f[k >>> 16 & 255] << 16 | f[n >>> 8 & 255] << 8 | f[g & 255]) ^ c[p++]; t = (f[k >>> 24] << 24 | f[n >>> 16 & 255] << 16 | f[g >>> 8 & 255] << 8 | f[h & 255]) ^ c[p++]; n = (f[n >>> 24] << 24 | f[g >>> 16 & 255] << 16 | f[h >>> 8 & 255] << 8 | f[k & 255]) ^ c[p++]; a[b] = q; a[b + 1] = s; a[b + 2] = t; a[b + 3] = n
            }, keySize: 8
        }); u.AES = p._createHelper(d)
})();

//TripleDES Algo (tripledes.js)

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Permuted Choice 1 constants
    var PC1 = [
        57, 49, 41, 33, 25, 17, 9,  1,
        58, 50, 42, 34, 26, 18, 10, 2,
        59, 51, 43, 35, 27, 19, 11, 3,
        60, 52, 44, 36, 63, 55, 47, 39,
        31, 23, 15, 7,  62, 54, 46, 38,
        30, 22, 14, 6,  61, 53, 45, 37,
        29, 21, 13, 5,  28, 20, 12, 4
    ];

    // Permuted Choice 2 constants
    var PC2 = [
        14, 17, 11, 24, 1,  5,
        3,  28, 15, 6,  21, 10,
        23, 19, 12, 4,  26, 8,
        16, 7,  27, 20, 13, 2,
        41, 52, 31, 37, 47, 55,
        30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53,
        46, 42, 50, 36, 29, 32
    ];

    // Cumulative bit shift constants
    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

    // SBOXes and round permutation constants
    var SBOX_P = [
        {
            0x0: 0x808200,
            0x10000000: 0x8000,
            0x20000000: 0x808002,
            0x30000000: 0x2,
            0x40000000: 0x200,
            0x50000000: 0x808202,
            0x60000000: 0x800202,
            0x70000000: 0x800000,
            0x80000000: 0x202,
            0x90000000: 0x800200,
            0xa0000000: 0x8200,
            0xb0000000: 0x808000,
            0xc0000000: 0x8002,
            0xd0000000: 0x800002,
            0xe0000000: 0x0,
            0xf0000000: 0x8202,
            0x8000000: 0x0,
            0x18000000: 0x808202,
            0x28000000: 0x8202,
            0x38000000: 0x8000,
            0x48000000: 0x808200,
            0x58000000: 0x200,
            0x68000000: 0x808002,
            0x78000000: 0x2,
            0x88000000: 0x800200,
            0x98000000: 0x8200,
            0xa8000000: 0x808000,
            0xb8000000: 0x800202,
            0xc8000000: 0x800002,
            0xd8000000: 0x8002,
            0xe8000000: 0x202,
            0xf8000000: 0x800000,
            0x1: 0x8000,
            0x10000001: 0x2,
            0x20000001: 0x808200,
            0x30000001: 0x800000,
            0x40000001: 0x808002,
            0x50000001: 0x8200,
            0x60000001: 0x200,
            0x70000001: 0x800202,
            0x80000001: 0x808202,
            0x90000001: 0x808000,
            0xa0000001: 0x800002,
            0xb0000001: 0x8202,
            0xc0000001: 0x202,
            0xd0000001: 0x800200,
            0xe0000001: 0x8002,
            0xf0000001: 0x0,
            0x8000001: 0x808202,
            0x18000001: 0x808000,
            0x28000001: 0x800000,
            0x38000001: 0x200,
            0x48000001: 0x8000,
            0x58000001: 0x800002,
            0x68000001: 0x2,
            0x78000001: 0x8202,
            0x88000001: 0x8002,
            0x98000001: 0x800202,
            0xa8000001: 0x202,
            0xb8000001: 0x808200,
            0xc8000001: 0x800200,
            0xd8000001: 0x0,
            0xe8000001: 0x8200,
            0xf8000001: 0x808002
        },
        {
            0x0: 0x40084010,
            0x1000000: 0x4000,
            0x2000000: 0x80000,
            0x3000000: 0x40080010,
            0x4000000: 0x40000010,
            0x5000000: 0x40084000,
            0x6000000: 0x40004000,
            0x7000000: 0x10,
            0x8000000: 0x84000,
            0x9000000: 0x40004010,
            0xa000000: 0x40000000,
            0xb000000: 0x84010,
            0xc000000: 0x80010,
            0xd000000: 0x0,
            0xe000000: 0x4010,
            0xf000000: 0x40080000,
            0x800000: 0x40004000,
            0x1800000: 0x84010,
            0x2800000: 0x10,
            0x3800000: 0x40004010,
            0x4800000: 0x40084010,
            0x5800000: 0x40000000,
            0x6800000: 0x80000,
            0x7800000: 0x40080010,
            0x8800000: 0x80010,
            0x9800000: 0x0,
            0xa800000: 0x4000,
            0xb800000: 0x40080000,
            0xc800000: 0x40000010,
            0xd800000: 0x84000,
            0xe800000: 0x40084000,
            0xf800000: 0x4010,
            0x10000000: 0x0,
            0x11000000: 0x40080010,
            0x12000000: 0x40004010,
            0x13000000: 0x40084000,
            0x14000000: 0x40080000,
            0x15000000: 0x10,
            0x16000000: 0x84010,
            0x17000000: 0x4000,
            0x18000000: 0x4010,
            0x19000000: 0x80000,
            0x1a000000: 0x80010,
            0x1b000000: 0x40000010,
            0x1c000000: 0x84000,
            0x1d000000: 0x40004000,
            0x1e000000: 0x40000000,
            0x1f000000: 0x40084010,
            0x10800000: 0x84010,
            0x11800000: 0x80000,
            0x12800000: 0x40080000,
            0x13800000: 0x4000,
            0x14800000: 0x40004000,
            0x15800000: 0x40084010,
            0x16800000: 0x10,
            0x17800000: 0x40000000,
            0x18800000: 0x40084000,
            0x19800000: 0x40000010,
            0x1a800000: 0x40004010,
            0x1b800000: 0x80010,
            0x1c800000: 0x0,
            0x1d800000: 0x4010,
            0x1e800000: 0x40080010,
            0x1f800000: 0x84000
        },
        {
            0x0: 0x104,
            0x100000: 0x0,
            0x200000: 0x4000100,
            0x300000: 0x10104,
            0x400000: 0x10004,
            0x500000: 0x4000004,
            0x600000: 0x4010104,
            0x700000: 0x4010000,
            0x800000: 0x4000000,
            0x900000: 0x4010100,
            0xa00000: 0x10100,
            0xb00000: 0x4010004,
            0xc00000: 0x4000104,
            0xd00000: 0x10000,
            0xe00000: 0x4,
            0xf00000: 0x100,
            0x80000: 0x4010100,
            0x180000: 0x4010004,
            0x280000: 0x0,
            0x380000: 0x4000100,
            0x480000: 0x4000004,
            0x580000: 0x10000,
            0x680000: 0x10004,
            0x780000: 0x104,
            0x880000: 0x4,
            0x980000: 0x100,
            0xa80000: 0x4010000,
            0xb80000: 0x10104,
            0xc80000: 0x10100,
            0xd80000: 0x4000104,
            0xe80000: 0x4010104,
            0xf80000: 0x4000000,
            0x1000000: 0x4010100,
            0x1100000: 0x10004,
            0x1200000: 0x10000,
            0x1300000: 0x4000100,
            0x1400000: 0x100,
            0x1500000: 0x4010104,
            0x1600000: 0x4000004,
            0x1700000: 0x0,
            0x1800000: 0x4000104,
            0x1900000: 0x4000000,
            0x1a00000: 0x4,
            0x1b00000: 0x10100,
            0x1c00000: 0x4010000,
            0x1d00000: 0x104,
            0x1e00000: 0x10104,
            0x1f00000: 0x4010004,
            0x1080000: 0x4000000,
            0x1180000: 0x104,
            0x1280000: 0x4010100,
            0x1380000: 0x0,
            0x1480000: 0x10004,
            0x1580000: 0x4000100,
            0x1680000: 0x100,
            0x1780000: 0x4010004,
            0x1880000: 0x10000,
            0x1980000: 0x4010104,
            0x1a80000: 0x10104,
            0x1b80000: 0x4000004,
            0x1c80000: 0x4000104,
            0x1d80000: 0x4010000,
            0x1e80000: 0x4,
            0x1f80000: 0x10100
        },
        {
            0x0: 0x80401000,
            0x10000: 0x80001040,
            0x20000: 0x401040,
            0x30000: 0x80400000,
            0x40000: 0x0,
            0x50000: 0x401000,
            0x60000: 0x80000040,
            0x70000: 0x400040,
            0x80000: 0x80000000,
            0x90000: 0x400000,
            0xa0000: 0x40,
            0xb0000: 0x80001000,
            0xc0000: 0x80400040,
            0xd0000: 0x1040,
            0xe0000: 0x1000,
            0xf0000: 0x80401040,
            0x8000: 0x80001040,
            0x18000: 0x40,
            0x28000: 0x80400040,
            0x38000: 0x80001000,
            0x48000: 0x401000,
            0x58000: 0x80401040,
            0x68000: 0x0,
            0x78000: 0x80400000,
            0x88000: 0x1000,
            0x98000: 0x80401000,
            0xa8000: 0x400000,
            0xb8000: 0x1040,
            0xc8000: 0x80000000,
            0xd8000: 0x400040,
            0xe8000: 0x401040,
            0xf8000: 0x80000040,
            0x100000: 0x400040,
            0x110000: 0x401000,
            0x120000: 0x80000040,
            0x130000: 0x0,
            0x140000: 0x1040,
            0x150000: 0x80400040,
            0x160000: 0x80401000,
            0x170000: 0x80001040,
            0x180000: 0x80401040,
            0x190000: 0x80000000,
            0x1a0000: 0x80400000,
            0x1b0000: 0x401040,
            0x1c0000: 0x80001000,
            0x1d0000: 0x400000,
            0x1e0000: 0x40,
            0x1f0000: 0x1000,
            0x108000: 0x80400000,
            0x118000: 0x80401040,
            0x128000: 0x0,
            0x138000: 0x401000,
            0x148000: 0x400040,
            0x158000: 0x80000000,
            0x168000: 0x80001040,
            0x178000: 0x40,
            0x188000: 0x80000040,
            0x198000: 0x1000,
            0x1a8000: 0x80001000,
            0x1b8000: 0x80400040,
            0x1c8000: 0x1040,
            0x1d8000: 0x80401000,
            0x1e8000: 0x400000,
            0x1f8000: 0x401040
        },
        {
            0x0: 0x80,
            0x1000: 0x1040000,
            0x2000: 0x40000,
            0x3000: 0x20000000,
            0x4000: 0x20040080,
            0x5000: 0x1000080,
            0x6000: 0x21000080,
            0x7000: 0x40080,
            0x8000: 0x1000000,
            0x9000: 0x20040000,
            0xa000: 0x20000080,
            0xb000: 0x21040080,
            0xc000: 0x21040000,
            0xd000: 0x0,
            0xe000: 0x1040080,
            0xf000: 0x21000000,
            0x800: 0x1040080,
            0x1800: 0x21000080,
            0x2800: 0x80,
            0x3800: 0x1040000,
            0x4800: 0x40000,
            0x5800: 0x20040080,
            0x6800: 0x21040000,
            0x7800: 0x20000000,
            0x8800: 0x20040000,
            0x9800: 0x0,
            0xa800: 0x21040080,
            0xb800: 0x1000080,
            0xc800: 0x20000080,
            0xd800: 0x21000000,
            0xe800: 0x1000000,
            0xf800: 0x40080,
            0x10000: 0x40000,
            0x11000: 0x80,
            0x12000: 0x20000000,
            0x13000: 0x21000080,
            0x14000: 0x1000080,
            0x15000: 0x21040000,
            0x16000: 0x20040080,
            0x17000: 0x1000000,
            0x18000: 0x21040080,
            0x19000: 0x21000000,
            0x1a000: 0x1040000,
            0x1b000: 0x20040000,
            0x1c000: 0x40080,
            0x1d000: 0x20000080,
            0x1e000: 0x0,
            0x1f000: 0x1040080,
            0x10800: 0x21000080,
            0x11800: 0x1000000,
            0x12800: 0x1040000,
            0x13800: 0x20040080,
            0x14800: 0x20000000,
            0x15800: 0x1040080,
            0x16800: 0x80,
            0x17800: 0x21040000,
            0x18800: 0x40080,
            0x19800: 0x21040080,
            0x1a800: 0x0,
            0x1b800: 0x21000000,
            0x1c800: 0x1000080,
            0x1d800: 0x40000,
            0x1e800: 0x20040000,
            0x1f800: 0x20000080
        },
        {
            0x0: 0x10000008,
            0x100: 0x2000,
            0x200: 0x10200000,
            0x300: 0x10202008,
            0x400: 0x10002000,
            0x500: 0x200000,
            0x600: 0x200008,
            0x700: 0x10000000,
            0x800: 0x0,
            0x900: 0x10002008,
            0xa00: 0x202000,
            0xb00: 0x8,
            0xc00: 0x10200008,
            0xd00: 0x202008,
            0xe00: 0x2008,
            0xf00: 0x10202000,
            0x80: 0x10200000,
            0x180: 0x10202008,
            0x280: 0x8,
            0x380: 0x200000,
            0x480: 0x202008,
            0x580: 0x10000008,
            0x680: 0x10002000,
            0x780: 0x2008,
            0x880: 0x200008,
            0x980: 0x2000,
            0xa80: 0x10002008,
            0xb80: 0x10200008,
            0xc80: 0x0,
            0xd80: 0x10202000,
            0xe80: 0x202000,
            0xf80: 0x10000000,
            0x1000: 0x10002000,
            0x1100: 0x10200008,
            0x1200: 0x10202008,
            0x1300: 0x2008,
            0x1400: 0x200000,
            0x1500: 0x10000000,
            0x1600: 0x10000008,
            0x1700: 0x202000,
            0x1800: 0x202008,
            0x1900: 0x0,
            0x1a00: 0x8,
            0x1b00: 0x10200000,
            0x1c00: 0x2000,
            0x1d00: 0x10002008,
            0x1e00: 0x10202000,
            0x1f00: 0x200008,
            0x1080: 0x8,
            0x1180: 0x202000,
            0x1280: 0x200000,
            0x1380: 0x10000008,
            0x1480: 0x10002000,
            0x1580: 0x2008,
            0x1680: 0x10202008,
            0x1780: 0x10200000,
            0x1880: 0x10202000,
            0x1980: 0x10200008,
            0x1a80: 0x2000,
            0x1b80: 0x202008,
            0x1c80: 0x200008,
            0x1d80: 0x0,
            0x1e80: 0x10000000,
            0x1f80: 0x10002008
        },
        {
            0x0: 0x100000,
            0x10: 0x2000401,
            0x20: 0x400,
            0x30: 0x100401,
            0x40: 0x2100401,
            0x50: 0x0,
            0x60: 0x1,
            0x70: 0x2100001,
            0x80: 0x2000400,
            0x90: 0x100001,
            0xa0: 0x2000001,
            0xb0: 0x2100400,
            0xc0: 0x2100000,
            0xd0: 0x401,
            0xe0: 0x100400,
            0xf0: 0x2000000,
            0x8: 0x2100001,
            0x18: 0x0,
            0x28: 0x2000401,
            0x38: 0x2100400,
            0x48: 0x100000,
            0x58: 0x2000001,
            0x68: 0x2000000,
            0x78: 0x401,
            0x88: 0x100401,
            0x98: 0x2000400,
            0xa8: 0x2100000,
            0xb8: 0x100001,
            0xc8: 0x400,
            0xd8: 0x2100401,
            0xe8: 0x1,
            0xf8: 0x100400,
            0x100: 0x2000000,
            0x110: 0x100000,
            0x120: 0x2000401,
            0x130: 0x2100001,
            0x140: 0x100001,
            0x150: 0x2000400,
            0x160: 0x2100400,
            0x170: 0x100401,
            0x180: 0x401,
            0x190: 0x2100401,
            0x1a0: 0x100400,
            0x1b0: 0x1,
            0x1c0: 0x0,
            0x1d0: 0x2100000,
            0x1e0: 0x2000001,
            0x1f0: 0x400,
            0x108: 0x100400,
            0x118: 0x2000401,
            0x128: 0x2100001,
            0x138: 0x1,
            0x148: 0x2000000,
            0x158: 0x100000,
            0x168: 0x401,
            0x178: 0x2100400,
            0x188: 0x2000001,
            0x198: 0x2100000,
            0x1a8: 0x0,
            0x1b8: 0x2100401,
            0x1c8: 0x100401,
            0x1d8: 0x400,
            0x1e8: 0x2000400,
            0x1f8: 0x100001
        },
        {
            0x0: 0x8000820,
            0x1: 0x20000,
            0x2: 0x8000000,
            0x3: 0x20,
            0x4: 0x20020,
            0x5: 0x8020820,
            0x6: 0x8020800,
            0x7: 0x800,
            0x8: 0x8020000,
            0x9: 0x8000800,
            0xa: 0x20800,
            0xb: 0x8020020,
            0xc: 0x820,
            0xd: 0x0,
            0xe: 0x8000020,
            0xf: 0x20820,
            0x80000000: 0x800,
            0x80000001: 0x8020820,
            0x80000002: 0x8000820,
            0x80000003: 0x8000000,
            0x80000004: 0x8020000,
            0x80000005: 0x20800,
            0x80000006: 0x20820,
            0x80000007: 0x20,
            0x80000008: 0x8000020,
            0x80000009: 0x820,
            0x8000000a: 0x20020,
            0x8000000b: 0x8020800,
            0x8000000c: 0x0,
            0x8000000d: 0x8020020,
            0x8000000e: 0x8000800,
            0x8000000f: 0x20000,
            0x10: 0x20820,
            0x11: 0x8020800,
            0x12: 0x20,
            0x13: 0x800,
            0x14: 0x8000800,
            0x15: 0x8000020,
            0x16: 0x8020020,
            0x17: 0x20000,
            0x18: 0x0,
            0x19: 0x20020,
            0x1a: 0x8020000,
            0x1b: 0x8000820,
            0x1c: 0x8020820,
            0x1d: 0x20800,
            0x1e: 0x820,
            0x1f: 0x8000000,
            0x80000010: 0x20000,
            0x80000011: 0x800,
            0x80000012: 0x8020020,
            0x80000013: 0x20820,
            0x80000014: 0x20,
            0x80000015: 0x8020000,
            0x80000016: 0x8000000,
            0x80000017: 0x8000820,
            0x80000018: 0x8020820,
            0x80000019: 0x8000020,
            0x8000001a: 0x8000800,
            0x8000001b: 0x0,
            0x8000001c: 0x20800,
            0x8000001d: 0x820,
            0x8000001e: 0x20020,
            0x8000001f: 0x8020800
        }
    ];

    // Masks that select the SBOX input
    var SBOX_MASK = [
        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
    ];

    /**
     * DES block cipher algorithm.
     */
    var DES = C_algo.DES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;

            // Select 56 bits according to PC1
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
                var keyBitPos = PC1[i] - 1;
                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
            }

            // Assemble 16 subkeys
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                // Create subkey
                var subKey = subKeys[nSubKey] = [];

                // Shortcut
                var bitShift = BIT_SHIFTS[nSubKey];

                // Select 48 bits according to PC2
                for (var i = 0; i < 24; i++) {
                    // Select from the left 28 key bits
                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

                    // Select from the right 28 key bits
                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
                }

                // Since each subkey is applied to an expanded 32-bit input,
                // the subkey can be broken into 8 values scaled to 32-bits,
                // which allows the key to be used without expansion
                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
                for (var i = 1; i < 7; i++) {
                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
                }
                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
            }

            // Compute inverse subkeys
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
                invSubKeys[i] = subKeys[15 - i];
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
        },

        decryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
        },

        _doCryptBlock: function (M, offset, subKeys) {
            // Get input
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];

            // Initial permutation
            exchangeLR.call(this, 4,  0x0f0f0f0f);
            exchangeLR.call(this, 16, 0x0000ffff);
            exchangeRL.call(this, 2,  0x33333333);
            exchangeRL.call(this, 8,  0x00ff00ff);
            exchangeLR.call(this, 1,  0x55555555);

            // Rounds
            for (var round = 0; round < 16; round++) {
                // Shortcuts
                var subKey = subKeys[round];
                var lBlock = this._lBlock;
                var rBlock = this._rBlock;

                // Feistel function
                var f = 0;
                for (var i = 0; i < 8; i++) {
                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                }
                this._lBlock = rBlock;
                this._rBlock = lBlock ^ f;
            }

            // Undo swap from last round
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;

            // Final permutation
            exchangeLR.call(this, 1,  0x55555555);
            exchangeRL.call(this, 8,  0x00ff00ff);
            exchangeRL.call(this, 2,  0x33333333);
            exchangeLR.call(this, 16, 0x0000ffff);
            exchangeLR.call(this, 4,  0x0f0f0f0f);

            // Set output
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
        },

        keySize: 64/32,

        ivSize: 64/32,

        blockSize: 64/32
    });

    // Swap bits across the left and right words
    function exchangeLR(offset, mask) {
        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
        this._rBlock ^= t;
        this._lBlock ^= t << offset;
    }

    function exchangeRL(offset, mask) {
        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
        this._lBlock ^= t;
        this._rBlock ^= t << offset;
    }

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
     */
    C.DES = BlockCipher._createHelper(DES);

    /**
     * Triple-DES block cipher algorithm.
     */
    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;

            // Create DES instances
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
        },

        encryptBlock: function (M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
        },

        decryptBlock: function (M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
        },

        keySize: 192/32,

        ivSize: 64/32,

        blockSize: 64/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
     */
    C.TripleDES = BlockCipher._createHelper(TripleDES);
}());


//MD5 Algo (md5.js)

(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Constants table
    var T = [];

    // Compute constants
    (function () {
        for (var i = 0; i < 64; i++) {
            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
        }
    }());

    /**
     * MD5 hash algorithm.
     */
    var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Swap endian
            for (var i = 0; i < 16; i++) {
                // Shortcuts
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];

                M[offset_i] = (
                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                );
            }

            // Shortcuts
            var H = this._hash.words;

            var M_offset_0  = M[offset + 0];
            var M_offset_1  = M[offset + 1];
            var M_offset_2  = M[offset + 2];
            var M_offset_3  = M[offset + 3];
            var M_offset_4  = M[offset + 4];
            var M_offset_5  = M[offset + 5];
            var M_offset_6  = M[offset + 6];
            var M_offset_7  = M[offset + 7];
            var M_offset_8  = M[offset + 8];
            var M_offset_9  = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];

            // Working varialbes
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];

            // Computation
            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
            d = II(d, a, b, c, M_offset_7,  10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5,  21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
            d = II(d, a, b, c, M_offset_3,  10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1,  21, T[55]);
            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6,  15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2,  15, T[62]);
            b = II(b, c, d, a, M_offset_9,  21, T[63]);

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
            var nBitsTotalL = nBitsTotal;
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
            );
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
            );

            data.sigBytes = (dataWords.length + 1) * 4;

            // Hash final blocks
            this._process();

            // Shortcuts
            var hash = this._hash;
            var H = hash.words;

            // Swap endian
            for (var i = 0; i < 4; i++) {
                // Shortcut
                var H_i = H[i];

                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
            }

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    function FF(a, b, c, d, x, s, t) {
        var n = a + ((b & c) | (~b & d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function GG(a, b, c, d, x, s, t) {
        var n = a + ((b & d) | (c & ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function HH(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function II(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.MD5('message');
     *     var hash = CryptoJS.MD5(wordArray);
     */
    C.MD5 = Hasher._createHelper(MD5);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacMD5(message, key);
     */
    C.HmacMD5 = Hasher._createHmacHelper(MD5);
}(Math));

//x64

(function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var X32WordArray = C_lib.WordArray;

    /**
     * x64 namespace.
     */
    var C_x64 = C.x64 = {};

    /**
     * A 64-bit word.
     */
    var X64Word = C_x64.Word = Base.extend({
        /**
         * Initializes a newly created 64-bit word.
         *
         * @param {number} high The high 32 bits.
         * @param {number} low The low 32 bits.
         *
         * @example
         *
         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
         */
        init: function (high, low) {
            this.high = high;
            this.low = low;
        }

        /**
         * Bitwise NOTs this word.
         *
         * @return {X64Word} A new x64-Word object after negating.
         *
         * @example
         *
         *     var negated = x64Word.not();
         */
        // not: function () {
            // var high = ~this.high;
            // var low = ~this.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Bitwise ANDs this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to AND with this word.
         *
         * @return {X64Word} A new x64-Word object after ANDing.
         *
         * @example
         *
         *     var anded = x64Word.and(anotherX64Word);
         */
        // and: function (word) {
            // var high = this.high & word.high;
            // var low = this.low & word.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Bitwise ORs this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to OR with this word.
         *
         * @return {X64Word} A new x64-Word object after ORing.
         *
         * @example
         *
         *     var ored = x64Word.or(anotherX64Word);
         */
        // or: function (word) {
            // var high = this.high | word.high;
            // var low = this.low | word.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Bitwise XORs this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to XOR with this word.
         *
         * @return {X64Word} A new x64-Word object after XORing.
         *
         * @example
         *
         *     var xored = x64Word.xor(anotherX64Word);
         */
        // xor: function (word) {
            // var high = this.high ^ word.high;
            // var low = this.low ^ word.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Shifts this word n bits to the left.
         *
         * @param {number} n The number of bits to shift.
         *
         * @return {X64Word} A new x64-Word object after shifting.
         *
         * @example
         *
         *     var shifted = x64Word.shiftL(25);
         */
        // shiftL: function (n) {
            // if (n < 32) {
                // var high = (this.high << n) | (this.low >>> (32 - n));
                // var low = this.low << n;
            // } else {
                // var high = this.low << (n - 32);
                // var low = 0;
            // }

            // return X64Word.create(high, low);
        // },

        /**
         * Shifts this word n bits to the right.
         *
         * @param {number} n The number of bits to shift.
         *
         * @return {X64Word} A new x64-Word object after shifting.
         *
         * @example
         *
         *     var shifted = x64Word.shiftR(7);
         */
        // shiftR: function (n) {
            // if (n < 32) {
                // var low = (this.low >>> n) | (this.high << (32 - n));
                // var high = this.high >>> n;
            // } else {
                // var low = this.high >>> (n - 32);
                // var high = 0;
            // }

            // return X64Word.create(high, low);
        // },

        /**
         * Rotates this word n bits to the left.
         *
         * @param {number} n The number of bits to rotate.
         *
         * @return {X64Word} A new x64-Word object after rotating.
         *
         * @example
         *
         *     var rotated = x64Word.rotL(25);
         */
        // rotL: function (n) {
            // return this.shiftL(n).or(this.shiftR(64 - n));
        // },

        /**
         * Rotates this word n bits to the right.
         *
         * @param {number} n The number of bits to rotate.
         *
         * @return {X64Word} A new x64-Word object after rotating.
         *
         * @example
         *
         *     var rotated = x64Word.rotR(7);
         */
        // rotR: function (n) {
            // return this.shiftR(n).or(this.shiftL(64 - n));
        // },

        /**
         * Adds this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to add with this word.
         *
         * @return {X64Word} A new x64-Word object after adding.
         *
         * @example
         *
         *     var added = x64Word.add(anotherX64Word);
         */
        // add: function (word) {
            // var low = (this.low + word.low) | 0;
            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
            // var high = (this.high + word.high + carry) | 0;

            // return X64Word.create(high, low);
        // }
    });

    /**
     * An array of 64-bit words.
     *
     * @property {Array} words The array of CryptoJS.x64.Word objects.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var X64WordArray = C_x64.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.x64.WordArray.create();
         *
         *     var wordArray = CryptoJS.x64.WordArray.create([
         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
         *     ]);
         *
         *     var wordArray = CryptoJS.x64.WordArray.create([
         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
         *     ], 10);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 8;
            }
        },

        /**
         * Converts this 64-bit word array to a 32-bit word array.
         *
         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
         *
         * @example
         *
         *     var x32WordArray = x64WordArray.toX32();
         */
        toX32: function () {
            // Shortcuts
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;

            // Convert
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
                var x64Word = x64Words[i];
                x32Words.push(x64Word.high);
                x32Words.push(x64Word.low);
            }

            return X32WordArray.create(x32Words, this.sigBytes);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {X64WordArray} The clone.
         *
         * @example
         *
         *     var clone = x64WordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);

            // Clone "words" array
            var words = clone.words = this.words.slice(0);

            // Clone each X64Word object
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
                words[i] = words[i].clone();
            }

            return clone;
        }
    });
}());

//sha1 Algo (sha1.js)

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Reusable object
    var W = [];

    /**
     * SHA-1 hash algorithm.
     */
    var SHA1 = C_algo.SHA1 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476,
                0xc3d2e1f0
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];

            // Computation
            for (var i = 0; i < 80; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                    W[i] = (n << 1) | (n >>> 31);
                }

                var t = ((a << 5) | (a >>> 27)) + e + W[i];
                if (i < 20) {
                    t += ((b & c) | (~b & d)) + 0x5a827999;
                } else if (i < 40) {
                    t += (b ^ c ^ d) + 0x6ed9eba1;
                } else if (i < 60) {
                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
                } else /* if (i < 80) */ {
                    t += (b ^ c ^ d) - 0x359d3e2a;
                }

                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA1('message');
     *     var hash = CryptoJS.SHA1(wordArray);
     */
    C.SHA1 = Hasher._createHelper(SHA1);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA1(message, key);
     */
    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
}());

//sha256 Algo (sha256.js)

(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Initialization and round constants tables
    var H = [];
    var K = [];

    // Compute constants
    (function () {
        function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n % factor)) {
                    return false;
                }
            }

            return true;
        }

        function getFractionalBits(n) {
            return ((n - (n | 0)) * 0x100000000) | 0;
        }

        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
            if (isPrime(n)) {
                if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                nPrime++;
            }

            n++;
        }
    }());

    // Reusable object
    var W = [];

    /**
     * SHA-256 hash algorithm.
     */
    var SHA256 = C_algo.SHA256 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];

            // Computation
            for (var i = 0; i < 64; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var gamma0x = W[i - 15];
                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                   (gamma0x >>> 3);

                    var gamma1x = W[i - 2];
                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                   (gamma1x >>> 10);

                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }

                var ch  = (e & f) ^ (~e & g);
                var maj = (a & b) ^ (a & c) ^ (b & c);

                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;

                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
            H[5] = (H[5] + f) | 0;
            H[6] = (H[6] + g) | 0;
            H[7] = (H[7] + h) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */
    C.SHA256 = Hasher._createHelper(SHA256);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA256(message, key);
     */
    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
}(Math));

//sha512 Algo (sha512.js)

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Hasher = C_lib.Hasher;
    var C_x64 = C.x64;
    var X64Word = C_x64.Word;
    var X64WordArray = C_x64.WordArray;
    var C_algo = C.algo;

    function X64Word_create() {
        return X64Word.create.apply(X64Word, arguments);
    }

    // Constants
    var K = [
        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
    ];

    // Reusable objects
    var W = [];
    (function () {
        for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
        }
    }());

    /**
     * SHA-512 hash algorithm.
     */
    var SHA512 = C_algo.SHA512 = Hasher.extend({
        _doReset: function () {
            this._hash = new X64WordArray.init([
                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Shortcuts
            var H = this._hash.words;

            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];

            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;

            // Working variables
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;

            // Rounds
            for (var i = 0; i < 80; i++) {
                // Shortcut
                var Wi = W[i];

                // Extend message
                if (i < 16) {
                    var Wih = Wi.high = M[offset + i * 2]     | 0;
                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
                } else {
                    // Gamma0
                    var gamma0x  = W[i - 15];
                    var gamma0xh = gamma0x.high;
                    var gamma0xl = gamma0x.low;
                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

                    // Gamma1
                    var gamma1x  = W[i - 2];
                    var gamma1xh = gamma1x.high;
                    var gamma1xl = gamma1x.low;
                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                    var Wi7  = W[i - 7];
                    var Wi7h = Wi7.high;
                    var Wi7l = Wi7.low;

                    var Wi16  = W[i - 16];
                    var Wi16h = Wi16.high;
                    var Wi16l = Wi16.low;

                    var Wil = gamma0l + Wi7l;
                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
                    var Wil = Wil + gamma1l;
                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
                    var Wil = Wil + Wi16l;
                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

                    Wi.high = Wih;
                    Wi.low  = Wil;
                }

                var chh  = (eh & fh) ^ (~eh & gh);
                var chl  = (el & fl) ^ (~el & gl);
                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

                // t1 = h + sigma1 + ch + K[i] + W[i]
                var Ki  = K[i];
                var Kih = Ki.high;
                var Kil = Ki.low;

                var t1l = hl + sigma1l;
                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
                var t1l = t1l + chl;
                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
                var t1l = t1l + Kil;
                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
                var t1l = t1l + Wil;
                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

                // t2 = sigma0 + maj
                var t2l = sigma0l + majl;
                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

                // Update working variables
                hh = gh;
                hl = gl;
                gh = fh;
                gl = fl;
                fh = eh;
                fl = el;
                el = (dl + t1l) | 0;
                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
                dh = ch;
                dl = cl;
                ch = bh;
                cl = bl;
                bh = ah;
                bl = al;
                al = (t1l + t2l) | 0;
                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
            }

            // Intermediate hash value
            H0l = H0.low  = (H0l + al);
            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
            H1l = H1.low  = (H1l + bl);
            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
            H2l = H2.low  = (H2l + cl);
            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
            H3l = H3.low  = (H3l + dl);
            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
            H4l = H4.low  = (H4l + el);
            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
            H5l = H5.low  = (H5l + fl);
            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
            H6l = H6.low  = (H6l + gl);
            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
            H7l = H7.low  = (H7l + hl);
            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Convert hash to 32-bit word array before returning
            var hash = this._hash.toX32();

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        },

        blockSize: 1024/32
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA512('message');
     *     var hash = CryptoJS.SHA512(wordArray);
     */
    C.SHA512 = Hasher._createHelper(SHA512);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA512(message, key);
     */
    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
}());

//CFB Mode (mode-cfb.js) Cipher Feedback block mode.

 CryptoJS.mode.CFB = (function () {
    var CFB = CryptoJS.lib.BlockCipherMode.extend();

    CFB.Encryptor = CFB.extend({
        processBlock: function (words, offset) {
            // Shortcuts
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;

            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

            // Remember this block to use with next block
            this._prevBlock = words.slice(offset, offset + blockSize);
        }
    });

    CFB.Decryptor = CFB.extend({
        processBlock: function (words, offset) {
            // Shortcuts
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;

            // Remember this block to use with next block
            var thisBlock = words.slice(offset, offset + blockSize);

            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

            // This block becomes the previous block
            this._prevBlock = thisBlock;
        }
    });

    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
        // Shortcut
        var iv = this._iv;

        // Generate keystream
        if (iv) {
            var keystream = iv.slice(0);

            // Remove IV for subsequent blocks
            this._iv = undefined;
        } else {
            var keystream = this._prevBlock;
        }
        cipher.encryptBlock(keystream, 0);

        // Encrypt
        for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
        }
    }

    return CFB;
}());

//ECB mode (mode-ecb.js)  Electronic Codebook block mode.

 CryptoJS.mode.ECB = (function () {
    var ECB = CryptoJS.lib.BlockCipherMode.extend();

    ECB.Encryptor = ECB.extend({
        processBlock: function (words, offset) {
            this._cipher.encryptBlock(words, offset);
        }
    });

    ECB.Decryptor = ECB.extend({
        processBlock: function (words, offset) {
            this._cipher.decryptBlock(words, offset);
        }
    });

    return ECB;
}());

//OFB mode (mode-ofb.js)  Output Feedback block mode

 CryptoJS.mode.OFB = (function () {
    var OFB = CryptoJS.lib.BlockCipherMode.extend();

    var Encryptor = OFB.Encryptor = OFB.extend({
        processBlock: function (words, offset) {
            // Shortcuts
            var cipher = this._cipher
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;

            // Generate keystream
            if (iv) {
                keystream = this._keystream = iv.slice(0);

                // Remove IV for subsequent blocks
                this._iv = undefined;
            }
            cipher.encryptBlock(keystream, 0);

            // Encrypt
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= keystream[i];
            }
        }
    });

    OFB.Decryptor = Encryptor;

    return OFB;
}());

//CTR mode
 CryptoJS.mode.CTR = (function () {
    var CTR = CryptoJS.lib.BlockCipherMode.extend();

    var Encryptor = CTR.Encryptor = CTR.extend({
        processBlock: function (words, offset) {
            // Shortcuts
            var cipher = this._cipher
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;

            // Generate keystream
            if (iv) {
                counter = this._counter = iv.slice(0);

                // Remove IV for subsequent blocks
                this._iv = undefined;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);

            // Increment counter
            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

            // Encrypt
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= keystream[i];
            }
        }
    });

    CTR.Decryptor = Encryptor;

    return CTR;
}());


//Zero padding strategy.
CryptoJS.pad.ZeroPadding = {
    pad: function (data, blockSize) {
        // Shortcut
        var blockSizeBytes = blockSize * 4;

        // Pad
        data.clamp();
        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
    },

    unpad: function (data) {
        // Shortcut
        var dataWords = data.words;

        // Unpad
        var i = data.sigBytes - 1;
        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
            i--;
        }
        data.sigBytes = i + 1;
    }
};

//No Padding :A noop padding strategy.

 CryptoJS.pad.NoPadding = {
    pad: function () {
    },

    unpad: function () {
    }
};

// ISO/IEC 9797-1 Padding Method 2.

 CryptoJS.pad.Iso97971 = {
    pad: function (data, blockSize) {
        // Add 0x80 byte
        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

        // Zero pad the rest
        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
    },

    unpad: function (data) {
        // Remove zero padding
        CryptoJS.pad.ZeroPadding.unpad(data);

        // Remove one more byte -- the 0x80 byte
        data.sigBytes--;
    }
};

// ISO 10126 padding strategy.

 CryptoJS.pad.Iso10126 = {
    pad: function (data, blockSize) {
        // Shortcut
        var blockSizeBytes = blockSize * 4;

        // Count padding bytes
        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

        // Pad
        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
    },

    unpad: function (data) {
        // Get number of padding bytes from last byte
        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

        // Remove padding
        data.sigBytes -= nPaddingBytes;
    }
};

//HMAC

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var C_algo = C.algo;

    /**
     * HMAC algorithm.
     */
    var HMAC = C_algo.HMAC = Base.extend({
        /**
         * Initializes a newly created HMAC.
         *
         * @param {Hasher} hasher The hash algorithm to use.
         * @param {WordArray|string} key The secret key.
         *
         * @example
         *
         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
         */
        init: function (hasher, key) {
            // Init hasher
            hasher = this._hasher = new hasher.init();

            // Convert string to WordArray, else assume WordArray already
            if (typeof key == 'string') {
                key = Utf8.parse(key);
            }

            // Shortcuts
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;

            // Allow arbitrary length keys
            if (key.sigBytes > hasherBlockSizeBytes) {
                key = hasher.finalize(key);
            }

            // Clamp excess bits
            key.clamp();

            // Clone key for inner and outer pads
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();

            // Shortcuts
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;

            // XOR keys with pad constants
            for (var i = 0; i < hasherBlockSize; i++) {
                oKeyWords[i] ^= 0x5c5c5c5c;
                iKeyWords[i] ^= 0x36363636;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this HMAC to its initial state.
         *
         * @example
         *
         *     hmacHasher.reset();
         */
        reset: function () {
            // Shortcut
            var hasher = this._hasher;

            // Reset
            hasher.reset();
            hasher.update(this._iKey);
        },

        /**
         * Updates this HMAC with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {HMAC} This HMAC instance.
         *
         * @example
         *
         *     hmacHasher.update('message');
         *     hmacHasher.update(wordArray);
         */
        update: function (messageUpdate) {
            this._hasher.update(messageUpdate);

            // Chainable
            return this;
        },

        /**
         * Finalizes the HMAC computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The HMAC.
         *
         * @example
         *
         *     var hmac = hmacHasher.finalize();
         *     var hmac = hmacHasher.finalize('message');
         *     var hmac = hmacHasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Shortcut
            var hasher = this._hasher;

            // Compute HMAC
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

            return hmac;
        }
    });
}());

//PBKDF2

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var SHA1 = C_algo.SHA1;
    var HMAC = C_algo.HMAC;

    /**
     * Password-Based Key Derivation Function 2 algorithm.
     */
    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
        /**
         * Configuration options.
         *
         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
         * @property {Hasher} hasher The hasher to use. Default: SHA1
         * @property {number} iterations The number of iterations to perform. Default: 1
         */
        cfg: Base.extend({
            keySize: 128/32,
            hasher: SHA1,
            iterations: 1
        }),

        /**
         * Initializes a newly created key derivation function.
         *
         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
         *
         * @example
         *
         *     var kdf = CryptoJS.algo.PBKDF2.create();
         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
         */
        init: function (cfg) {
            this.cfg = this.cfg.extend(cfg);
        },

        /**
         * Computes the Password-Based Key Derivation Function 2.
         *
         * @param {WordArray|string} password The password.
         * @param {WordArray|string} salt A salt.
         *
         * @return {WordArray} The derived key.
         *
         * @example
         *
         *     var key = kdf.compute(password, salt);
         */
        compute: function (password, salt) {
            // Shortcut
            var cfg = this.cfg;

            // Init HMAC
            var hmac = HMAC.create(cfg.hasher, password);

            // Initial values
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([0x00000001]);

            // Shortcuts
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;

            // Generate key
            while (derivedKeyWords.length < keySize) {
                var block = hmac.update(salt).finalize(blockIndex);
                hmac.reset();

                // Shortcuts
                var blockWords = block.words;
                var blockWordsLength = blockWords.length;

                // Iterations
                var intermediate = block;
                for (var i = 1; i < iterations; i++) {
                    intermediate = hmac.finalize(intermediate);
                    hmac.reset();

                    // Shortcut
                    var intermediateWords = intermediate.words;

                    // XOR intermediate with block
                    for (var j = 0; j < blockWordsLength; j++) {
                        blockWords[j] ^= intermediateWords[j];
                    }
                }

                derivedKey.concat(block);
                blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;

            return derivedKey;
        }
    });

    /**
     * Computes the Password-Based Key Derivation Function 2.
     *
     * @param {WordArray|string} password The password.
     * @param {WordArray|string} salt A salt.
     * @param {Object} cfg (Optional) The configuration options to use for this computation.
     *
     * @return {WordArray} The derived key.
     *
     * @static
     *
     * @example
     *
     *     var key = CryptoJS.PBKDF2(password, salt);
     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
     */
    C.PBKDF2 = function (password, salt, cfg) {
        return PBKDF2.create(cfg).compute(password, salt);
    };
}());


/* FILE PATH :: 'lib/utils/voltmxconstants.js' */
Object.defineProperty(voltmx.$kwebfw$, 'constants', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    $K.defVoltmxProp(_ns, [
        {keey:'IMAGE_PATH', value:'images'},
        {keey:'RESOURCES_PATH', value:'resources'},
        {keey:'TRANSLATION_EXT', value:'js'},
        {keey:'TRANSLATION_PATH', value:'strings'},
        //dropdown searchCritaria plugin
        {keey:'STARTS_WITH', value:'startswith'},
        {keey:'CONTAINS', value: 'contains'},
        {keey:'POSITION_TOP', value: 'top'},
        {keey:'POSITION_BOTTOM', value: 'bottom'},
        {keey:'POSITION_AUTO', value: 'auto'}

    ]);

    return _ns;
}())});


/* FILE PATH :: 'lib/utils/voltmxutils.js' */
Object.defineProperty(voltmx.$kwebfw$, 'utils', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$, __uid = null,
        __browser = {supports:{}}, __is = {
            argument: function(datatype) {
                return (datatype === 'argument');
            },

            array: function(datatype) {
                return (datatype === 'array');
            },

            boolean: function(datatype) {
                return (datatype === 'boolean');
            },

            color: function(datatype, obj) {
                var flag = false;

                if(datatype === 'string') {
                    flag = (!obj) ? true : (/(^[0-9A-F]{8}$)|(^[0-9A-F]{6}$)/i.test(obj));

                    if(!flag && obj.indexOf('$') === 0) flag = true; //Color constants support

                    return flag;
                }
                return flag;
            },

            date: function(datatype, obj) {
                if(datatype === 'date') {
                    return true;
                } else if(datatype === 'array' && [3, 6].indexOf(obj.length) >= 0) {
                    return _isDateString((obj[2]+'-'+obj[1]+'-'+obj[0]+' '+(obj[3] || 0)+':'+(obj[4] || 0)+':'+(obj[5] || 0)));
                }
                return false;
            },

            decimal: function(datatype, obj) {
                return (datatype === 'number' && !__is.integer(datatype, obj));
            },

            document: function(datatype) {
                return (datatype === 'document');
            },

            dom: function(datatype) {
                return (datatype === 'node');
            },

            empty: function(datatype, obj) {
                var k = '';

                if(datatype === 'null' || datatype === 'undefined') {
                    return true;
                } else if(datatype === 'string' || __is.list(datatype, obj)) {
                    return (obj.length === 0);
                } else if(datatype === 'object') {
                    for(k in obj) {
                        if(Object.prototype.hasOwnProperty.call(obj, k)) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            },

            equals: function(datatype, obj, a) {
                var i = 0, k = '', adatatype = _datatype(a);

                if(datatype !== adatatype) {
                    return false;
                } else if(__is.list(adatatype, a)) {
                    if(obj.length !== a.length) {
                        return false;
                    }
                    for(i=0; i<a.length; i++) {
                        if(!__is.equals(_datatype(obj[i]), obj[i], a[i])) {
                            return false;
                        }
                    }
                    return true;
                } else if(adatatype === 'object') {
                    if(_size(a) !== _size(obj)) {
                        return false;
                    }
                    for(k in a) {
                        if(Object.prototype.hasOwnProperty.call(a, k)) {
                            if(!__is.equals(_datatype(obj[k]), obj[k], a[k])) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
                return (obj === a);
            },

            event: function(datatype) {
                return (['event', 'touch'].indexOf(datatype) >= 0);
            },

            fragment: function(datatype) {
                return (datatype === 'fragment');
            },

            function: function(datatype) {
                return (datatype === 'function');
            },

            i18n: function(datatype, obj) {
                return (datatype === 'string' && obj.indexOf('voltmx.i18n.getLocalizedString(') === 0);
            },

            integer: function(datatype, obj) {
                return (datatype === 'number' && Math.ceil(obj) === Math.floor(obj));
            },

            leapyear: function(datatype, obj) {
                if(datatype === 'number' && obj >= 1000 && obj <= 9999) {
                    obj = new Date(obj, 1, 29, 0, 0, 0);
                    return (obj.getMonth() === 1) ? true : false;
                } else if(datatype === 'date') {
                    obj = new Date(obj.getFullYear(), 1, 29, 0, 0, 0);
                    return (obj.getMonth() === 1) ? true : false;
                }
                return false;
            },

            list: function(datatype) {
                return ([
                    'argument',
                    'array',
                    'cssrulelist',
                    'nodelist',
                    'stylesheetlist',
                    'filelist',
                    'touchlist'
                ].indexOf(datatype) >= 0);
            },

            null: function(datatype) {
                return (datatype === 'null');
            },

            number: function(datatype) {
                return (datatype === 'number');
            },

            numeric: function(datatype, obj) {
                var regexp = /^\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*$/;
                return (datatype === 'string' && regexp.test(obj));
            },

            object: function(datatype) {
                return (['object', 'widget'].indexOf(datatype) >= 0);
            },

            size: function(datatype, obj, arg2) {
                if(datatype === 'number') {
                    if(arg2 === true) { //Only +ve number
                        return (obj >= 0);
                    } else if(arg2 === false) { //Only -ve number
                        return (obj <= 0);
                    } //Both +ve/-ve number
                    return true;
                } else if(datatype === 'string') {
                    if(!obj) {
                        return true;
                    } else if(__is.numeric(datatype, obj)) {
                        return false;
                    } else if(arg2 === true) { //Only +ve number
                        return (/^([0-9]+)(\.[0-9]+)?(px|%|dp)?$/.test(obj));
                    } else if(arg2 === false) { //Only -ve number
                        return (/^[-]([0-9]+)(\.[0-9]+)?(px|%|dp)?$/.test(obj));
                    } //Both +ve/-ve number
                    return (/^[-+]?([0-9]+)(\.[0-9]+)?(px|%|dp)?$/.test(obj));
                }
                return false;
            },

            skinningConstant: function(datatype, value) {
                return (datatype === 'string' && value.indexOf('$') === 0);
            },

            string: function(datatype) {
                return (datatype === 'string');
            },

            undefined: function(datatype) {
                return (datatype === 'undefined');
            },

            widget: function(datatype, obj, arg2) {
                if(datatype !== 'widget') {
                    return false;
                }
                if(!arg2) { //arg2 is expected to be a "string"
                    return true;
                } else if(arg2 === 'component') {
                    if((obj instanceof voltmx.ui.UserWidget
                        || obj instanceof voltmx.ui.FlexContainer
                        || obj instanceof voltmx.ui.FlexScrollContainer)
                        && _datatype(obj._kwebfw_.is.component) === 'object') {
                        return true;
                    }
                    return false;
                } else if(arg2 === 'inherited') {
                    if(obj.__$kwebfw$ns__ && obj.__$kwebfw$name__
                        && !Object.prototype.hasOwnProperty.call(obj, '__$kwebfw$ns__')
                        && !Object.prototype.hasOwnProperty.call(obj, '__$kwebfw$name__')) {
                        return true;
                    }
                    return false;
                } else if(obj instanceof voltmx.ui[arg2]
                    && (obj.__$kwebfw$name__ === arg2
                    || obj._kwebfw_.ns === ('voltmx.ui.'+arg2))) {
                    return true;
                }
                return false;
            },

            window: function(datatype) {
                return (datatype === 'window');
            }
        };


    var _accessorDescriptor = function $KU_accessorDescriptor(configurable, prop, fn) {
        var desc = {enumerable:true, configurable:configurable};

        desc[prop] = fn;

        return desc;
    };

    var _convertPlainObjectToWidgetInstance = function $KU_convertPlainObjectToWidgetInstance(obj) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, c = 0,
            _ = null, widget = null, klass = null, child = null, clen = -1;

        if(obj) {
            _ = obj._kwebfw_; delete obj._kwebfw_;
            klass = _get(_.ns, window);

            if($KU.is(klass, 'function')) {
                obj.isPreValidated = true;
                widget = (_.tpwp) ? (new klass(obj, {}, _.tpwp)) : (new klass(obj));

                delete widget._kwebfw_.isPreValidated;
                widget._kwebfw_.is.cloned = true;
                if(_.is.template) widget._kwebfw_.is.template = true;

                if(widget._kwebfw_.is.component) {
                    widget._kwebfw_.is.cloned = true;

                    $KW.iterate($KW.proxy(widget), function(child) {
                        child._kwebfw_.is.cloned = true;
                    });
                } else if($KW.isContainer(widget)) {
                    clen = _.children.length;

                    for(c=0; c<clen; c++) {
                        child = _.children[c];
                        child = _convertPlainObjectToWidgetInstance(child);
                        child && widget.add(child);
                    }
                }

                _ = null; //For GC
            }
        }

        return widget;
    };


    var _convertWidgetInstanceToPlainObject = function $KU_convertWidgetInstanceToPlainObject(widget, prefix) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, _ = widget._kwebfw_,
            prop = _.prop, obj = {_kwebfw_:{ns:_.ns, name:_.name, is:{}}},
            child = null, children = null, c = 0, clen = 0, escapeProps = null;

        if(!$KW.isClonable(widget)) {
            obj = null;
        } else {
            if(_.tpwp) {
                obj._kwebfw_.tpwp = {};

                $KU.each(_.tpwp, function(value, key) {
                    obj._kwebfw_.tpwp[key] = value;
                });
            }

            $KU.each($KW.inheritedProperties(widget), function(value, key) {
                obj[key] = value;
            });

            escapeProps = _deduceEscapeProperties(widget);

            if($KU.is(_.args, 'array')
            && _.args.length === 3
            && $KU.is(_.args[0], 'object')
            && $KU.is(_.args[1], 'object')
            && $KU.is(_.args[2], 'object')) {
                $KU.each(_.args, function(config) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.each(config, function(value, key) {
                        obj[key] = (key === 'id') ? (prefix+value) : value;
                    });
                });
            } else {
                $KU.each(prop, function(value, key) {
                    if(escapeProps.indexOf(key) === -1) {
                        obj[key] = (key === 'id') ? (prefix+value) : value;
                    }
                });
            }

            if(_.is.template === true) {
                obj._kwebfw_.is.template = true;
            }

            if($KW.isContainer(widget)) {
                children = $KW.children(widget);
                clen = children.length;
                obj._kwebfw_.children = [];

                for(c=0; c<clen; c++) {
                    child = _convertWidgetInstanceToPlainObject(children[c], prefix);
                    child && obj._kwebfw_.children.push(child);
                }
            }
        }

        return obj;
    };


    var _deduceEscapeProperties = function $KU_deduceEscapeProperties(widget) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, _ = widget._kwebfw_,
            prop = _.prop, escapeProps = $KW.getNonConstructorProperties($KW.name(widget));

        if(_escapeProperties[$KW.name(widget)]) {
            escapeProps = escapeProps.concat(_escapeProperties[$KW.name(widget)]);
        }

        escapeProps.push('parent', 'frame', '_voltmxControllerName');
        if($KU.is(prop.focusSkin, 'null')) escapeProps.push('focusSkin');
        if($KU.is(prop.padding, 'null')) escapeProps.push('padding');
        if($KU.is(prop.skin, 'null')) escapeProps.push('skin');


        if($KU.is(widget, 'widget', 'SegmentedUI2')) {
            if($KU.is(prop.contentOffset, 'object')) {
                escapeProps.push('contentOffset');
            }

            if($KU.is(prop.contentOffsetMeasured, 'object')) {
                escapeProps.push('contentOffsetMeasured');
            }

            if($KU.is(prop.selectionBehaviorConfig, 'null')) {
                escapeProps.push('selectionBehaviorConfig');
            }

            if($KU.is(prop.rowTemplate, 'null')) {
                escapeProps.push('rowTemplate');
            }

            if($KU.is(prop.sectionHeaderTemplate, 'null')) {
                escapeProps.push('sectionHeaderTemplate');
            }
            return escapeProps;
        }

        if($KU.is(prop.selectedValue, 'null')
            && $KU.is(widget, 'widget', 'Slider')) {
            escapeProps.push('selectedValue');
            return escapeProps;
        }

        if($KU.is(widget, 'widget', 'Camera')) {
            if($KU.is(prop.videoDuration, 'null')) {
                escapeProps.push('videoDuration');
            }

            if($KU.is(prop.rawBytes, 'null')) {
                escapeProps.push('rawBytes');
            }

            return escapeProps;
        }

        if($KU.is(widget, 'widget', 'Map')) {
            if($KU.is(prop.navControlsImageConfig, 'string')) {
                escapeProps.push('navControlsImageConfig');
            }

            if($KU.is(prop.onBoundsChanged, 'string')) {
                escapeProps.push('onBoundsChanged');
            }

            if($KU.is(prop.onMapLoaded, 'string')) {
                escapeProps.push('onMapLoaded');
            }

            if($KU.is(prop.onPinClick, 'string')) {
                escapeProps.push('onPinClick');
            }

            if($KU.is(prop.onSelection, 'string')) {
                escapeProps.push('onSelection');
            }

            if($KU.is(prop.widgetDataMapForCallout, 'string')) {
                escapeProps.push('widgetDataMapForCallout');
            }
            return escapeProps;
        }

        if($KU.is(widget, 'widget', 'CollectionView')) {
            if($KU.is(prop.contentOffset, 'object')) {
                escapeProps.push('contentOffset');
            }

            if($KU.is(prop.contentOffsetMeasured, 'object')) {
                escapeProps.push('contentOffsetMeasured');
            }

            if($KU.is(prop.pullToRefreshView, 'null')) {
                escapeProps.push('pullToRefreshView');
            }

            if($KU.is(prop.pushToRefreshView, 'null')) {
                escapeProps.push('pushToRefreshView');
            }

            if($KU.is(prop.releaseToPullRefreshView, 'null')) {
                escapeProps.push('releaseToPullRefreshView');
            }

            if($KU.is(prop.releaseToPushRefreshView, 'null')) {
                escapeProps.push('releaseToPushRefreshView');
            }

            if($KU.is(prop.selectedItemindex, 'array')) {
                escapeProps.push('selectedItemindex');
            }

            if($KU.is(prop.selectionBehaviorConfig, 'array')) {
                escapeProps.push('selectionBehaviorConfig');
            }
            return escapeProps;
        }

        return escapeProps;
    };


    var _debounce = function(func, delay) {
        var debounceTimer = null;
        return function() {
            var context = this;
            var args = arguments;
            debounceTimer && clearTimeout(debounceTimer);
            debounceTimer = setTimeout(function() {
                func.apply(context, args);
            }, delay);
        };
    };


    var _deserializeDate = function $KU_deserializeDate(value) {
        var date = '', time = '';

        if(_isDateString(value)) {
            value = value.split(' ');
            date = value[0].split('-');
            time = value[1].split(':');

            return new Date(parseInt(date[0], 10), (parseInt(date[1], 10)-1), parseInt(date[2], 10), parseInt(time[0], 10), parseInt(time[1], 10), parseInt(time[2], 10));
        }
        return value;
    };


    var _deserializeFunction = function $KU_deserializeFunction(value) {
        //*
        var fn = null, args = '', body = '';

        if(_isFunctionString(value)) {
            args = value.substring((value.indexOf('(') + 1), (value.indexOf(')')));
            body = value.substring((value.indexOf('{') + 1), (value.lastIndexOf('}')));
            fn = new Function(args, body);
        } else {
            fn = value;
        }
        //*/

        /*
        var $K = voltmx.$kwebfw$, $KU = $K.utils, regexp = '', fn = '', matches = null, name = '', args = '', body = '';

        if(_isFunctionString(value)) {
            regexp = /^function\s*([^\s(]*)\s*\(([^)]*)\)[^{]*\{([^]*)\}$/gi;
            fn = value.replace(/^\s|\s$/g, '');
            matches = regexp.exec(fn);

            if(matches && matches.length) {
                name = matches[1] || '';
                args = matches[2].replace(/\s+/g,'').split(',');
                body = matches[3] || '';

                fn = Function.prototype.constructor.apply(this, [].concat(args, body));
            } else {
                fn = value;
            }
        } else {
            fn = value;
        }
        //*/

        return fn;
    };


    var _deserializeWidget = function $KU_deserializeWidget(value) {
        if(_isWidgetString(value)) {
            value = value.slice(20, (value.length-1));
            value = JSON.parse(value);
            value = _convertPlainObjectToWidgetInstance(value);
        } else {
            value = null;
        }

        return value;
    };


    var _escapeProperties = {
        Calendar: ['day', 'month', 'year', 'hour', 'minutes', 'seconds']
    };


    var _isDateString = function $KU_isDateString(value) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, isValid = false, regexp = null;

        if($KU.is(value, 'string') && value) {
            regexp = new RegExp(/^\d\d\d\d-(0?[1-9]|1[0-2])-(0?[1-9]|[12][0-9]|3[01]) (00|[0-9]|1[0-9]|2[0-3]):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9])$/g);
            isValid = regexp.test(value);
        }

        return isValid;
    };


    var _isFunctionString = function $KU_isFunctionString(value) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, isValid = false;

        if($KU.is(value, 'string')) {
            if(value.substr(0, 8) === 'function') {
                isValid = true;
            }
        }

        return isValid;
    };


    var _isWidgetString = function $KU_isWidgetString(value) {
        var flag = false;

        if(value.substr(0, 21) === 'voltmx.ui.BasicWidget({'
        && value.substr((value.length-2), 2) === '})') {
            flag = true;
        }

        return flag;
    };


    var _serializeDate = function $KU_serializeDate(value) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, yyyy = '', mm = '', dt = '', hr = '', min = '', sec = '';

        if($KU.is(value, 'date')) {
            yyyy = value.getFullYear().toString();
            mm = (value.getMonth()+1); mm = (mm < 10) ? ('0'+mm) : mm.toString();
            dt = value.getDate(); dt = (dt < 10) ? ('0'+dt) : dt.toString();
            hr = value.getHours(); hr = (hr < 10) ? ('0'+hr) : hr.toString();
            min = value.getMinutes(); min = (min < 10) ? ('0'+min) : min.toString();
            sec = value.getSeconds(); sec = (sec < 10) ? ('0'+sec) : sec.toString();

            return (yyyy+'-'+mm+'-'+dt+' '+hr+':'+min+':'+sec);
        }
        return value;
    };


    var _serializeFunction = function $KU_serializeFunction(value) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(value, 'function')) {
            return value.toString();
        }
        return value;
    };


    var _serializeWidget = function $KU_serializeWidget(value) {
        value = _convertWidgetInstanceToPlainObject(value);

        return (value) ? ('voltmx.ui.BasicWidget(' + JSON.stringify(value) + ')') : '';
    };

    /* -------------------------------------------------------------------------- */

    var _angle = function $KU_angle(endPoint, startPoint) {
        var deltaX = 0, deltaY = 0, angle = 0;

        if(_is(endPoint, 'object') && _is(startPoint, 'object')) {
            deltaX = endPoint.x - startPoint.x;
            deltaY = endPoint.y - startPoint.y;
        } else if(_is(endPoint, 'number') && _is(startPoint, 'number')) {
            deltaX = endPoint;
            deltaY = startPoint;
        }

        angle = (Math.atan2(deltaY, deltaX) * 180) / Math.PI;

        return angle;
    };

    var _browser = function $KU_browser(info, supports) {
        var ua = navigator.userAgent.toLowerCase(), index = -1,
            name = '', os = '', version = '', channel = '',
            orientation = null, bodyHeight = 0, bodyWidth = 0;

        if(_is(info, 'string') && info) info = info.toLowerCase();
        if(_is(supports, 'string') && supports) supports = supports.toLowerCase();

        if(ua.indexOf('edg/') >= 0) {
            ua = ua.replace('edg/', 'edge/');
        } else if(ua.indexOf('trident/') >= 0
        && ua.indexOf('rv:11.0') >= 0) {
            ua = ua.replace('rv:11.0', 'msie/11.0');
        }

        if(info === 'orientation') {
            orientation = screen.orientation || screen.mozOrientation || screen.msOrientation;

            if(window.ScreenOrientation
            && orientation instanceof ScreenOrientation) {
                if(orientation.type === 'portrait-primary'
                || orientation.type === 'portrait-secondary') {
                    return 'portrait';
                } else if(orientation.type === 'landscape-primary'
                || orientation.type === 'landscape-secondary') {
                    return 'landscape';
                }
                return 'portrait';
            } else if(typeof window.orientation === 'number') {
                if(window.orientation === 0 || window.orientation === 180) {
                    if(_browser('os') === 'android'
                    && _browser('channel') === 'tablet') {
                        return 'landscape';
                    }
                    return 'portrait';
                } else if(window.orientation === 90 || window.orientation === -90) {
                    if(_browser('os') === 'android'
                    && _browser('channel') === 'tablet') {
                        return 'portrait';
                    }
                    return 'landscape';
                }
                return 'portrait';
            } else if(window.matchMedia) {
                if(window.matchMedia('(orientation: portrait)').matches) {
                    return 'portrait';
                } else if(window.matchMedia('(orientation: landscape)').matches) {
                    return 'landscape';
                }
                return 'portrait';
            }
            bodyHeight = document.body.offsetHeight;
            bodyWidth = document.body.offsetWidth;
            if(bodyHeight > bodyWidth) {
                return 'portrait';
            } else if(bodyHeight < bodyWidth) {
                return 'landscape';
            }
            return 'portrait';
        } else if(info === 'channel') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                os = _browser('os');
                if(ua.indexOf('mobile') >= 0) {
                    if(os === 'ios') {
                        __browser[info] = (ua.indexOf('iphone') >= 0)
                            ? 'mobile' : (ua.indexOf('ipad') >= 0)
                                ? 'tablet' : 'desktop';
                    } else if(os === 'windows') {
                        __browser[info] = (ua.indexOf('phone') >= 0)
                            ? 'mobile' : (ua.indexOf('tablet') >= 0)
                                ? 'tablet' : 'desktop';
                    } else {
                        __browser[info] = 'mobile';
                    }
                } else if(ua.indexOf('tablet') >= 0) {
                    __browser[info] = 'tablet';
                } else {
                    __browser[info] = 'desktop';
                }
            }
        } else if(info === 'os') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                if(ua.indexOf('mac os') >= 0) {
                    __browser[info] = 'ios';
                } else if(ua.indexOf('windows') >= 0) {
                    __browser[info] = 'windows';
                } else if(ua.indexOf('android') >= 0) {
                    __browser[info] = 'android';
                } else {
                    __browser[info] = 'unknown';
                }
            }
        } else if(info === 'osversion') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                os = _browser('os');
            }
        } else if(info === 'name') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                //NOTE:: Order of if/else condition matters
                if(ua.indexOf('edge') >= 0) {
                    __browser[info] = 'edge';
                } else if(ua.indexOf('msie') >= 0) {
                    __browser[info] = 'msie';
                } else if(ua.indexOf('chrome') >= 0) {
                    __browser[info] = 'chrome';
                } else if(ua.indexOf('firefox') >= 0) {
                    __browser[info] = 'firefox';
                } else if(ua.indexOf('safari') >= 0) {
                    __browser[info] = 'safari';
                } else {
                    __browser[info] = 'unknown';
                }
            }
        } else if(info === 'device') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                os = _browser('os');
                channel = _browser('channel');

                if(channel === 'desktop') {
                    __browser[info] = 'desktop';
                } else if(os === 'android') {
                    __browser[info] = (channel === 'tablet')
                        ? 'androidtablet' : 'android';
                } else if(os === 'ios') {
                    __browser[info] = (channel === 'tablet') ? 'ipad'
                        : (channel === 'mobile') ? 'iphone' : 'mac';
                } else if(os === 'windows') {
                    __browser[info] = (channel === 'tablet') ? 'windowstablet'
                        : (channel === 'mobile') ? 'windowsphone' : 'pc';
                }
            }
        } else if(info === 'version') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                name = _browser('name');
                index = ua.indexOf(name+'/');
                if(index >= 0) {
                    index += (name.length + 1);
                    while(index < ua.length && ['.', '-', '_', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'].indexOf(ua[index]) >= 0) {
                        version += ua[index];
                        index++;
                    }
                }
                __browser[info] = (version) ? version : 'unknown';
            }
        } else if(info === 'engine') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                name = _browser('name');
                if(['chrome', 'safari', 'edge'].indexOf(name) >= 0) {
                    __browser[info] = 'webkit';
                } else if(name === 'firefox') {
                    __browser[info] = 'moz';
                } else if(name === 'msie') {
                    __browser[info] = 'ms';
                } else {
                    __browser[info] = 'unknown';
                }
            }
        } else if(info === 'devicememory') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                __browser[info] = navigator.deviceMemory;
            }
        } else if(info === 'language') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                __browser[info] = navigator.language
                               || navigator.userLanguage
                               || navigator.browserLanguage;
            }
        } else if(info === 'supports') {
            if(supports === 'cookies') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = navigator.cookieEnabled;
                }
            } else if(supports === 'cache') {
                if(Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (window.caches
                                              && window.caches instanceof CacheStorage)
                        ? true : false;
                }
            } else if(supports === 'appcache') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (window.applicationCache
                                              && window.applicationCache instanceof ApplicationCache)
                        ? true : false;
                }
            } else if(supports === 'battery') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(navigator.getBattery, 'function'))
                        ? true : false;
                }
            } else if(supports === 'bluetooth') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = '//TODO::';
                }
            } else if(supports === 'usb') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = '//TODO::';
                }
            } else if(supports === 'clipboard') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = '//TODO::';
                }
            } else if(supports === 'connection') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (navigator.connection instanceof NetworkInformation)
                        ? true : false;
                }
            } else if(supports === 'displaymedia') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(navigator.mediaDevices.getDisplayMedia, 'function'))
                        ? true : false;
                }
            } else if(supports === 'fullscreen') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = document.fullscreenEnabled;
                }
            } else if(supports === 'geolocation') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = navigator.geolocation ? true : false;
                }
            } else if(supports === 'orientation') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = ('onorientationchange' in window);
                }
            } else if(supports === 'touch') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = ('ontouchstart' in window);
                }
            } else if(supports === 'localstorage') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (localStorage
                                              && localStorage instanceof Storage)
                        ? true : false;
                }
            } else if(supports === 'mediarecorder') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(window.MediaRecorder, 'function'))
                        ? true : false;
                }
            } else if(supports === 'sessionstorage') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (sessionStorage
                                              && sessionStorage instanceof Storage)
                        ? true : false;
                }
            } else if(supports === 'usermedia') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (navigator.mediaDevices
                                              && _is(navigator.mediaDevices.getUserMedia, 'function'))
                        ? true : false;
                }
            } else if(supports === 'webshare') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(navigator.share, 'function'))
                        ? true : false;
                }
            } else if(supports === 'speechrecognition') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(window.webkitSpeechRecognition, 'function'))
                        ? true : false;
                }
            } else if(supports === 'contacts') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(navigator.contacts, 'function'))
                        ? true : false;
                }
            } else if(supports === 'getwakelock') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(navigator.getWakeLock, 'function'))
                        ? true : false;
                }
            }
        }

        if(_is(info, 'string') && info) {
            return (info === 'supports' && _is(supports, 'string') && supports)
                ? __browser[info][supports] : __browser[info];
        }
        return __browser;
    };

    var _clone = function $KU_clone(obj, prefix) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, type = '';

        if(_is(obj, 'dom')) {
            return (_is(obj.cloneNode, 'function')) ? obj.cloneNode(true) : obj;
        } else if(_is(obj, 'widget')) {
            if($KW.isClonable(obj)) {
                if(!_is(prefix, 'string')) {
                    prefix = '';
                }

                obj = _convertWidgetInstanceToPlainObject(obj, prefix);

                if($KU.is(obj, 'object') && !$KU.is(obj, 'widget')) {
                    obj = _convertPlainObjectToWidgetInstance(obj);

                    if(obj) {
                        if($KW.isContainer(obj)) {
                            if(obj._kwebfw_.is.template === true) type = 'template';
                            //NOTE:: TabPane and Tab clone is not yet tested
                            else if(obj._kwebfw_.is.tab === true) type = 'tab';

                            if(type) {
                                $KW.root(obj, type);
                            } else {
                                $KW.iterate(obj, function(widget) {
                                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                                    if($KU.is(widget, 'widget', 'component')) {
                                        return true; //No need to loop over its children
                                    }
                                }, {tabs:false});
                            }
                        }
                    }
                }
            }

            return obj;
        }
        return _deserialize(_serialize(obj, prefix));
    };


    var _convertHexToRGBA = function $KU_convertHexToRGBA(value) {
        var r = value.charAt(0) + value.charAt(1),
            g = value.charAt(2) + value.charAt(3),
            b = value.charAt(4) + value.charAt(5),
            a = 0, rgba = '';

        if(value.length === 6) {
            rgba = '#' + r + g + b;
        } else if(value.length === 8) {
            a = value.charAt(6) + value.charAt(7);

            r = parseInt(r, 16);
            g = parseInt(g, 16);
            b = parseInt(b, 16);

            a = parseInt(a, 16);
            a = ((100 - a) / 100).toFixed(2);
            a = parseFloat(a, 10);
            a = (a < 0) ? 0 : (a > 1) ? 1 : a;

            rgba = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
        }

        return rgba;
    };


    var _copy = function $KU_copy(obj) {
        if(_is(obj, 'array')) {
            var arr = []; for(var i=0; i<obj.length; i++) {
                arr.push(_copy(obj[i]));
            }
            return arr;
        } else if(_is(obj, 'object')) {
            var o = {}, k = '';
            for(k in obj) {
                o[k] = _copy(obj[k]);
            }
            return o;
        } else if(_is(obj, 'date')) {
            return new Date(obj.getTime());
        } else if(obj && obj.tagName) {
            return obj.cloneNode(true);
        } else if(_is(obj, 'function')) {
            return function() {
                obj.apply(obj, arguments);
            };
        } else if(_is(obj, 'string') || _is(obj, 'number') || _is(obj, 'boolean')) {
            return obj;
        }
    };

    var _datatype = function $KU_datatype(obj, arg1) {
        var objStr = '';
        if((voltmx.ui.BasicWidget && obj instanceof voltmx.ui.BasicWidget)
        || (voltmx.ui.UserWidget && obj instanceof voltmx.ui.UserWidget)) {
            return 'widget';
        }
        objStr = Object.prototype.toString.call(obj);

        if(objStr === '[object Boolean]' || obj instanceof Boolean) {
            return 'boolean';
        } else if(objStr === '[object String]' || obj instanceof String) {
            return 'string';
        } else if(objStr === '[object Function]' || obj instanceof Function) {
            return 'function';
        } else if(objStr === '[object Undefined]' || obj === arg1) {
            return 'undefined';
        } else if(objStr === '[object Number]' && !isNaN(obj)) {
            return 'number';
        } else if(objStr === '[object Object]') { // || obj instanceof Object
            return 'object';
        } else if(objStr === '[object Array]' || obj instanceof Array) {
            return 'array';
        } else if(objStr === '[object Null]' || obj === null) {
            return 'null';
        } else if(objStr === '[object NodeList]' || objStr === '[object HTMLCollection]'
            || obj instanceof NodeList || obj instanceof HTMLCollection) {
            return 'nodelist';
        } else if(objStr === '[object StyleSheetList]' || obj instanceof StyleSheetList) {
            return 'stylesheetlist';
        } else if(objStr === '[object CSSRuleList]' || obj instanceof CSSRuleList) {
            return 'cssrulelist';
        } else if(objStr === '[object FileList]' || obj instanceof FileList) {
            return 'filelist';
        } else if(objStr === '[object TouchList]') {
            return 'touchlist';
        } else if((objStr === '[object Date]' || obj instanceof Date)
            && (obj.toDateString() !== 'Invalid Date' || !isNaN(obj.getTime()))) {
            return 'date';
        } else if(objStr === '[object Arguments]') {
            return 'argument';
        } else if(obj && obj.tagName) {
            return 'node';
        } else if(obj && obj.type) {
            return 'event';
        } else if(objStr === '[object Touch]') {
            return 'touch';
        } else if(objStr === '[object HTMLDocument]' || objStr === '[object Document]'
            || obj instanceof HTMLDocument || obj instanceof Document) {
            return 'document';
        } else if(objStr === '[object DocumentFragment]' || obj instanceof DocumentFragment) {
            return 'fragment';
        } else if(objStr === '[object global]' || objStr === '[object Window]' || obj === window) {
            return 'window';
        }
        return '';

    };

    var _deduceRoute = function $KU_deduceRoute() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            hash = location.hash,
            formId = null, deeplink = null;

        if(hash.startsWith('#_')) {
            hash = hash.split('/'),
            formId = hash[0];
            deeplink = hash[1];
            formId = formId.substr(2, (formId.length-2));
        } else {
            hash = hash.substr(2, (hash.length)).split('/');
            formId = hash[1];
            deeplink = hash[2];
        }

        if(!$KU.is(formId, 'string')) {
            formId = '';
        }

        if($KU.is(deeplink, 'string') && deeplink) {
            deeplink = deeplink.trim();

            if(deeplink[0] === '{' && deeplink[(deeplink.length-1)] === '}') {
                try{
                    deeplink = decodeURI(deeplink);
                    deeplink = JSON.parse(deeplink);
                } catch(e) {
                    deeplink = null;
                }
            }
        } else {
            deeplink = null;
        }

        return {formId:formId, deeplinkParams:deeplink};
    };


    var _defaults = function $KU_defaults(sub, sup) {
        var k = '';

        if(_is(sub, 'object') && _is(sup, 'object')) {
            for(k in sup) {
                if(!Object.prototype.hasOwnProperty.call(sub, k)
                && Object.prototype.hasOwnProperty.call(sup, k)) {
                    sub[k] = sup[k];
                }
            }
        }

        return sub;
    };

    //NOTE:: defineGetter must be called before defineSetter
    var _defineGetter = function $KU_defineGetter(obj, prop, get, configurable) {
        if(typeof configurable !== 'boolean') configurable = true;

        if(Object.defineProperty) {
            return Object.defineProperty(obj, prop, _accessorDescriptor(configurable, 'get', get));
        } else if(Object.prototype.__defineGetter__) {
            return obj.__defineGetter__(prop, get);
        }
        //Throw Error
    };


    var _defineProperty = function $KU_defineProperty(obj, prop, value, arg3) {
        var descriptor = {configurable:false, enumerable:false, value:value, writable:false};

        //NOTE:: When a function scope is changed using bind API.
        //Then that new function does not contain "prototype" property
        if(typeof value === 'function') {
            value.toLocaleString = value.__proto__.toLocaleString;
            value.toSource = value.__proto__.toSource;
            value.toString = value.__proto__.toString;
        }

        //Pass null as 4th argument, if none of the if condition to be met
        if(arguments.length === 3) {
            descriptor.configurable = true;
            descriptor.writable = true;
        } else if(arguments.length === 4) {
            if(typeof arg3 === 'boolean') {
                descriptor.writable = arg3;
            } else if(arg3 && typeof arg3 === 'object') {
                descriptor = arg3;
                descriptor.value = value;
            }
        }

        Object.defineProperty(obj, prop, descriptor);
    };


    //NOTE:: defineSetter must be called after defineGetter
    var _defineSetter = function $KU_defineSetter(obj, prop, set, configurable) {
        if(typeof configurable !== 'boolean') configurable = true;

        if(Object.defineProperty) {
            return Object.defineProperty(obj, prop, _accessorDescriptor(configurable, 'set', set));
        } else if(Object.prototype.__defineSetter__) {
            return obj.__defineSetter__(prop, set);
        }
        //Throw Error
    };

    var _deserialize = function $KU_deserialize(text) {
        if(!_is(text, 'string')) {
            return text;
        }
        if((text[0] === '{' && text[text.length-1] === '}')
            || (text[0] === '[' || text[text.length-1] === ']')) {
            try{
                return JSON.parse(text, function(key, value) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    if($KU.is(value, 'string') && value) {
                        if(_isDateString(value)) {
                            return _deserializeDate(value);
                        } else if(_isFunctionString(value)) {
                            return _deserializeFunction(value);
                        }
                        return value;
                    }
                    return value;
                });
            } catch(e) {
                return text;
            }
        } else if(_isWidgetString(text)) {
            return _deserializeWidget(text);
        } else if(_isDateString(text)) {
            return _deserializeDate(text);
        } else if(_isFunctionString(text)) {
            return _deserializeFunction(text);
        } else {
            return text;
        }
    };


    var _direction = function $KU_direction(movedPoint, startPoint) {
        var direction = '', angle = _angle(movedPoint, startPoint);

        if(angle >= 45 && angle < 135) {
            direction = 'down';
        } else if(angle >= 135 || angle <= -135) {
            direction = 'left';
        } else if(angle < -45 && angle > -135) {
            direction = 'up';
        } else if(angle >= -45 && angle <= 45) {
            direction = 'right';
        }

        return direction;
    };


    //Return boolean TRUE to break the looping
    var _each = function $KU_each(variable, callback, scope) {
        var k = '', len = 0, output = null;

        if(!_is(callback, 'function')) return;

        if(_is(variable, 'list')) {
            len = variable.length - 1;

            for(k=0; k<=len; k++) {
                if(arguments.length === 3) {
                    output = callback.call(scope, variable[k], k, len);
                } else if(arguments.length === 2) {
                    output = callback(variable[k], k, len);
                }

                if(output === true) {
                    break;
                }
            }
        } else if(_is(variable, 'object')) {
            for(k in variable) {
                if(Object.prototype.hasOwnProperty.call(variable, k)) {
                    if(arguments.length === 3) {
                        output = callback.call(scope, variable[k], k);
                    } else if(arguments.length === 2) {
                        output = callback(variable[k], k);
                    }

                    if(output === true) {
                        break;
                    }
                }
            }
        }
    };


    var _error = function VoltmxError(errorcode, name, message) {
        this.errorCode = errorcode;
        this.name = name;
        this.message = message;
    };


    var _escapeHTML = function $KU_escapeHTML(str) {
        var div = null;

        if(_is(str, 'string')) {
            if(document && _is(document.createElement, 'function')) {
                div = document.createElement('div');
                div.appendChild(document.createTextNode(str));
                return div.innerHTML;
            }
            //eslint-disable-next-line no-useless-escape
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/\'/g, '&#39;');
        }
        return str;
    };


    var _get = function $KU_get(key, root) {
        var k = 0, klen = 0, value = null;

        if(arguments.length === 1) root = window;
        if(_is(key, 'string') && key) key = key.split('.');

        if(_is(key, 'array') && (_is(root, 'object') || root === window)) {
            klen = key.length-1; value = root;

            for(k=0; k<klen; k++) { //Here klen = key.length-1;
                if((_is(root, 'object') || root === window)
                && Object.prototype.hasOwnProperty.call(value, key[k])) {
                    value = value[key[k]];
                } else {
                    break;
                }
            }

            if((_is(root, 'object') || root === window)
            && Object.prototype.hasOwnProperty.call(value, key[klen])) {
                value = value[key[klen]];
            } else {
                value = undefined;
            }
        }

        return value;
    };


    var _getI18Nvalue = function $KU_getI18Nvalue(value) {
        var regexp = null, matches = null, key = '';

        if(_is(value, 'i18n')) {
            //eslint-disable-next-line no-useless-escape
            regexp = /\((\'|\")([^)]+)(\'|\")\)/;
            matches = regexp.exec(value);
            key = (matches && matches[2]) ? matches[2] : '';
        }

        return (key) ? voltmx.i18n.getLocalizedString(key) : '';
    };


    var _getImageURL = function $KU_getImageURL(src) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KG = $K.globals, $KA = $K.app, path = '';

        if($KU.is(src, 'string') && src) {
            if(src.indexOf('http') === 0) {
                path = src;
            } else {
                if((src.match(/^([^.]+)$/) !== null)) {
                    src = src + '.svg';
                }

                if($KA.staticContentPath) {
                    path += $KA.staticContentPath;
                }

                if($KG.platform) {
                    path += ($KG.platform + '/');
                }

                path += 'images/';

                if($K.device.resolution) {
                    path += ($K.device.resolution + '/');
                }

                path += src;
            }
        }

        return path;
    };

    var _getLocalStorage = function $KU_getLocalStorage() {
        var $K = voltmx.$kwebfw$, $KA = $K.app, store = null,
            data = localStorage.getItem($KA.id);

        if(typeof data === 'string' && data) {
            try{
                store = JSON.parse(data);
            } catch(e) {
                store = data;
            }
        }

        return store;
    };

    /**
    * For given src (any asset e.g. image, font) and path would be folder (e.g. web/localfiles).
    * returns proper relative URL wrt runtime.
    *
    * This utility doesn't check for existence of actual asset in that folder.
    */
    var _getRelativeURL = function $KU_getRelativeURL(src, path) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KG = $K.globals, $KA = $K.app, relativepath = '';

        if($KU.is(src, 'string') && src
        && $KU.is(path, 'string') && path) {
            if($KA.staticContentPath) {
                relativepath += $KA.staticContentPath;
            }

            if($KG.platform) {
                relativepath += ($KG.platform + '/');
            }

            relativepath += path;

            relativepath += src;
        }

        return relativepath;
    };

    var _getResourceURL = function(src) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            path = '';

        if($KU.is(src, 'string') && src) {
            if(src.indexOf('blob') === 0) {
                path = src;
            } else {
                path = _getImageURL(src);
            }
        }

        return path;
    };

    var _getThemeStyleSheet = function $KU_getThemeStyleSheet(identifier) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, stylesheet = null;

        $KU.each(document.styleSheets, function(sheet) {
            if(sheet.ownerNode.tagName === 'LINK'
            && sheet.ownerNode.hasAttribute('ktheme')) {
                if(sheet.ownerNode.getAttribute('ktheme') === identifier) {
                    stylesheet = sheet;
                    return true;
                }
            }
        });

        return stylesheet;
    };


    var _getValueUnitByWidgetFrame = function $KU_getValueUnitByWidgetFrame(value, axis, widgetFrame) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KF = voltmx.flex,
            len = 0, unit = null;

        if($KU.is(value, 'string')) {
            len = value.length;
            if(value.substr((len-1), 1) === $KF.PERCENTAGE) {
                value = parseFloat(value.replace($KF.PERCENTAGE, ''), 10);
                if(axis === 'x') {
                    value = (value * widgetFrame.width) / 100;
                } else if(axis === 'y') {
                    value = (value * widgetFrame.height) / 100;
                }
                unit = $KF.PERCENTAGE;
            } else if(value.substr((len-2), 2) === $KF.PX) {
                value = (parseFloat(value.replace($KF.PX, ''), 10) / $K.device.DPI);
                value = Math.round(value);
                unit = $KF.PX;
            } else if(value.substr((len-2), 2) === $KF.DP) {
                value = parseFloat(value.replace($KF.DP, ''), 10);
                unit = $KF.DP;
            }
        }

        return {'value': value, 'unit': unit};
    };

    var _hasEventProperty = function(model, key) {
        var isEvent = false, events = ['onClick', 'onTextChange', 'onDone', 'onSelection', 'onSlide'],
            touchEvent = [ 'onTouchStart', 'onTouchEnd', 'onTouchMove'], widgetType = model._kwebfw_.name,
            clickWidgets = ['Button', 'FlexContainer', 'FlexScrollContainer', 'RichText'],
            onSlideWidgets = ['Switch', 'Slider'],
            onSelectionWidgets = ['CheckBoxGroup', 'ListBox', 'RadioButtonGroup', 'Calendar', 'Slider'],
            textChangeWidgets = ['TextBox2', 'TextArea2'];

        if(touchEvent.indexOf(key) !== -1) {
            isEvent = true;
        }

        if(events.indexOf(key) !== -1) {
            if((key === 'onClick' && clickWidgets.indexOf(widgetType) !== -1)
            || (key === 'onSelection' && onSelectionWidgets.indexOf(widgetType) !== -1)
            || (key === 'onSlide' && onSlideWidgets.indexOf(widgetType) !== -1)
            || ((key === 'onTextChange' || key === 'onDone')
            && textChangeWidgets.indexOf(widgetType) !== -1)
            || (key === 'onDownloadComplete' && widgetType === 'Image2')) {
                isEvent = true;
            }
        }

        return isEvent;
    };


    var _inherits = function $KU_inherits(child, parent) {
        var Inherit = null;

        if(typeof Object.create === 'function') {
            child.prototype = Object.create(parent.prototype);
        } else {
            Inherit = function() {};
            Inherit.prototype = parent.prototype;
            child.prototype = new Inherit();
            child.prototype.constructor = child;
        }

        child.base = parent;
    };

    var _is = function $KU_is(obj, type, arg2) {
        var flag = false, datatype = '';

        if(__is[type]) {
            datatype = _datatype(obj);

            flag = (arg2 !== undefined && datatype !== undefined)
                ? __is[type](datatype, obj, arg2)
                : __is[type](datatype, obj);
        }

        return flag;
    };

    var _loadedFromOtherFramework = function $KU_loadedFromOtherFramework() {
        var flag = false, $KG = $K.globals;

        if($KG.kof.loadedFromOtherFramework) {
            flag = true;
        }

        return flag;
    };

    var _loadScript = function $KU_loadScript(src, attr, onsuccess, onerror, arg4) {
        var head = arg4 || document.head, key = '',
            script = document.createElement('SCRIPT');

        if(attr === true) {
            script.async = false;
        } else if(typeof attr === 'object' && attr) {
            if(attr.sync === true) {
                script.async = false;
                delete attr.sync;
            }
        }

        script.type = 'text/javascript';
        script.src = src;

        if(typeof attr === 'object' && attr) {
            for(key in attr) {
                if(Object.prototype.hasOwnProperty.call(attr, key) && attr[key]) {
                    script.setAttribute(key, attr[key]);
                }
            }
        }

        script.onload = function() {
            script.onload = script.onerror = null; //For GC

            if(typeof onsuccess === 'function') {
                onsuccess.call(this);
            }
        };

        script.onerror = function() {
            script.onload = script.onerror = null; //For GC

            if(typeof onerror === 'function') {
                onerror.call(this);
            }
        };

        head.appendChild(script);
    };


    var _loadStyle = function $KU_loadStyle(src, attr, onsuccess, onerror, arg4) {
        var link = document.createElement('link'),
            key = '', media = 'all', head = arg4;

        if(arguments.length === 4
        && typeof onerror !== 'function') {
            head = onerror;
            onerror = function() {};
        }

        if(typeof attr === 'string') {
            media = attr;
        }

        if(!head) {
            head = document.head;
        }

        link.href = src;
        link.media = 'none';
        link.type = 'text/css';
        link.rel = 'stylesheet';

        if(typeof attr === 'object' && attr) {
            for(key in attr) {
                if(Object.prototype.hasOwnProperty.call(attr, key) && attr[key]) {
                    link.setAttribute(key, attr[key]);
                }
            }
        }

        link.onload = function() {
            link.onload = link.onerror = null; //For GC

            if(typeof onsuccess === 'function') {
                onsuccess.call(this);
            }

            if(this.media === 'none') {
                this.media = media;
            }
        };

        link.onerror = function() {
            link.onload = link.onerror = null; //For GC

            if(typeof onerror === 'function') {
                onerror.call(this);
            }
        };

        head.appendChild(link);
    };

    //meta = {api:'', enter|exit:true|false}
    //meta = {api:'', params:[]}
    var _log = function $KU_log(meta, arg1) {
        var $K = voltmx.$kwebfw$, $KA = $K.app, msg = '',
            $KB = $K.behavior, argLen = arguments.length;

        if(_is(meta, 'object') && Object.prototype.hasOwnProperty.call(meta, 'api')
        && (Object.prototype.hasOwnProperty.call(meta, 'enter')
        || Object.prototype.hasOwnProperty.call(meta, 'exit')
        || Object.prototype.hasOwnProperty.call(meta, 'params'))) {
            if(_is(meta.params, 'list')) {
                msg = 'PARAMS:: ' + meta.api + '(';
                //TODO:: meta.params.join(' ')
                msg += ').';
            } else if(_is(meta.enter, 'boolean')) {
                msg = 'ENTER:: ' + meta.api + '().';
            } else if(_is(meta.exit, 'boolean')) {
                msg = 'EXIT:: ' + meta.api + '().';
            }
            _trace(msg);
        } else if(argLen >= 2) {
            msg = arg1;

            if(argLen === 2 && typeof meta === 'string'
            && console && typeof console[msg] === 'function' //eslint-disable-line no-console
            && typeof console[meta] !== 'function') { //eslint-disable-line no-console
                console[msg](meta); //eslint-disable-line no-console
            } else if($KB.enableLoggerFramework === true
            && $KA.logger && $KA.logger[meta]) {
                $KA.logger[meta](msg);
            } else voltmx.print(msg);
        } else if(arguments.length === 1) {
            console.log(meta); //eslint-disable-line no-console
        }
    };

    //This function returns a new Array/Object, does not change the passed Array/Object
    var _removeFromIndexes = function $KU_removeFromIndexes(obj, indexes) {
        var items = null, i=0, len = 0, index = -1, count = 0;

        if(_is(indexes, 'array')) {
            len = indexes.length;

            if(_is(obj, 'array')) {
                items = []; for(i=0; i<len; i++) {
                    index = indexes[i] - count;
                    if(index >= 0 && index < obj.length) {
                        items.push(obj.splice(index, 1)[0]);
                        count++;
                    }
                }

                return items;
            } else if(_is(obj, 'object')) {
                items = {}; for(i in obj) {
                    if(indexes.indexOf(i) < 0) {
                        items[i] = obj[i];
                    }
                }

                return items;
            }
        }

        return obj;
    };


    var _scrollType = function $KU_scrollType() {
        return 'native'; //native/custom
    };


    var _serialize = function $KU_serialize(obj, opt) {
        if(!_is(opt, 'object')) opt = {};

        if(_is(obj, 'string') || _is(obj, 'number')
        || _is(obj, 'boolean') || _is(obj, 'null')) {
            return obj;
        } else if(_is(obj, 'function')) {
            return _serializeFunction(obj);
        } else if(_is(obj, 'date')) {
            return _serializeDate(obj);
        } else if(_is(obj, 'widget')) {
            return _serializeWidget(obj);
        } else if(_is(obj, 'object') || _is(obj, 'array')) {
            return JSON.stringify(obj, function(key, value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                if($KU.is(value, 'function')) {
                    return (opt.function === false) ? value : _serializeFunction(value);
                } else if($KU.is(value, 'date')) {
                    return _serializeDate(value);
                } else if($KU.is(value, 'widget')) {
                    return _serializeWidget(value);
                }
                return value;
            });
        }
        throw new Error('Passed data cannot be serialized.');
    };


    var _set = function $KU_set(key, value, root) {
        var k = 0, klen = 0, err = 'A part of the path is already defined, and its datatype is not <object>.';

        if(_is(key, 'string') && key) {
            key = key.split('.');
        }

        if(_is(key, 'array') && _is(root, 'object')) {
            klen = key.length-1; value = root;

            for(k=0; k<klen; k++) { //Here klen = key.length-1;
                if(_is(value, 'object')) {
                    if(!Object.prototype.hasOwnProperty.call(value, key[k])) {
                        value[key[k]] = {};
                    }

                    value = value[key[k]];
                } else {
                    throw new Error(err);
                }
            }

            if(_is(value, 'object')) {
                if(!Object.prototype.hasOwnProperty.call(value, key[klen])) {
                    value[key[klen]] = value;
                } else {
                    throw new Error(err);
                }
            } else {
                throw new Error(err);
            }
        }
    };


    var _shouldApplyA11Y = function $KW_shouldApplyA11Y() {
        var flag = true;

        //NOTE:: It is decided that it is always true
        //We are keeping it, in case in future any such requirement arises

        return flag;
    };


    var _size = function $KU_size(obj) {
        var i = 0, k = null;

        if(_is(obj, 'string') || _is(obj, 'list')) {
            return obj.length;
        } else if(_is(obj, 'object')) {
            for(k in obj) {
                if(Object.prototype.hasOwnProperty.call(obj, k)) {
                    i++;
                }
            }
            return i;
        }
    };


    var _trace = function(msg) {
        var $K = voltmx.$kwebfw$, $KA = $K.app;

        if($K.behavior.enableLoggerFramework === true
        && $KA.logger && $KA.logger.trace) {
            $KA.logger.trace('KFW-'+msg);
        } else voltmx.print('KFW-'+msg);
    };

    var _uid = function $KU_uid() {
        var time = null;

        if(__uid === null) {
            time = new Date().getTime().toString();
            __uid = parseInt(time, 10);
        } else {
            __uid++;
        }
        return __uid.toString();
    };

    var _unescapeHTML = function $KU_unescapeHTML(str) {
        var div = null, child = null;

        if(_is(str, 'string')) {
            if(document && _is(document.createElement, 'function')) {
                document.createElement('div');
                div.innerHTML = str;
                child = div.childNodes[0];
                return child ? child.nodeValue : '';
            }
            //eslint-disable-next-line no-useless-escape
            return str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '\"').replace(/&#39;/g, '\'');
        }
        return str;
    };


    var _unsupportedAPI = function(api, channel) {
        if(typeof channel === 'string') {
            channel = channel.toLowerCase();

            if(channel === 'spa') {
                channel = 'SPA';
            } else if(channel === 'desktop'
            || channel === 'desktopweb') {
                channel = 'Desktop';
            }
        } else {
            channel = 'SPA & Desktop';
        }
        //eslint-disable-next-line no-console
        console.log('API <' + api + '()> is not supported in ' + channel + ' channel.');
    };

    var _uuid = function $KU_uuid() {
        var uuid = '';

        if(window.crypto) {
            uuid = ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, function(c) {
                //eslint-disable-next-line no-undef
                return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16);
            });
        } else {
            uuid = new Date().getTime();

            if(window.performance && typeof performance.now === 'function') {
                uuid += performance.now();
            }

            uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = (uuid + Math.random() * 16) % 16 | 0;

                uuid = Math.floor(uuid / 16);

                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        return uuid.toUpperCase();
    };
    _inherits(_error, Error);

    $K.defVoltmxProp(_ns, [
        {keey:'angle', value:_angle},
        {keey:'browser', value:_browser},
        {keey:'clone', value:_clone},
        {keey:'convertHexToRGBA', value:_convertHexToRGBA},
        {keey:'copy', value:_copy},
        {keey:'datatype', value:_datatype},
        {keey:'debounce', value:_debounce},
        {keey:'deduceRoute', value:_deduceRoute},
        {keey:'defaults', value:_defaults},
        {keey:'defineGetter', value:_defineGetter},
        {keey:'defineProperty', value:_defineProperty},
        {keey:'defineSetter', value:_defineSetter},
        {keey:'deserialize', value:_deserialize},
        {keey:'direction', value:_direction},
        {keey:'each', value:_each},
        {keey:'error', value:_error},
        {keey:'escapeHTML', value:_escapeHTML},
        {keey:'get', value:_get},
        {keey:'getI18Nvalue', value:_getI18Nvalue},
        {keey:'getImageURL', value:_getImageURL},
        {keey:'getLocalStorage', value:_getLocalStorage},
        {keey:'getRelativeURL', value:_getRelativeURL},
        {keey:'getThemeStyleSheet', value:_getThemeStyleSheet},
        {keey:'getValueUnitByWidgetFrame', value:_getValueUnitByWidgetFrame},
        {keey:'getResourceURL', value:_getResourceURL},
        {keey:'hasEventProperty', value:_hasEventProperty},
        {keey:'inherits', value:_inherits},
        {keey:'is', value:_is},
        {keey:'loadedFromOtherFramework', value:_loadedFromOtherFramework},
        {keey:'loadScript', value:_loadScript},
        {keey:'loadStyle', value:_loadStyle},
        {keey:'log', value:_log},
        {keey:'removeFromIndexes', value:_removeFromIndexes},
        {keey:'scrollType', value:_scrollType},
        {keey:'serialize', value:_serialize},
        {keey:'set', value:_set},
        {keey:'shouldApplyA11Y', value:_shouldApplyA11Y},
        {keey:'size', value:_size},
        {keey:'uid', value:_uid},
        {keey:'unescapeHTML', value:_unescapeHTML},
        {keey:'unsupportedAPI', value:_unsupportedAPI},
        {keey:'uuid', value:_uuid}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/utils/voltmxapm.js' */
Object.defineProperty(voltmx.$kwebfw$, 'apm', {configurable:false, enumerable:false, writable:false, value:(function() {
    var $K = voltmx.$kwebfw$, _foreGroundAt = null, _formEntryAt = null,
        _ns = {}, _metricsService = null, _trackEvents = null, _validEvents = [
            'AppLoad', 'AppTransition',
            'Crash', 'Error', 'Exception',
            'Custom', 'Gesture', 'Touch',
            'FormEntry', 'FormExit', 'Orientation',
            'ServiceCall', 'ServiceRequest', 'ServiceResponse'
        ];


    var _send = function $KAPM_send(widget, event, params) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app, wid = '',
            cf = $KW.model($KA.currentFormUID), flowTag = '', fid = '';

        if(_metricsService && _trackEvents && _trackEvents.indexOf(event) >= 0) {
            fid = (cf) ? cf.id : '';
            wid = (widget) ? widget.id : '';

            switch(event) {
                case 'AppLoad':
                    _metricsService.sendEvent(event, $KA.id, null, null, flowTag, {
                        loaddur: (new Date() - $KA.startedAt)
                    });
                    break;

                case 'AppTransition':
                    if(params.status === 'Foreground') {
                        _foreGroundAt = new Date();
                        params.foredur = 0;
                    } else if(params.status === 'Background') {
                        params.foredur = (new Date() - _foreGroundAt);
                    }

                    _metricsService.sendEvent(event, params.status, wid, null, flowTag, {
                        foredur: params.foredur
                    });
                    break;

                case 'Error':
                    _metricsService.sendEvent(event, widget, fid, null, flowTag, params);
                    break;

                case 'Exception':
                    _metricsService.sendEvent(event, widget, fid, null, flowTag, params);
                    break;

                case 'FormEntry':
                    _formEntryAt = new Date();
                    _metricsService.sendEvent(event, wid, wid, null, flowTag, null);
                    break;

                case 'FormExit':
                    _metricsService.sendEvent(event, wid, wid, null, flowTag, {
                        formdur: (new Date() - _formEntryAt)
                    });
                    break;

                case 'Gesture': //TODO:: Usage
                    _metricsService.sendEvent(event, params.type, fid, wid, flowTag, null);
                    break;

                case 'Orientation':
                    _metricsService.sendEvent(event, params.from, wid, null, flowTag, null);
                    break;

                case 'ServiceRequest': //TODO:: Usage
                    _metricsService.sendEvent(event, widget, fid, null, flowTag, null);
                    break;

                case 'ServiceResponse': //TODO:: Usage
                    _metricsService.sendEvent(event, widget, fid, null, flowTag, params);
                    break;

                case 'Touch': //TODO:: Usage onslide:Slider, onrowselected:DataGrid, ontabclick:TabPane
                    _metricsService.sendEvent(event, params.type, fid, wid, flowTag, null);
                    break;

                default:
                    break;
            }
        }
    };


    var _startTracking = function $KAPM_startTracking(events) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, sdk = null;

        if($KU.is(events, 'array')) {
            _trackEvents = events.slice(0);
            //eslint-disable-next-line no-undef
        } else if($KU.is(appConfig.eventTypes, 'array')) {
            //eslint-disable-next-line no-undef
            _trackEvents = appConfig.eventTypes.slice(0);
        }

        if(_trackEvents) {
            try{
                sdk = voltmx.sdk.getDefaultInstance();
                _metricsService = sdk.getMetricsService();
                _metricsService.setEventConfig('BUFFER', 15, 20);
            } catch(e) {
                _trackEvents = _metricsService = null;
                voltmx.print('MetricsService can be initialize due to some issue in MBAAS SDK. ' + e.message);
            }

            if(_metricsService) {
                _metricsService.setEventTracking = function(events) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    if($KU.is(events, 'array')) {
                        _trackEvents = [];

                        $KU.each(events, function(event) {
                            if(_validEvents.indexOf(event) >= 0) {
                                _trackEvents.push(event);
                            }
                        });
                    }
                };
            }
        }
    };


    $K.defVoltmxProp(window, [
        {keey:'spaAPM', value:{}, items:[
            {keey:'startTracking', value:_startTracking}
        ]}
    ]);

    $K.defVoltmxProp(_ns, [
        {keey:'send', value:_send}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/utils/voltmxstore.js' */
Object.defineProperty(voltmx.$kwebfw$, 'store', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;


    var _ = {
        local: {
            clear: function() {
                if(window.localStorage) {
                    localStorage.clear();
                } else {
                    //LOG:: LOG WARNING - 'localStorage is not available.'
                }
            },

            fetch: function(key) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, data = null;

                if(window.localStorage) {
                    data = localStorage.getItem(key);
                    data = ($KU.is(data, 'string')) ? data : null;
                } else {
                    //LOG:: LOG WARNING - 'localStorage is not available.'
                }

                return data;
            },

            put: function(key, value) {
                var success = true;

                if(window.localStorage) {
                    try{
                        localStorage.setItem(key, value);
                    } catch(err) {
                        success = false;

                        if(err.name === 'QUOTA_EXCEEDED_ERR'
                        || err.name === 'QuotaExceededError') {
                            if(localStorage.length === 0) {
                                //LOG:: LOG WARNING - 'Private Browsing is switched ON.'
                            } else {
                                //LOG:: LOG WARNING - 'Local storage limit has exceeded.'
                            }
                        } else {
                            //LOG:: LOG ERROR - 'Unexpected error encountered.'
                        }
                    }
                } else {
                    success = false;
                    //LOG:: LOG WARNING - 'localStorage is not available.'
                }

                return success;
            },

            remove: function(key) {
                if(window.localStorage) {
                    localStorage.removeItem(key);
                } else {
                    //LOG:: LOG WARNING - 'localStorage is not available.'
                }
            }
        },


        session: {
            clear: function() {
                if(window.sessionStorage) {
                    sessionStorage.clear();
                } else {
                    //LOG:: LOG WARNING - 'sessionStorage is not available.'
                }
            },

            fetch: function(key) {
                if(window.sessionStorage) {
                    return sessionStorage.getItem(key);
                }
                //LOG:: LOG WARNING - 'sessionStorage is not available.'

                return null;
            },

            put: function(key, value) {
                if(window.sessionStorage) {
                    try{
                        sessionStorage.setItem(key, value);
                    } catch(err) {
                        if(err.name === 'QUOTA_EXCEEDED_ERR'
                        || err.name === 'QuotaExceededError') {
                            if(sessionStorage.length === 0) {
                                //LOG:: LOG WARNING - 'Private Browsing is switched ON.'
                            } else {
                                //LOG:: LOG WARNING - 'Session storage limit has exceeded.'
                            }
                        } else {
                            //LOG:: LOG ERROR - 'Unexpected error encountered.'
                        }
                    }
                } else {
                    //LOG:: LOG WARNING - 'sessionStorage is not available.'
                }
            },

            remove: function(key) {
                if(window.sessionStorage) {
                    sessionStorage.removeItem(key);
                } else {
                    //LOG:: LOG WARNING - 'sessionStorage is not available.'
                }
            }
        }
    };


    var _clear = function(type) {
        _[type] && _[type].clear();
    };


    var _fetch = function(type, key) {
        if(_[type]) return _[type].fetch(key);
        return null;
    };


    var _put = function(type, key, value) {
        if(_[type]) return _[type].put(key, value);
        return false;
    };


    var _remove = function(type, key) {
        _[type] && _[type].remove(key);
    };


    $K.defVoltmxProp(_ns, [
        {keey:'clear', value:_clear},
        {keey:'fetch', value:_fetch},
        {keey:'put', value:_put},
        {keey:'remove', value:_remove}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/utils/voltmxdom.js' */

Object.defineProperty(voltmx.$kwebfw$, 'dom', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$, __event = {}, _keyCodeMap = {
        '8':  'Backspace',
        '9':  'Tab',
        '13': 'Enter',
        '16': 'ShiftLeft',
        '17': 'ControlLeft',
        '18': 'AltLeft',
        '20': 'CapsLock',
        '27': 'Escape',
        '32': 'Space',
        '33': 'PageUp',
        '34': 'PageDown',
        '35': 'End',
        '36': 'Home',
        '37': 'ArrowLeft',
        '38': 'ArrowUp',
        '39': 'ArrowRight',
        '40': 'ArrowDown',
        '45': 'Insert',
        '46': 'Delete',
        '48': 'Digit0',
        '49': 'Digit1',
        '50': 'Digit2',
        '51': 'Digit3',
        '52': 'Digit4',
        '53': 'Digit5',
        '54': 'Digit6',
        '55': 'Digit7',
        '56': 'Digit8',
        '57': 'Digit9',
        '65': 'KeyA',
        '66': 'KeyB',
        '67': 'KeyC',
        '68': 'KeyD',
        '69': 'KeyE',
        '70': 'KeyF',
        '71': 'KeyG',
        '72': 'KeyH',
        '73': 'KeyI',
        '74': 'KeyJ',
        '75': 'KeyK',
        '76': 'KeyL',
        '77': 'KeyM',
        '78': 'KeyN',
        '79': 'KeyO',
        '80': 'KeyP',
        '81': 'KeyQ',
        '82': 'KeyR',
        '83': 'KeyS',
        '84': 'KeyT',
        '85': 'KeyU',
        '86': 'KeyV',
        '87': 'KeyW',
        '88': 'KeyX',
        '89': 'KeyY',
        '90': 'KeyZ',
        '91': 'MetaLeft',
        '112': 'F1',
        '113': 'F2',
        '114': 'F3',
        '115': 'F4',
        '116': 'F5',
        '117': 'F6',
        '118': 'F7',
        '119': 'F8',
        '120': 'F9',
        '121': 'F10',
        '122': 'F11',
        '123': 'F12',
        '186': 'Semicolon',
        '187': 'Equal',
        '188': 'Comma',
        '189': 'Minus',
        '190': 'Period',
        '191': 'Slash',
        '192': 'Backquote',
        '219': 'BracketLeft',
        '220': 'Backslash',
        '221': 'BracketRight',
        '222': 'Quote',
        '255': 'WakeUp'
    }; //window.ge = __event; //For testing purpose only


    var _addEvent = function $KD_addEvent(el, type, name, cb, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            eid = '', emap = null, option = null;

        if($KU.is(config, 'boolean')) config = {capture:config};
        if(!$KU.is(config, 'object')) config = {capture:false};
        if(!$KU.is(config.capture, 'boolean')) config.capture = false;
        if(!Object.prototype.hasOwnProperty.call(config, 'scope')) config.scope = el;

        if($KU.is(el, 'dom') && !$KD.hasAttr(el, 'ke')) {
            $KD.setAttr(el, 'ke', $KU.uid());
        }

        eid = (el === document) ? 'document' : (el === window) ? 'window' : $KD.getAttr(el, 'ke');

        if(!__event[eid]) __event[eid] = {};

        emap = __event[eid];

        if(!$KU.is(emap[type], 'object')) emap[type] = {};

        emap[type][name] = function(e) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

            if(!e.target && e.srcElement) e.target = e.srcElement; //IE fix
            if('data' in config) e.data = config.data;
            if(type === 'contextmenu') $KD.preventDefault(e);

            e.isCtrlPressed = e.ctrlKey || e.metaKey; //MAC fix
            e.isShiftPressed = e.shiftKey; e.isAltPressed = e.altKey;

            if(config.sp === true || ($KU.is(config.sp, 'function') && config.sp(e) === true)) {
                $KD.stopPropagation(e);
            }

            if(config.sip === true || ($KU.is(config.sip, 'function') && config.sip(e) === true)) {
                $KD.stopImmediatePropagation(e);
            }

            if(config.pd === true || ($KU.is(config.pd, 'function') && config.pd(e) === true)) {
                $KD.preventDefault(e);
            }

            if(el.tagName === 'INPUT' && type === 'change' && el.type === 'file') {
                if(e.fileChangeEventFired !== true) {
                    e.fileChangeEventFired = true;
                    cb.call(e.target, e);
                }
            } else {
                cb.call(config.scope, e);
            }
        };

        if(_passiveEventSupported) {
            option = {capture:config.capture};
            option.passive = ($KU.is(config.passive, 'boolean')) ? config.passive : false;
            option.once = ($KU.is(config.once, 'boolean')) ? config.once : false;
        }

        if($KU.is(el.addEventListener, 'function')) {
            el.addEventListener(type, emap[type][name], (option || config.capture));
        } else if($KU.is(el.attachEvent, 'function')) {
            el.attachEvent(type, emap[type][name], (option || config.capture));
        } else {
            el['on'+type] = emap[type][name];
        }
    };


    var _addGesture = function $KD_addGesture(el, type, name, cb, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            touchStartFired = false, moveEvent = '', endEvent = '';

        if(($KU.is(el, 'dom') || el === document)
        && ($KU.is(type, 'string') && type && _gesture[type] && $KU.is(_gesture[type].add, 'function'))
        && ($KU.is(name, 'string') && name) && ($KU.is(cb, 'function'))) {
            if(!$KU.is(config, 'object')) config = {};
            if(!$KU.is(config.data, 'object')) config.data = {};
            if(!Object.prototype.hasOwnProperty.call(config, 'scope')) config.scope = el;
            if(!Object.prototype.hasOwnProperty.call(config, 'boundary')) config.boundary = document;

            //Registering START_HANDLER
            $KD.on(el, 'mousedown touchstart', type+'-'+name+'-gst', function(e) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    g = {type:e.data.type, name:e.data.name, callback:e.data.callback, target:e.target, event:{}},
                    mvnm = (g.type+'-'+g.name+'-gmv'), ndnm = (g.type+'-'+g.name+'-gnd'), startExecuted = false,
                    movedPosition = null, currentPosition = null, delta = null, absdelta = null, distance = null,
                    displacement = null, lastMovedAt = null, startTime = new Date(), startPosition = $KD.position(e);

                if(e.type === 'mousedown' && $KU.is(e.which, 'number') && e.which !== 1) return;
                if(e.type === 'touchstart') touchStartFired = true;

                if(touchStartFired && e.type === 'mousedown') {
                    touchStartFired = false;
                } else {
                    if(e.type === 'touchstart') {
                        moveEvent = 'touchmove';
                        endEvent = 'touchend touchcancel';
                    } else {
                        moveEvent = 'mousemove';
                        endEvent = 'mouseup';
                    }

                    g.absdelta = {x:0, y:0};
                    g.angle = 0;
                    g.delta = {x:0, y:0};
                    g.direction = '';
                    g.displacement = {x:0, y:0};
                    g.distance = {x:0, y:0};
                    g.duration = 0;
                    g.event.start = e;
                    g.status = 'started';
                    g.zoom = 1;

                    lastMovedAt = startTime;
                    $KU.defaults(g, e.data.config);

                    //Populating g.delay
                    g.delay = ($KU.is(g.delay, 'number') && g.delay >= 0) ? g.delay : 17;

                    //Populating g.minimum
                    if($KU.is(g.minimum, 'number')) {
                        g.minimum = (g.minimum >= 0) ? {x:g.minimum, y:g.minimum} : {x:0, y:0};
                    } else if($KU.is(g.minimum, 'object')) {
                        if(!$KU.is(g.minimum.x, 'number') || g.minimum.x < 0) {
                            g.minimum.x = 0;
                        }
                        if(!$KU.is(g.minimum.y, 'number') || g.minimum.y < 0) {
                            g.minimum.y = 0;
                        }
                    } else {
                        g.minimum = {x:0, y:0};
                    }

                    delete e.data;

                    //Registering MOVE_HANDLER
                    $KD.on(config.boundary, moveEvent, mvnm, function(e) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                        if($KU.is(g, 'undefined') || $KU.is(g, 'null') || g.status === 'ended') {
                            //Removing MOVE_HANDLER and END_HANDLER
                            $KD.off(config.boundary, moveEvent, mvnm);
                            $KD.off(config.boundary, endEvent, ndnm);

                            return;
                        }

                        if(g.delay > 0) {
                            var now = new Date();
                            if((now - lastMovedAt) <= g.delay) {
                                return;
                            }
                            lastMovedAt = now;
                        }

                        currentPosition = $KD.position(e);
                        movedPosition = (g.event.move) ? $KD.position(g.event.move) : {x:startPosition.x, y:startPosition.y};
                        distance = {x:(currentPosition.x - startPosition.x), y:(currentPosition.y - startPosition.y)};
                        displacement = {x:Math.abs(distance.x), y:Math.abs(distance.y)};

                        if(displacement.x >= g.minimum.x || displacement.y >= g.minimum.y) {
                            if(!startExecuted) {
                                startExecuted = true;
                                g.callback.call(g.scope, g);
                            }

                            delta = {x:(currentPosition.x - movedPosition.x), y:(currentPosition.y - movedPosition.y)};
                            absdelta = {x:Math.abs(delta.x), y:Math.abs(delta.y)};
                            g.absdelta = absdelta;
                            g.angle = 0; //TODO::
                            g.delta = delta;
                            g.direction = $KU.direction(currentPosition, movedPosition);
                            g.displacement = displacement;
                            g.distance = distance;
                            g.duration = new Date() - startTime;
                            g.event.move = e;
                            g.status = 'moving';
                            g.zoom = {x:(g.delta.x < 0) ? -1 : 1, y:(g.delta.y < 0) ? -1 : 1};

                            g.callback.call(g.scope, g);
                        }
                    });

                    //Registering END_HANDLER
                    $KD.on(config.boundary, endEvent, ndnm, function(e) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                        if($KU.is(g, 'undefined') || $KU.is(g, 'null') || g.status === 'ended') {
                            //Removing MOVE_HANDLER and END_HANDLER
                            $KD.off(config.boundary, moveEvent, mvnm);
                            $KD.off(config.boundary, endEvent, ndnm);

                            return;
                        }

                        currentPosition = $KD.position(e);
                        movedPosition = (g.event.move) ? $KD.position(g.event.move) : (g.event.start) ? {x:startPosition.x, y:startPosition.y} : {x:0, y:0};
                        delta = {x:(currentPosition.x - movedPosition.x), y:(currentPosition.y - movedPosition.y)};
                        absdelta = {x:Math.abs(delta.x), y:Math.abs(delta.y)};
                        distance = {x:(currentPosition.x - startPosition.x), y:(currentPosition.y - startPosition.y)};
                        displacement = {x:Math.abs(distance.x), y:Math.abs(distance.y)};

                        if(!startExecuted) {
                            startExecuted = true;
                            g.callback.call(g.scope, g);
                        }

                        delta = {x:(currentPosition.x - movedPosition.x), y:(currentPosition.y - movedPosition.y)};
                        absdelta = {x:Math.abs(delta.x), y:Math.abs(delta.y)};
                        g.absdelta = absdelta;
                        g.angle = 0; //TODO::
                        g.delta = delta;
                        g.direction = $KU.direction(currentPosition, movedPosition);
                        g.displacement = displacement;
                        g.distance = distance;
                        g.duration = new Date() - startTime;
                        g.event.end = e;
                        g.status = 'ended';
                        g.zoom = {x:(g.delta.x < 0) ? -1 : 1, y:(g.delta.y < 0) ? -1 : 1};

                        g.callback.call(g.scope, g);

                        //Removing MOVE_HANDLER and END_HANDLER
                        $KD.off(document, moveEvent, mvnm);
                        $KD.off(document, endEvent, ndnm);
                    });
                }
            }, {data:{type:type, name:name, callback:cb, config:config}});
        }
    };


    var _gesture = {
        basic: {
            add: function(el, name, cb, config) {
                _addGesture(el, 'basic', name, function(g) {
                    cb.call(g.scope, g);
                }, config);
            },
            remove : function(el, name) {
                _removeGesture(el, 'basic', name);
            }
        },

        longpress: {
            add: function(el, name, cb, config) {
                _addGesture(el, 'longpress', name, cb, config);
            },
            remove: function(el, name) {
                _removeGesture(el, 'longpress', name);
            }
        },

        pan: {
            add: function(el, name, cb, config) {
                _addGesture(el, 'pan', name, function() {
                //
                }, config);
            },
            remove: function(el, name) {
                _removeGesture(el, 'pan', name);
            }
        },

        pinch: {
            add: function(el, name, cb, config) {
                _addGesture(el, 'pinch', name, function() {
                    //
                }, config);
            },
            remove: function(el, name) {
                _removeGesture(el, 'pinch', name);
            }
        },

        rotation: {
            add: function(el, name, cb, config) {
                _addGesture(el, 'rotation', name, function() {
                    //
                }, config);
            },
            remove: function(el, name) {
                _removeGesture(el, 'rotation', name);
            }
        },

        swipe: {
            add: function(el, name, cb, config) {
                _addGesture(el, 'swipe', name, function(g) {
                    cb.call(g.scope, {type:g.type, name:g.name, status:g.status,
                        target:g.target, data:g.data, distance: g.distance});
                }, config);
            },
            remove: function(el, name) {
                _removeGesture(el, 'swipe', name);
            }
        },

        tap: {
            add: function(el, name, cb, config) {
                _addGesture(el, 'tap', name, function(g) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils, scope = g.scope;

                    if(g.status === 'ended' && $KU.is(cb, 'function')) {
                        if(g.event.start.target === g.event.end.target) {
                            cb.call(scope, {type:g.type, name:g.name, target:g.target, data:g.data});
                        } else {
                            //voltmx.print('g.event.start.target !== g.event.end.target');
                        }
                    }
                }, config);
            }, remove: function(el, name) {
                _removeGesture(el, 'tap', name);
            }
        }
    };


    var _passiveEventSupported = false;


    var _removeEvent = function $KD_removeEvent(el, type, name) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, eid = '', emap = null;

        if(($KU.is(el, 'dom') || el === document || el === 'window')) {
            eid = (el === document) ? 'document' : (el === window) ? 'window' : $KD.getAttr(el, 'ke');

            emap = ($KU.is(eid, 'string')) ? __event[eid] : null;

            if($KU.is(emap, 'object')) {
                if($KU.is(type, 'string') && type) {
                    if($KU.is(name, 'string') && name) {
                        if(emap[type] && emap[type][name] && $KU.is(emap[type][name], 'function')) {
                            if($KU.is(el.removeEventListener, 'function')) {
                                el.removeEventListener(type, emap[type][name], false);
                            } else if($KU.is(el.detachEvent, 'function')) {
                                el.detachEvent(type, emap[type][name], false);
                            } else {
                                delete el['on'+type];
                            }

                            delete emap[type][name];

                            if(!$KU.size(emap[type])) {
                                delete emap[type];
                            }

                            if(!$KU.size(emap)) {
                                delete __event[eid];

                                if(['document', 'window'].indexOf(eid) === -1) {
                                    $KD.removeAttr(el, 'ke');
                                }
                            }
                        }
                    } else {
                        $KU.each(emap[type], function(v, k) {
                            var $K = voltmx.$kwebfw$, $KU = $K.utils;

                            if($KU.is(v, 'function')) {
                                _removeEvent(el, type, k);
                            }
                        });
                    }
                } else {
                    $KU.each(emap, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(value, 'object')) {
                            $KU.each(value, function(v, k) {
                                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                                if($KU.is(v, 'function')) {
                                    _removeEvent(el, key, k);
                                }
                            });
                        }
                    });
                }
            }
        }
    };


    var _removeGesture = function $KD_removeGesture(el, type, name) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

        if(($KU.is(el, 'dom') || el === document) && $KU.is(name, 'string') && name) {
            $KD.off(el, 'mousedown touchstart', (type+'-'+name+'-gst'));
            //$KD.off(document, 'mousemove touchmove', (type+'-'+name+'-gmv'));
            //$KD.off(document, 'mouseup mouseout touchend touchcancel', (type+'-'+name+'-gnd'));
        }
    };


    //Detect is passive event listener is supported or not
    (function(div) {
        var on = '';

        if(typeof div.addEventListener === 'function') {
            on = 'addEventListener';
        } else if(typeof div.attachEvent === 'function') {
            on = 'attachEvent';
        }

        if(on) {
            //*
            div[on]('test', function() {}, {
                get passive() {
                    _passiveEventSupported = true;
                    return false;
                }
            });
            //*/
            /*
            div[on]('test', function() {},
                Object.defineProperty({}, 'passive', {
                    get: function() {
                        _passiveEventSupported = true;
                        return false;
                    }
                })
            );
            //*/
        }
    }(document.createElement('div')));


    if(!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.webkitRequestAnimationFrame
                                        || window.mozRequestAnimationFrame
                                        || window.oRequestAnimationFrame
                                        || window.msRequestAnimationFrame
                                        || function(callback) {
                                            var id = window.setInterval(function() {
                                                callback();
                                            }, 16);

                                            return id;
                                        };
    }
    if(!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = window.webkitCancelAnimationFrame
                                        || window.mozCancelAnimationFrame
                                        || window.oCancelAnimationFrame
                                        || window.msCancelAnimationFrame
                                        || function(id) {
                                            window.clearInterval(id);
                                        };
    }


    var _active = function $KD_active() {
        if(!document.activeElement) {
            _body().focus();
        }

        return document.activeElement;
    };


    var _add = function $KD_add(el, newElement) {
        el.appendChild(newElement);
    };


    var _addAt = function $KD_addAt(el, newElement, index) {
        var ref = _childAt(el, index);

        ref && _before(ref, newElement);
    };


    var _addCls = function $KD_addCls(el, names) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        names = names.replace(/\s+/g, ' ');
        names = names.split(' ');
        //eslint-disable-next-line no-unused-vars
        $KU.each(names, function(value, index) {
            value && el.classList.add(value);
        });
    };


    var _after = function $KD_after(el, newElement) {
        var parent = null, next = _next(el);

        if(next) {
            _before(next, newElement);
        } else {
            parent = _parent(el);
            parent && _add(parent, newElement);
        }
    };


    var _before = function $KD_before(el, newElement) {
        var parent = _parent(el);

        parent && parent.insertBefore(newElement, el);
    };


    var _blur = function $KD_blur(el) {
        el.blur();
    };


    var _body = function $KD_body() {
        return document.body || document.getElementsByTagName('BODY')[0];
    };


    var _childAt = function $KD_childAt(el, index) {
        var children = _children(el);

        return (index >= 0 && index < children.length) ? children[index] : null;
    };


    var _children = function $KD_children(el) {
        return el.children || el.childNodes;
    };


    var _closest = function $KD_closest(el, name, value) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, closest = null;

        while(el) {
            if(name === 'class') {
                if(_hasCls(el, value)) {
                    closest = el;
                    break;
                }
            } else if(name === 'tag') {
                if(el.tagName === value.toUpperCase()) {
                    closest = el;
                    break;
                }
            } else if($KU.is(name, 'function')) {
                if(name(el) === true) {
                    closest = el;
                    break;
                } else if(name(el) === false) {
                    closest = null;
                    break;
                }
            } else if($KU.is(name, 'string') && name) {
                if(arguments.length === 2) {
                    if(_hasAttr(el, name)) {
                        closest = el;
                        break;
                    }
                } else if(arguments.length === 3) {
                    if($KU.is(value, 'function')) {
                        if(value(el) === true) {
                            closest = el;
                            break;
                        } else if(value(el) === false) {
                            closest = null;
                            break;
                        }
                    } else if($KU.is(value, 'string')) {
                        if(value === _getAttr(el, name)) {
                            closest = el;
                            break;
                        }
                    }
                }
            }

            el = _parent(el);
        }

        return closest;
    };


    var _contains = function $KD_contains(el, ref) {
        return el.contains(ref);
    };


    var _create = function $KD_create(tag, attr, style) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, fragment = null;

        if(arguments.length > 0) {
            if(arguments.length === 1) {
                attr = {}; style = {};
            }
            if(arguments.length === 2) {
                style = {};
            }

            if($KU.is(tag, 'string') && tag && $KU.is(attr, 'object') && $KU.is(style, 'object')) {
                if(tag[0] === '<' && tag[tag.length-1] === '>') {
                    fragment = document.createDocumentFragment();
                    fragment.innerHTML = tag;

                    $KU.each(fragment.childNodes, function(el) {
                        if($KU.is(el, 'dom')) {
                            $KU.each(attr, function(val, key) {
                                el.setAttribute(key, val);
                            });

                            $KU.each(style, function(val, key) {
                                el.style[key] = val;
                            });
                        }
                    });
                } else {
                    fragment = document.createElement(tag.toUpperCase());

                    $KU.each(attr, function(val, key) {
                        fragment.setAttribute(key, val);
                    });

                    $KU.each(style, function(val, key) {
                        fragment.style[key] = val;
                    });
                }
            }
        } else {
            fragment = document.createDocumentFragment();
        }

        return fragment;
    };

    //eslint-disable-next-line no-unused-vars
    var _event = function $KD_event(type) {
        var names = '';

        return names;
    };


    var _find = function $KD_find(el, selector) {
        selector = selector.trim();

        if(el === document && selector === 'html') {
            return [document.documentElement];
        } else if(el === document && selector === 'body') {
            return [document.body];
        }
        if(selector[0] === '#'
            && (selector.indexOf(' ') < 0
            || selector.indexOf(',') < 0
            || selector.indexOf('>') < 0
            || selector.indexOf('+') < 0
            || selector.indexOf('~') < 0)) {
            return [document.getElementById(selector.substr(1, (selector.length-1)))];
        }
        if(el) return el.querySelectorAll(selector);
    };


    var _fire = function $KD_fire(el, type, payload) {
        var evt = null;

        if(type === 'click') {
            el[type] && el[type]();
        } else if(document.createEventObject) {
            evt = document.createEventObject();

            if(arguments.length > 2) {
                evt.data = payload;
            }

            return el.fireEvent('on' + type, evt);
        } else {
            evt = document.createEvent('HTMLEvents');

            if(arguments.length > 2) {
                evt.data = payload;
            }

            evt.initEvent(type, true, true);

            return !el.dispatchEvent(evt);
        }
    };


    var _first = function $KD_first(el) {
        return el.firstElementChild;
    };


    var _focus = function $KD_focus(el) {
        el.focus();
    };


    var _focusable = function $KD_focusable(el) {
        var flag = false;

        if(['A', 'BODY', 'BUTTON', 'IFRAME', 'INPUT', 'SELECT', 'TEXTAREA'].indexOf(el.tagName) >= 0) {
            if(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'].indexOf(el.tagName) >= 0) {
                flag = !el.disabled;
            } else {
                flag = true;
            }
        } else if(_hasAttr(el, 'tabindex')) {
            flag = true;
        }

        return flag;
    };


    var _getAttr = function $KD_getAttr(el, attr) {
        if(attr === 'value'
        && ['INPUT', 'SELECT', 'TEXTAREA'].indexOf(el.tagName) >= 0) {
            return el.value;
        }
        return el.getAttribute(attr);
    };


    var _hasAttr = function $KD_hasAttr(el, attr) {
        return el.hasAttribute(attr);
    };


    var _hasCls = function $KD_hasCls(el, name) {
        return el.classList.contains(name);
    };


    var _head = function $KD_head() {
        return document.head || document.getElementsByTagName('HEAD')[0];
    };


    var _hide = function $KD_hide(el) {
        el.hidden = true;
    };

    //eslint-disable-next-line no-unused-vars
    var _hotkey = function $KD_hotkey(el, keys, cb) {
        //TODO::
    };


    var _html = function $KD_html(el, str) {
        el.innerHTML = str;
    };


    var _index = function $KD_index(el) {
        var prev = el, index = -1;

        while(prev) {
            index += 1;
            prev = _prev(prev);
        }

        return index;
    };


    var _keyCode = function $KD_keyCode(evt) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, code = null;

        if(evt instanceof Event) {
            if(Object.prototype.hasOwnProperty.call(evt, 'code')) {
                code = evt.code;
            } else if($KU.is(evt.keyCode, 'number')
            && Object.prototype.hasOwnProperty.call(_keyCodeMap, evt.keyCode.toString())) {
                code = _keyCodeMap[evt.keyCode.toString()];
            }
        }

        return code;
    };


    var _last = function $KD_last(el) {
        return el.lastElementChild;
    };


    var _next = function $KD_next(el) {
        return el.nextElementSibling;
    };


    var _off = function $KD_off(el, types, name) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(($KU.is(el, 'dom') || el === document || el === window)) {
            if(($KU.is(types, 'string') && types) || $KU.is(types, 'array')) {
                if($KU.is(types, 'string') && types) {
                    types = types.replace(/\s+/g, ' ');
                    types = types.split(' ');
                }

                if($KU.is(types, 'array')) {
                    $KU.each(types, function(value) {
                        if(_gesture[value] && $KU.is(_gesture[value].remove, 'function')) {
                            _gesture[value].remove(el, value, name);
                        } else if($KU.is(name, 'string') && name) {
                            _removeEvent(el, value, name);
                        } else {
                            _removeEvent(el, value);
                        }
                    });
                }
            } else {
                _removeEvent(el);
            }
        }
    };

    //eslint-disable-next-line no-unused-vars
    var _offset = function $KD_offset(el, scroll) {
        //TODO::
    };


    var _on = function $KD_on(el, types, name, cb, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(el && ($KU.is(el, 'dom') || el === document || el === window)
        && (($KU.is(types, 'string') && types) || $KU.is(types, 'array'))
        && $KU.is(name, 'string') && name && $KU.is(cb, 'function')) {
            if($KU.is(types, 'string')) {
                types = types.replace(/\s+/g, ' ');
                types = types.split(' ');
            }

            if($KU.is(types, 'array')) {
                $KU.each(types, function(value) {
                    value = value.trim();

                    if(_gesture[value] && $KU.is(_gesture[value].add, 'function')) {
                        _gesture[value].add(el, name, cb, config);
                    } else {
                        _addEvent(el, value, name, cb, config);
                    }
                });
            }
        }
    };


    var _parent = function $KD_parent(el) {
        return el.parentElement;
    };


    var _point = function $KD_point(el) {
        var point = {x:0, y:0}, html = document.documentElement;

        if(el.getBoundingClientRect) {
            point = el.getBoundingClientRect();
        }

        point.x = (point.x + window.pageXOffset - html.clientLeft);
        point.y = (point.y + window.pageYOffset - html.clientTop);

        return point;
    };


    var _position = function $KD_position(evt) {
        var position = null;

        evt = (evt.touches && evt.touches[0])
        || (evt.changedTouches && evt.changedTouches[0])
        || evt;

        if(evt instanceof Event || evt instanceof Touch) {
            position = {x:evt.pageX, y:evt.pageY};
        }

        return position;
    };


    var _prev = function $KD_prev(el) {
        return el.previousElementSibling;
    };


    var _preventDefault = function $KD_preventDefault(evt) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(evt instanceof Event && $KU.is(evt.preventDefault, 'function')) {
            evt.preventDefault();
        }

        if(evt instanceof Event && 'returnValue' in evt) {
            evt.returnValue = false;
        }
    };


    var _remove = function $KD_remove(el) {
        var parent = _parent(el);

        parent && parent.removeChild(el);
    };


    var _removeAt = function $KD_removeAt(el, index) {
        var child = _childAt(el, index);

        child && _remove(child);
    };


    var _removeAttr = function $KD_removeAttr(el, attr) {
        if(['checked', 'disabled', 'hidden', 'selected'].indexOf(attr) >= 0) {
            el[attr] = false;
            el.removeAttribute(('aria-'+attr));
        } else if(['readonly'].indexOf(attr) >= 0) {
            el.readOnly = false;
            el.removeAttribute(('aria-'+attr));
        } else if(['placeholder'].indexOf(attr) >= 0) {
            el.removeAttribute(attr);
            el.removeAttribute(('aria-'+attr));
        } else {
            el.removeAttribute(attr);
        }
    };


    var _removeCls = function $KD_removeCls(el, name) {
        name && el.classList.remove(name);
    };


    var _replace = function $KD_replace(newElement, oldElement) {
        var parent = _parent(oldElement);

        parent && parent.replaceChild(newElement, oldElement);
    };


    var _replaceCls = function $KD_replaceCls(el, oldName, newName) {
        if(oldName !== newName) {
            _removeCls(el, oldName);
            _addCls(el, newName);
        }
    };

    //eslint-disable-next-line no-unused-vars
    var _scrollLeft = function $KD_scrollLeft(el) {
        //TODO::
    };

    //eslint-disable-next-line no-unused-vars
    var _scrollTop = function $KD_scrollTop(el) {
        //TODO::
    };


    var _setAttr = function $KD_setAttr(el, attr, value) {
        if(['checked', 'disabled', 'hidden', 'selected'].indexOf(attr) >= 0) {
            if(!value || value === 'false') {
                el[attr] = false;
                el.removeAttribute(('aria-'+attr));
            } else {
                el[attr] = true;
                el.setAttribute(('aria-'+attr), true);
            }
        } else if(['readonly'].indexOf(attr) >= 0) {
            if(!value || value === 'false') {
                el.readOnly = false;
                el.removeAttribute(('aria-'+attr));
            } else {
                el.readOnly = true;
                el.setAttribute(('aria-'+attr), true);
            }
        } else if(['placeholder'].indexOf(attr) >= 0) {
            el.setAttribute(attr, value);
            el.setAttribute(('aria-'+attr), value);
        } else if(attr === 'value') {
            if(['INPUT', 'SELECT', 'TEXTAREA'].indexOf(el.tagName) >= 0) {
                if(['SELECT'].indexOf(el.tagName) === -1) {
                    el.setAttribute('value', value);
                }

                el.value = value;
            }
        } else {
            el.setAttribute(attr, value);
        }
    };


    var _show = function $KD_show(el) {
        el.hidden = false;
    };


    var _stopImmediatePropagation = function $KD_stopImmediatePropagation(evt) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(evt instanceof Event && $KU.is(evt.stopImmediatePropagation, 'function')) {
            evt.stopImmediatePropagation();
        }
    };


    var _stopPropagation = function $KD_stopPropagation(evt) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(evt instanceof Event && $KU.is(evt.stopPropagation, 'function')) {
            evt.stopPropagation();
        }
        if(evt instanceof Event && 'cancelBubble' in evt) {
            evt.cancelBubble = true;
        }
    };


    var _style = function $KD_style(el, key, value) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, style = null;

        if(arguments.length === 3 && $KU.is(key, 'string')) {
            if(value === null) { //key must be hyphenated
                el.style.removeProperty(key);
            } else { //key must be camel-cased
                el.style[key] = value;
            }
        } else if(arguments.length === 2 && $KU.is(key, 'object')) {
            $KU.each(key, function(val, k) {
                if(val === null) { //k must be hyphenated
                    el.style.removeProperty(k);
                } else if(k.indexOf('-') >= 0) { //k must be hyphenated
                    el.style.setProperty(k, val);
                } else { //k must be camel-cased
                    el.style[k] = val;
                }
            });
        } else if((arguments.length === 1 && $KU.is(el, 'dom'))
        || (arguments.length === 2 && $KU.is(key, 'string'))) {
            style = getComputedStyle(el);

            if(key) { //key must be hyphenated
                style = style.getPropertyValue(key);
            }

            return style;
        }
    };


    var _text = function $KD_text(el, str) {
        el.innerText = str;
    };


    var _toggle = function $KD_toggle(el) {
        if(el.style.display === 'none') {
            _show(el);
        } else {
            _hide(el);
        }
    };

    var _toggleCls = function $KD_toggleCls(el, name) {
        name && el.classList.toggle(name);
    };

    //eslint-disable-next-line no-unused-vars
    var _wrap = function $KD_wrap(el, ref) {
        //TODO::
    };


    $K.defVoltmxProp(_ns, [
        {keey:'active', value:_active},
        {keey:'add', value:_add},
        {keey:'addAt', value:_addAt},
        {keey:'addCls', value:_addCls},
        {keey:'after', value:_after},
        {keey:'before', value:_before},
        {keey:'blur', value:_blur},
        {keey:'body', value:_body},
        {keey:'childAt', value:_childAt},
        {keey:'children', value:_children},
        {keey:'closest', value:_closest},
        {keey:'contains', value:_contains},
        {keey:'create', value:_create},
        {keey:'event', value:_event},
        {keey:'find', value:_find},
        {keey:'fire', value:_fire},
        {keey:'first', value:_first},
        {keey:'focus', value:_focus},
        {keey:'focusable', value:_focusable},
        {keey:'getAttr', value:_getAttr},
        {keey:'hasAttr', value:_hasAttr},
        {keey:'hasCls', value:_hasCls},
        {keey:'head', value:_head},
        {keey:'hide', value:_hide},
        {keey:'hotkey', value:_hotkey},
        {keey:'html', value:_html},
        {keey:'index', value:_index},
        {keey:'keyCode', value:_keyCode},
        {keey:'last', value:_last},
        {keey:'next', value:_next},
        {keey:'off', value:_off},
        {keey:'offset', value:_offset},
        {keey:'on', value:_on},
        {keey:'parent', value:_parent},
        {keey:'point', value:_point},
        {keey:'position', value:_position},
        {keey:'prev', value:_prev},
        {keey:'preventDefault', value:_preventDefault},
        {keey:'remove', value:_remove},
        {keey:'removeAt', value:_removeAt},
        {keey:'removeAttr', value:_removeAttr},
        {keey:'removeCls', value:_removeCls},
        {keey:'replace', value:_replace},
        {keey:'replaceCls', value:_replaceCls},
        {keey:'scrollLeft', value:_scrollLeft},
        {keey:'scrollTop', value:_scrollTop},
        {keey:'setAttr', value:_setAttr},
        {keey:'show', value:_show},
        {keey:'stopImmediatePropagation', value:_stopImmediatePropagation},
        {keey:'stopPropagation', value:_stopPropagation},
        {keey:'style', value:_style},
        {keey:'text', value:_text},
        {keey:'toggle', value:_toggle},
        {keey:'toggleCls', value:_toggleCls},
        {keey:'wrap', value:_wrap}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/utils/voltmxanim.js' */
Object.defineProperty(voltmx.$kwebfw$, 'Animator', {configurable:false, enumerable:false, writable:false, value:(function() {
    var $K = voltmx.$kwebfw$, _isPresent = {transform:false, anchorPoint:false}, _vendor = null;


    var _calculateSizeAndUnit = function $K_Anim_calculateSizeAndUnit(value, unit) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = {value:-1, unit:''};

        if($KU.is(value, 'number')) {
            data.unit = unit;
            data.value = value;
        } else {
            value = value.toLowerCase();

            if(value.indexOf('%') > 0
            || value.indexOf('dp') > 0
            || value.indexOf('px') > 0) {
                if(value.indexOf('%') > 0) unit = '%';
                if(value.indexOf('dp') > 0) unit = 'dp';
                if(value.indexOf('px') > 0) unit = 'px';

                data.unit = unit;
                data.value = value.replace(unit, '');
                data.value = parseFloat(data.value, 10);
            }
        }

        if(unit === 'px') {
            data.value = (data.value/$K.device.DPI);
        } else if(unit === 'dp') {
            data.unit = 'px';
        }

        return data;
    };


    var _createKeyFrames = function $K_Anim_createKeyFrames(widget, name, keyframes, animType, animateHeightOnly) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, cssRule = '', keyframesSum = {};

        cssRule += ('@'+_vendor.prefix+'keyframes ' + name + '{');

        $KU.each(keyframes, function(stepConfig, step) {
            cssRule += (step + '%{');

            if([
                voltmx.anim.EASE,
                voltmx.anim.EASE_IN,
                voltmx.anim.EASE_IN_OUT,
                voltmx.anim.EASE_OUT,
                voltmx.anim.LINEAR
            ].indexOf(stepConfig.timingFunction) === -1) {
                stepConfig.timingFunction = voltmx.anim.EASE;
            }
            if(animateHeightOnly) {
                stepConfig = stepConfig.height ? {height: stepConfig.height} : {};
            } else {
                //delete postion properties from stepconfig in case of template animations
                $KU.each(stepConfig, function(value, key) {
                    if(widget._kwebfw_.is.template && animType === 'rowAnimation'
                       && ($KW.getFlexProperties().indexOf(key) > -1)) {
                        delete stepConfig[key];
                    }
                });
            }
            //merge keyframesSum with stepConfig
            $KU.each(keyframesSum, function(value, key) {
                if(!Object.prototype.hasOwnProperty.call(stepConfig, key)) {
                    stepConfig[key] = value;
                }
            });
            keyframesSum = stepConfig;
            keyframes[step] = stepConfig;
            $KU.each(stepConfig, function(value, key) {
                if($KU.is(_style[key], 'function')) {
                    cssRule += _style[key](value, widget);
                } else {
                    cssRule += (key + ':' + value + ';');
                }
            });

            if(_isPresent.transform && !_isPresent.anchorPoint) {
                cssRule += (_vendor.prefix+'transform-origin:50% 50%;');
            }

            cssRule += '}';

            _isPresent = {transform:false, anchorPoint:false};
        });

        return (cssRule + '}');
    };


    var _getAnimStyleSheet = function $K_Anim_getAnimStyleSheet() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, stylesheet = null;

        $KU.each(document.styleSheets, function(sheet) {
            var link = sheet.ownerNode;

            if(link.tagName === 'LINK' && link.getAttribute('kfwss') === 'voltmx') {
                if(link.href.indexOf('anim.css') >= 0) {
                    stylesheet = sheet;
                    return true;
                }
            }
        });

        return stylesheet;
    };


    var _serializeKeyFrames = function $K_Anim_serializeKeyFrames(keyframes) {
        return JSON.stringify(keyframes, function(key, value) {
            var $K = voltmx.$kwebfw$, t = null;

            if(key === 'transform' && value instanceof $K.Transform) {
                t = value.transform;

                return {
                    rotate: t.rotate,
                    scale: t.scale,
                    perspective: t.perspective,
                    translate: t.translate
                };
            }
            return value;
        });
    };


    var _style = {
        anchorPoint: function $K_Anim_style_anchorPoint(value) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, rule = '';

            if($KU.is(value, 'object') && $KU.is(value.x, 'number') && $KU.is(value.y, 'number')
            && value.x >= 0 && value.x <= 1 && value.y >= 0 && value.y <= 1) {
                _isPresent.anchorPoint = true;
                rule = (_vendor.prefix + 'transform-origin:' + (value.x*100) + '% ' + (value.y*100) + '%;');
            }

            return rule;
        },

        backgroundColor: function $K_Anim_style_backgroundColor(value) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, background = '', rule = '';

            if($KU.is(value, 'color')) {
                background = $KU.convertHexToRGBA(value);
                rule = 'background-color:' + background + ';';
            }

            return rule;
        },

        borderColor: function $K_Anim_style_borderColor(value) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, rule = '', border = '';

            if($KU.is(value, 'color')) {
                border = $KU.convertHexToRGBA(value);
                rule = 'border-color:' + border + ';';
            }

            return rule;
        },

        borderWidth: function $K_Anim_style_borderWidth(value) {
            return ('border-width:' + value + 'px;');
        },

        bottom: function $K_Anim_style_bottom(value, widget) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils, rule = '', key = '', data,
                parent = $KW.pmodel(widget), layout = $KW.layout(parent), msg ='';

            data = _calculateSizeAndUnit(value, widget._kwebfw_.layoutUnit);
            key = (['fflex', 'hflex'].indexOf(layout) >= 0) ? 'bottom' : 'margin-bottom';

            if(layout !== voltmx.flex.RESPONSIVE_GRID) {
                rule = (key + ':' + data.value + data.unit + ';');
            } else {
                rule = '';
            }

            if(data.unit === '%' && data.value !== 0
            && ['hflex', 'vflex'].indexOf(layout) >= 0) {
                msg += 'KFW-ANIM:: Animation doesn\'t work, if widget\'s ';
                msg += 'bottom is in %, inside parent with ';
                if(layout === 'hflex') msg += 'FlowHorizontal';
                if(layout === 'vflex') msg += 'FlowVertical';
                msg += ' layout.';

                $KU.log('warn', msg+' <<'+widget._kwebfw_.wap+'>>');
            }

            return rule;
        },

        centerX: function $K_Anim_style_centerX(value, widget) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, msg = '';

            $KU.log('warn', msg+'KFW-ANIM:: Animation is skipped on widget\'s centerX property. <<'+widget._kwebfw_.wap+'>>');

            return '';
        },

        centerY: function $K_Anim_style_centerY(value, widget) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, msg = '';

            $KU.log('warn', msg+'KFW-ANIM:: Animation is skipped on widget\'s centerY property. <<'+widget._kwebfw_.wap+'>>');

            return '';
        },

        cornerRadius: function $K_Anim_style_cornerRadius(value) {
            return ('border-radius:' + value + ';');
        },

        height: function $K_Anim_style_height(value, widget) {
            var rule = '', data = null;

            data = _calculateSizeAndUnit(value, widget._kwebfw_.layoutUnit);

            rule = ('height:' + data.value + data.unit + ';');

            return rule;
        },

        left: function $K_Anim_style_left(value, widget) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, rule = '', data = null, key = '',
                parent = $KW.pmodel(widget), layout = $KW.layout(parent);
            if(layout !== voltmx.flex.RESPONSIVE_GRID) {
                data = _calculateSizeAndUnit(value, widget._kwebfw_.layoutUnit);
                key = (layout === 'fflex') ? 'left' : 'margin-left';
                rule = (key + ':' + data.value + data.unit + ';');
            } else {
                rule = '';
            }

            return rule;
        },

        margintop: function $K_Anim_style_margintop(value) {
            return ('margin-top:' + value + 'px;');
        },

        maxHeight: function $K_Anim_style_maxHeight(value, widget) {
            var rule = '', data = null;

            data = _calculateSizeAndUnit(value, widget._kwebfw_.layoutUnit);

            rule = ('max-height:' + data.value + data.unit + ';');

            return rule;
        },

        maxWidth: function $K_Anim_style_maxWidth(value, widget) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, rule = '', data = null,
                parent = $KW.pmodel(widget), layout = $KW.layout(parent);
            if(layout !== voltmx.flex.RESPONSIVE_GRID) {
                data = _calculateSizeAndUnit(value, widget._kwebfw_.layoutUnit);
                rule = ('max-width:' + data.value + data.unit + ';');
            } else {
                rule = '';
            }
            return rule;
        },

        minHeight: function $K_Anim_style_minHeight(value, widget) {
            var rule = '', data = null;

            data = _calculateSizeAndUnit(value, widget._kwebfw_.layoutUnit);

            rule = ('min-height:' + data.value + data.unit + ';');

            return rule;
        },

        minWidth: function $K_Anim_style_minWidth(value, widget) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, rule = '', data = null,
                parent = $KW.pmodel(widget), layout = $KW.layout(parent);
            if(layout !== voltmx.flex.RESPONSIVE_GRID) {
                data = _calculateSizeAndUnit(value, widget._kwebfw_.layoutUnit);
                rule = ('min-width:' + data.value + data.unit + ';');
            } else {
                rule = '';
            }
            return rule;
        },

        right: function $K_Anim_style_right(value, widget) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, rule = '', data = null, key = '',
                parent = $KW.pmodel(widget), layout = $KW.layout(parent);
            if(layout !== voltmx.flex.RESPONSIVE_GRID) {
                data = _calculateSizeAndUnit(value, widget._kwebfw_.layoutUnit);
                key = (layout === 'fflex') ? 'right' : 'margin-right';
                rule = (key + ':' + data.value + data.unit + ';');
            } else {
                rule = '';
            }

            return rule;
        },

        shadow: function $K_Anim_style_shadow(value) {
            return ('box-shadow:' + value + ';');
        },

        timingFunction: function $K_Anim_style_timingFunction(value) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, rule = '';

            if($KU.is(value, 'string')) {
                rule = (_vendor.prefix + 'animation-timing-function:' + value + ';');
            } else {
                rule = (_vendor.prefix + 'animation-timing-function:cubic-bezier(' + value + ');');
            }

            return rule;
        },

        top: function $K_Anim_style_top(value, widget) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils, rule = '', data = null, key = '',
                parent = $KW.pmodel(widget), layout = $KW.layout(parent), msg = '';

            data = _calculateSizeAndUnit(value, widget._kwebfw_.layoutUnit);
            key = (['fflex', 'hflex'].indexOf(layout) >= 0) ? 'top' : 'margin-top';
            if(layout !== voltmx.flex.RESPONSIVE_GRID) {
                rule = (key + ':' + data.value + data.unit + ';');
            } else {
                rule = '';
            }

            if(data.unit === '%' && data.value !== 0 && layout === 'vflex') {
                msg += 'KFW-ANIM:: Animation doesn\'t work, if widget\'s ';
                msg += 'top is in %, inside parent with FlowVertical layout.';

                $KU.log('warn', msg+' <<'+widget._kwebfw_.wap+'>>');
            }

            return rule;
        },

        transform: function $K_Anim_style_transform(value) {
            var rule = '';

            if(value) {
                _isPresent.transform = true;

                rule += value.perspective;
                rule += value.scale;
                rule += value.translate;
                rule += value.rotate;

                if(rule) {
                    rule = (rule.substr(0, (rule.length-1)) + ';');
                }
            }

            return (rule) ? (_vendor.prefix + 'transform:' + rule + ';') : '';
        },

        width: function $K_Anim_style_width(value, widget) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, rule = '', data = null,
                parent = $KW.pmodel(widget), layout = $KW.layout(parent);
            if(layout !== voltmx.flex.RESPONSIVE_GRID) {
                data = _calculateSizeAndUnit(value, widget._kwebfw_.layoutUnit);
                rule = ('width:' + data.value + data.unit + ';');
            } else {
                rule = '';
            }

            return rule;
        },

        zIndex: function $K_Anim_style_zIndex(value) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, rule = '';

            if($KU.is(value, 'integer') && value <= 2147482647) {
                rule = ('z-index:' + value + ';');
            }

            return rule;
        }
    };


    var _validKeyFrames = function $K_Anim_validKeyFrames(keyframes) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = true;

        if($KU.is(keyframes, 'object')) {
            $KU.each(keyframes, function(value, key) {
                var step = parseFloat(key);

                if(step < 0 || step > 100) {
                    flag = false;
                    return true;
                } else if(key === '100' && !$KU.is(value, 'object')) {
                    flag = false;
                    return true;
                }
            });
        }

        return flag;
    };


    var Animator = function Animator(keyframes) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(_validKeyFrames(keyframes)) {
            $KU.defineProperty(this, 'keyframes', _serializeKeyFrames(keyframes), null);
        } else {
            $KU.defineProperty(this, 'keyframes', '', null);
            throw new Error('Invalid animDefinition passed.');
        }
    };


    var animator_animate = function Animator$animate(widget, config, callback, animType, animateHeightOnly) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, cssRule = null,
            $KD = $K.dom, _ = null, animStyleSheet = null, animName = '', animEl = null,
            animStyle = '', keyframes = null, browser = '', meta = {
                delay: 0,
                direction: voltmx.anim.DIRECTION_NONE,
                duration: 0,
                fillMode: voltmx.anim.FILL_MODE_NONE,
                iterationCount: 1
            };

        if(arguments.length === 1) {
            config = JSON.parse(this.config);
            callback = {
                animationEnd: this.onEnd,
                animationStart: this.onStart
            };
        } else {
            //START:: Argument validation
            if($KU.is(this.widget, 'null')) {
                this.widget = widget._kwebfw_.uid;
            }

            if($KU.is(config, 'object')) {
                if($KU.is(config.delay, 'number') && config.delay > 0) {
                    meta.delay = config.delay;
                }

                if([voltmx.anim.DIRECTION_ALTERNATE].indexOf(config.direction) != -1) {
                    meta.direction = config.direction;
                }

                if($KU.is(config.duration, 'number') && config.duration > 0) {
                    meta.duration = config.duration;
                }

                if([voltmx.anim.FILL_MODE_BACKWARDS, voltmx.anim.FILL_MODE_BOTH, voltmx.anim.FILL_MODE_FORWARDS].indexOf(config.fillMode) != -1) {
                    meta.fillMode = config.fillMode;
                }

                if($KU.is(config.iterationCount, 'integer') && config.iterationCount >= 0) {
                    meta.iterationCount = config.iterationCount || 'infinite';
                }
            }

            $KU.defineProperty(this, 'config', JSON.stringify(meta), null);
            config = JSON.parse(this.config);

            if($KU.is(callback, 'object') && !animateHeightOnly) {
                if($KU.is(callback.animationEnd, 'function')) {
                    this.onEnd = callback.animationEnd;
                } else {
                    this.onEnd = null;
                }

                if($KU.is(callback.animationStart, 'function')) {
                    this.onStart = callback.animationStart;
                } else {
                    this.onStart = null;
                }
            } else {
                this.onEnd = null;
                this.onStart = null;
            }

            callback = {
                animationEnd: this.onEnd,
                animationStart: this.onStart
            };
            //END:: Argument validation
        }

        if(this.keyframes && $KU.is(widget, 'widget')) {
            _ = widget._kwebfw_;

            if($KU.is(widget, 'widget', 'Image2') && !_.loaded) {
                _.animator = this;
            } else {
                if($KU.is(widget, 'widget', 'Image2')) {
                    delete _.animator;
                }

                if($KW.isRendered(widget)) {
                    if(!_vendor) {
                        browser = $KU.browser('name');
                        _vendor = {prefix:''};

                        if(['msie'].indexOf(browser) >= 0) {
                            _vendor.prefix = '-ms-';
                        }
                    }

                    keyframes = JSON.parse(this.keyframes);
                    animName = ('anim_' + $KU.uid());
                    animStyleSheet = _getAnimStyleSheet();
                    animStyle += (animName + ' ' + config.duration+'s ');
                    animStyle += (config.delay + 's ' + config.iterationCount + ' ');
                    animStyle += (config.direction + ' ' + config.fillMode);

                    cssRule = _createKeyFrames(widget, animName, keyframes, animType, animateHeightOnly);
                    animStyleSheet.insertRule(cssRule, animStyleSheet.cssRules.length);
                    if(animateHeightOnly) {
                        animEl = $KD.parent(_.view);
                    } else {
                        animEl = _.view;
                    }

                    $KD.on(animEl, 'animationstart', 'anim', function(/*e*/) {
                        //TODO:: More paramenters to be passed
                        callback.animationStart && callback.animationStart(widget);
                    });

                    $KD.on(animEl, 'animationend', 'anim', function(e) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                            keyframe = null, fmodel = null, flexProps = [], otherProps = [], transformObj = null;

                        $KD.style(e.target, (_vendor.prefix+'animation'), null);
                        $KD.off(e.target, ['animationend', 'animationstart'], 'anim');

                        if(config.fillMode === voltmx.anim.FILL_MODE_FORWARDS
                        || config.fillMode === voltmx.anim.FILL_MODE_BOTH) {
                            if(config.direction === voltmx.anim.DIRECTION_NONE) {
                                keyframe = keyframes['100'];
                            } else if(config.direction === voltmx.anim.DIRECTION_ALTERNATE) {
                                keyframe = (config.iterationCount === 'infinite'
                                            || config.iterationCount % 2 === 0)
                                    ? keyframes['0'] : keyframes['100'];
                            }
                        }

                        if(keyframe) {
                            flexProps = $KW.getFlexProperties();
                            otherProps = ['zIndex', 'opacity', 'transform', 'anchorPoint', 'backgroundColor'];
                            fmodel = $KW.fmodel(widget);

                            $KU.each(keyframe, function(value, key) {
                                if(flexProps.indexOf(key) >= 0) {
                                    widget[key] = value;
                                }
                                if(otherProps.indexOf(key) >= 0) {
                                    if(key === 'transform') {
                                        transformObj = new voltmx.ui.makeAffineTransform();
                                        transformObj.transform = value;
                                        value = transformObj;
                                    }
                                    widget[key] = value;
                                }
                            });

                            fmodel && fmodel.forceLayout();
                        }

                        //TODO:: More paramenters to be passed
                        callback.animationEnd && callback.animationEnd(widget);
                    });

                    $KD.style(animEl, (_vendor.prefix+'animation'), animStyle);
                }
            }
        }
    };

    var animator_applyRowAnimation = function Animator$applyRowAnimation(elements, config, callbacks) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            model = null;
        if($KU.is(callbacks, 'object')) {
            $KU.each(callbacks, function(cb, cbName) {
                if(cb) {
                    callbacks[cbName] = _decorateCallback(cb, elements.length);
                }
            });
        }

        $KU.each(elements, function(el/*, key*/) {
            model = $KW.model(el);
            this.animate(model, config, callbacks, 'rowAnimation');
            if(model._kwebfw_.is.template) {
                //template row height should apply on li. Treating the height animation separately
                this.animate(model, config, callbacks, 'rowAnimation', true);
            }
        }, this);

        return;
    };

    var _decorateCallback = function Animator$decorateCallback(callback, totalCount) {
        var counter = 0;
        var wrapper = function() {
            counter ++;
            if(counter === totalCount) {
                callback.apply(this, arguments);
            }
        };

        return wrapper;
    };

    $K.defVoltmxProp(Animator.prototype, [
        {keey:'animate', value: animator_animate},
        {keey:'applyRowAnimation', value: animator_applyRowAnimation}
    ]);


    return Animator;
}())});


Object.defineProperty(voltmx.$kwebfw$, 'Transform', {configurable:false, enumerable:false, writable:false, value:(function() {
    var $K = voltmx.$kwebfw$;


    var Transform = function Transform() {
        this.transform = {rotate:'', scale:'', perspective:'', translate:''};
        this.is3D = false;
    };


    var transform_rotate = function Transform$rotate(angle) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, rotate = '';

        if($KU.is(angle, 'number')) {
            if(this.is3D) {
                if(this.transform.scale.indexOf('3d') === -1
                && this.transform.translate.indexOf('3d') === -1) {
                    this.is3D = false;
                }
            }

            rotate = (angle <= 0) ? Math.abs(angle) : ('-' + angle);
            this.transform.rotate = ('rotate(' + rotate + 'deg) ');
        }

        return this;
    };


    var transform_rotate3D = function Transform$rotate3D(angle, x, y, z) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, rotate = '';

        if($KU.is(angle, 'number')) {
            this.is3D = true;
            rotate = (angle <= 0) ? Math.abs(angle) : ('-' + angle);
            this.transform.rotate = ('rotate3d(' + x + ', ' + y + ', ' + z + ', ' + rotate + 'deg) ');
        }

        return this;
    };


    var transform_scale = function Transform$scale(x, y) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(x, 'number') && $KU.is(y, 'number')) {
            if(this.is3D) {
                if(this.transform.rotate.indexOf('3d') === -1
                && this.transform.translate.indexOf('3d') === -1) {
                    this.is3D = false;
                }
            }

            this.transform.scale = ('scale(' + x + ', ' + y + ') ');
        }

        return this;
    };


    var transform_scale3D = function Transform$scale3D(x, y, z) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(x, 'number') && $KU.is(y, 'number') && $KU.is(z, 'number')) {
            this.is3D = true;
            this.transform.scale = ('scale3d(' + x + ', ' + y + ', ' + z + ') ');
        }

        return this;
    };


    var transform_setPerspective = function Transform$setPerspective(p) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(p, 'number') && p > 0) {
            this.transform.perspective = ('perspective(' + p + 'px) ');
        }

        return this;
    };


    var transform_translate = function Transform$translate(x, y) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(x, 'number') && $KU.is(y, 'number')) {
            if(this.is3D) {
                if(this.transform.rotate.indexOf('3d') === -1
                && this.transform.scale.indexOf('3d') === -1) {
                    this.is3D = false;
                }
            }

            this.transform.translate = ('translate(' + x + 'px, ' + y + 'px) ');
        }

        return this;
    };


    var transform_translate3D = function Transform$translate3D(x, y, z) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(x, 'number') && $KU.is(y, 'number') && $KU.is(z, 'number')) {
            this.is3D = true;
            this.transform.translate = ('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px) ');
        }

        return this;
    };


    $K.defVoltmxProp(Transform.prototype, [
        {keey:'rotate', value:transform_rotate},
        {keey:'rotate3D', value:transform_rotate3D},
        {keey:'scale', value:transform_scale},
        {keey:'scale3D', value:transform_scale3D},
        {keey:'setPerspective', value:transform_setPerspective},
        {keey:'translate', value:transform_translate},
        {keey:'translate3D', value:transform_translate3D}
    ]);


    return Transform;
}())});


/* FILE PATH :: 'lib/apis/voltmx.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    //Available on SPA and DesktopWeb
    var _convertToBase64 = function voltmx_convertToBase64(rawbytes) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;
        var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc='', tmp_arr = [];

        $KU.log({api:'voltmx.convertToBase64', enter:true});

        if(!rawbytes) {
            enc = rawbytes;
        } else if('btoa' in window) {
            enc = window.btoa(unescape(encodeURIComponent(rawbytes)));
        } else {
            do{ //Pack three octets into four hexets
                o1 = rawbytes.charCodeAt(i++) & 0xff;
                o2 = rawbytes.charCodeAt(i++) & 0xff;
                o3 = rawbytes.charCodeAt(i++) & 0xff;

                bits = o1<<16 | o2<<8 | o3;

                h1 = bits>>18 & 0x3f;
                h2 = bits>>12 & 0x3f;
                h3 = bits>>6 & 0x3f;
                h4 = bits & 0x3f;

                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while(i < rawbytes.length);

            enc = tmp_arr.join('');

            switch(rawbytes.length % 3) {
                case 1: enc = enc.slice(0, -2) + '==';
                    break;
                case 2: enc = enc.slice(0, -1) + '=';
                    break;
                default: break;
            }
        }

        $KU.log({api:'voltmx.convertToBase64', exit:true});

        return enc;
    };

    //Available on SPA but not on except DesktopWeb
    //On SPA, reading base64 from an image src is not supported.
    //But you can read the base64 from an image which is displayed through base64.
    //eslint-disable-next-line no-unused-vars
    var _convertToRawBytes = function voltmx_convertToRawBytes(base64String) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.convertToRawBytes', enter:true});
        $KU.log({api:'voltmx.convertToRawBytes', exit:true});

        return null; //Dummy implementation
    };


    var _getError = function voltmx_getError(error) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.getError', enter:true});
        $KU.log({api:'voltmx.getError', exit:true});

        return error;
    };


    var _getProperty = function(group, key) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, value = null;

        $KU.log({api:'voltmx.getProperty', enter:true});

        if(arguments.length === 2) {
            if(typeof _voltmxAppProperties === 'object' && _voltmxAppProperties
            && typeof key === 'string' && key) {
                value = _voltmxAppProperties[key] || null;
            }
        }

        $KU.log({api:'voltmx.getProperty', exit:true});

        return value;
    };


    var _screenshot = function voltmx_screenshot(config) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, $KA = $K.app,
            $KU = $K.utils, parent = $KW.model($KA.currentFormUID),
            pel = $KD.parent($KW.el(parent, 'node')), cssscript = '',
            filereader = new FileReader(), viewportMain = $KW.el(parent, 'viewport'),
            viewportHeight = viewportMain.scrollHeight, i = 0, j = 0,
            viewportWidth = viewportMain.scrollWidth, data = '', svg = [],
            tempCSS = document.styleSheets, Script = '', formMain = null, csstext = '';

        if($KU.browser('name') === 'msie' || $KU.browser('name') === 'unknown') {
            return;
        }

        formMain = $KD.first(pel);
        csstext = formMain.style.cssText;
        $KD.setAttr(formMain, 'style', csstext +'height:'+ viewportHeight.toString() + 'px !important;' + 'width:' + viewportWidth.toString() + 'px !important;');

        for(i = 0; i < tempCSS.length; i++) {
            if(tempCSS[i].href) {
                for(j = 0; j < tempCSS[i].rules.length; j++) {
                    cssscript = cssscript + tempCSS[i].rules[j].cssText;
                }
            }
        }

        for(i = 0; i < pel.childNodes.length; i++) {
            Script = Script + (new XMLSerializer).serializeToString(pel.childNodes[i]);
        }

        data = '<svg xmlns="http://www.w3.org/2000/svg" width="' + viewportWidth + '" height="' + viewportHeight + '">'
                + '<foreignObject width="100%" height="100%">'
                + '<div xmlns="http://www.w3.org/1999/xhtml" style="font-size:40px" >'
                + '<style>'
                + cssscript
                + '</style>'
                +Script
                + '</div>'
                + '</foreignObject>'
                + '</svg>';
        svg = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});
        filereader.readAsDataURL(svg);
        filereader.onload = function() {
            var img = $KD.create('IMG');
            this.onload = null;
            $KD.setAttr(img, 'crossOrigin', 'anonymous');
            $KD.setAttr(img, 'src', filereader.result);
            $KD.setAttr(img, 'height', viewportHeight);
            $KD.setAttr(img, 'width', viewportWidth);
            $KD.style(img, 'display', 'none');
            $KD.add($KD.body(), img);
            img.onload = function() {
                var canvas = $KD.create('canvas'),
                    ctx = [];
                this.onload = null;
                $KD.setAttr(canvas, 'src', filereader.result);
                $KD.setAttr(canvas, 'height', viewportHeight);
                $KD.setAttr(canvas, 'width', viewportWidth);
                $KD.style(canvas, 'display', 'none');
                $KD.add($KD.body(), canvas);
                ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.drawImage(img, 0, 0);
                $KD.remove(img);
                $KD.remove(canvas);
                config.callback && config.callback(canvas.toDataURL().split(',')[1]);
            };
        };

        $KD.setAttr(formMain, 'style', csstext);
    };

    var _print = function voltmx_print(str) {
        //eslint-disable-next-line no-console
        if(console && typeof console.log === 'function'
        && constants.PRINTSTUB !== 'true') {
            if(typeof str === 'string'
            || typeof str === 'number'
            || typeof str === 'boolean'
            || str === null || str === undefined) {
                //eslint-disable-next-line no-console
                console.log(str);
            } else if(typeof str === 'object' && str) {
                if(JSON) {
                    //eslint-disable-next-line no-console
                    console.log(JSON.stringify(str));
                } else if(typeof str.toString === 'function') {
                    //eslint-disable-next-line no-console
                    console.log(str.toString());
                }
            }
        }
    };


    var _type = function voltmx_type(variable) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, datatype = '';

        $KU.log({api:'voltmx.type', enter:true});

        if($KU.is(variable, 'string')) {
            datatype = 'string';
        } else if($KU.is(variable, 'number')) {
            datatype = 'number';
        } else if($KU.is(variable, 'function')) {
            datatype = 'function';
        } else if($KU.is(variable, 'null')) {
            datatype = 'null';
        } else if($KU.is(variable, 'widget')) {
            variable = $KW.proxy(variable);
            datatype = (variable) ? variable._kwebfw_.ns : 'userdata';
        } else {
            datatype = 'userdata';
        }

        $KU.log({api:'voltmx.type', exit:true});

        return datatype;
    };

    $K.defVoltmxProp(voltmx, [
        {keey:'convertToBase64', value:_convertToBase64},
        {keey:'convertToRawBytes', value:_convertToRawBytes},
        {keey:'getError', value:_getError},
        {keey:'screenshot', value:_screenshot},
        {keey:'print', value:_print, writable: true},
        {keey:'type', value:_type}
    ]);


    $K.defVoltmxProp(voltmx.props, [
        {keey:'getProperty', value:_getProperty}
    ]);
}());


/* FILE PATH :: 'lib/apis/voltmxapplication.js' */
Object.defineProperty(voltmx, 'application', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$, _lastFocusedElement = null;


    var _addApplicationCallbacks = function $KAPP_addApplicationCallbacks() {
        //
    };

    //TODO:: addBMState
    //
    var _addBMState = function $KAPP_addBMState(/*formId, keey, value*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.addBMState', enter:true});

        //

        $KU.log({api:'voltmx.application.addBMState', exit:true});
    };


    //TODO:: addGestureRecognizerForAllForms
    var _addGestureRecognizerForAllForms = function $KAPP_addGestureRecognizerForAllForms(gestureType, gestureConfigParams, onGestureClosure) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, id = $KU.uid(), gesture = null;

        $KU.log({api:'voltmx.application.addGestureRecognizerForAllForms', enter:true});

        if(!$KU.is($K.app.gesture, 'object')) {
            gesture = $K.app.gesture = {};
        }
        if(!$KU.is(gesture[gestureType], 'array')) {
            gesture[gestureType] = [];
        }

        gesture = gesture[gestureType];

        gesture.push({cb:onGestureClosure, id:id, opt:gestureConfigParams});

        $KU.log({api:'voltmx.application.addGestureRecognizerForAllForms', exit:true});

        return id;
    };


    var _checkPermission = function $KAPP_checkPermission(resourceId/*, options*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, permission = null;

        $KU.log({api:'voltmx.application.checkPermission', enter:true});

        switch(resourceId) {
            case voltmx.os.RESOURCE_LOCATION:
            case voltmx.os.RESOURCE_CAMERA:
            case voltmx.os.RESOURCE_PHOTO_GALLERY:
            case voltmx.os.RESOURCE_CALENDAR:
                permission = {status:voltmx.application.PERMISSION_GRANTED, canRequestPermission:false};
                break;
            case voltmx.os.RESOURCE_CONTACTS:
            case voltmx.os.RESOURCE_EXTERNAL_STORAGE:
            default:
                permission = {status:voltmx.application.RESOURCE_NOT_SUPPORTED, canRequestPermission:false};
                break;
        }

        $KU.log({api:'voltmx.application.checkPermission', exit:true});

        return permission;
    };


    var _dismissLoadingScreen = function $KAPP_dismissLoadingScreen() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            $KA = $K.app, $KG = $K.globals;

        $KU.log({api:'voltmx.application.dismissLoadingScreen', enter:true});

        if($KU.is($KA.blocked, 'boolean')) {
            $KD.setAttr($KG.appBlocker, 'hidden', true);
            $KD.removeAttr($KG.appBlocker, 'class');
            $KD.removeAttr($KG.appBlocker, 'tabindex');

            $KD.style($KG.appBlocker, {
                left: null,
                top: null,
                width: null,
                height: null,
                transform: null,
                'pointer-events': null
            });

            if(_lastFocusedElement) {
                $KD.focus(_lastFocusedElement);
                _lastFocusedElement = null; //For GC
            }

            $KA.blocked = null;
        }

        $KU.log({api:'voltmx.application.dismissLoadingScreen', exit:true});
    };


    //This is defined in voltmxmvc_sdk.js file
    //var _destroyForm = function $KAPP_destroyForm(formId) {};


    //Available only on SPA
    var _exit = function $KAPP_exit() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.exit', enter:true});

        window.open('about:blank', '_self', '');

        $KU.log({api:'voltmx.application.exit', exit:true});

        window.close();
    };


    var _getApplicationBehavior = function $KAPP_getApplicationBehavior(behavior) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, value = null;

        $KU.log({api:'voltmx.application.getApplicationBehavior', enter:true});

        if($KU.is(behavior, 'string') && behavior) {
            value = $K.behavior[behavior];
        }

        $KU.log({api:'voltmx.application.getApplicationBehavior', exit:true});

        return value;
    };


    var _getApplicationMode = function $KAPP_getApplicationMode() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.application.getApplicationMode', enter:true});
        $KU.log({api:'voltmx.application.getApplicationMode', exit:true});

        return $KA.mode;
    };


    var _getBaseURL = function $KAPP_getBaseURL() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;
        $KU.log({api:'voltmx.application.getBaseURL', enter:true});
        $KU.log({api:'voltmx.application.getBaseURL', exit:true});

        return window.location.host + window.location.pathname;
    };


    //TODO:: getBMState
    var _getBMState = function $KAPP_getBMState(/*formId*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.getBMState', enter:true});

        //

        $KU.log({api:'voltmx.application.getBMState', exit:true});
    };


    var _getBrowserProtocol = function $KAPP_getBrowserProtocol() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;
        $KU.log({api:'voltmx.application.getBrowserProtocol', enter:true});
        $KU.log({api:'voltmx.application.getBrowserProtocol', exit:true});
        return window.location.protocol;
    };


    var _getCurrentBreakpoint = function $KAPP_getCurrentBreakpoint() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.application.getCurrentBreakpoint', enter:true});
        $KU.log({api:'voltmx.application.getCurrentBreakpoint', exit:true});

        return $KA.currentBreakpoint;
    };

    var _getCurrentForm = function $KAPP_getCurrentForm() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KA = $K.app;

        $KU.log({api:'voltmx.application.getCurrentForm', enter:true});
        $KU.log({api:'voltmx.application.getCurrentForm', exit:true});

        return $KW.model($KA.currentFormUID);
    };

    var _getPreviousForm = function $KAPP_getPreviousForm() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, $KW = $K.widget;

        $KU.log({api:'voltmx.application.getPreviousForm', enter:true});
        $KU.log({api:'voltmx.application.getPreviousForm', exit:true});

        return $KW.model($KA.previousFormUID);
    };


    var _getWebAssetRelativeURL = function $KAPP_getWebAssetRelativeURL(src, path) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, relativePath = src;

        $KU.log({api:'voltmx.application.getWebAssetRelativeURL', enter:true});

        if($KU.is(src, 'string') && src
        && !(src.indexOf('//') === 0 || src.indexOf('://') > 0)) {
            if(path === 'weblocal') {
                relativePath = $KU.getRelativeURL(src, 'web/localfiles/');
            } else {
                relativePath = $KU.getImageURL(src);
            }
        }

        $KU.log({api:'voltmx.application.getWebAssetRelativeURL', exit:true});

        return relativePath;
    };


    var _isImageTurnedOff = function $KAPP_isImageTurnedOff(callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            $KG = $K.globals, timeout = null, image = null;

        $KU.log({api:'voltmx.application.isImageTurnedOff', enter:true});

        if($KU.is(callback, 'function')) {
            image = $KD.create('IMG');
            image.src = $KU.getImageURL('loading.gif');
            image.style.visibility = 'hidden';
            $KD.on(image, 'mousedown', 'image', function(e) {
                $KD.preventDefault(e);
            });
            $KD.add($KG.appScrap, image);

            timeout = setTimeout(function() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                clearTimeout(timeout);

                if(image.complete) {
                    callback(false);
                } else {
                    callback(true);
                }

                $KD.remove(image);

                $KU.log({api:'voltmx.application.isImageTurnedOff', exit:true});
            }, 1000);
        }
    };


    var _isPopupBlocked = function $KAPP_isPopupBlocked(callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, timeout = null, win = null;

        $KU.log({api:'voltmx.application.isPopupBlocked', enter:true});

        if($KU.is(callback, 'function')) {
            timeout = setTimeout(function() {
                clearTimeout(timeout);
                win = window.open(null);

                try{
                    win.close();
                    callback(false); //popups are enabled;
                } catch(e) {
                    callback(true); //popups are disabled;
                }

                $KU.log({api:'voltmx.application.isPopupBlocked', exit:true});
            }, 2000);
        }
    };


    //Supported for DesktopWeb, not for SPA
    var _openMediaURL = function $KAPP_openMediaURL(url, params, name) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.openMediaURL', enter:true});

        _openURL(url, params, name);

        $KU.log({api:'voltmx.application.openMediaURL', exit:true});
    };


    var _openURL = function $KAPP_openURL(url, params, name) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, options = null;

        $KU.log({api:'voltmx.application.openURL', enter:true});

        if(arguments.length === 1) {
            name = '_blank';
            params = null;
        } else if(arguments.length === 2) {
            if($KU.is(params, 'string')) {
                name = params;
                params = null;
            }
        }

        if($KU.is(url, 'string') && url) {
            if(!($KU.is(name, 'string') && name)) {
                name = '_blank';
            }

            if(!$KU.is(params, 'object')) {
                window.open(url);
            } else { //Supported for DesktopWeb, not for SPA
                if(params.innewwindow !== true) {
                    window.open(url);
                } else {
                    options = [];

                    if($KU.is(params.width, 'number')) {
                        options.push('width=' + params.width + 'px');
                    }
                    if($KU.is(params.height, 'number')) {
                        options.push('height=' + params.height + 'px');
                    }
                    if(!params.menubar === false) {
                        options.push('menubar=no');
                    }
                    if(!params.statusbar === false) {
                        options.push('statusbar=no');
                    }
                    if(!params.toolbar === false) {
                        options.push('toolbar=no');
                    }
                    if(!params.titlebar === false) {
                        options.push('titlebar=no');
                    }

                    window.open(url, '_blank', options.join(', '));
                }
            }
        }

        $KU.log({api:'voltmx.application.openURL', exit:true});
    };


    var _openURLAsync = function $KAPP_openURLAsync(config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.openURLAsync', enter:true});

        if(config.isSameWindow === true) {
            return window.open(config.url, '_self');
        } else if(config.isSameWindow === false) {
            return window.open(config.url, '_blank');
        }
        window.open(config.url, '_blank');


        if($KU.is(config.callback, 'function')) {
            config.callback(constants.OPEN_URL_UNKNOWN);
        }

        $KU.log({api:'voltmx.application.openURLAsync', exit:true});
    };


    var _populateLaunchParams = function $KAPP_populateLaunchParams(launch) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KG = $K.globals, route = $KU.deduceRoute();

        if(route.formId) {
            $KG.deeplinkParams.formID = route.formId;

            //JSON based deeplink parameters
            $KU.each(route.deeplinkParams, function(value, keey) {
                launch.params[keey] = value;
            });
        }

        launch.launchmode = $KG.launchmode;

        //QueryString based deeplink parameters
        $KU.each($KG.deeplinkParams, function(value, keey) {
            launch.params[keey] = value;
        });

        if($K.F.EIWP) {
            launch.launchparams = launch.params;
        }
    };


    var _prepareLoadingScreen = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            $KG = $K.globals, image ='', label = '', body = document.body;

        $KG.appForms = $KD.find(body, '[kr="app_forms"]')[0];
        $KG.appDialogs = $KD.find(body, '[kr="app_dialogs"]')[0];
        $KG.appScrap = $KD.find(body, '[kr="app_scrap"]')[0];
        $KG.appBlocker = $KD.find(body, '[kr="app_blocker"]')[0];

        $KD.on($KG.appBlocker, 'blur', 'abblur', function(e) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, $KA = $K.app;

            if($KA.blocked === true && !$KD.hasAttr(e.target, 'hidden')) {
                $KD.preventDefault(e);
                $KD.focus(e.target);
            }
        });

        image = ('<img loading="lazy" onmousedown="return false;" src="'+$KU.getImageURL('loading.gif')+'" alt=""/>');
        label = '<label></label>';

        $KD.html($KG.appBlocker, (image+label));
    };


    var _registerForIdleTimeout = function $KAPP_registerForIdleTimeout(delay, callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KA = $K.app;

        $KU.log({api:'voltmx.application.registerForIdleTimeout', enter:true});

        if($KU.is(delay, 'number') && delay > 0 && $KU.is(callback, 'function')) {
            $KA.idleTime = (delay * 60 * 1000);
            $KA.idleCallback = callback;
            $KW.registerForIdleTimeout();
        } else if($KA.idleTimeout) {
            clearTimeout($KA.idleTimeout);
            $KA.lastInteractionAt = $KA.idleTimeout = null;
        }

        $KU.log({api:'voltmx.application.registerForIdleTimeout', exit:true});
    };


    var _registerMaster = function $KAPP_registerMaster(config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.registerMaster', enter:true});

        _registerUserWidget(config);

        $KU.log({api:'voltmx.application.registerMaster', exit:true});
    };


    var _registerUserWidget = function $KAPP_registerUserWidget(config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            classname = '', name = '', namespace = '', n = 0,
            namspaceArr = null, userWidgetNamespace = window,
            nlen = 0, getNSObj = function(userNS1, userNS2) {
                if(!userNS1[userNS2]) {
                    userNS1[userNS2] = {};
                }

                return userNS1[userNS2];
            };

        $KU.log({api:'voltmx.application.registerUserWidget', enter:true});

        if(!config) return 100;
        if(typeof config !== 'object') return 101;

        classname = config.classname;
        name = config.name;
        namespace = config.namespace;

        if(classname === null || classname.length <= 0) return 102;
        if(name === null || name.length <= 0) return 102;

        if(namespace !== null && namespace !== '') {
            namspaceArr = namespace.split('.');
            nlen = namspaceArr.length;

            for(n=0; n<nlen; n++) {
                userWidgetNamespace = getNSObj(userWidgetNamespace, namspaceArr[n]);
            }
        }

        if(userWidgetNamespace[classname]) return 103;

        userWidgetNamespace[classname] = function(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, model = null;

            if(!$KU.is(lconfig, 'object')) lconfig = {};
            if(!$KU.is(pspconfig, 'object')) pspconfig = {};

            if(bconfig.masterType === constants.MASTER_TYPE_USERWIDGET) {
                bconfig.isMaster = true;
                model = voltmx.$kwebfw$.ComponentWithContract(bconfig, lconfig, pspconfig, name);
            } else {
                model = voltmx.$kwebfw$.ComponentWithoutContract(bconfig, lconfig, pspconfig, name);
            }

            return model;
        };

        $KU.log({api:'voltmx.application.registerUserWidget', exit:true});

        return 0;
    };


    var _removeApplicationCallbacks = function $KAPP_removeApplicationCallbacks() {
        //
    };


    //TODO:: removeBMState
    var _removeBMState = function $KAPP_removeBMState(/*formId, keey*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.removeBMState', enter:true});

        //

        $KU.log({api:'voltmx.application.removeBMState', exit:true});
    };


    //TODO:: removeGestureRecognizerForAllForms
    var _removeGestureRecognizerForAllForms = function $KAPP_removeGestureRecognizerForAllForms(uid) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, list = null, position = -1;

        $KU.log({api:'voltmx.application.removeGestureRecognizerForAllForms', enter:true});

        $KU.each($K.app.gesture, function(gesture) {
            list = gesture; position = -1;

            $KU.each(gesture, function(value, index) {
                if(value.id === uid) {
                    position = index;
                }
            });
        });

        if($KU.is(list, 'array') && position !== -1) {
            list.splice(position, 1);
        }

        $KU.log({api:'voltmx.application.removeGestureRecognizerForAllForms', exit:true});
    };


    var _removeQueryParamsByKey = function $KAPP_removeQueryParamsByKey(param) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            baseURL, path, hashValue, searchstring,
            queryParams, finalParams, i, finalurl;

        $KU.log({api:'voltmx.application.removeQueryParamsByKey', enter:true});

        if(window.location.search.length > 0) {
            baseURL = window.location.href.split('?')[0];
            path = window.location.href.split('?')[1];
            hashValue = path.split('#')[1];
            searchstring = window.location.search.slice(1);
            queryParams = searchstring.split('&');
            finalParams = '';
            for(i = queryParams.length-1; i >= 0; i--) {
                if(queryParams[i].indexOf(param) !== -1) {
                    queryParams.splice(i, 1);
                }
            }

            finalParams = queryParams.join('&');
            if(hashValue) {
                if(queryParams.length === 0) {
                    finalurl = baseURL + '#' + hashValue;
                } else {
                    finalurl = baseURL + '?' + finalParams + '#' + hashValue;
                }
            } else {
                if(queryParams.length === 0) {
                    finalurl = baseURL;
                } else {
                    finalurl = baseURL + '?' + finalParams;
                }
            }
            history.replaceState(null, '', finalurl);
        }

        $KU.log({api:'voltmx.application.removeQueryParamsByKey', exit:true});
    };


    var _removeSeoDataReadyFlag = function $KAPP_removeSeoDataReadyFlag() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KD = $K.dom, body = $KD.body();

        $KU.log({api:'voltmx.application.removeSeoDataReadyFlag', enter:true});
        $KD.removeAttr(body, 'data-ready');
        $KU.log({api:'voltmx.application.removeSeoDataReadyFlag', exit:true});
    };


    var _requestPermission = function $KAPP_requestPermission(resourceId, callback/*, options*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, permission = null;

        $KU.log({api:'voltmx.application.requestPermission', enter:true});

        if($KU.is(callback, 'function')) {
            switch(resourceId) {
                case voltmx.os.RESOURCE_LOCATION:
                case voltmx.os.RESOURCE_CAMERA:
                case voltmx.os.RESOURCE_PHOTO_GALLERY:
                case voltmx.os.RESOURCE_CALENDAR:
                    permission = {status:voltmx.application.PERMISSION_GRANTED, canRequestPermission:false};
                    break;
                case voltmx.os.RESOURCE_CONTACTS:
                case voltmx.os.RESOURCE_EXTERNAL_STORAGE:
                default:
                    permission = {status:voltmx.application.RESOURCE_NOT_SUPPORTED, canRequestPermission:false};
            }
        }

        callback(permission);

        $KU.log({api:'voltmx.application.requestPermission', exit:true});
    };


    //TODO:: resetBMState
    var _resetBMState = function $KAPP_resetBMState() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.resetBMState', enter:true});

        //

        $KU.log({api:'voltmx.application.resetBMState', exit:true});
    };


    var _resetBodyHTML = function() {
        _appendTag({'id':'skip'}, 'z-index:2147483647 !important;', true);
        _appendTag({'kr':'app_forms'}, 'z-index:2147483647 !important;', false);
        _appendTag({'kr':'app_dialogs'}, 'z-index:2147483647 !important;', false);
        _appendTag({'kr':'app_scrap'}, 'z-index:2147483647 !important;', false);
        _appendTag({'kr':'app_blocker', 'aria-hidden': true}, 'z-index:2147483647 !important;', true);

    };

    var _kofInitTags = function() {
        var $KG = $K.globals, $KW = $K.widget, $KD = $K.dom, body = document.body;

        _appendTag({'kr':'app_dialogs'}, 'z-index:2147483647 !important;', false);
        _appendTag({'kr':'app_scrap'}, 'z-index:2147483647 !important;', false);
        _appendTag({'kr':'app_blocker', 'aria-hidden': true}, 'z-index:2147483647 !important;', true);

        $KG.appDialogs = $KD.find(body, '[kr="app_dialogs"]')[0];
        $KG.appScrap = $KD.find(body, '[kr="app_scrap"]')[0];
        $KG.appBlocker = $KD.find(body, '[kr="app_blocker"]')[0];

        $KW.registerEvents($KG.appDialogs);
    };

    var _appendTag = function(attrs, style, hidden) {
        var el = '', body = document.body, key = null;

        el = document.createElement('div');
        el.style = style;

        for(key in attrs) {
            el.setAttribute(key, attrs[key]);
        }

        if(hidden) {
            el.hidden = hidden;
        }

        body.appendChild(el);
    };


    var _setApplicationBehaviors = function $KAPP_setApplicationBehaviors(behaviors) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.setApplicationBehaviors', enter:true});

        $KU.each(behaviors, function(value, keey) {
            if($KU.is(keey, 'string') && keey) {
                if($KU.is(value, 'undefined')) {
                    delete $K.behavior[keey];
                } else {
                    $K.behavior[keey] = value;
                }
            }
        });

        $KU.log({api:'voltmx.application.setApplicationBehaviors', exit:true});
    };

    var _setApplicationInitializationEvents = function $KAPP_setApplicationInitializationEvents(evt) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, launch = {params:{}}, home = null,
            $KAR = $K.automation.recorder, testresources = null,
            testAutomationScriptURL = null, voltmxAutomationPath = null,
            params = window.location.search, protocol = null;

        $KU.log({api:'voltmx.application.setApplicationInitializationEvents', enter:true});

        _populateLaunchParams(launch);

        if($KU.is(evt.preappinit, 'function')) {
            evt.preappinit(launch);
        }

        if($KU.is(evt.init, 'function')) {
            evt.init(launch);
        }

        /* What is this, why it is required before firing "postappinit" and after "appinit" ???
        $K.behavior.isMVC || false;

        launch.params.isRefresh = false;
        launch.params.isNewSPASession = (voltmx.appinit.isNewSession === 'true');

        if(window.location.hash) {
            var formObj = window[window.location.hash.substring(2)];
            if(formObj && !launch.params.isNewSPASession) {
                launch.params.isRefresh = true;
                launch.params.refreshForm = formObj;
            }
        }
        //*/
        //eslint-disable-next-line no-undef
        if(appConfig.testAutomation) {
            window._voltmx.automation = {}; // for IntegrationTests object to be available globally
            //eslint-disable-next-line no-undef
            testAutomationScriptURL = appConfig.testAutomation.scriptsURL;
            if(params) {
                _voltmx.automation.params = {};
                params = new URLSearchParams(params);
                protocol = params.get('protocol');
                testresources = params.get('testurl');
                params.forEach(function(value, key) {
                    _voltmx.automation.params[key] = value;
                });
                if(protocol && testresources) {
                    testAutomationScriptURL = protocol + '://' + testresources;
                }
            }

            if(testAutomationScriptURL && testAutomationScriptURL.length !== 0
            && testAutomationScriptURL.startsWith('http')) {
                voltmxAutomationPath = testAutomationScriptURL + 'Desktop';
                setTimeout(function() {
                    $KAR && $KAR.invokeJasmineAutomation(voltmxAutomationPath);
                }, 1000);
            } else {
                $KU.log('Invalid test automation configuration.');
            }
        }

        if($KU.is(evt.postappinit, 'function')) {
            home = evt.postappinit(launch);
        }

        if($KU.is(evt.appServiceAsync, 'function')) {
            evt.appServiceAsync(launch, function(launchParams) {
                if(!$KU.loadedFromOtherFramework()) {
                    _showForm(evt, home, launchParams);
                } else {
                    _kofInitTags();
                }
            });
        } else {
            if(!$KU.loadedFromOtherFramework()) {
                _showForm(evt, home, launch);
            } else {
                _kofInitTags();
            }
        }

        $KU.log({api:'voltmx.application.setApplicationInitializationEvents', exit:true});
    };

    var _setApplicationMode = function $KAPP_setApplicationMode(mode) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app,
            supportedModes = [
                constants.APPLICATION_MODE_NATIVE,
                constants.APPLICATION_MODE_HYBRID,
                constants.APPLICATION_MODE_WRAPPER
            ];

        $KU.log({api:'voltmx.application.setApplicationMode', enter:true});
        $KA.mode = (supportedModes.indexOf() === -1) ? constants.APPLICATION_MODE_NATIVE : mode;
        $KU.log({api:'voltmx.application.setApplicationMode', exit:true});
    };


    //TODO:: setBMState
    var _setBMState = function $KAPP_setBMState(/*formId, state*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.setBMState', enter:true});

        //

        $KU.log({api:'voltmx.application.setBMState', exit:true});
    };


    var _showForm = function(evt, home, launch) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KG = $K.globals, $KD = $K.dom, body = $KD.body(), form = null;

        if($KU.is(evt.deeplink, 'function')
        || $KU.is(evt.appservice, 'function')) {
            if(evt.appservice) {
                home = evt.appservice(launch);
            } else if(evt.deeplink) {
                home = evt.deeplink($KG.deeplinkParams);
            }
        }

        _resetBodyHTML();
        _prepareLoadingScreen();

        if(home) {
            if($KU.is(home, 'string')) {
                form = $KW.root(home);

                if(!form || form._voltmxControllerName) {
                    _voltmx.mvc.navigate(home);
                } else {
                    form.show();
                }
            } else {
                home.show();
            }
        } else if($KU.is(evt.showstartupform, 'function')) {
            evt.showstartupform(launch);
        }

        $KD.removeAttr(body, 'aria-busy');
    };


    //TODO:: setGestureRecognizerForAllForms
    var _setGestureRecognizerForAllForms = function $KAPP_setGestureRecognizerForAllForms() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.application.setGestureRecognizerForAllForms', enter:true});

        //

        $KU.log({api:'voltmx.application.setGestureRecognizerForAllForms', exit:true});
    };


    var _setSeoDataReadyFlag = function $KAPP_setSeoDataReadyFlag() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KD = $K.dom, body = $KD.body();

        $KU.log({api:'voltmx.application.setSeoDataReadyFlag', enter:true});
        $KD.setAttr(body, 'data-ready', 1);
        $KU.log({api:'voltmx.application.setSeoDataReadyFlag', exit:true});
    };


    var _setupWidgetDataRecording = function $KAPP_setupWidgetDataRecording() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.application.setupWidgetDataRecording', enter:true});
        $KA.behavior.recording = true;
        $KU.log({api:'voltmx.application.setupWidgetDataRecording', exit:true});
    };


    var _showLoadingScreen = function $KAPP_showLoadingScreen(skin, text, position, isBlocked, showProgressIndicator/*, properties*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            $KA = $K.app, $KG = $K.globals, image = null,
            label = null, supportedPositions = [
                constants.LOADING_SCREEN_POSITION_FULL_SCREEN,
                constants.LOADING_SCREEN_POSITION_ONLY_CENTER
            ];

        $KU.log({api:'voltmx.application.showLoadingScreen', enter:true});

        if(!$KU.is($KA.blocked, 'boolean')) {
            if(!$KU.is(skin, 'string')) skin = '';
            if(!$KU.is(text, 'string')) text = '';
            if(!$KU.is(isBlocked, 'boolean')) isBlocked = true;
            if(!$KU.is(showProgressIndicator, 'boolean')) {
                showProgressIndicator = true;
            }
            if(supportedPositions.indexOf(position) === -1) {
                position = constants.LOADING_SCREEN_POSITION_FULL_SCREEN;
            }

            $KA.blocked = isBlocked;
            image = $KD.first($KG.appBlocker);
            label = $KD.last($KG.appBlocker);

            $KG.appBlocker.className = ((skin) ? skin : '-voltmx-loading');
            $KD.setAttr(image, 'hidden', !showProgressIndicator);
            $KD.html(label, ''); $KD.text(label, text);
            $KD.setAttr(label, 'hidden', !text);

            if(!isBlocked) {
                if(position === constants.LOADING_SCREEN_POSITION_FULL_SCREEN) {
                    $KD.style($KG.appBlocker, {
                        pointerEvents: 'none'
                    });
                } else if(position === constants.LOADING_SCREEN_POSITION_ONLY_CENTER) {
                    $KD.style($KG.appBlocker, {
                        left: '50%',
                        top: '50%',
                        width: 'auto',
                        height: 'auto',
                        transform: 'translate(-50%, -50%)'
                    });
                }
            }

            $KD.setAttr($KG.appBlocker, 'hidden', false);
            _lastFocusedElement = $KD.active();
            $KD.setAttr($KG.appBlocker, 'tabindex', -1);
            $KD.focus($KG.appBlocker);
        }

        $KU.log({api:'voltmx.application.showLoadingScreen', exit:true});
    };


    var _unregisterForIdleTimeout = function $KAPP_unregisterForIdleTimeout() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.application.unregisterForIdleTimeout', enter:true});

        if($KA.idleTimeout) {
            $KA.idleTime = 0;
            $KA.idleCallback = null;
            clearTimeout($KA.idleTimeout);
            $KA.lastInteractionAt = $KA.idleTimeout = null;
        }

        $KU.log({api:'voltmx.application.unregisterForIdleTimeout', exit:true});
    };


    $K.defVoltmxProp(_ns, [
        {keey:'addApplicationCallbacks', value:_addApplicationCallbacks},
        {keey:'addBMState', value:_addBMState},
        {keey:'addGestureRecognizerForAllForms', value:_addGestureRecognizerForAllForms},
        {keey:'checkPermission', value:_checkPermission},
        {keey:'dismissLoadingScreen', value:_dismissLoadingScreen},
        //{keey:'destroyForm', value:_destroyForm}, //This is defined in voltmxmvc_sdk.js file
        {keey:'exit', value:_exit},
        {keey:'getApplicationBehavior', value:_getApplicationBehavior},
        {keey:'getApplicationMode', value:_getApplicationMode},
        {keey:'getBaseURL', value: _getBaseURL},
        {keey:'getBMState', value:_getBMState},
        {keey:'getBrowserProtocol', value:_getBrowserProtocol},
        {keey:'getCurrentBreakpoint', value:_getCurrentBreakpoint},
        {keey:'getCurrentForm', value:_getCurrentForm},
        {keey:'getPreviousForm', value:_getPreviousForm},
        {keey:'getWebAssetRelativeURL', value:_getWebAssetRelativeURL},
        {keey:'openMediaURL', value:_openMediaURL},
        {keey:'isImageTurnedOff', value:_isImageTurnedOff},
        {keey:'isPopupBlocked', value:_isPopupBlocked},
        {keey:'openURL', value:_openURL},
        {keey:'openURLAsync', value:_openURLAsync},
        {keey:'registerForIdleTimeout', value:_registerForIdleTimeout},
        {keey:'registerMaster', value:_registerMaster},
        {keey:'registerUserWidget', value:_registerUserWidget},
        {keey:'removeApplicationCallbacks', value:_removeApplicationCallbacks},
        {keey:'removeBMState', value:_removeBMState},
        {keey:'removeGestureRecognizerForAllForms', value:_removeGestureRecognizerForAllForms},
        {keey:'removeQueryParamsByKey', value:_removeQueryParamsByKey},
        {keey:'removeSeoDataReadyFlag', value:_removeSeoDataReadyFlag},
        {keey:'requestPermission', value:_requestPermission},
        {keey:'resetBMState', value:_resetBMState},
        {keey:'setApplicationBehaviors', value:_setApplicationBehaviors},
        {keey:'setApplicationInitializationEvents', value:_setApplicationInitializationEvents, writable:true},
        {keey:'setApplicationMode', value:_setApplicationMode},
        {keey:'setBMState', value:_setBMState},
        {keey:'setGestureRecognizerForAllForms', value:_setGestureRecognizerForAllForms},
        {keey:'setSeoDataReadyFlag', value:_setSeoDataReadyFlag},
        {keey:'setupWidgetDataRecording', value:_setupWidgetDataRecording},
        {keey:'showLoadingScreen', value:_showLoadingScreen},
        {keey:'unregisterForIdleTimeout', value:_unregisterForIdleTimeout}
    ]);

    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxconstants.js' */
Object.defineProperty(window, 'constants', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    $K.defVoltmxProp(_ns, [
        {keey:'ALERT_TYPE_CONFIRMATION', value:'confirmation'},
        {keey:'ALERT_TYPE_ERROR', value:'error'},
        {keey:'ALERT_TYPE_INFO', value:'info'},
        {keey:'API_LEVEL', value:'APILevel'},
        {keey:'API_LEVEL_8200', value:8200},
        {keey:'API_LEVEL_8300', value:8300},
        {keey:'API_LEVEL_8400', value:8400},
        {keey:'API_LEVEL_9200', value:9200},
        {keey:'APPLICATION_MODE_HYBRID', value:'hybrid'},
        {keey:'APPLICATION_MODE_NATIVE', value:'native'},
        {keey:'APPLICATION_MODE_WRAPPER', value:'wrapper'},
        {keey:'BREAKPOINT_MAX_VALUE', value:Number.MAX_VALUE},
        {keey:'BROWSER_REQUEST_METHOD_GET', value:'get'},
        {keey:'BROWSER_REQUEST_METHOD_POST', value:'post'},
        {keey:'CALENDAR_DATE_FORMAT_DEFAULT', value:'dd/MM/yyyy'},
        {keey:'CALENDAR_ICON_ALIGN_AUTO', value:'auto'},
        {keey:'CALENDAR_ICON_ALIGN_LEFT', value:'left'},
        {keey:'CALENDAR_ICON_ALIGN_RIGHT', value:'right'},
        {keey:'CALENDAR_SELECTION_TYPE_MULTI_SELECT', value:'multiselect'},
        {keey:'CALENDAR_SELECTION_TYPE_RANGE_SELECT', value:'rangeselect'},
        {keey:'CALENDAR_SELECTION_TYPE_SINGLE_SELECT', value:'singleselect'},
        {keey:'CALENDAR_VIEW_TYPE_DEFAULT', value:'default'},
        {keey:'CALENDAR_VIEW_TYPE_GRID_ONSCREEN', value:'onscreen'},
        {keey:'CALENDAR_VIEW_TYPE_GRID_POPUP', value:'popup'},
        {keey:'CAMERA_CAPTURE_FAILED', value:'capturefailed'},
        {keey:'CAMERA_NOT_SUPPORTED', value:'notsupported'},
        {keey:'CAMERA_PERMISSION_DENIED', value:'permissiondenied'},
        {keey:'CAMERA_SOURCE_DEFAULT', value:'front'},
        {keey:'CAMERA_SOURCE_FRONT', value:'front'},
        {keey:'CAMERA_SOURCE_FRONT_UNAVAILABLE', value:'frontunavailable'},
        {keey:'CAMERA_SOURCE_REAR', value:'rear'},
        {keey:'CAMERA_SOURCE_REAR_UNAVAILABLE', value:'rearunavailable'},
        {keey:'CAMERA_VIDEO_RECORDING_FAILED', value:'recordingfailed'},
        {keey:'CHECKBOX_ITEM_ORIENTATION_HORIZONTAL', value:'horizontal'},
        {keey:'CHECKBOX_ITEM_ORIENTATION_VERTICAL', value:'vertical'},
        {keey:'CHECKBOX_VIEW_TYPE_CUSTOMVIEW', value:'customview'},
        {keey:'CHECKBOX_VIEW_TYPE_DEFAULTTVIEW', value:'defaultview'},
        {keey:'CHECKBOX_VIEW_TYPE_LISTVIEW', value:'listview'},
        {keey:'CHECKBOX_VIEW_TYPE_ONSCREENWHEEL', value:'onscreenwheel'},
        {keey:'CHECKBOX_VIEW_TYPE_TABLEVIEW', value:'tableview'},
        {keey:'CHECKBOX_VIEW_TYPE_TOGGLEVIEW', value:'toggleview'},
        {keey:'CONTENT_ALIGN_BOTTOM_CENTER', value:'bottomcenter'},
        {keey:'CONTENT_ALIGN_BOTTOM_LEFT', value:'bottomleft'},
        {keey:'CONTENT_ALIGN_BOTTOM_RIGHT', value:'bottomright'},
        {keey:'CONTENT_ALIGN_MIDDLE_LEFT', value:'middleleft'},
        {keey:'CONTENT_ALIGN_MIDDLE_RIGHT', value:'middleright'},
        {keey:'CONTENT_ALIGN_TOP_CENTER', value:'topcenter'},
        {keey:'CONTENT_ALIGN_TOP_LEFT', value:'topleft'},
        {keey:'CONTENT_ALIGN_TOP_RIGHT', value:'topright'},
        {keey:'CONTENT_ALIGN_CENTER', value:'middlecenter'},
        {keey:'DATAGRID_COLUMN_TYPE_IMAGE', value:'image'},
        {keey:'DATAGRID_COLUMN_TYPE_TEMPLATE', value:'template'},
        {keey:'DATAGRID_COLUMN_TYPE_TEXT', value:'text'},
        {keey:'DATAGRID_SCROLLBAR_NONE', value:'none'},
        {keey:'DATAGRID_SCROLLBAR_VERTICAL', value:'vertical'},
        {keey:'DEVICE_ORIENTATION_LANDSCAPE', value:'landscape'},
        {keey:'DEVICE_ORIENTATION_PORTRAIT', value:'portrait'},
        {keey:'DEVICE_OSNAME_ANDROID', value:'android'},
        {keey:'DEVICE_OSNAME_ANDROIDTABLET', value:'androidtablet'},
        {keey:'DEVICE_OSNAME_IPHONE', value:'iPhone'},
        {keey:'DEVICE_OSNAME_IPAD', value:'iPad'},
        {keey:'DEVICE_OSNAME_MACINTOSH', value:'Macintosh'},
        {keey:'DEVICE_OSNAME_WINDOWS', value:'windows'},
        {keey:'DEVICE_OSNAME_WINDOWSTABLET', value:'windowstablet'},
        {keey:'DEVICE_OSNAME_WINDOWPHONE', value:'windowsphone'},
        {keey:'DEVICE_OSNAME_LINUX', value:'Linux'},
        {keey:'FILE_UPLOAD_COMPLETE_STATE', value:'complete'},
        {keey:'FILE_UPLOAD_ERROR_STATE', value:'error'},
        {keey:'FILE_UPLOAD_PROGRESS_STATE', value:'progress'},
        {keey:'FILE_UPLOAD_START_STATE', value:'start'},
        {keey:'FORM_ADJUST_RESIZE', value:'resize'},
        {keey:'FORM_ADJUST_PAN', value:'pan'},
        {keey:'FORM_DEVICE_ORIENTATION_LANDSCAPE', value:'landscape'},
        {keey:'FORM_DEVICE_ORIENTATION_PORTRAIT', value:'portrait'},
        {keey:'FORM_DISPLAY_ORIENTATION_BOTH', value:'both'},
        {keey:'FORM_DISPLAY_ORIENTATION_LANDSCAPE', value:'landscape'},
        {keey:'FORM_DISPLAY_ORIENTATION_PORTRAIT', value:'portrait'},
        {keey:'FORM_FORWARD_NAVIGATION', value:'forward'},
        {keey:'FORM_TYPE_DYNAMIC', value:'dynamic'},
        {keey:'FORM_TYPE_NATIVE', value:'native'},
        {keey:'FORM_TYPE_STATIC', value:'static'},
        {keey:'GESTURE_TYPE_LONGPRESS', value:'longpress'},
        {keey:'GESTURE_TYPE_PAN', value:'pan'},
        {keey:'GESTURE_TYPE_PINCH', value:'pinch'},
        {keey:'GESTURE_TYPE_ROTATION', value:'rotation'},
        {keey:'GESTURE_TYPE_SWIPE', value:'swipe'},
        {keey:'GESTURE_TYPE_TAP', value:'tap'},
        {keey:'HTTP_INTEGRITY_CHECK_FAILED', value:2},
        {keey:'HTTP_INTEGRITY_CHECK_NOT_DONE', value:0},
        {keey:'HTTP_INTEGRITY_CHECK_SUCCESSFUL', value:1},
        {keey:'HTTP_METHOD_GET', value:'get'},
        {keey:'HTTP_METHOD_POST', value:'post'},
        {keey:'HTTP_RESPONSE_TYPE_ARRAYBUFFER', value:'arraybuffer'},
        {keey:'HTTP_RESPONSE_TYPE_BLOB', value:'blob'},
        {keey:'HTTP_RESPONSE_TYPE_DOCUMENT', value:'document'},
        {keey:'HTTP_RESPONSE_TYPE_JSON', value:'json'},
        {keey:'HTTP_RESPONSE_TYPE_RAWDATA', value:'image/png'},
        {keey:'HTTP_RESPONSE_TYPE_TEXT', value:'text'},
        {keey:'HTTP_READY_STATE_DONE', value:'done'},
        {keey:'HTTP_READY_STATE_HEADERS_RECEIVED', value:'headersreceived'},
        {keey:'HTTP_READY_STATE_LOADING', value:'loading'},
        {keey:'HTTP_READY_STATE_OPENED', value:'opened'},
        {keey:'HTTP_READY_STATE_UNSENT', value:'unsent'},
        {keey:'IMAGE_GALLERY_VIEW_TYPE_PAGEVIEW', value:'pageview'},
        {keey:'IMAGE_GLOSSY_EFFECT_DEFAULT', value:'default'},
        {keey:'IMAGE_GLOSSY_EFFECT_LINEAR', value:'linear'},
        {keey:'IMAGE_GLOSSY_EFFECT_RADIAL', value:'radial'},
        {keey:'IMAGE_SCALE_MODE_CROP', value:'crop'},
        {keey:'IMAGE_SCALE_MODE_FIT_TO_DIMENSIONS', value:'fittodimensions'},
        {keey:'IMAGE_SCALE_MODE_MAINTAIN_ASPECT_RATIO', value:'maintainaspectratio'},
        {keey:'LISTBOX_VIEW_TYPE_EDITVIEW', value:'editableview'},
        {keey:'LISTBOX_VIEW_TYPE_LISTVIEW', value:'listview'},
        {keey:'LISTBOX_VIEW_TYPE_ONSCREENWHEEL', value:'onscreenwheel'},
        {keey:'LISTBOX_VIEW_TYPE_TABLEVIEW', value:'tableview'},
        {keey:'LISTBOX_VIEW_TYPE_TOGGLEVIEW', value:'toggleview'},
        {keey:'LISTBOX_VIEW_TYPE_SPINNER', value:'spinner'},
        {keey:'LOADING_SCREEN_POSITION_FULL_SCREEN', value:'fullscreen'},
        {keey:'LOADING_SCREEN_POSITION_ONLY_CENTER', value:'center'},
        {keey:'MAP_PROVIDER_GOOGLE', value:'google'},
        {keey:'MAP_SOURCE_NATIVE', value:'native'},
        {keey:'MAP_SOURCE_NON_NATIVE', value:'non-native'},
        {keey:'MAP_SOURCE_STATIC', value:'static'},
        {keey:'MAP_VIEW_MODE_HYBRID', value:'hybrid'},
        {keey:'MAP_VIEW_MODE_POLYGON', value:'polygon'},
        {keey:'MAP_VIEW_MODE_NORMAL', value:'normal'},
        {keey:'MAP_VIEW_MODE_SATELLITE', value:'satellite'},
        {keey:'MAP_VIEW_MODE_TERRAIN', value:'terrain'},
        {keey:'MAP_HEIGHT_BY_FORM_REFERENCE', value:'formreference'}, // form height
        {keey:'MAP_HEIGHT_BY_PARENT_WIDTH', value:'parentwidth'}, // ref to parent width
        {keey:'MASTER_TYPE_DEFAULT', value:'withoutcontract'},
        {keey:'MASTER_TYPE_USERWIDGET', value:'withcontract'},
        {keey:'NETWORK_TYPE_3G', value:'3G'},
        {keey:'NETWORK_TYPE_ANY', value:'ANY'},
        {keey:'NETWORK_TYPE_ETHERNET', value:'ETHERNET'},
        {keey:'NETWORK_TYPE_WIFI', value:'WIFI'},
        {keey:'ONHOVER_MOUSE_ENTER', value:'enter'},
        {keey:'ONHOVER_MOUSE_LEAVE', value:'leave'},
        {keey:'ONHOVER_MOUSE_MOVE', value:'move'},
        {keey:'OPEN_URL_SUCCESS', value:'success'},
        {keey:'OPEN_URL_FAILURE', value:'failure'},
        {keey:'OPEN_URL_UNKNOWN', value:'unknown'},
        {keey:'PRINTSTUB', value:'@printlevel'},
        {keey:'RADIOGROUP_ITEM_ORIENTATION_HORIZONTAL', value:'horizontal'},
        {keey:'RADIOGROUP_ITEM_ORIENTATION_VERTICAL', value:'vertical'},
        {keey:'RADIOBUTTON_VIEW_TYPE_CUSTOMVIEW', value:'customview'},
        {keey:'RADIOBUTTON_VIEW_TYPE_DEFAULTTVIEW', value:'defaultview'},
        {keey:'SEGUI_DEFAULT_BEHAVIOR', value:'default'},
        {keey:'SEGUI_MULTI_SELECT_BEHAVIOR', value:'multiselect'},
        {keey:'SEGUI_SCROLL_POSITION_DEFAULT', value:'default'},
        {keey:'SEGUI_SCROLL_POSITION_RETAIN', value:'retain'},
        {keey:'SEGUI_SCROLL_POSITION_TOP', value:'top'},
        {keey:'SEGUI_SEARCH_CRITERIA_CONTAINS', value:'CONTAINS'},
        {keey:'SEGUI_SEARCH_CRITERIA_ENDSWITH', value:'ENDSWITH'},
        {keey:'SEGUI_SEARCH_CRITERIA_GREATER', value:'GREATER'},
        {keey:'SEGUI_SEARCH_CRITERIA_GREATER_EQUAL', value:'GREATER_EQUAL'},
        {keey:'SEGUI_SEARCH_CRITERIA_LESSER', value:'LESSER'},
        {keey:'SEGUI_SEARCH_CRITERIA_LESSER_EQUAL', value:'LESSER_EQUAL'},
        {keey:'SEGUI_SEARCH_CRITERIA_NOT_CONTAINS', value:'NOT_CONTAINS'},
        {keey:'SEGUI_SEARCH_CRITERIA_NOT_EQUAL', value:'NOT_EQUAL'},
        {keey:'SEGUI_SEARCH_CRITERIA_NOT_ENDSWITH', value:'NOT_ENDSWITH'},
        {keey:'SEGUI_SEARCH_CRITERIA_NOT_STARTSWITH', value:'NOT_STARTSWITH'},
        {keey:'SEGUI_SEARCH_CRITERIA_OPERATOR_AND', value:'AND'},
        {keey:'SEGUI_SEARCH_CRITERIA_OPERATOR_OR', value:'OR'},
        {keey:'SEGUI_SEARCH_CRITERIA_STARTSWITH', value:'STARTSWITH'},
        {keey:'SEGUI_SEARCH_CRITERIA_STRICT_EQUAL', value:'STRICT_EQUAL'},
        {keey:'SEGUI_SINGLE_SELECT_BEHAVIOR', value:'singleselect'},
        {keey:'SEGUI_VIEW_TYPE_PAGEVIEW', value:'pageview'},
        {keey:'SEGUI_VIEW_TYPE_TABLEVIEW', value:'tableview'},
        {keey:'SLIDER_HORIZONTAL_ORIENTATION', value:'horizontal'},
        {keey:'SLIDER_VERTICAL_ORIENTATION', value:'vertical'},
        {keey:'SLIDER_VIEW_TYPE_DEFAULT', value:'default'},
        {keey:'SLIDER_VIEW_TYPE_PROGRESS', value:'progress'},
        {keey:'TAB_HEADER_POSITION_BOTTOM', value:'bottom'},
        {keey:'TAB_HEADER_POSITION_LEFT', value:'left'},
        {keey:'TAB_HEADER_POSITION_RIGHT', value:'right'},
        {keey:'TAB_HEADER_POSITION_TOP', value:'top'},
        {keey:'TABPANE_COLLAPSIBLE_IMAGE_POSITION_LEFT', value:'left'},
        {keey:'TABPANE_COLLAPSIBLE_IMAGE_POSITION_RIGHT', value:'right'},
        {keey:'TABPANE_COLLAPSIBLE_TABNAME_ALIGNMENT_CENTER', value:'center'},
        {keey:'TABPANE_COLLAPSIBLE_TABNAME_ALIGNMENT_LEFT', value:'left'},
        {keey:'TABPANE_COLLAPSIBLE_TABNAME_ALIGNMENT_RIGHT', value:'right'},
        {keey:'TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW', value:'collapsibleview'},
        {keey:'TABPANE_VIEW_TYPE_PAGEVIEW', value:'pageview'},
        {keey:'TABPANE_VIEW_TYPE_TABVIEW', value:'tabview'},
        {keey:'TEXTBOX_AUTO_CAPITALIZE_ALL', value:'characters'},
        {keey:'TEXTBOX_AUTO_CAPITALIZE_NONE', value:'none'},
        {keey:'TEXTBOX_AUTO_CAPITALIZE_SENTENCES', value:'sentences'},
        {keey:'TEXTBOX_AUTO_CAPITALIZE_WORDS', value:'words'},
        {keey:'TEXTBOX_CUSTOM_HEIGHT', value:'custom'},
        {keey:'TEXTBOX_DEFAULT_PLATFORM_HEIGHT', value:'default'},
        {keey:'TEXTBOX_FONT_METRICS_DRIVEN_HEIGHT', value:'fontmetrics'},
        {keey:'TEXTBOX_INPUT_MODE_ANY', value:'any'},
        {keey:'TEXTBOX_INPUT_MODE_NUMERIC', value:'numeric'},
        {keey:'TEXTBOX_INPUT_MODE_PASSWORD', value:'password'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_CHAT', value:'chat'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_DECIMAL', value:'decimal'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_DEFAULT', value:'text'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_EMAIL', value:'email'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_NONE', value:'none'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_NUMBER_PAD', value:'numeric'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_PHONE_PAD', value:'tel'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_SEARCH', value:'search'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_URL', value:'url'},
        {keey:'TEXTBOX_VIEW_TYPE_DEFAULT', value:'default'},
        {keey:'TEXTBOX_VIEW_TYPE_SEARCH_VIEW', value:'search'},
        {keey:'TEXTAREA_INPUT_MODE_ANY', value:'any'},
        {keey:'TEXTAREA_INPUT_MODE_NUMERIC', value:'numeric'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_CHAT', value:'chat'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_DECIMAL', value:'decimal'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_DEFAULT', value:'text'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_EMAIL', value:'email'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_NONE', value:'none'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_NUMBER_PAD', value:'numeric'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_PHONE_PAD', value:'tel'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_SEARCH', value:'search'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_URL', value:'url'},
        {keey:'TEXTAREA_AUTO_CAPITALIZE_ALL', value:'characters'},
        {keey:'TEXTAREA_AUTO_CAPITALIZE_NONE', value:'none'},
        {keey:'TEXTAREA_AUTO_CAPITALIZE_SENTENCES', value:'sentences'},
        {keey:'TEXTAREA_AUTO_CAPITALIZE_WORDS', value:'words'},
        {keey:'UPLOAD_MAX_WAIT_TIME', value:120000}, // 2 mins
        {keey:'WIDGET_ALIGN_BOTTOM_CENTER', value:'bottomcenter'},
        {keey:'WIDGET_ALIGN_BOTTOM_LEFT', value:'bottomleft'},
        {keey:'WIDGET_ALIGN_BOTTOM_RIGHT', value:'bottomright'},
        {keey:'WIDGET_ALIGN_CENTER', value:'middlecenter'},
        {keey:'WIDGET_ALIGN_MIDDLE_LEFT', value:'middleleft'},
        {keey:'WIDGET_ALIGN_MIDDLE_RIGHT', value:'middleright'},
        {keey:'WIDGET_ALIGN_TOP_CENTER', value:'topcenter'},
        {keey:'WIDGET_ALIGN_TOP_LEFT', value:'topleft'},
        {keey:'WIDGET_ALIGN_TOP_RIGHT', value:'topright'},
        {keey:'WIDGET_DIRECTION_LTR', value:'ltr'},
        {keey:'WIDGET_DIRECTION_RTL', value:'rtl'}
    ]);

    return _ns;
}())});

Object.defineProperty(voltmx, 'anim', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    $K.defVoltmxProp(_ns, [
        {keey:'DIRECTION_ALTERNATE', value:'alternate'},
        {keey:'DIRECTION_ALTERNATE_REVERSE', value:'alternate-reverse'},
        {keey:'DIRECTION_NONE', value:'normal'},
        {keey:'DIRECTION_REVERSE', value:'reverse'},
        {keey:'EASE', value:'ease'},
        {keey:'EASE_IN', value:'ease-in'},
        {keey:'EASE_IN_OUT', value:'ease-in-out'},
        {keey:'EASE_OUT', value:'ease-out'},
        {keey:'FILL_MODE_BACKWARDS', value:'backwards'},
        {keey:'FILL_MODE_BOTH', value:'both'},
        {keey:'FILL_MODE_FORWARDS', value:'forwards'},
        {keey:'FILL_MODE_NONE', value:'none'},
        {keey:'LINEAR', value:'linear'}
    ]);

    return _ns;
}())});


Object.defineProperty(voltmx, 'calendar', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    $K.defVoltmxProp(_ns, [
        {keey:'LEGACY', value:'legacy'},
        {keey:'MODERN', value:'modern'}
    ]);

    return _ns;
}())});

Object.defineProperty(voltmx, 'canvas', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    $K.defVoltmxProp(_ns, [
        {keey:'SHAPE_TYPE_LINE', value:'line'},
        {keey:'LINE_STYLE_SOLID', value:'solidline'},
        {keey:'LINE_STYLE_DASHED', value:'dashedline'},
        {keey:'LINE_STYLE_DOTTED', value:'dottedline'}
    ]);

    return _ns;
}())});

Object.defineProperty(voltmx, 'collectionview', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    $K.defVoltmxProp(_ns, [
        {keey:'LAYOUT_CUSTOM', value:'custom'},
        {keey:'LAYOUT_HORIZONTAL', value:'horizontal'},
        {keey:'LAYOUT_VERTICAL', value:'vertical'},
        {keey:'MULTI_SELECT', value:'multiselect'},
        {keey:'SCROLL_DIRECTION_BOTH', value:'both'},
        {keey:'SCROLL_DIRECTION_HORIZONTAL', value:'horizontal'},
        {keey:'SCROLL_DIRECTION_VERTICAL', value:'vertical'},
        {keey:'SINGLE_SELECT', value:'singleselect'}
    ]);

    return _ns;
}())});


Object.defineProperty(voltmx, 'flex', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    $K.defVoltmxProp(_ns, [
        {keey:'AUTOGROW_HEIGHT', value:'height'},
        {keey:'AUTOGROW_NONE', value:'none'},
        {keey:'DEFAULT_UNIT', value:'%'},
        {keey:'DP', value:'dp'},
        {keey:'FLOW_HORIZONTAL', value:'hflex'},
        {keey:'FLOW_VERTICAL', value:'vflex'},
        {keey:'FREE_FORM', value:'fflex'},
        {keey:'PERCENTAGE', value:'%'},
        {keey:'PX', value:'px'},
        {keey:'RESPONSIVE_GRID', value:'rflex'},
        {keey:'SCROLL_BOTH', value:'both'},
        {keey:'SCROLL_HORIZONTAL', value:'horizontal'},
        {keey:'SCROLL_NONE', value:'none'},
        {keey:'SCROLL_VERTICAL', value:'vertical'},
        {keey:'USE_AVAILABLE_SPACE', value:'available'},
        {keey:'USE_PREFERRED_SIZE', value:''},
        {keey:'ZINDEX_AUTO', value:'auto'}
    ]);

    return _ns;
}())});


Object.defineProperty(voltmx, 'map', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    $K.defVoltmxProp(_ns, [
        {keey:'PIN_IMG_ANCHOR_BOTTOM_CENTER', value:'bottomcenter'},
        {keey:'PIN_IMG_ANCHOR_BOTTOM_LEFT', value:'bottomleft'},
        {keey:'PIN_IMG_ANCHOR_BOTTOM_RIGHT', value:'bottomright'},
        {keey:'PIN_IMG_ANCHOR_CENTER', value:'middlecenter'},
        {keey:'PIN_IMG_ANCHOR_MIDDLE_LEFT', value:'middleleft'},
        {keey:'PIN_IMG_ANCHOR_MIDDLE_RIGHT', value:'middleright'},
        {keey:'PIN_IMG_ANCHOR_TOP_CENTER', value:'topcenter'},
        {keey:'PIN_IMG_ANCHOR_TOP_LEFT', value:'topleft'},
        {keey:'PIN_IMG_ANCHOR_TOP_RIGHT', value:'topright'},
        {keey:'MAP_PROVIDER_GOOGLE', value:'google'},
        {keey:'MAP_VIEW_MODE_NORMAL', value:'normal'},
        {keey:'MAP_VIEW_MODE_SATELLITE', value:'satellite'}
    ]);

    return _ns;
}())});


Object.defineProperty(voltmx, 'segment', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    $K.defVoltmxProp(_ns, [
        {keey:'ADD', value:'add'},
        {keey:'INVISIBLE', value:'invisible'},
        {keey:'REMOVE', value:'remove'},
        {keey:'UPDATE', value:'update'},
        {keey:'VISIBLE', value:'visible'}
    ]);

    return _ns;
}())});


Object.defineProperty(voltmx, 'skin', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    $K.defVoltmxProp(_ns, [
        {keey:'BACKGROUND_TYPE_IMAGE', value:'bgimage'},
        {keey:'BACKGROUND_TYPE_MULTI_STEP_GRADIENT', value:'bgmsgradient'},
        {keey:'BACKGROUND_TYPE_SINGLE_COLOR', value:'bgsinglecolor'},
        {keey:'BACKGROUND_TYPE_TWO_STEP_GRADIENT', value:'bgtwostepgradient'},
        {keey:'BORDER_TYPE_MULTI_STEP_GRADIENT', value:'bordermsgradient'},
        {keey:'BORDER_TYPE_SINGLE_COLOR', value:'bordersinglecolor'},
        {keey:'BORDER_STYLE_COMPLETE_ROUNDED_CORNER', value:'borderstylecompleteroundedcorner'},
        {keey:'BORDER_STYLE_CUSTOM', value:'borderstylecustom'},
        {keey:'BORDER_STYLE_PLAIN', value:'borderstyleplain'},
        {keey:'BORDER_STYLE_ROUNDED_CORNER', value:'borderstyleroundedcorner'},
        {keey:'FONT_STYLE_ITALIC', value:'italic'},
        {keey:'FONT_STYLE_NONE', value:'normal'},
        {keey:'FONT_STYLE_UNDERLINE', value:'underline'},
        {keey:'FONT_WEIGHT_BOLD', value:'bold'},
        {keey:'FONT_WEIGHT_NORMAL', value:'normal'},
        {keey:'MULTI_STEP_GRADIENT_TYPE_CUSTOM', value:'msgradientcustom'},
        {keey:'MULTI_STEP_GRADIENT_TYPE_TO_BOTTOM', value:'msgradientbottom'},
        {keey:'MULTI_STEP_GRADIENT_TYPE_TO_LEFT', value:'msgradientleft'},
        {keey:'MULTI_STEP_GRADIENT_TYPE_TO_RIGHT', value:'msgradientright'},
        {keey:'MULTI_STEP_GRADIENT_TYPE_TO_TOP', value:'msgradienttop'},
        {keey:'TWO_STEP_GRADIENT_STYLE_HORIZONTAL_GRADIENT', value:'hg'},
        {keey:'TWO_STEP_GRADIENT_STYLE_HORIZONTAL_SPLIT', value:'hs'},
        {keey:'TWO_STEP_GRADIENT_STYLE_VERTICAL_GRADIENT', value:'vg'},
        {keey:'TWO_STEP_GRADIENT_STYLE_VERTICAL_SPLIT', value:'vs'}
    ]);

    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxcrypto.js' */
/* global CryptoJS */
Object.defineProperty(voltmx, 'crypto', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;


    var _createHash = function(algo, str, options) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, msg = '';

        $KU.log({api:'voltmx.crypto.createHash', enter:true});

        if(!$KU.is(str, 'string')) {
            return {
                errcode: 100,
                errmessage: 'invalid input parameters'
            };
        }

        try {
            if ($K.behavior.strictMode) {
                switch(algo.toLowerCase()) {
                    case 'sha256':
                        msg = CryptoJS.SHA256(str);
                        break;
                    case 'sha512':
                        msg = CryptoJS.SHA512(str);
                        break;
                    default:
                        msg = {
                            errcode: 101,
                            errmessage: 'unsupported algorithm'
                        };
                        break;
                    }
            }else{
                switch(algo.toLowerCase()) {
                    case 'md5':
                        msg = CryptoJS.MD5(str);
                        break;
                    case 'sha256':
                        msg = CryptoJS.SHA256(str);
                        break;
                    case 'sha1':
                        msg = CryptoJS.SHA1(str);
                        break;
                    case 'sha512':
                        msg = CryptoJS.SHA512(str);
                        break;
                    default:
                        msg = {
                            errcode: 101,
                            errmessage: 'unsupported algorithm'
                        };
                        break;
                    }
            }

            if(!$KU.is(msg, 'string')) {
                if($KU.is(options, 'object')) {
                    if(options.returnBase64String === 'true') {
                        msg = msg.toString(CryptoJS.enc.Base64);
                    } else {
                        msg = msg.toString(CryptoJS.enc.UTF8);
                    }
                } else {
                    msg = msg.toString(CryptoJS.enc.UTF8);
                }
            }

            $KU.log({api:'voltmx.crypto.createHash', exit:true});

            return msg;
        } catch(ex) {
            return {
                errcode: 102,
                errmessage: 'unknown  error'
            };
        }
    };

    var _createHashToUpperCase = function(algo, str) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            hashValueToUpperCase = _createHash(algo, str);

        if($KU.is(hashValueToUpperCase, 'string')) {
            hashValueToUpperCase = hashValueToUpperCase.toUpperCase();
        }

        return hashValueToUpperCase;
    };

    var _createPBKDF2Key = function(algo, password, salt, iteration, klen) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, key, hashFun;

        $KU.log({api:'voltmx.crypto._createPBKDF2Key', enter:true});

        if(!$KU.is(password, 'string')) {
            return {
                errcode: 100,
                errmessage: 'invalid input parameters'
            };
        }

        try {
            if ($K.behavior.strictMode) {
                switch(algo.toLowerCase()) {
                    case 'sha256':
                        hashFun = CryptoJS.algo.SHA256;
                        break;
                    case 'sha512':
                        hashFun = CryptoJS.algo.SHA512;
                        break;
                    default:
                        break;
                    }
            }else{
                switch(algo.toLowerCase()) {
                    case 'md5':
                        hashFun = CryptoJS.algo.MD5;
                        break;
                    case 'sha256':
                        hashFun = CryptoJS.algo.SHA256;
                        break;
                    case 'sha1':
                        hashFun = CryptoJS.algo.SHA1;
                        break;
                    case 'sha512':
                        hashFun = CryptoJS.algo.SHA512;
                        break;
                    default:
                        break;
                }
            }

            if(hashFun) {
                klen = klen ? klen/32 : 256/32;
                key = CryptoJS.PBKDF2(password, salt, {keySize: klen, iterations: iteration, hasher: hashFun});
                return key.toString();
            }

            $KU.log({api:'voltmx.crypto.createPBKDF2Key', exit:true});

            return {
                errcode: 101,
                errmessage: 'unsupported  algo'
            };
        } catch(err) {
            return {
                errcode: 102,
                errmessage: 'unknown  error'
            };
        }
    };

    var _decrypt = function(algo, generatedkey, encryptedRawbytes, propertiesTable) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            mode = CryptoJS.mode.CBC, msg = '',
            padding = CryptoJS.pad.Pkcs7;

        $KU.log({api:'voltmx.crypto.decrypt', enter:true});

        if(!$KU.is(algo, 'string') && encryptedRawbytes && generatedkey) {
            $KU.log({api:'voltmx.crypto.decrypt', exit:true});

            return {
                errcode: 100,
                errmessage: 'invalid input parameters'
            };
        }

        try{
            if(propertiesTable) {
                if(propertiesTable.mode) {
                    switch(propertiesTable.mode.toLowerCase()) {
                        case 'cfb':
                            mode = CryptoJS.mode.CFB;
                            break;
                        case 'ctr':
                            mode = CryptoJS.mode.CTR;
                            break;
                        case 'ofb':
                            mode = CryptoJS.mode.OFB;
                            break;
                        case 'ecb':
                            mode = CryptoJS.mode.ECB;
                            break;
                        default:
                            break;
                    }
                }

                if(propertiesTable.padding) {
                    switch(propertiesTable.padding.toLowerCase()) {
                        case 'iso97971':
                            padding = CryptoJS.pad.Iso97971;
                            break;
                        case 'iso10126':
                            padding = CryptoJS.pad.Iso10126;
                            break;
                        case 'zeropadding':
                            padding = CryptoJS.pad.ZeroPadding;
                            break;
                        case 'nopadding':
                            padding = CryptoJS.pad.NoPadding;
                            break;
                        default:
                            break;
                    }
                }
            }

            encryptedRawbytes = _parse(encryptedRawbytes);

            if(algo.toLowerCase() === 'aes') {
                msg = CryptoJS.AES.decrypt(encryptedRawbytes, generatedkey, {
                    mode: mode,
                    padding: padding
                });

                $KU.log({api:'voltmx.crypto.decrypt', exit:true});

                return msg.toString(CryptoJS.enc.Utf8);
            } else if(algo.toLowerCase() === 'tripledes') {
                msg = CryptoJS.TripleDES.decrypt(
                    encryptedRawbytes,
                    generatedkey, {
                        mode: mode,
                        padding: padding
                    }
                );

                $KU.log({api:'voltmx.crypto.decrypt', exit:true});

                return msg.toString(CryptoJS.enc.Utf8);
            }
            $KU.log({api:'voltmx.crypto.decrypt', exit:true});

            return {
                errcode: 101,
                errmessage: 'unsupported algorithm'
            };
        } catch(err) {
            return {
                errcode: 102,
                errmessage: 'unknown  error'
            };
        }
    };


    var _deleteKey = function(uid) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, store = $K.store;

        $KU.log({api:'voltmx.crypto.deleteKey', enter:true});
        store.remove('local', uid);
        $KU.log({api:'voltmx.crypto.deleteKey', exit:true});
    };


    var _encrypt = function(algo, generatedkey, str, propertiesTable) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, mode = CryptoJS.mode.CBC,
            encryptedObj = null, padding = CryptoJS.pad.Pkcs7;

        $KU.log({api:'voltmx.crypto.createHash', enter:true});

        if(!$KU.is(algo, 'string') && str && generatedkey) {
            $KU.log({api:'voltmx.crypto.encrypt', exit:true});

            return {
                errcode: 100,
                errmessage: 'invalid input parameters'
            };
        }

        try{
            if(propertiesTable) {
                if(propertiesTable.mode) {
                    switch(propertiesTable.mode.toLowerCase()) {
                        case 'cfb':
                            mode = CryptoJS.mode.CFB;
                            break;
                        case 'ctr':
                            mode = CryptoJS.mode.CTR;
                            break;
                        case 'ofb':
                            mode = CryptoJS.mode.OFB;
                            break;
                        case 'ecb':
                            mode = CryptoJS.mode.ECB;
                            break;
                        default:
                            break;
                    }
                }

                if(propertiesTable.padding) {
                    switch(propertiesTable.padding.toLowerCase()) {
                        case 'iso97971':
                            padding = CryptoJS.pad.Iso97971;
                            break;
                        case 'iso10126':
                            padding = CryptoJS.pad.Iso10126;
                            break;
                        case 'zeropadding':
                            padding = CryptoJS.pad.ZeroPadding;
                            break;
                        case 'nopadding':
                            padding = CryptoJS.pad.NoPadding;
                            break;
                        default:
                            break;
                    }
                }
            }

            if(algo.toLowerCase() === 'aes') {
                encryptedObj = CryptoJS.AES.encrypt(str, generatedkey, {
                    mode: mode,
                    padding: padding
                });

                $KU.log({api:'voltmx.crypto.encrypt', exit:true});

                return _stringify(encryptedObj);
            } else if(algo.toLowerCase() === 'tripledes') {
                encryptedObj = CryptoJS.TripleDES.encrypt(str, generatedkey, {
                    mode: mode,
                    padding: padding,
                    format: _jsonFormatter
                });

                $KU.log({api:'voltmx.crypto.encrypt', exit:true});

                return _stringify(encryptedObj);
            }
            $KU.log({api:'voltmx.crypto.encrypt', exit:true});

            return {
                errcode: 101,
                errmessage: 'unsupported algorithm'
            };
        } catch(ex) {
            return {
                errcode: 102,
                errmessage: 'unknown  error'
            };
        }
    };


    var _generateRandomNumber = function(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);

        return Math.floor(Math.random() * (max - min + 1)) + min;
    };


    var _generateRandomString = function() {
        var possibleString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
            randomLength = _generateRandomNumber(8, 16), i = 0,
            possibleLength = possibleString.length, randomString = '';

        for(i=0; i< randomLength; i++) {
            randomString += possibleString.charAt(Math.floor(Math.random() * possibleLength));
        }

        return randomString.toUpperCase();
    };


    var _generateSecureRandom = function(config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, salt = null;

        if(!$KU.is(config, 'object')) {
            config = {type:'base64', size:36};
        } else {
            if(['base64'].indexOf(config.type) === -1) {
                config.type = 'base64';
            }

            if(!$KU.is(config.size, 'integer') || config.size < 0) {
                config.size = 36;
            }
        }

        salt = CryptoJS.lib.WordArray.random(config.size);

        return (config.type === 'base64')
            ? salt.toString(CryptoJS.enc.Base64)
            : salt.toString(CryptoJS.enc.Hex);
    };


    var _jsonFormatter = function() {
        //Not available in SPA repo too. Ask Shankar about it.
    };


    var _newKey = function(algo, keystrength, algoObject) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.crypto.newKey', enter:true});

        try{
            if(algo !== 'passphrase') {
                $KU.log({api:'voltmx.crypto.newKey', exit:true});

                return {
                    errcode: 100,
                    errmessage: 'invalid input parameters'
                };
            } else if(!algoObject.subalgo) {
                $KU.log({api:'voltmx.crypto.newKey', exit:true});

                return {
                    errcode: 105,
                    errmessage: 'subalgo parameter is missing'
                };
            }
            if(algoObject.subalgo.toLowerCase() === 'aes'
            || algoObject.subalgo.toLowerCase() === 'tripledes') {
                $KU.log({api:'voltmx.crypto.newKey', exit:true});

                return algoObject.passphrasetext[0];
            }
            $KU.log({api:'voltmx.crypto.newKey', exit:true});

            return {
                errcode: 101,
                errmessage: 'unsupported algorithm'
            };
        } catch(ex) {
            return {
                errcode: 102,
                errmessage: 'unknown error'
            };
        }
    };


    var _parse = function(str) {
        var json = JSON.parse(str), cipher = null;

        //Extract ciphertext from json object, and create cipher params object
        cipher = CryptoJS.lib.CipherParams.create({
            ciphertext: CryptoJS.enc.Base64.parse(json.ct)
        });

        // optionally extract iv and salt
        if(json.iv) {
            cipher.iv = CryptoJS.enc.Hex.parse(json.iv);
        }

        if(json.s) {
            cipher.salt = CryptoJS.enc.Hex.parse(json.s);
        }

        return cipher;
    };


    var _readKey = function(uid) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            store = $K.store, dataobj = null;

        $KU.log({api:'voltmx.crypto.readKey', enter:true});

        if($KU.is(uid, 'undefined')) {
            $KU.log({api:'voltmx.crypto.readKey', enter:true});

            return {
                errcode: 100,
                errmsg: 'Invalid input parameters'
            };
        }

        try{
            if(localStorage) {
                dataobj = JSON.parse(store.fetch('local', uid) || 'null');

                if(dataobj === null) {
                    $KU.log({api:'voltmx.crypto.readKey', exit:true});

                    return {
                        errcode: 101,
                        errmsg: 'unable to find the key with the specified unique ID'
                    };
                }
                $KU.log({api:'voltmx.crypto.readKey', exit:true});

                return dataobj;
            }
            $KU.log({api:'voltmx.crypto.readKey', exit:true});

            return {
                errcode: 102,
                errmsg: 'unknown error, storage not supported'
            };
        } catch(err) {
            //
        }
    };


    var _saveKey = function(name, key) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, store = $K.store;

        $KU.log({api:'voltmx.crypto.saveKey', enter:true});

        if($KU.is(name, 'undefined') || $KU.is(key, 'undefined')) {
            $KU.log({api:'voltmx.crypto.saveKey', exit:true});

            return {
                errcode: 100,
                errmsg: 'Invalid input parameters'
            };
        }

        store.put('local', name, JSON.stringify(key));
        $KU.log({api:'voltmx.crypto.saveKey', exit:true});
        return name;
    };


    var _stringify = function(obj) {
        // create json object with ciphertext
        var jsonObj = {
            ct: obj.ciphertext.toString(CryptoJS.enc.Base64)
        };

        // optionally add iv and salt
        if(obj.iv) {
            jsonObj.iv = obj.iv.toString();
        }

        if(obj.salt) {
            jsonObj.s = obj.salt.toString();
        }

        // stringify json object
        return JSON.stringify(jsonObj);
    };


    $K.defVoltmxProp(_ns, [
        {keey:'createHash', value:_createHash},
        {keey:'createHashToUpperCase', value:_createHashToUpperCase},
        {keey:'createPBKDF2Key', value:_createPBKDF2Key},
        {keey:'decrypt', value:_decrypt},
        {keey:'deleteKey', value:_deleteKey},
        {keey:'encrypt', value:_encrypt},
        {keey:'generateRandomNumber', value:_generateRandomNumber},
        {keey:'generateRandomString', value:_generateRandomString},
        {keey:'generateSecureRandom', value:_generateSecureRandom},
        {keey:'newKey', value:_newKey},
        {keey:'readKey', value:_readKey},
        {keey:'saveKey', value:_saveKey}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxdb.js' */
Object.defineProperty(voltmx, 'db', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;


    var _changeVersion = function(db, oldver, newver, transcb, ecb, vcb) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.db.changeVersion', enter:true});

        if(window.openDatabase) {
            db && db.changeVersion(oldver, newver, transcb, ecb, vcb);
            $KU.log({api:'voltmx.db.changeVersion', exit:true});
        } else {
            voltmx.print('Web Databases not supported.');
        }
    };


    var _executeSql = function(transid, sqlstmt, args, scb, ecb) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.db.executeSql', enter:true});

        if(window.openDatabase) {
            if(transid) {
                if(args && args[0] === null) {
                    args = args.slice(1);
                }

                transid.executeSql(sqlstmt, args, scb, ecb);
            }

            $KU.log({api:'voltmx.db.executeSql', exit:true});
        } else {
            voltmx.print('Web Databases not supported.');
        }
    };


    var _openDatabase = function(name, version, dname, size, cb) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, db = this.db || null;

        $KU.log({api:'voltmx.db.openDatabase', enter:true});

        if(!$KU.is(cb, 'function')) {
            cb = function() {};
        }

        try{
            if(window.openDatabase) {
                if(!db) {
                    db = openDatabase(name, version, dname, size, cb);
                    this.db = db;
                }

                $KU.log({api:'voltmx.db.openDatabase', exit:true});
            } else {
                voltmx.print('Web Databases not supported.');
            }
        } catch(e) {
            if(e === 2) {
                // Version number mismatch.
                voltmx.print('opendatabase:Invalid database version.');
            } else {
                voltmx.print('opendatabase:Unknown error ' + e + '.');
            }

            return null;
        }

        return db;
    };


    var _readTransaction = function(db, transcb, ecb, vcb) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.db.readTransaction', enter:true});

        if(window.openDatabase) {
            db && db.readTransaction(transcb, ecb, vcb);
            $KU.log({api:'voltmx.db.readTransaction', exit:true});
        } else {
            voltmx.print('Web Databases not supported.');
        }
    };


    var _sqlResultsetRowItem = function(transid, sqlresultset, index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, item = null;

        $KU.log({api:'voltmx.db.sqlResultsetRowItem', enter:true});

        if(window.openDatabase) {
            if(index < sqlresultset.rows.length) {
                item = sqlresultset.rows.item(index);
            }
        } else {
            voltmx.print('Web Databases not supported.');
        }

        $KU.log({api:'voltmx.db.sqlResultsetRowItem', exit:true});
        return item;
    };


    var _transaction = function(db, transcb, ecb, vcb) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.db.transaction', enter:true});

        if(window.openDatabase) {
            db && db.transaction(transcb, ecb, vcb);
            $KU.log({api:'voltmx.db.transaction', exit:true});
        } else {
            voltmx.print('Web Databases not supported.');
        }
    };


    $K.defVoltmxProp(_ns, [
        {keey:'changeVersion', value:_changeVersion},
        {keey:'executeSql', value:_executeSql},
        {keey:'openDatabase', value:_openDatabase},
        {keey:'readTransaction', value:_readTransaction},
        {keey:'sqlResultsetRowItem', value:_sqlResultsetRowItem},
        {keey:'transaction', value:_transaction}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxds.js' */
(function() {
    var _clean = function(namespace, arg1) {
        var $K = voltmx.$kwebfw$, $KA = $K.app,
            $KU = $K.utils, store = $KU.getLocalStorage();

        if($KU.is(store, 'object') && store.migrated === true) {
            if(arg1 === true) {
                store[namespace] = [];
            } else if(store.ns[namespace]
            && store.ns[namespace].length) {
                store.ns[namespace] = [];
            }

            $K.store.put('local', $KA.id, JSON.stringify(store));
        } else {
            $K.store.clear('local'); //For backward compatibility
            $K.store.put('local', $KA.id, JSON.stringify($KU.createBlankLocalStorage()));
        }
    };


    var _delete = function(key, namespace, arg2) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, data = null,
            store = $KU.getLocalStorage(), i = 0, index = -1, len = 0;

        if(arg2 === true) {
            data = store[namespace];
        } else {
            data = store.ns[namespace];
        }

        if($KU.is(data, 'array')) {
            len = data.length;

            for(i = 0; i < len; i++) {
                if(data[i].key === key) {
                    index = i;
                    break;
                }
            }
        }

        if(index >= 0) {
            data.splice(index, 1);
            $K.store.put('local', $KA.id, JSON.stringify(store));
        }
    };


    var _fetch = function(key, namespace, arg2) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            store = $KU.getLocalStorage(), i = 0,
            len = 0, item = null, data = null;

        if(arg2 === true) {
            data = store[namespace];
        } else {
            data = store.ns[namespace];
        }

        if($KU.is(data, 'array')) {
            len = data.length;

            for(i = 0; i < len; i++) {
                if(data[i].key === key) {
                    item = data[i].value;
                    break;
                }
            }
        }

        return item;
    };


    var _getLength = function(namespace, arg1) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            store = $KU.getLocalStorage(), data = null;

        if(arg1 === true) {
            data = store[namespace];
        } else {
            data = store.ns[namespace];
        }

        return ($KU.is(data, 'array')) ? data.length : 0;
    };


    var _keyAt = function(index, namespace, arg2) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            store = $KU.getLocalStorage(), data = null;

        if(arg2 === true) {
            data = store[namespace];
        } else {
            data = store.ns[namespace];
        }

        if($KU.is(data, 'array')) data = data[index];

        return (data) ? data.key : null;
    };


    var _put = function(key, value, namespace, arg3) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, data = null,
            store = $KU.getLocalStorage(), i = 0, index = -1, len = 0;

        if(arg3 === true) {
            data = store[namespace];
        } else {
            if(!$KU.is(store.ns[namespace], 'array')) {
                store.ns[namespace] = [];
            }

            data = store.ns[namespace];
        }

        if($KU.is(data, 'array')) {
            len = data.length;

            for(i = 0; i < len; i++) {
                if(data[i].key === key) {
                    index = i;
                    break;
                }
            }

            if(index === -1) { //New key
                data.push({
                    key: key,
                    value: value
                });
            } else { //Existing key
                data[index].value = value;
            }

            $K.store.put('local', $KA.id, JSON.stringify(store));
        }
    };


    Object.defineProperty(voltmx, 'ds', {configurable:false, enumerable:false, writable:false, value:(function() {
        var _ns = {}, $K = voltmx.$kwebfw$;


        var _read = function(name, storeContext) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'voltmx.ds.read', enter:true});

            if(typeof storeContext === 'string' && storeContext) {
                $KU.log({api:'voltmx.ds.read', exit:true});
                return _fetch(name, storeContext);
            }
            $KU.log({api:'voltmx.ds.read', exit:true});
            return _fetch(name, 'ds', true);
        };


        var _remove = function(name, storeContext) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'voltmx.ds.remove', enter:true});

            if(typeof storeContext === 'string' && storeContext) {
                _delete(name, storeContext);
            } else {
                _delete(name, 'ds', true);
            }

            $KU.log({api:'voltmx.ds.remove', exit:true});

            return true;
        };


        var _save = function(inputtable, name, metainfo /*, storeContext*/) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'voltmx.ds.save', enter:true});

            if(typeof metainfo === 'string' && metainfo) {
                _put(name, inputtable, metainfo);
            } else if(arguments.length === 2
            || (typeof metainfo === 'object' && metainfo)) {
                _put(name, inputtable, 'ds', true);
            }

            $KU.log({api:'voltmx.ds.save', exit:true});
        };


        $K.defVoltmxProp(_ns, [
            {keey:'read', value:_read},
            {keey:'remove', value:_remove},
            {keey:'save', value:_save}
        ]);


        return _ns;
    }())});


    Object.defineProperty(voltmx, 'store', {configurable:false, enumerable:false, writable:false, value:(function() {
        var _ns = {}, $K = voltmx.$kwebfw$;


        var _clear = function(arg0) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'voltmx.store.clear', enter:true});

            //eslint-disable-next-line no-undef
            if(typeof storeContext === 'string' && storeContext) {
                _clean(arg0);
            } else {
                _clean('store', true);
            }

            $KU.log({api:'voltmx.store.clear', exit:true});
        };


        var _getItem = function(key, arg1) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'voltmx.store.getItem', enter:true});

            if(typeof arg1 === 'string' && arg1) {
                $KU.log({api:'voltmx.store.getItem', exit:true});
                return _fetch(key, arg1);
            }
            $KU.log({api:'voltmx.store.getItem', exit:true});
            return _fetch(key, 'store', true);
        };


        var _key = function(index, arg1) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'voltmx.store.key', enter:true});

            if(typeof arg1 === 'string' && arg1) {
                $KU.log({api:'voltmx.store.key', exit:true});
                return _keyAt(index, arg1);
            }
            $KU.log({api:'voltmx.store.key', exit:true});
            return _keyAt(index, 'store', true);
        };


        var _length = function(arg0) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'voltmx.store.length', enter:true});

            if(typeof arg0 === 'string' && arg0) {
                $KU.log({api:'voltmx.store.length', exit:true});
                return _getLength(arg0);
            }
            $KU.log({api:'voltmx.store.length', exit:true});
            return _getLength('store', true);
        };


        var _removeItem = function(keey, arg1) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'voltmx.store.removeItem', enter:true});

            if(typeof arg1 === 'string' && arg1) {
                _delete(keey, arg1);
            } else {
                _delete(keey, 'store', true);
            }

            $KU.log({api:'voltmx.store.removeItem', exit:true});
        };


        var _setItem = function(keey, value, arg2) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'voltmx.store.setItem', enter:true});

            if(typeof arg2 === 'string' && arg2) {
                _put(keey, value, arg2);
            } else {
                _put(keey, value, 'store', true);
            }

            $KU.log({api:'voltmx.store.setItem', exit:true});
        };


        $K.defVoltmxProp(_ns, [
            {keey:'clear', value:_clear},
            {keey:'getItem', value:_getItem},
            {keey:'key', value:_key},
            {keey:'length', value:_length},
            {keey:'removeItem', value:_removeItem},
            {keey:'setItem', value:_setItem}
        ]);


        return _ns;
    }())});
}());


/* FILE PATH :: 'lib/apis/voltmxi18n.js' */
Object.defineProperty(voltmx, 'i18n', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;


    var _cleanupI18nCache = function $KI18N_cleanupI18nCache() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.i18n.cleanupI18nCache', enter:true});

        $KU.each($KA.supportedLocales, function(locale) {
            var $K = voltmx.$kwebfw$, $KA = $K.app, $KS = $K.store,
                $KL = $K.locale, key = ($KA.id+'_'+locale);

            $KS.remove('local', key);
            delete $KL[locale];
        });

        $KU.log({api:'voltmx.i18n.cleanupI18nCache', exit:true});
    };


    var _deleteResourceBundle = function $KI18N_deleteResourceBundle(locale) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, $KL = $K.locale,
            $KS = $K.store, key = ($KA.id+'_'+locale), index = -1;

        $KU.log({api:'voltmx.i18n.deleteResourceBundle', enter:true});

        $KS.remove('local', key);
        delete $KL[locale];

        index = $KA.supportedLocales.indexOf(locale);
        if(index >= 0) $KA.supportedLocales.splice(index, 1);

        $KU.log({api:'voltmx.i18n.deleteResourceBundle', exit:true});
    };


    var _determineCurrentLocale = function $KI18N_determineCurrentLocale() {
        var $K = voltmx.$kwebfw$, $KA = $K.app, locales = $KA.supportedLocales,
            deviceLocale = _getBrowserLanguage(), current = $KA.defaultLocale;

        deviceLocale = deviceLocale.replace('-', '_');

        if(locales.indexOf(deviceLocale) >= 0) {
            current = deviceLocale;
        } else {
            deviceLocale = deviceLocale.split('_')[0];

            if(locales.indexOf(deviceLocale) >= 0) {
                current = deviceLocale;
            }
        }

        return current;
    };


    var _getBrowserLanguage = function $KI18N_getBrowserLanguage() {
        var $K = voltmx.$kwebfw$, $KG = $K.globals, $KA = $K.app,
            httpheaders = $KG.httpheaders, language = '';

        if(httpheaders && httpheaders['Accept-Language']) {
            language = httpheaders['Accept-Language'].split(',')[0];
        } else {
            language = navigator.language || navigator.userLanguage || $KA.defaultLocale;
        }

        return language;
    };


    var _getCurrentDeviceLocale = function $KI18N_getCurrentDeviceLocale() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            lang = _getBrowserLanguage(),
            list = lang.split('-');

        $KU.log({api:'voltmx.i18n.getCurrentDeviceLocale', enter:true});
        $KU.log({api:'voltmx.i18n.getCurrentDeviceLocale', exit:true});

        return {language:list[0], country:list[1], name:lang};
    };


    var _getCurrentLocale = function $KI18N_getCurrentLocale() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.i18n.getCurrentLocale', enter:true});
        $KU.log({api:'voltmx.i18n.getCurrentLocale', exit:true});

        return $KA.currentLocale;
    };


    var _getLocalizedString = function $KI18N_getLocalizedString(i18nKey) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KL = $K.locale,
            $KA = $K.app, i18nValue = $KL[$KA.currentLocale];

        $KU.log({api:'voltmx.i18n.getLocalizedString', enter:true});

        if(i18nValue) i18nValue = i18nValue[i18nKey];

        $KU.log({api:'voltmx.i18n.getLocalizedString', exit:true});

        return ($KU.is(i18nValue, 'undefined')) ? '' : i18nValue;
    };


    var _getResource = function $KI18N_getResource(locale, initializeFn, successcallback, errorcallback, info) {
        var $K = voltmx.$kwebfw$, $KG = $K.globals,
            $KU = $K.utils, filePath = '', timer = '';

        filePath = $K.constants.RESOURCES_PATH + '/'
                 + $K.constants.TRANSLATION_PATH + '/'
                 + locale + '.' + $K.constants.TRANSLATION_EXT
                 + '?ver=' + $KG.version;

        filePath = ($KG.platform + '/' + filePath);

        timer = setTimeout(function() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

            if(timer) {
                clearTimeout(timer);
                timer = '';
            }

            $KU.log('error', 'Timeout while loading resource bundle.');
            $KA.localeInitialized = true;
            initializeFn && initializeFn();
        }, 60000);

        $KU.loadScript(filePath, false,
            function() { //Success Callback
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    $KA = $K.app, $KL = $K.locale, $KS = $K.store,
                    success = true, key = ($KA.id+'_'+locale);

                //Resource file exists so store it in the database
                //voltmx.print('i18n resource loaded successfully');
                if(timer) {
                    clearTimeout(timer);
                    timer = '';
                }

                $KA.localeInitialized = true;
                $KA.currentLocale = locale;
                $KD.setAttr($KD.find(document, 'html')[0],
                    'lang', locale.split('_')[0].toLowerCase());

                if(window.i18nObject) { //STARTS:: Saving to localstore
                    success = $KS.put('local', key,
                        ($KU.is(window.i18nObject, 'object')
                            ? JSON.stringify(window.i18nObject)
                            : window.i18nObject
                        )
                    );

                    if(!success) {
                        $KS.remove('local', ($KA.id+'_'+'i18nVersion'));
                    }

                    $KL[locale] = (
                        $KU.is(window.i18nObject, 'object')
                            ? window.i18nObject
                            : JSON.parse(window.i18nObject)
                    );

                    window.i18nObject = null;
                } //ENDS:: Saving to localstore

                initializeFn && initializeFn();

                if($KU.is(successcallback, 'function')) {
                    successcallback($KA.previousLocale, $KA.currentLocale, info);
                }
            },

            function() { //Error Callback
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

                $KU.log('error', 'An error has occurred while loading i18 locales');

                if(timer) {
                    clearTimeout(timer);
                    timer = '';
                }

                $KA.localeInitialized = true;
                initializeFn && initializeFn();

                if($KU.is(errorcallback, 'function')) {
                    errorcallback($KA.previousLocale, $KA.currentLocale, info);
                }
            }
        );
    };


    //Returns only current locale instead of all locales supported by the browser
    var _getSupportedLocales = function $KI18N_getSupportedLocales() {
        var $K = voltmx.$kwebfw$, $KU =$K.utils, lang = '';

        $KU.log({api:'voltmx.i18n.getSupportedLocales', enter:true});
        $KU.log('warn', 'getsupportedlocales: Not supported!');
        lang = _getBrowserLanguage();
        $KU.log({api:'voltmx.i18n.getSupportedLocales', exit:true});

        return [lang];
    };


    var _initializeI18n = function $KI18N_initializeI18n(locale, initializeFn, successcallback, errorcallback, info) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, $KA = $K.app,
            $KS = $K.store, $KL = $K.locale, key = ($KA.id+'_'+locale), value = '';

        value = $KS.fetch('local', key);

        if(!value) {
            _getResource(locale, initializeFn, successcallback, errorcallback, info);
        } else {
            value = JSON.parse(value);
            $KA.localeInitialized = true;
            $KA.currentLocale = locale;
            $KL[locale] = value;

            $KD.setAttr($KD.find(document, 'html')[0],
                'lang', locale.split('_')[0].toLowerCase());

            initializeFn && initializeFn();

            if($KU.is(successcallback, 'function')) {
                successcallback($KA.previousLocale, locale, info);
            }
        }
    };


    var _isResourceBundlePresent = function $KI18N_isResourceBundlePresent(locale) {
        var $K = voltmx.$kwebfw$, $KA = $K.app;

        return ($KA.supportedLocales.indexOf(locale) >= 0);
    };


    var _setCurrentLocaleAsync = function $KI18N_setCurrentLocaleAsync(localename, onsuccesscallback, onfailurecallback, info) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, locales = $KA.supportedLocales;

        $KU.log({api:'voltmx.i18n.setCurrentLocaleAsync', enter:true});

        if($KU.is(localename, 'string') && localename
        && locales.indexOf(localename) >= 0) {
            if($KA.currentLocale !== localename) {
                $KA.previousLocale = $KA.currentLocale;
                _initializeI18n(localename, null, onsuccesscallback, onfailurecallback, info);
            } else if($KU.is(onsuccesscallback, 'function')) {
                onsuccesscallback($KA.previousLocale, localename, info);
            }
        } else {
            //LOG:: LOG WARNING
        }

        $KU.log({api:'voltmx.i18n.setCurrentLocaleAsync', exit:true});
    };


    var _setDefaultLocale = function $KI18N_setDefaultLocale(localename, onsuccesscallback, onerrorcallback, initializeFn) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app,
            $KS = $K.store, locales = $KA.supportedLocales,
            version = '', key = ($KA.id+'_i18nVersion');

        $KU.log({api:'voltmx.i18n.setDefaultLocale', enter:true});

        if(!localename) localename = '';
        if(!onsuccesscallback) onsuccesscallback = null;
        if(!onerrorcallback) onerrorcallback = null;
        if(!initializeFn) initializeFn = null;

        if((!$KA.currentLocale || $KA.defaultLocale !== localename)
        && $KU.is(localename, 'string') && localename
        && locales.indexOf(localename) >= 0) {
            if(initializeFn) {
                version = $KS.fetch('local', key) || '';

                if(version !== $KA.i18nVersion) {
                    $KS.put('local', key, $KA.i18nVersion);
                    _cleanupI18nCache();
                }
            }

            $KA.defaultLocale = localename;

            _initializeI18n(_determineCurrentLocale(), initializeFn, onsuccesscallback, onerrorcallback);
        } else {
            //LOG:: LOG WARNING
        }

        $KU.log({api:'voltmx.i18n.setDefaultLocale', exit:true});
    };


    var _setDefaultLocaleAsync = function $KI18N_setDefaultLocaleAsync(localename, onsuccesscallback, onfailurecallback, info) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, $KS = $K.store,
            locales = $KA.supportedLocales, version = '', key = ($KA.id+'_i18nVersion');

        $KU.log({api:'voltmx.i18n.setDefaultLocaleAsync', enter:true});

        if((!$KA.currentLocale || $KA.defaultLocale !== localename)
        && $KU.is(localename, 'string') && localename
        && locales.indexOf(localename) >= 0) {
            version = $KS.fetch('local', key) || '';

            if(version !== $KA.i18nVersion) {
                $KS.put('local', key, $KA.i18nVersion);
                _cleanupI18nCache();
            }

            $KA.defaultLocale = localename;

            _initializeI18n(_determineCurrentLocale(), null, onsuccesscallback, onfailurecallback, info);
        } else {
            //LOG:: LOG WARNING
        }

        $KU.log({api:'voltmx.i18n.setDefaultLocaleAsync', exit:true});
    };


    var _setLocaleLayoutConfig = function $KI18N_setLocaleLayoutConfig(config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.i18n.setLocaleLayoutConfig', enter:true});

        if($KU.is(config, 'object')) {
            $KA.localeLayoutConfig = config;
        }

        $KU.log({api:'voltmx.i18n.setLocaleLayoutConfig', exit:true});
    };


    var _setResourceBundle = function $KI18N_setResourceBundle(inputtable, locale) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app,
            $KL = $K.locale, $KS = $K.store, key = ($KA.id+'_'+locale);

        $KU.log({api:'voltmx.i18n.setResourceBundle', enter:true});

        if($KU.is(inputtable, 'object') && $KU.is(locale, 'string') && locale) {
            $KS.put('local', key, JSON.stringify(inputtable)); // overrides existing key
            $KL[locale] = inputtable;

            if($KA.supportedLocales.indexOf(locale) === -1) {
                $KA.supportedLocales.push(locale);
            }
        }

        $KU.log({api:'voltmx.i18n.setResourceBundle', exit:true});
    };


    var _updateResourceBundle = function $KI18N_updateResourceBundle(inputtable, locale) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, bundle = null,
            $KL = $K.locale, $KS = $K.store, key = ($KA.id+'_'+locale);

        $KU.log({api:'voltmx.i18n.updateResourceBundle', enter:true});

        if($KU.is(inputtable, 'object') && $KU.is(locale, 'string') && locale) {
            bundle = $KS.fetch('local', key);
            bundle = JSON.parse(bundle);

            $KU.each(inputtable, function(value, keey) {
                bundle[keey] = value;
            });

            $KS.put('local', key, JSON.stringify(bundle)); //Overrides existing key
            $KL[locale] = bundle;

            if($KA.supportedLocales.indexOf(locale) === -1) {
                $KA.supportedLocales.push(locale);
            }
        }

        $KU.log({api:'voltmx.i18n.updateResourceBundle', exit:true});
    };


    $K.defVoltmxProp(_ns, [
        {keey:'deleteResourceBundle', value:_deleteResourceBundle},
        {keey:'getCurrentDeviceLocale', value:_getCurrentDeviceLocale},
        {keey:'getCurrentLocale', value:_getCurrentLocale},
        {keey:'getLocalizedString', value:_getLocalizedString},
        {keey:'getSupportedLocales', value:_getSupportedLocales},
        {keey:'isResourceBundlePresent', value:_isResourceBundlePresent},
        {keey:'setCurrentLocaleAsync', value:_setCurrentLocaleAsync},
        {keey:'setDefaultLocale', value:_setDefaultLocale},
        {keey:'setDefaultLocaleAsync', value:_setDefaultLocaleAsync},
        {keey:'setLocaleLayoutConfig', value:_setLocaleLayoutConfig},
        {keey:'setResourceBundle', value:_setResourceBundle},
        {keey:'updateResourceBundle', value:_updateResourceBundle}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxio.js' */
Object.defineProperty(voltmx, 'io', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$, _iframe = null,
        _form = null, _input = null, _scrap = null;


    var _ajaxBrowse = function(e, callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, files = [];

        $KU.each(this.files, function(file) {
            files.push(new File(file));
        });

        callback(e, files);
    };


    var _ajaxUpload = function(url, state, index, callback/*, config*/) {
        var xhr = new XMLHttpRequest(), formData = new FormData();

        formData.append(state.file.name, state.file.file);
        if(!url.match(new RegExp(/^(http|https):\/\/?/))) {
            state.status = constants.FILE_UPLOAD_ERROR_STATE;
            callback && callback(url, state);
            return;
        }

        xhr.open('POST', url, true);

        xhr.upload.onloadstart = function(/*e*/) {
            state.status = constants.FILE_UPLOAD_START_STATE;
            state.uploadBytes = 0;
            callback && callback(url, state);
        };
        xhr.upload.onprogress = function(e) {
            if(e.lengthComputable) {
                state.uploadBytes = e.loaded;
            }
            state.status = constants.FILE_UPLOAD_PROGRESS_STATE;
            callback && callback(url, state);
        };
        xhr.upload.onerror = function(/*e*/) {
            state.status = constants.FILE_UPLOAD_ERROR_STATE;
            state.uploadBytes = 0;
            callback && callback(url, state);
        };
        xhr.upload.onabort = function(/*e*/) {
            state.status = constants.FILE_UPLOAD_ERROR_STATE;
            callback && callback(url, state);
        };
        xhr.onload = function(/*e*/) {
            if(this.status === 200) {
                state.status = constants.FILE_UPLOAD_COMPLETE_STATE;
                state.uploadBytes = state.file.size;
                callback && callback(url, state);
            }
        };
        xhr.onerror = function(/*e*/) {
            state.status = constants.FILE_UPLOAD_ERROR_STATE;
            state.uploadBytes = 0;
            callback && callback(url, state);
        };
        xhr.onreadystatechange = function() {
            if(xhr.readyState !== 4)
                return;
            clearTimeout(setTimeout(function() {
                xhr.abort();
            }, constants.UPLOAD_MAX_WAIT_TIME));
            if(xhr.status !== 200) {
                state.status = constants.FILE_UPLOAD_ERROR_STATE;
                state.uploadBytes = 0;
                callback && callback(url, state);
            }
        };
        xhr.send(formData);
    };

    var _iframeBrowse = function(e, callback) {
        var path = e.value, files = [],
            name = path.substring(path.lastIndexOf('\\') + 1),
            parent = path.substring(0, path.lastIndexOf('\\')); // get path of parent directory

        parent = parent.substring(parent.lastIndexOf('\\') + 1); // name of parent directory

        files.push(new File({name:name, fullPath:path, parent:parent, file:e}));

        callback(e, files);
    };


    var _iframeUpload = function() {
        //
    };

    var File = function(file) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.io.File', enter:true});

        if(_isAjaxUploadSupported()) {
            $KU.defineProperty(this, 'name', file.name);
            $KU.defineProperty(this, 'file', file); // original file object return via browser
        } else {
            $KU.each(file, function(value, key) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                $KU.defineProperty(this, key, value);
            });
        }

        $KU.defineProperty(this, 'readable', true);
        $KU.defineProperty(this, 'writable', false);

        if(file.lastModifiedDate) {
            $KU.defineProperty(this, 'modificationTime', new Date(file.lastModifiedDate).toISOString());
        }

        if(file.size) {
            $KU.defineProperty(this, 'size', file.size);
        }

        $KU.log({api:'voltmx.io.File', exit:true});
    };


    var FileSystem_browse = function(config, callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, $KG = $K.globals;

        $KU.log({api:'voltmx.io.FileSystem.browse', enter:true});

        if(!_scrap) _scrap = $KG.appScrap;

        if($KU.is(config, 'object') && $KU.is(callback, 'function')) {
            _form = $KD.create('form');
            _input = $KD.create('input', {type:'file'});

            $KD.on(_input, 'click', 'upload', function(/*e*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.parent(this).reset();
            });

            $KD.add(_form, _input);

            if(_isAjaxUploadSupported()) {
                if(config.selectMultipleFiles === true) {
                    $KD.setAttr(_input, 'multiple', 'multiple');
                } else {
                    $KD.removeAttr(_input, 'multiple');
                }

                if($KU.is(config.filter, 'array')) {
                    $KD.setAttr(_input, 'accept', config.filter.join(','));
                } else {
                    $KD.removeAttr(_input, 'accept');
                }

                $KD.on(_input, 'change', 'upload', function(e) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    _ajaxBrowse.call(this, e, callback);
                    $KD.remove($KD.parent(e.target));
                });

                if(!$KD.contains(_scrap, _form)) {
                    $KD.add($KG.appScrap, _form);
                }
            } else {
                if(!_iframe) {
                    _iframe = $KD.create('iframe');
                    $KD.add(_iframe.document.body, _form);

                    $KD.add(_scrap, _iframe);
                }

                $KD.setAttr(_form, 'method', 'POST');
                $KD.setAttr(_form, 'enctype', 'multipart/form-data');

                $KD.on(_input, 'click', 'upload', function(e) {
                    _iframeBrowse.call(this, e, callback);
                });
            }

            $KD.fire(_input, 'click');
        }

        $KU.log({api:'voltmx.io.FileSystem.browse', exit:true});
    };


    var FileSystem_uploadFiles = function(url, files, callBack, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.io.FileSystem.uploadFiles', enter:true});

        if($KU.is(url, 'string') && url
        && $KU.is(files, 'array') && files.length > 0) {
            $KU.each(files, function(file, index) {
                var state = {file:file, status:null, uploadBytes:null};

                if(_isAjaxUploadSupported()) {
                    _ajaxUpload(url, state, index, callBack, config);
                } else {
                    _iframeUpload();
                }
            });
        }

        $KU.log({api:'voltmx.io.FileSystem.uploadFiles', exit:true});
    };


    var _isAjaxUploadSupported = function() {
        if(window.File && window.FileList
        && new XMLHttpRequest().upload) {
            return true;
        } return false;
    };


    $K.defVoltmxProp(_ns, [
        {keey:'File', value:File},
        {keey:'FileSystem', value:{}, items:[
            {keey:'browse', value:FileSystem_browse},
            {keey:'uploadFiles', value:FileSystem_uploadFiles}
        ]}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxlistener.js' */
(function() {
    /**
     * voltmx.listener.create('some_name');
     * var id = voltmx.listener.subscribe('some_name', function(payload) {}, scope);
     * voltmx.listener.broadcast('some_name', payload);
     * voltmx.listener.unsubscribe(id);
     * voltmx.listener.destroy('some_name');
     */

    Object.defineProperty(voltmx, 'listener', {configurable:false, enumerable:false, writable:false, value:(function() {
        var _ns = {}, $K = voltmx.$kwebfw$, _listeners = {}, _map = {};

        var _broadcast = function(name, payload) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            payload = (arguments.length === 1) ?  {}: {data:payload};
            
            if(_listeners[name]) {
                $KU.each(_listeners[name], function(subscription, id) {
                    subscription.call(_map[id].scope, payload);
                });
            }
        };

        var _create = function(name) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            if(name && $KU.is(name, 'string')) {
                if(Object.prototype.hasOwnProperty.call(_listeners, name)) {
                    throw new Error("voltmx error: listener already exists.");
                } else {
                    _listeners[name] = {};
                }
            }
        };

        var _destroy = function(name) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            if(_listeners[name]) {
                $KU.each(_listeners[name], function(subscription, id) {
                    delete _map[id];
                });

                delete _listeners[name];
            }
        };

        var _subscribe = function(name, callback, scope) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, id = '';

            if(_listeners[name] && $KU.is(callback, 'function')) {
                if(arguments.length === 2) scope = null;

                id = $KU.uid();
                _map[id] = {name:name, scope:scope};
                _listeners[name][id] = callback;
            }

            return id;
        };

        var _unsubscribe = function(id) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, name = '';

            if(id && $KU.is(id, 'string')) {
                name = (_map[id] && _map[id].name) || '';

                if(name) {
                    delete _map[id];
                    delete _listeners[name][id];
                }
            }
        };

        $K.defVoltmxProp(_ns, [
            {keey:'broadcast', value:_broadcast},
            {keey:'create', value:_create},
            {keey:'destroy', value:_destroy},
            {keey:'subscribe', value:_subscribe},
            {keey:'unsubscribe', value:_unsubscribe}
        ]);

        return _ns;
    }())});
}());


/* FILE PATH :: 'lib/apis/voltmxlocation.js' */


Object.defineProperty(voltmx, 'location', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    var _clearWatch = function(watchId) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.location.clearWatch', enter:true});

        if($KU.browser('supports', 'geolocation')) {
            $KU.log({api:'voltmx.location.clearWatch', exit:true});
            navigator.geolocation.clearWatch(watchId);
        }
    };


    var _getCurrentPosition = function(successCallback, errorCallback, positionOptions) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.location.getCurrentPosition', enter:true});

        if($KU.browser('supports', 'geolocation')) {
            $KU.log({api:'voltmx.location.getCurrentPosition', exit:true});
            navigator.geolocation.getCurrentPosition(successCallback, errorCallback, positionOptions);
        }
    };

    var _watchPosition = function(successCallback, errorCallback, positionOptions) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, watchId = null;

        $KU.log({api:'voltmx.location.watchPosition', enter:true});

        if($KU.browser('supports', 'geolocation')) {
            $KU.log({api:'voltmx.location.watchPosition', exit:true});
            watchId = navigator.geolocation.watchPosition(successCallback, errorCallback, positionOptions);
        }

        return watchId;
    };


    $K.defVoltmxProp(_ns, [
        {keey:'PERMISSION_DENIED', value:1},
        {keey:'POSITION_UNAVAILABLE', value:2},
        {keey:'TIMEOUT', value:3},
        {keey:'clearWatch', value:_clearWatch},
        {keey:'getCurrentPosition', value:_getCurrentPosition},
        {keey:'watchPosition', value:_watchPosition}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxmodules.js' */
Object.defineProperty(voltmx, 'modules', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;


    var _loadFunctionalModule = function(/* modulename */) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.modules.loadFunctionalModule', enter:true});

        //TODO:: loadFunctionalModule API

        $KU.log({api:'voltmx.modules.loadFunctionalModule', exit:true});
    };


    var _loadFunctionalModuleAsync = function(/* modulename, successcallback, errorcallback */) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.modules.loadFunctionalModuleAsync', enter:true});

        //TODO:: loadFunctionalModuleAsync API

        $KU.log({api:'voltmx.modules.loadFunctionalModuleAsync', exit:true});
    };


    $K.defVoltmxProp(_ns, [
        {keey:'loadFunctionalModule', value:_loadFunctionalModule},
        {keey:'loadFunctionalModuleAsync', value:_loadFunctionalModuleAsync}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxmedia.js' */
Object.defineProperty(voltmx, 'media', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    var _record = function(config, arg1) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _audioRecorder = null,
            _recordMedia = null, tracks = null;

        $KU.log({api:'voltmx.media.record', enter:true});

        if(arguments.length === 2) config = arg1;

        if($KU.browser('supports', 'usermedia') && $KU.browser('supports', 'mediarecorder')) {
            _recordMedia = {
                startRecording: function() {
                    if(!_audioRecorder || (_audioRecorder && _audioRecorder.state === 'inactive')) {
                        navigator.mediaDevices.getUserMedia({audio:true}).then(function(stream) {
                            _audioRecorder = new MediaRecorder(stream);
                            _audioRecorder.start();
                        }).catch(function(err) {
                            config.onFailure && config.onFailure('Error :' + err);
                        });
                    }
                },

                stopRecording: function() {
                    var i = 0, ilen = 0;

                    if(_audioRecorder && _audioRecorder.state === 'recording') {
                        _audioRecorder.ondataavailable = function(e) {
                            config.onSuccess && config.onSuccess(URL.createObjectURL(e.data));
                            _audioRecorder = null;
                        };

                        _audioRecorder.stop();
                        tracks = _audioRecorder.stream.getTracks();
                        ilen = tracks.length;

                        for(i=0; i<ilen; i++) {
                            tracks[i].stop();
                        }
                    } else {
                        config.onFailure && config.onFailure('Failed during stop recording');
                    }
                }
            };
        } else {
            config.onFailure && config.onFailure('Audio API is not supported in your browser');
        }

        $KU.log({api:'voltmx.media.record', exit:true});
        return _recordMedia;
    };


    $K.defVoltmxProp(_ns, [
        {keey:'record', value:_record}
    ]);


    return _ns;
}())});

Object.defineProperty(voltmx, 'screenrecorder', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$, _ScreenRecorder = [], _videoData = [], _tracks = [];

    var _start = function(config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, frameRate = 30,
            constraints = null, videoTracks = null;

        $KU.log({api:'voltmx.screenrecorder.start', enter:true});
        if(config && config.frameRate) {
            frameRate = config.frameRate;
        }
        constraints = {video: {frameRate: frameRate}};
        if($KU.browser('supports', 'displaymedia') && $KU.browser('supports', 'mediarecorder')) {
            navigator.mediaDevices.getDisplayMedia(constraints).then(function(stream) {
                _ScreenRecorder = new MediaRecorder(stream);
                _ScreenRecorder.start();
                videoTracks = _ScreenRecorder.stream.getVideoTracks();
                videoTracks[0].onended = function() {
                    if(_ScreenRecorder.state === 'recording') {
                        _stop();
                    } else if(_ScreenRecorder.state === 'paused') {
                        _resume();
                        _stop();
                    }
                };
                $KU.log({api:'voltmx.screenrecorder.start', exit:true});
            }).catch(function(err) {
                if(config && config.onFailure) {
                    config.onFailure(err);
                }
            });
        } else {
            if(config && config.onFailure) {
                config.onFailure('ScreenRecorder API is not supported by your browser');
            }
        }
    };

    var _stop = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, i = 0;
        if(_ScreenRecorder && !(_ScreenRecorder.state === 'inactive')) {
            $KU.log({api:'voltmx.screenrecorder.stop', enter:true});
            _ScreenRecorder.stop();
            _tracks = _ScreenRecorder.stream.getTracks();
            _ScreenRecorder.ondataavailable = function(e) {
                _videoData.push(e.data);
            };
            for(i = 0; i < _tracks.length; i++) {
                _tracks[i].stop();
            }
            $KU.log({api:'voltmx.screenrecorder.stop', exit:true});
        }
    };

    var _pause = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;
        if(_ScreenRecorder && _ScreenRecorder.state === 'recording') {
            $KU.log({api:'voltmx.screenrecorder.pause', enter:true});
            _ScreenRecorder.pause();
            $KU.log({api:'voltmx.screenrecorder.pause', exit:true});
        }
    };

    var _resume = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;
        if(_ScreenRecorder && _ScreenRecorder.state === 'paused') {
            $KU.log({api:'voltmx.screenrecorder.resume', enter:true});
            _ScreenRecorder.resume();
            $KU.log({api:'voltmx.screenrecorder.resume', exit:true});
        }
    };

    var _getrecordeddata = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, blob = null, videoBlobURL = null;
        if(_ScreenRecorder && _ScreenRecorder.state && _ScreenRecorder.state === 'inactive') {
            $KU.log({api:'voltmx.screenrecorder.getrecordeddata', enter:true});
            blob = new Blob(_videoData, {type:'video/webm'});
            window.URL = window.URL || window.webkitURL;
            videoBlobURL = window.URL.createObjectURL(blob);
            $KU.log({api:'voltmx.screenrecorder.getrecordeddata', exit:true});
        }
        return videoBlobURL;
    };

    var _getrecordingstate = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, state = 'inactive';
        $KU.log({api:'voltmx.screenrecorder.getrecordedstate', enter:true});
        if(_ScreenRecorder && _ScreenRecorder.state) {
            $KU.log({api:'voltmx.screenrecorder.getrecordedstate', exit:true});
            state = _ScreenRecorder.state;
        }
        return state;
    };


    $K.defVoltmxProp(_ns, [
        {keey:'getrecordeddata', value:_getrecordeddata},
        {keey:'getrecordingstate', value:_getrecordingstate},
        {keey:'pause', value:_pause},
        {keey:'resume', value:_resume},
        {keey:'start', value:_start},
        {keey:'stop', value:_stop}
    ]);

    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxnet.js' */
Object.defineProperty(voltmx, 'net', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$, $KU = $K.utils, _http = {},
        _integrityProperties = null;


    var _cancel = function(connection) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.net.cancel', enter:true});

        if($KU.is(connection, 'object')
        && $KU.is(connection.abort, 'function')) {
            connection.userCancelled = true;
            connection.abort();
        }

        $KU.log({api:'voltmx.net.cancel', exit:true});
    };


    var _clearCookies = function(url, cookies) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            allCookies = document && document.cookie.split(';'),
            pathBits = null, i = 0, ilen = 0, pathCurrent = '/',
            cookieName = '', j = 0, jlen = 0;

        $KU.log({api:'voltmx.net.clearCookies', enter:true});

        url = url || document.URL;

        if(window && url.indexOf(window.location.origin) !== -1) {
            cookies = cookies || allCookies;

            if(cookies) {
                pathBits = window.location.pathname.split('/');
                ilen = cookies.length;

                for(i=0; i<ilen; i++) {
                    cookieName = cookies[i].trim();

                    if(document.cookie.indexOf(cookieName) !== -1) {
                        jlen = pathBits.length;

                        for(j=0; j<jlen; j++) {
                            pathCurrent += ((pathCurrent.substr(-1) !== '/') ? '/' : '') + pathBits[j];

                            if(cookieName.indexOf('=') !== -1) {
                                document.cookie = cookieName + '; expires=Thu, 01-Jan-1970 00:00:01 GMT;path=' + pathCurrent + ';';
                            } else {
                                document.cookie = cookieName + '=; expires=Thu, 01-Jan-1970 00:00:01 GMT;path=' + pathCurrent + ';';
                            }

                            if(document.cookie.indexOf(cookieName) === -1) break;
                        }
                    }
                }
            }

            $KU.log({api:'voltmx.net.clearCookies', exit:true});
        } else {
            throw new $KU.error(1005, 'invalid input url', 'invalid input url');
        }
    };


    var _FormData = function(param) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _formdata = {};

        $KU.log({api:'voltmx.net.FormData', enter:true});

        if($KU.is(param, 'object')
        && param.isMultiPart && window.FormData) {
            return new FormData();
        }
        this.append = function(key, value) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KB = $K.behavior;

            if($KU.is(key, 'string') && key) {
                if(!$KB.doNotEncodeFormValue) {
                    value = encodeURIComponent(value);
                }

                if(!_formdata[key]) {
                    _formdata[key] = [value];
                } else {
                    _formdata[key].push(value);
                }
            } else {
                throw new Error('FormData append Error: key cannot be empty');
            }
        };

        this.toString = function() {
            var formdata = '', key = '';

            for(key in _formdata) {
                if(formdata === '') {
                    formdata = key + '=' + _formdata[key].join('&' + key + '=');
                } else {
                    formdata += '&' + key + '=' + _formdata[key].join('&' + key + '=');
                }
            }

            return formdata;
        };

        this.delete = function(key) {
            delete _formdata[key];
        };

        this.entries = function() {
            return _iterator(_formdata, 'entries');
        };

        this.get = function(key) {
            return _formdata[key][0];
        };

        this.getAll = function(key) {
            return _formdata[key];
        };

        this.has = function(key) {
            //eslint-disable-next-line no-prototype-builtins
            return _formdata.hasOwnProperty(key);
        };

        this.keys = function() {
            return _iterator(_formdata, 'keys');
        };

        this.set = function(key, value) {
            _formdata[key] = [value];
        };

        this.values = function() {
            return _iterator(_formdata, 'values');
        };

        $KU.log({api:'voltmx.net.FormData', exit:true});
    };


    var _getActiveNetworkType = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.net.getActiveNetworkType', enter:true});

        if($KU.is(navigator.onLine, 'undefined')) {
            $KU.log({api:'voltmx.net.getActiveNetworkType', exit:true});
            return constants.NETWORK_TYPE_ANY;
        }
        if(navigator.onLine) {
            $KU.log({api:'voltmx.net.getActiveNetworkType', exit:true});
            return constants.NETWORK_TYPE_ANY;
        }
        $KU.log({api:'voltmx.net.getActiveNetworkType', exit:true});
        return null;
    };


    var _getCookies = function(url) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, allCookies = null;

        $KU.log({api:'voltmx.net.getCookies', enter:true});

        if($KU.is(url, 'string') && url) {
            if(url.indexOf(window.location.origin) !== -1) {
                allCookies = document && document.cookie;

                if(allCookies && allCookies.length > 0) {
                    allCookies = allCookies.split(';');
                }
            }
        }

        $KU.log({api:'voltmx.net.getCookies', exit:true});

        return allCookies;
    };

    var _getResponseHeader = function(headerfield) {
        var xhr = this.xhr;

        if(xhr.getResponseHeader(headerfield)) {
            return xhr.getResponseHeader(headerfield);
        }
        return null;
    };

    var _getAllResponseHeaders = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KB = $K.behavior,
            xhr = this.xhr, headers = null, arr, parts, header,
            value, line, count = 0, len = 0, map = {};

        if(xhr.getAllResponseHeaders()) {
            headers = xhr.getAllResponseHeaders();
        }

        if(!$KB.isResponseHeaderString && $KU.is(headers, 'string')) {
            // Convert the header string into an array
            // of individual headers
            arr = headers.trim().split(/[\r\n]+/);
            len = arr.length;

            for(count=0; count<len; count++) {
                line = arr[count];
                parts = line.split(': ');
                header = parts.shift();
                value = parts.join(': ');
                map[header] = value;
            }

            headers = map;
        }
        return headers;
    };


    var _HttpRequest = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, id = $KU.uid();

        $KU.log({api:'voltmx.net.HttpRequest', enter:true});

        _http[id] = {
            disableIntegrityCheck: false,
            enableWithCredentials: false,
            integrityCheckRequired: false,
            integrityStatus: constants.HTTP_INTEGRITY_CHECK_NOT_DONE,
            isMultiPartOrBinary: false,
            onReadyStateChange: function() {},
            randomString: null,
            response: '',
            responseType: '',
            status: null,
            statusText: null,
            timeout: 0,
            url: null,
            xhr: new XMLHttpRequest()

        };

        _http[id].xhr.onreadystatechange = function() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app,
                http = _http[id], xhr = http.xhr, cf = null;

            http.status = xhr.status;
            http.readyState = xhr.readyState;

            switch(xhr.readyState) {
                case 0: // UNINITIALIZED
                case 1: // LOADING
                case 2: // LOADED
                case 3: // INTERACTIVE
                    http.readyState = xhr.readyState;
                    http.statusText = (xhr.readyState === 0)
                        ? 'Request Uninitialised'
                        : (xhr.readyState === 1)
                            ? 'Request Loading'
                            : (xhr.readyState === 2)
                                ? 'Request Loaded'
                                : (xhr.readyState === 3)
                                    ? 'Request Interactive' : '';
                    http.onReadyStateChange({
                        enableWithCredentials: http.enableWithCredentials,
                        integrityStatus: http.integrityStatus,
                        readyState: http.readyState,
                        response: http.response,
                        responseType: http.responseType,
                        status: http.status,
                        statusText: http.statusText,
                        timeout: http.timeout
                    });
                    break;

                case 4: // COMPLETED
                    http.readyState = xhr.readyState;
                    http.statusText = 'Request Completed';

                    if(xhr.responseType === '' || xhr.responseType === 'text') {
                        http.response = xhr.responseText;
                    } else {
                        http.response = xhr.response;
                    }

                    if(http.integrityCheckRequired) {
                        _integrity.generateResponseCheckSumAndCheckIntegrity.call(http, http.response);
                    }

                    if(xhr.status === 200) {
                        http.statusText += ': OK';

                        if(http.timeout) {
                            clearTimeout(http.timeout);
                        }
                    }

                    if(xhr.status === 400) {
                        http.statusText += ': Error';

                        if(http.timeout) {
                            clearTimeout(http.timeout);
                        }
                    }

                    http.onReadyStateChange({
                        enableWithCredentials: http.enableWithCredentials,
                        integrityStatus: http.integrityStatus,
                        readyState: http.readyState,
                        response: http.response,
                        responseType: http.responseType,
                        status: http.status,
                        statusText: http.statusText,
                        timeout: http.timeout
                    }); //MADPSPA-425: SDK expecting result obj in callback handler

                    cf = $KW.model($KA.currentFormUID);
                    cf && cf.forceLayout();

                    xhr = http = null; //For GC
                    delete _http[id];
                    break;

                default:
                    xhr = http = null; //For GC
                    delete _http[id];
                    //$KU.logErrorMessage('Unknown Error: XMLHttpRequest Error');
            }
        };

        $KU.defineProperty(this, 'id', id);

        $KU.defineGetter(this, 'disableIntegrityCheck', function() {
            return _http[this.id].disableIntegrityCheck;
        });
        $KU.defineSetter(this, 'disableIntegrityCheck', function(value) {
            if(typeof value === 'boolean') {
                _http[this.id].disableIntegrityCheck = value;
            }
        });

        $KU.defineGetter(this, 'enableWithCredentials', function() {
            return _http[this.id].enableWithCredentials;
        });
        $KU.defineSetter(this, 'enableWithCredentials', function(value) {
            if(typeof value === 'boolean') {
                _http[this.id].enableWithCredentials = value;
            }
        });

        $KU.defineGetter(this, 'integrityStatus', function() {
            return _http[this.id].integrityStatus;
        });
        //eslint-disable-next-line no-unused-vars
        $KU.defineSetter(this, 'integrityStatus', function(value) {
            //Readonly:: Throw error
        });

        $KU.defineGetter(this, 'onReadyStateChange', function() {
            return _http[this.id].onReadyStateChange;
        });
        $KU.defineSetter(this, 'onReadyStateChange', function(value) {
            if(typeof value === 'function') {
                _http[this.id].onReadyStateChange = value;
            }
        });

        $KU.defineGetter(this, 'readyState', function() {
            return _http[this.id].readyState;
        });
        //eslint-disable-next-line no-unused-vars
        $KU.defineSetter(this, 'readyState', function(value) {
            //Readonly:: Throw error
        });

        $KU.defineGetter(this, 'response', function() {
            return _http[this.id].response;
        });
        //eslint-disable-next-line no-unused-vars
        $KU.defineSetter(this, 'response', function(value) {
            //Readonly:: Throw error
        });

        $KU.defineGetter(this, 'responseType', function() {
            return _http[this.id].responseType;
        });
        $KU.defineSetter(this, 'responseType', function(value) {
            _http[this.id].responseType = value;
        });

        $KU.defineGetter(this, 'status', function() {
            return _http[this.id].status;
        });
        //eslint-disable-next-line no-unused-vars
        $KU.defineSetter(this, 'status', function(value) {
            //Readonly:: Throw error
        });

        $KU.defineGetter(this, 'statusText', function() {
            return _http[this.id].statusText;
        });
        //eslint-disable-next-line no-unused-vars
        $KU.defineSetter(this, 'statusText', function(value) {
            //Readonly:: Throw error
        });

        $KU.defineGetter(this, 'timeout', function() {
            return _http[this.id].timeout;
        });
        $KU.defineSetter(this, 'timeout', function(value) {
            if(typeof value === 'number' && !isNaN(value)) {
                _http[this.id].timeout = value;
            }
        });

        $KU.log({api:'voltmx.net.HttpRequest', exit:true});
    };

    $KU.defineProperty(_HttpRequest.prototype, 'abort', function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            http = _http[this.id], xhr = http.xhr;

        $KU.log({api:'voltmx.net.HttpRequest.abort', enter:true});

        if(http.timeout) {
            clearTimeout(http.timeout);
        }

        xhr.abort();
        delete _http[this.id];

        $KU.log({api:'voltmx.net.HttpRequest.abort', exit:true});
    });

    $KU.defineProperty(_HttpRequest.prototype, 'getAllResponseHeaders', function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, http = _http[this.id], headers = null;

        $KU.log({api:'voltmx.net.HttpRequest.getAllResponseHeaders', enter:true});

        headers = _getAllResponseHeaders.call(http);

        $KU.log({api:'voltmx.net.HttpRequest.getAllResponseHeaders', exit:true});

        return headers;
    });

    $KU.defineProperty(_HttpRequest.prototype, 'getResponseHeader', function(headerfield) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, http = _http[this.id], header = null;

        $KU.log({api:'voltmx.net.HttpRequest.getResponseHeader', enter:true});

        header = _getResponseHeader.call(http, headerfield);

        $KU.log({api:'voltmx.net.HttpRequest.getResponseHeader', exit:true});

        return header;
    });

    $KU.defineProperty(_HttpRequest.prototype, 'open', function(method, url, async, username, password) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            http = _http[this.id], xhr = http.xhr;

        $KU.log({api:'voltmx.net.HttpRequest.open', enter:true});

        if($KU.is(method, 'string')) {
            method = method.toUpperCase();
        }

        if($KU.is(url, 'string') && url) {
            http.url = url;
            http.open = true;
            http.method = method;
            async = ($KU.is(async, 'boolean')) ? async : true;

            xhr.open(method, url, async, username, password);
        }

        $KU.log({api:'voltmx.net.HttpRequest.open', exit:true});
    });

    $KU.defineProperty(_HttpRequest.prototype, 'send', function(data) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            http = _http[this.id], xhr = http.xhr, self = null;

        $KU.log({api:'voltmx.net.HttpRequest.send', enter:true});

        if(data instanceof voltmx.net.FormData) {
            //Calling toString() if it is Voltmx.net.FormData
            //otherwise send the data directly to send method.
            data = data.toString();
        } else if(!data) {
            data = '';
        } else if((window.FormData !== undefined) && data instanceof window.FormData) {
            http.isMultiPartOrBinary = true;
        }

        if(this.enableWithCredentials) {
            xhr.withCredentials = true;
        }

        xhr.count++;
        xhr.timeout = !!this.timeout && this.timeout;

        if(xhr.timeout) {
            self = this;

            http.timeout = setTimeout(function() {
                self.abort();
                self.readyState = xhr.readyState;
                self.status = 0;
                self.statusText = 'Request timed out';
                self.response = '';

                self.onReadyStateChange();
            }, this.timeout);
        }

        if(this.responseType) {
            xhr.responseType = this.responseType;
        }


        http.integrityCheckRequired = _integrity.isIntegrityCheckRequired(http.url, http.disableIntegrityCheck);

        if(http.integrityCheckRequired) {
            _integrity.generateRequestCheckSumAndSetRequestHeader.call(http, data);
        }
        xhr.send(data);

        $KU.log({api:'voltmx.net.HttpRequest.send', exit:true});
    });

    $KU.defineProperty(_HttpRequest.prototype, 'setRequestHeader', function(header, value) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            http = _http[this.id],
            binaryFormats = ['application/octet-stream', 'multipart/form-data'];

        $KU.log({api:'voltmx.net.HttpRequest.setRequestHeader', enter:true});

        if(header && header.toLowerCase() === 'content-type'
        && value && binaryFormats.indexOf(value.toLowerCase()) !== -1) {
            http.isMultiPartOrBinary = true;
        }

        _setRequestHeader.call(http, header, value);

        $KU.log({api:'voltmx.net.HttpRequest.setRequestHeader', exit:true});
    });


    //Dummy implementation
    //eslint-disable-next-line no-unused-vars
    var _invokeService = function(url, inputParamTable, isblocking) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.net.invokeService', enter:true});
        $KU.log({api:'voltmx.net.invokeService', exit:true});
    };


    //Dummy implementation
    //eslint-disable-next-line no-unused-vars
    var _invokeServiceAsync = function(url, inputParamTable, callback, info) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.net.invokeServiceAsync', enter:true});
        $KU.log({api:'voltmx.net.invokeServiceAsync', exit:true});
    };

    var _integrity = {

        //This function will be called in the scope of http instance
        generateRequestCheckSum: function Integrity$generateRequestCheckSum(data, passThroughOrFileMultipart) {
            var requestCheckSum = null, toHash = null, requestBodyHash = 'EMPTY_BODY';

            if(passThroughOrFileMultipart !== null) {
                requestBodyHash = passThroughOrFileMultipart;
            } else if(data) {
                requestBodyHash = voltmx.crypto.createHashToUpperCase(_integrityProperties.algo, data);
            }

            toHash = 'Request:' + _integrityProperties.salt + ':' + this.randomString + ':' + requestBodyHash;
            requestCheckSum = voltmx.crypto.createHashToUpperCase(_integrityProperties.algo, toHash);
            return requestCheckSum;
        },

        //This function will be called in the scope of http instance
        generateResponseCheckSum: function Integrity$generateResponseCheckSum(data, passThroughOrFileMultipart) {
            var responseCheckSum = null, toHash = null, responseBodyHash = 'EMPTY_BODY';

            if(passThroughOrFileMultipart !== null) {
                responseBodyHash = passThroughOrFileMultipart;
            } else if(data) {
                responseBodyHash = voltmx.crypto.createHashToUpperCase(_integrityProperties.algo, data);
            }
            toHash = ('Response:' + _integrityProperties.salt + ':' + this.randomString + ':' + responseBodyHash);
            responseCheckSum = voltmx.crypto.createHashToUpperCase(_integrityProperties.algo, toHash);

            return responseCheckSum;
        },

        //This function will be called in the scope of http instance
        generateRequestCheckSumAndSetRequestHeader: function Integrity$generateRequestCheckSumAndSetRequestHeader(data) {
            var createCheckSumOnReq = null, requestChecksum = null, headerValue = null;

            this.randomString = voltmx.crypto.generateRandomString();

            if(this.isMultiPartOrBinary) {
                createCheckSumOnReq = this.randomString;
            }

            requestChecksum = _integrity.generateRequestCheckSum.call(this, data, createCheckSumOnReq);
            headerValue = (this.randomString + ';' + requestChecksum);

            _setRequestHeader.call(this, _integrityProperties.headerName, headerValue);
        },

        //This function will be called in the scope of http instance
        generateResponseCheckSumAndCheckIntegrity: function Integrity$generateResponseCheckSumAndCheckIntegrity(data) {
            var responseChecksum = null, responseHeaders = null, checkSum =null,
                passthroughHeaderVal = null, createCheckSumOnResp = null,
                responseContentTypes = ['application/text', 'application/json', 'application/xml',
                    'text/xml', 'text/html', 'application/rss+xml', 'text/plain'];

            var getHeaderValue = function(http, headers, headerName) {
                var headerVal = '';
                //eslint-disable-next-line no-prototype-builtins
                if(headerName && (headers.hasOwnProperty(headerName) || headers.hasOwnProperty(headerName.toLowerCase()))) {
                    headerVal = _getResponseHeader.call(http, headerName);
                }
                return headerVal;
            };

            if(_integrityProperties.validateResp) {
                responseHeaders = _getAllResponseHeaders.call(this);
                passthroughHeaderVal = getHeaderValue(this, responseHeaders, _integrityProperties.passthroughHeaderName);
                if(passthroughHeaderVal.trim().toLowerCase() === 'true') {
                    createCheckSumOnResp = this.randomString;
                } else if(responseContentTypes.indexOf(_getResponseHeader.call(this, 'Content-Type').split(';')[0]) === -1) {
                    createCheckSumOnResp = this.randomString;
                }
                responseChecksum = _integrity.generateResponseCheckSum.call(this, data, createCheckSumOnResp);
                checkSum = getHeaderValue(this, responseHeaders, _integrityProperties.headerName);
                _integrity.setIntegrityStatus.call(this, responseChecksum, checkSum);
            }
        },


        isIntegrityCheckRequired: function Integrity$isIntegrityCheckRequired(url, userDisabledIntegrityCheck) {
            var isIntegrityRequired = false, currHost = null, hyperLink = null;

            if(_integrityProperties && !userDisabledIntegrityCheck) {
                if(_integrityProperties.hostNamesList) {
                    if(typeof document !== 'undefined') {
                        hyperLink = document.createElement('a');
                        hyperLink.href = url;
                        currHost = hyperLink.host;
                    } else {
                        currHost = url.replace('http://', '').replace('https://', '').replace('wwww.', '').split('/')[0];
                    }
                    currHost = currHost.toLowerCase();
                    isIntegrityRequired = _integrity.isIntegrityCheckRequiredForThisHost(currHost);
                } else {
                    isIntegrityRequired = true;
                }
            }

            return isIntegrityRequired;
        },

        isIntegrityCheckRequiredForThisHost: function Integrity$isIntegrityCheckRequiredForThisHost(currHost) {
            var i = 0, host = '', hostsLen = 0, isIntegrityRequired = false,
                hostNamesList = _integrityProperties.hostNamesList;

            hostsLen = hostNamesList.length;
            if(hostsLen > 0) {
                for(i = 0; i < hostsLen; i++) {
                    host = hostNamesList[i];
                    if(host.startsWith('*.')) {
                        host = host.replace('*.', '').toLowerCase();
                        if(currHost.endsWith(host)) {
                            isIntegrityRequired = true;
                            break;
                        }
                    } else if(host === currHost) {
                        isIntegrityRequired = true;
                        break;
                    }
                }
            } else {
                isIntegrityRequired = true;
            }

            return isIntegrityRequired;
        },

        //This function will be called in the scope of http instance
        setIntegrityStatus: function Integrity$setIntegrityStatus(responseChecksum, checkSum) {
            if(responseChecksum === checkSum) {
                voltmx.print('Integrity Successful');
                this.integrityStatus = constants.HTTP_INTEGRITY_CHECK_SUCCESSFUL;
            } else {
                this.integrityStatus = constants.HTTP_INTEGRITY_CHECK_FAILED;
            }
        },

        validateHostNamesList: function Integrity$validateHostNamesList(hostNamesList) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, i = 0, j = 0, domain = null,
                domainArr = null, domainLen = 0;

            //eslint-disable-next-line no-useless-escape
            var regex = /^[A-Za-z0-9\\\-]+$/;

            if(!$KU.is(hostNamesList, 'undefined') && !$KU.is(hostNamesList, 'null')) {
                if(!$KU.is(hostNamesList, 'array')) {
                    throw new $KU.error('100', 'Error', 'Invalid argument :- hostNamesList');
                }

                for(i = hostNamesList.length - 1; i >= 0; i--) {
                    domain = hostNamesList[i];
                    if(typeof domain === 'undefined' || domain === null || domain.trim() === '') {
                        throw new $KU.error('100', 'Error', 'Invalid argument :- hostNamesList');
                    }
                    if(domain.startsWith('*.')) {
                        domain = domain.replace('*.', '');
                    }
                    domainArr = domain.split('.');
                    domainLen = domainArr.length;
                    if(domainLen <= 1) {
                        throw new $KU.error('100', 'Error', 'Invalid argument :- hostNamesList');
                    }
                    for(j = domainLen - 1; j >= 0; j--) {
                        if(!regex.test(domainArr[j])) {
                            throw new $KU.error('100', 'Error', 'Invalid argument :- hostNamesList');
                        }
                    }
                }
            }
        },

        validateIntegrityParams: function Integrity$validateIntegrityParams(properties) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                algoList = ($K.behavior.strictMode)?['sha256', 'sha512']:['md5', 'sha1', 'sha256', 'sha512'];

            if(Object.keys(properties).length > 0) {
                _integrity.validateIntegrityPropertyType('validateResp', properties.validateResp, 'boolean');
                _integrity.validateIntegrityPropertyType('algo', properties.algo, 'string');
                _integrity.validateIntegrityPropertyType('salt', properties.salt, 'string');
                _integrity.validateIntegrityPropertyType('headerName', properties.headerName, 'string');

                if((algoList.indexOf(properties.algo.toLowerCase())) === -1) {
                    throw new $KU.error('100', 'Error', 'Invalid argumment' + properties.algo);
                }

                if(properties.salt.length > 1024) {
                    properties.salt = properties.salt.substring(0, 1024);
                }

                if(properties.headerName.length > 64) {
                    properties.headerName = properties.headerName.substring(0, 64);
                }

                if(properties.passthroughHeaderName) {
                    _integrity.validateIntegrityPropertyType('passthroughHeaderName', properties.passthroughHeaderName, 'string');
                    if(properties.passthroughHeaderName.length > 64) {
                        properties.passthroughHeaderName = properties.passthroughHeaderName.substring(0, 64);
                    }
                }

                _integrity.validateHostNamesList(properties.hostNamesList);
            } else {
                throw new $KU.error('101', 'Error', 'Invalid number of arguments');
            }

            return true;
        },

        validateIntegrityPropertyType: function Integrity$validateIntegrityPropertyType(propertyName, propertyValue, propertyType) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            if(typeof propertyValue !== propertyType) {
                throw new $KU.error('100', 'Error', 'Invalid argument' + propertyName);
            }

            return true;
        }

    };


    var _iterator = function(data, arg) {
        var keys = Object.keys(data),
            keyIndex = 0, valueIndex = 0;

        if(arg === 'entries') {
            return {
                next: function() {
                    var key = '', value = null;

                    if(keyIndex < keys.length) {
                        key = keys[keyIndex];
                        value = data[key];

                        if(valueIndex >= value.length) {
                            valueIndex = 0;
                            keyIndex++;
                        }

                        return {
                            done: false,
                            value: [key, value[valueIndex++]]
                        };
                    }
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        } else if(arg === 'keys') {
            return {
                next: function() {
                    if(keyIndex < keys.length) {
                        return {
                            done: false,
                            value: keys[keyIndex++]
                        };
                    }
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        } else if(arg === 'values') {
            return {
                next: function() {
                    var key = '', value = null;

                    if(keyIndex < keys.length) {
                        key = keys[keyIndex];
                        value = data[key];

                        if(valueIndex >= value.length) {
                            valueIndex = 0;
                            keyIndex++;
                        }
                        return {
                            done: false,
                            value: value[valueIndex++]
                        };
                    }
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        }
    };


    var _isNetworkAvailable = function(networkType) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.net.isNetworkAvailable', enter:true});

        if(networkType) {
            if(networkType === constants.NETWORK_TYPE_ANY) {
                if(!$KU.is(navigator.onLine, 'undefined')) {
                    $KU.log({api:'voltmx.net.isNetworkAvailable', exit:true});
                    return navigator.onLine;
                }
                $KU.log({api:'voltmx.net.isNetworkAvailable', exit:true});
                return false;
            } else if(networkType === constants.NETWORK_TYPE_3G
            || networkType === constants.NETWORK_TYPE_WIFI
            || networkType === constants.NETWORK_TYPE_ETHERNET) {
                $KU.log({api:'voltmx.net.isNetworkAvailable', exit:true});
                return false;
            }
            throw new Error('Invalid Network Type');
        } else {
            throw new Error('Invalid Network Type');
        }
    };


    var _loadClientCertificate = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.unsupportedAPI('voltmx.net.loadClientCertificate');
    };


    var _removeAllCachedResponses = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.unsupportedAPI('voltmx.net.removeAllCachedResponses');
    };


    var _removeClientCertificate = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.unsupportedAPI('voltmx.net.removeClientCertificate');
    };


    var _removeIntegrityCheck = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.net.removeIntegrityCheck', enter:true});

        _integrityProperties = null;

        $KU.log({api:'voltmx.net.removeIntegrityCheck', exit:true});
    };


    //This function will be called in the scope of http instance
    var _setRequestHeader = function(header, value) {
        var xhr = this.xhr;

        xhr.setRequestHeader(header, value);
    };


    var _setIntegrityCheck = function(properties) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.net.setIntegrityCheck', enter:true});

        if(_integrity.validateIntegrityParams(properties)) {
            $KU.log('voltmx.net.setIntegrityCheck', properties);

            _integrityProperties = properties;
        }

        $KU.log({api:'voltmx.net.setIntegrityCheck', exit:true});
    };


    var _setNetworkCallbacks = function(config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.net.setNetworkCallbacks', enter:true});

        if($KU.is(config, 'object') && $KU.is(config.statusChange, 'function')) {
            if($KU.is(window.ononline, 'object')) {
                window.addEventListener('online', function() {
                    config.statusChange(navigator.onLine);
                }, false);
            }
            if($KU.is(window.onoffline, 'object')) {
                window.addEventListener('offline', function() {
                    config.statusChange(navigator.onLine);
                }, false);
            }

            $KU.log({api:'voltmx.net.setNetworkCallbacks', enter:true});
        } else {
            throw new Error('Invalid Input : config is not of valid type');
        }
    };

    $K.defVoltmxProp(_ns, [
        {keey:'cancel', value:_cancel},
        {keey:'clearCookies', value:_clearCookies},
        {keey:'FormData', value:_FormData},
        {keey:'getActiveNetworkType', value:_getActiveNetworkType},
        {keey:'getCookies', value:_getCookies},
        {keey:'HttpRequest', value:_HttpRequest},
        {keey:'invokeService', value:_invokeService},
        {keey:'invokeServiceAsync', value:_invokeServiceAsync, writable:true},
        {keey:'isNetworkAvailable', value:_isNetworkAvailable},
        {keey:'loadClientCertificate', value:_loadClientCertificate},
        {keey:'removeAllCachedResponses', value:_removeAllCachedResponses},
        {keey:'removeClientCertificate', value:_removeClientCertificate},
        {keey:'removeIntegrityCheck', value:_removeIntegrityCheck},
        {keey:'setIntegrityCheck', value:_setIntegrityCheck},
        {keey:'setNetworkCallbacks', value:_setNetworkCallbacks}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxnosql.js' */
/* globals Promise */
Object.defineProperty(voltmx, 'nosql', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$, _validTypes = null, _validOrders = null, _validOperators = null,
        _AND = '&&', _ASCENDING = 'ASC', _DESCENDING = 'DESC', _EQ = '=',
        _GT = '>', _GTE = '>=', _LT = '<', _LTE = '<=', _NEQ = '!=',
        _OR = '||', _READ = 'read', _READ_WRITE = 'readwrite', _REGEXP = null,
        _NOT_SUPPORTED_MSG = 'Your browser doesn\'t support a stable version of IndexedDB.',
        _ENDS_WITH = '', _CONTAINS = '', _NOT_CONTAINS = '', _NOT_ENDS_WITH = '',
        _NOT_STARTS_WITH = '', _STARTS_WITH = '',
        _iDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;


    var _deleteAllByIndex = function(objectStore, index, keyRangeValue) {
        return new Promise(function(resolve, reject) {
            var cursor, i, recordToDelete = [], recordCount = 0, record, successCallback;

            successCallback = function(/*event*/) {
                recordCount++;

                if(recordCount === recordToDelete.length) {
                    resolve();
                }
            };

            cursor = index.openCursor(keyRangeValue);
            cursor.onsuccess = function(event) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, cursor = event.target.result, request;

                if(cursor) {
                    if($KU.browser('name') === 'safari') {
                        record = cursor.primaryKey;
                        recordToDelete.push(record);
                    } else {
                        request = cursor.delete();

                        request.onsuccess = function(/*event*/) {
                            //Do nothing
                        };
                        request.onerror = function(event) {
                            reject(event);
                        };
                    }

                    cursor.continue();
                } else {
                    if(recordToDelete.length === 0) { //it gets executed for Safari and also in the case of records not found for applied filter
                        resolve();
                    } else {
                        for(i=0; i<recordToDelete.length; i++) {
                            request = objectStore.delete(recordToDelete[i]);
                            request.onsuccess = successCallback.bind(this, recordCount, recordToDelete);
                            request.onerror = function(event) {
                                reject(event);
                            };
                        }
                    }
                }
            };

            cursor.onerror = function(event) {
                reject(event);
            };
        });
    };


    var _evaluate = function(record, rule) {
        var result = false, col = record[rule.column], val = rule.value;

        switch(rule.operator) {
            case _ENDS_WITH:
                result = (col.indexOf(val) === (col.length - val.length)) ? true : false;
                break;
            case _EQ:
                result = (col === val);
                break;
            case _GT:
                result = (col > val);
                break;
            case _GTE:
                result = (col >= val);
                break;
            case _CONTAINS:
                result = (col.indexOf(val) >= 0) ? true : false;
                break;
            case _LT:
                result = (col < val);
                break;
            case _LTE:
                result = (col <= val);
                break;
            case _NEQ:
                result = (col !== val);
                break;
            case _NOT_CONTAINS:
                result = (col.indexOf(val) >= 0) ? false : true;
                break;
            case _NOT_ENDS_WITH:
                result = (col.indexOf(val) === (col.length - val.length)) ? false : true;
                break;
            case _NOT_STARTS_WITH:
                result = (col.indexOf(val) === 0) ? false : true;
                break;
            case _STARTS_WITH:
                result = (col.indexOf(val) === 0) ? true : false;
                break;
            case _REGEXP:
                val.lastIndex = 0;
                result = val.test(col);
                break;
            default:
                break;
        }

        return result;
    };


    var _expression = function(record, condition) {
        var str = '', c = 0, clen = condition.length;

        for(c=0; c<clen; c++) {
            if(condition[c] instanceof Array) {
                str += _expression(record, condition[c]);
            } else if(typeof condition[c] === 'string') {
                str += (' ' + condition[c] + ' ');
            } else if(typeof condition[c] === 'object' && condition[c]) {
                str += _evaluate(record, condition[c]);
            }
        }

        return ('(' + str + ')');
    }; //eval(_expression(record, condition))


    var _filterRecords = function(records, condition) {
        return records.filter(function(record) {
            return _isConditionMatched(record, condition);
        });
    };


    //This method is the polyfil of ObjectStore getAll API.
    //In Edge browser getAll API is not available on ObjectStore
    var _getAll = function(objectStore) {
        var records = [];

        return new Promise(function(resolve, reject) {
            var cursor = objectStore.openCursor();
            cursor.onsuccess = function(event) {
                var cursor = event.target.result, record;

                if(cursor) {
                    record = cursor.value;
                    records.push(record);
                    cursor.continue();
                } else {
                    resolve(records);
                }
            };

            cursor.onerror = function(event) {
                reject(event);
            };
        });
    };


    var _getAllByIndex = function(index, keyRangeValue) {
        var records = [];

        return new Promise(function(resolve, reject) {
            var cursor = index.openCursor(keyRangeValue);

            cursor.onsuccess = function(event) {
                var cursor = event.target.result, record;

                if(cursor) {
                    record = cursor.value;
                    records.push(record);
                    cursor.continue();
                } else {
                    resolve(records);
                }
            };

            cursor.onerror = function(event) {
                reject(event);
            };
        });
    };


    var _getDataBaseName = function(dbName) {
        var $K = voltmx.$kwebfw$, $KA = $K.app;

        return ($KA.id + '_' + dbName);
    };


    var _getKeyRangeValue = function(data) {
        var keyRangeValue;

        switch(data.operator) {
            case _EQ:
                keyRangeValue = IDBKeyRange.only(data.value);
                break;
            case _GT:
                keyRangeValue = IDBKeyRange.lowerBound(data.value, true);
                break;
            case _GTE:
                keyRangeValue = IDBKeyRange.lowerBound(data.value);
                break;
            case _LT:
                keyRangeValue = IDBKeyRange.upperBound(data.value, true);
                break;
            case _LTE:
                keyRangeValue = IDBKeyRange.upperBound(data.value);
                break;
            default:
                break;
            //need to find solution for mosule.NEQ
        }

        return keyRangeValue;
    };


    var _getObjectValues= function(obj) {
        var values = [], key;

        for(key in obj) {
            if(Object.prototype.hasOwnProperty.call(obj, key)) {
                values.push(obj[key]);
            }
        }

        return values;
    };


    var _isConditionOptimizable = function(condition, objectStore) {
        var canOperatorFitInKeyRange, column, isColumnIndexed, operator, isValueBoolean;

        if(!(condition instanceof voltmx.nosql.Condition)
        || condition.data.length !== 1) {
            return false;
        }

        column = condition.data[0].column;
        operator = condition.data[0].operator;
        isColumnIndexed = objectStore.indexNames.contains(column);
        canOperatorFitInKeyRange = (operator !== _NEQ && operator !== _REGEXP);
        isValueBoolean = (typeof condition.data[0].value === 'boolean');

        return (isColumnIndexed && canOperatorFitInKeyRange && !isValueBoolean);
    };


    var _isConditionMatched = function(record, condition) {
        return eval(_expression(record, condition)); // eslint-disable-line no-eval
    };


    var _replaceRecordValues = function(record, valueObject, includeKeys) {
        var key;

        for(key in valueObject) {
            if(includeKeys instanceof Array) {
                if(includeKeys.indexOf(key) !== -1) {
                    record[key] = valueObject[key];
                }
            } else {
                record[key] = valueObject[key];
            }
        }

        return record;
    };


    var _updateAllByIndex = function(objectStore, index, keyRangeValue, updateObject) {
        return new Promise(function(resolve, reject) {
            var cursor, i, recordCount = 0, recordsToAdd = [], successCallback;

            successCallback = function(/*event*/) {
                recordCount++;

                if(recordCount === recordsToAdd.length) {
                    resolve();
                }
            };

            cursor = index.openCursor(keyRangeValue);

            cursor.onsuccess = function(event) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, record,
                    cursor = event.target.result, request;

                if(cursor) {
                    record = cursor.value;
                    record = _replaceRecordValues(record, updateObject);

                    if($KU.browser('name') === 'safari') {
                        recordsToAdd.push(record);
                    } else {
                        request = cursor.update(record);

                        request.onsuccess = function(/*event*/) {
                            //Do nothing
                        };
                        request.onerror = function(/*event*/) {
                            reject();
                        };
                    }

                    cursor.continue();
                } else {
                    if(recordsToAdd.length === 0) {
                        resolve();
                    } else {
                        for(i=0; i<recordsToAdd.length; i++) {
                            request = objectStore.put(recordsToAdd[i]);
                            request.onsuccess = successCallback.bind(this, recordCount, recordsToAdd);

                            request.onerror = function(event) {
                                reject(event);
                            };
                        }
                    }
                }
            };

            cursor.onerror = function(event) {
                reject(event);
            };
        });
    };


    /***************************************************************************
    *                                                                          *
    *                                                                          *
    ****************************************************************************/
    var _addOrReplaceRecords = function $K_nosql_addOrReplaceRecords(transaction, tableName, records) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;
        $KU.log({api:'voltmx.nosql.addOrReplaceRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var i = 0, storeReq = null, tx = null, store = null,
                    onerrorcb = function(event) {
                        reject(event.target.error);
                    },
                    replaceNext = function() {
                        if(i < records.length) {
                            storeReq = store.put(records[i]);
                            storeReq.onsuccess = replaceNext;
                            storeReq.onerror = onerrorcb;
                            ++i;
                        } else {
                            $KU.log({api:'voltmx.nosql.addOrReplaceRecords', exit:true});
                            resolve();
                        }
                    };

                if(!(transaction instanceof _Transaction)) {
                    $KU.log('error', 'Pass proper transaction object.');
                    reject({'errorMsg': 'Pass proper transaction object.'});
                }

                tx = transaction.tx;
                store = tx.objectStore(tableName);

                replaceNext();
            });

            return promise;
        }
    };


    var _addRecords = function $K_nosql_addRecords(transaction, tableName, data) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;
        $KU.log({api:'voltmx.nosql.addRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var i = 0, storeReq = null, tx = null, store = null,
                    onerrorcb = function(event) {
                        $KU.log('error', 'unknown error' + event.target.error);
                        reject(event.target.error);
                    },
                    addNext = function() {
                        if(i < data.length) {
                            storeReq = store.add(data[i]);
                            storeReq.onsuccess = addNext;
                            storeReq.onerror = onerrorcb;
                            ++i;
                        } else {
                            $KU.log({api:'voltmx.nosql.addRecords', exit:true});
                            resolve();
                        }
                    };

                if(transaction instanceof _Transaction) {
                    tx = transaction.tx;
                    store = tx.objectStore(tableName);
                    addNext();
                } else {
                    $KU.log('error', 'Pass proper transaction object.');
                    reject({errorMsg: 'Pass proper transaction object.'});
                }
            });

            return promise;
        }
    };


    var _clearTable = function $K_nosql_clearTable(transaction, tableName) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;
        $KU.log({api:'voltmx.nosql.clearTable', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var objectStore, tx, request;

                if(transaction instanceof _Transaction) {
                    tx = transaction.tx;
                    objectStore = tx.objectStore(tableName);
                    request = objectStore.clear();

                    request.onsuccess = function(/*event*/) {
                        $KU.log({api:'voltmx.nosql.clearTable', exit:true});
                        resolve();
                    };
                    request.onerror = function(event) {
                        reject(event.target.error);
                    };
                } else {
                    $KU.log('error', 'Pass proper transaction object.');
                    reject({errorMsg: 'Pass proper transaction object.'});
                }
            });

            return promise;
        }
    };


    var _closeDatabase = function $K_nosql_closeDatabase(database) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.closeDatabase', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var db;

                if(database instanceof _DataBase) {
                    db = database.db;
                    try{
                        db.close();
                        delete database.dbOpenRequest;
                        $KU.log({api:'voltmx.nosql.closeDatabase', exit:true});
                        resolve();
                    } catch(error) {
                        $KU.log('error', 'unknown error' + error);
                        delete database.dbOpenRequest;
                        reject(error);
                    }
                } else {
                    $KU.log('error', 'Pass proper database object.');
                    reject({'errorMsg': 'Pass proper database object.'});
                }
            });

            return promise;
        }
    };


    var _createIndices = function $K_nosql_createIndices(database, tableName, indexes) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.createIndices', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request, store, transaction, index;

                try{
                    request = database.dbOpenRequest;
                    transaction = request.transaction;
                    store = transaction.objectStore(tableName);

                    for(index in indexes) {
                        store.createIndex(index, index, indexes[index]);
                    }
                } catch(error) {
                    reject(error);
                }

                transaction.oncomplete = function(/*e*/) {
                    $KU.log({api:'voltmx.nosql.createIndices', exit:true});
                    resolve(true);
                };
            });

            return promise;
        }
    };


    var _createTable = function $K_nosql_createTable(transaction, tableName, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, index = '',
            primaryKey = config.primaryKey, objectStore = null,
            indexes = config.indexes || {}, db = transaction.db;
            /*autoIncrement = $KU.is(primaryKey, 'array') ? false : config.autoIncrement;*/

        $KU.log({api:'voltmx.nosql.createTable', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            objectStore = db.createObjectStore(tableName, {keyPath: primaryKey, autoIncrement: false});
            for(index in indexes) {
                objectStore.createIndex(index, index, indexes[index]);
            }
        }
        $KU.log({api:'voltmx.nosql.createTable', exit:true});
    };


    var _databaseExists = function $K_nosql_databaseExists(databaseName) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.databaseExists', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request = _iDB.open(_getDataBaseName(databaseName));

                request.onupgradeneeded = function(event) {
                    event.target.transaction.abort();
                    $KU.log({api:'voltmx.nosql.databaseExists', exit:true});
                    resolve(false);
                };
                request.onsuccess = function(event) {
                    var database = event.target.result;
                    $KU.log({api:'voltmx.nosql.databaseExists', exit:true});
                    resolve(true);
                    database.close();
                };
                request.onerror = function(event) {
                    $KU.log('error', 'unknown error' + event.target.error);
                    reject(event.target.error);
                };
            });

            return promise;
        }
    };


    var _databaseVersion = function $K_nosql_databaseVersion(databaseName) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.databaseVersion', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request = _iDB.open(_getDataBaseName(databaseName));

                request.onupgradeneeded = function(event) {
                    event.target.transaction.abort();
                    $KU.log({api:'voltmx.nosql.databaseVersion', exit:true});
                    resolve(0);
                };
                request.onsuccess = function(event) {
                    var database = event.target.result;
                    resolve(database.version);
                    $KU.log({api:'voltmx.nosql.databaseVersion', exit:true});
                    database.close();
                };
                request.onerror = function(event) {
                    $KU.log('error', 'unknown error' + event.target.error);
                    reject(event.target.error);
                };
            });

            return promise;
        }
    };


    var _deleteDatabase = function $K_nosql_deleteDatabase(databaseName) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.deleteDatabase', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request = _iDB.deleteDatabase(_getDataBaseName(databaseName));

                request.onsuccess = function(/*event*/) {
                    $KU.log({api:'voltmx.nosql.deleteDatabase', exit:true});
                    resolve();
                };
                request.onerror = function(event) {
                    $KU.log('error', 'unknown error' + event.target.error);
                    reject(event.target.error);
                };
            });

            return promise;
        }
    };


    var _deleteIndices = function $K_nosql_deleteIndices(database, tableName, indexes) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.deleteIndices', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request, store, transaction, index;

                try{
                    request = database.dbOpenRequest;
                    transaction = request.transaction;
                    store = transaction.objectStore(tableName);

                    for(index in indexes) {
                        store.deleteIndex(index);
                    }
                } catch(error) {
                    reject(error);
                }

                transaction.oncomplete = function(/*e*/) {
                    $KU.log({api:'voltmx.nosql.deleteIndices', exit:true});
                    resolve(true);
                };
            });

            return promise;
        }
    };


    var _deleteRecords = function $K_nosql_deleteRecords(transaction, tableName, condition) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.deleteRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var tx, objectStore, data, keyRangeValue, index;

                if(!(transaction instanceof _Transaction)) {
                    $KU.log('error', 'Pass proper transaction object');
                    reject({'errorMsg': 'Pass proper transaction object'});
                }

                tx = transaction.tx;
                objectStore = tx.objectStore(tableName);

                if(_isConditionOptimizable(condition, objectStore)) {
                    data = condition.data[0];
                    keyRangeValue = _getKeyRangeValue(data);
                    index = objectStore.index(data.column);

                    if(keyRangeValue) {
                        _deleteAllByIndex(objectStore, index, keyRangeValue).then(function() {
                            $KU.log({api:'voltmx.nosql.deleteRecords', exit:true});
                            resolve();
                        }).catch(function(event) {
                            $KU.log('error', 'unknown error' + event.message);
                            reject({errorMsg: event.message});
                        });
                    }
                } else {
                    objectStore.openCursor().onsuccess = function(event) {
                        var cursor = event.target.result, request;

                        if(cursor) {
                            if(!condition || _isConditionMatched(cursor.value, condition.data)) {
                                request = cursor.delete();

                                request.onsuccess = function(/*event*/) {
                                    $KU.log('info', 'deleteRecords success');
                                };
                                request.onerror = function(event) {
                                    reject(event.target.error);
                                };
                            }

                            cursor.continue();
                        } else {
                            resolve();
                        }
                    };
                }
            });

            return promise;
        }
    };


    var _deleteTable = function $K_nosql_deleteTable(database, tableName) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.deleteTable', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var db;

                if(database instanceof _DataBase) {
                    db = database.db;
                    db.deleteObjectStore(tableName);
                    $KU.log({api:'voltmx.nosql.deleteTable', exit:true});
                    resolve();
                } else {
                    $KU.log('error', 'Pass proper database object.');
                    reject({errorMsg: 'Pass proper database object.'});
                }
            });

            return promise;
        }
    };


    var _fetchRecords = function $K_nosql_fetchRecords(transaction, tableName, condition) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.fetchRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var resultSet = null, objectStore, tx, data, keyRangeValue, index;
                var successCallback = function(records) {
                    if(condition instanceof _Condition) {
                        records = _filterRecords(records, condition.data);
                    }

                    resultSet = new _Result(records);
                    $KU.log({api:'voltmx.nosql.fetchRecords', exit:true});
                    resolve(resultSet);
                };
                var errorCallback = function(event) {
                    $KU.log('error', 'unknown error' + event.target.error);
                    reject(event.target.error);
                };

                if(!(transaction instanceof _Transaction)) {
                    $KU.log('error', 'Pass proper transaction object');
                    reject({'errorMsg': 'Pass proper transaction object'});
                }

                tx = transaction.tx;
                objectStore = tx.objectStore(tableName);

                if(_isConditionOptimizable(condition, objectStore)) {
                    data = condition.data[0];
                    keyRangeValue = _getKeyRangeValue(data);
                    index = objectStore.index(data.column);

                    if(keyRangeValue) {
                        _getAllByIndex(index, keyRangeValue).then(function(records) {
                            resultSet = new _Result(records);
                            resolve(resultSet);
                        }).catch(function(event) {
                            reject(event.target.error);//todo
                        });
                    }
                } else {
                    if(objectStore.getAll) {
                        objectStore = objectStore.getAll();
                    } else {
                        _getAll(objectStore).then(function(records) {
                            successCallback(records);
                        }).catch(function(errorObj) {
                            errorCallback(errorObj);
                        });
                    }
                    objectStore.onsuccess = function(event) {
                        successCallback(event.target.result);
                    };
                    objectStore.onerror = errorCallback;
                }
            });

            return promise;
        }
    };


    var _getPrimaryKeys = function $K_nosql_getPrimaryKeys(database, tableName, transaction) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.getPrimaryKeys', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var primaryKeys, objectStore;
                var _getPrimaryKeys = function(transaction) {
                    var primaryKeys = [];

                    objectStore = transaction.tx.objectStore(tableName);
                    primaryKeys = (typeof objectStore.keyPath === 'string')
                        ? [objectStore.keyPath] : objectStore.keyPath;

                    return primaryKeys;
                };

                voltmx.nosql.tableExists(database, tableName).then(function(exists) {
                    if(exists) {
                        if(!transaction) {
                            voltmx.nosql.openTransaction(database, [tableName], voltmx.nosql.READ_WRITE, function(transaction) {
                                primaryKeys = _getPrimaryKeys(transaction);
                            }).then(function() {
                                $KU.log({api:'voltmx.nosql.getPrimaryKeys', exit:true});
                                resolve(primaryKeys);
                            }).catch(function(error) {
                                reject(error);
                            });
                        } else {
                            $KU.log({api:'voltmx.nosql.getPrimaryKeys', exit:true});
                            resolve(_getPrimaryKeys(transaction));
                        }
                    } else {
                        $KU.log('error', 'Table doesn\'t exists.');
                        reject({errorMsg: 'Table doesn\'t exists.'});
                    }
                }).catch(function(error) {
                    reject(error);
                });
            });

            return promise;
        }
    };


    var _getTables = function $K_nosql_getTables(database) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.getTables', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var db;

                if(database instanceof _DataBase) {
                    db = database.db;
                    $KU.log({api:'voltmx.nosql.getTables', exit:true});
                    resolve(_getObjectValues(db.objectStoreNames));
                } else {
                    $KU.log('error', 'Pass proper database object.');
                    reject({errorMsg: 'Pass proper database object.'});
                }
            });

            return promise;
        }
    };


    var _openDatabase = function $K_nosql_openDatabase(databaseName, version, upgradeCallback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.openDatabase', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request, kdb;

                if(version) {
                    request = _iDB.open(_getDataBaseName(databaseName), version);
                } else {
                    request = _iDB.open(_getDataBaseName(databaseName));
                }

                request.onerror = function(event) {
                    reject(event.target.error);
                };
                request.onsuccess = function(/*event*/) {
                    var db = request.result;

                    kdb = kdb || new _DataBase(db, 'indexedDB', request);
                    $KU.log({api:'voltmx.nosql.openDatabase', exit:true});
                    resolve(kdb);
                };
                request.onupgradeneeded = function(event) {
                    var db = event.target.result;

                    kdb = new _DataBase(db, 'indexedDB', request);
                    upgradeCallback && upgradeCallback(kdb);
                };
            });

            return promise;
        }
    };


    var _openTransaction = function $K_nosql_openTransaction(database, tableNames, accessType, callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.openTransaction', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var db = database.db, tx = db.transaction(tableNames, accessType),
                    transaction = new _Transaction(tx);

                callback(transaction);

                tx.oncomplete = function(/*e*/) {
                    $KU.log({api:'voltmx.nosql.openTransaction', exit:true});
                    resolve(transaction);
                };
                tx.onerror = function(e) {
                    $KU.log('error', 'unknown error' + e);
                    reject(e.target.error);
                };
                tx.onabort = function(e) {
                    $KU.log('error', 'unknown error' + e);
                    reject(e.target.error);
                };
            });

            return promise;
        }
    };


    var _replaceRecords = function $K_nosql_replaceRecords(transaction, tableName, replaceObject, condition) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.replaceRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                voltmx.nosql.fetchRecords(transaction, tableName, condition).then(function(resultSet) {
                    var i = 0, storeReq = null, store, records = resultSet.data,
                        onerrorcb = function(event) {
                            reject(event.target.error);
                        },
                        replaceNext = function() {
                            var record, primaryKeys;

                            if(i < records.length) {
                                record = records[i];
                                primaryKeys = (typeof store.keyPath === 'string') ? [store.keyPath] : store.keyPath;

                                record = _replaceRecordValues(replaceObject, record, primaryKeys);

                                storeReq = store.put(record);
                                storeReq.onsuccess = replaceNext;
                                storeReq.onerror = onerrorcb;
                                ++i;
                            } else {
                                $KU.log({api:'voltmx.nosql.replaceRecords', exit:true});
                                resolve();
                            }
                        };

                    if(!(transaction instanceof _Transaction)) {
                        $KU.log('error', 'Pass proper transaction object.');
                        reject({'errorMsg': 'Pass proper transaction object.'});
                    }

                    store = transaction.tx.objectStore(tableName);

                    replaceNext();
                }).catch(function(error) {
                    $KU.log('error', 'unknown error' + error);
                    reject(error);
                });
            });

            return promise;
        }
    };


    var _tableExists = function $K_nosql_tableExists(database, tableName) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.tableExists', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var tableExists;

                if(database instanceof _DataBase) {
                    voltmx.nosql.getTables(database).then(function(tables) {
                        if(tables.indexOf(tableName) !== -1) {
                            tableExists = true;
                        } else {
                            tableExists = false;
                        }
                        $KU.log({api:'voltmx.nosql.tableExists', exit:true});
                        resolve(tableExists);
                    }).catch(function(error) {
                        reject(error);
                    });
                } else {
                    $KU.log('error', 'Pass proper database object.');
                    reject({errorMsg: 'Pass proper database object.'});
                }
            });

            return promise;
        }
    };


    var _updateRecords = function $K_nosql_updateRecords(transaction, tableName, updateObject, condition) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'voltmx.nosql.updateRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var index, objectStore, data, keyRangeValue;


                if(!(transaction instanceof _Transaction)) {
                    $KU.log('error', 'Pass proper transaction object.');
                    reject({'errorMsg': 'Pass proper transaction object'});
                }

                objectStore = transaction.tx.objectStore(tableName);

                if(_isConditionOptimizable(condition, objectStore)) {
                    data = condition.data[0];
                    index = objectStore.index(data.column);
                    keyRangeValue = _getKeyRangeValue(data);

                    if(keyRangeValue) {
                        _updateAllByIndex(objectStore, index, keyRangeValue, updateObject).then(function() {
                            $KU.log({api:'voltmx.nosql.updateRecords', exit:true});
                            resolve();
                        }).catch(function(event) {
                            $KU.log('error', 'unknown' + event.message);
                            reject({errorMsg: event.message});
                        });
                    }
                } else {
                    objectStore.openCursor().onsuccess = function(event) {
                        var cursor = event.target.result, record, request;

                        if(cursor) {
                            record = cursor.value;
                            if(!condition || _isConditionMatched(record, condition.data)) {
                                record = _replaceRecordValues(record, updateObject);
                                request = cursor.update(record);
                                request.onsuccess = function(/*event*/) {
                                    $KU.log('info', 'Successfully deleting record.');
                                };
                                request.onerror = function(/*event*/) {
                                    reject();
                                };
                            }

                            cursor.continue();
                        } else {
                            resolve();
                        }
                    };
                }
            });

            return promise;
        }
    };


    /***************************************************************************
    *                                                                          *
    ****************************************************************************/
    var _Condition = function Condition(ruleOrCondition) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = null;

        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else if(!(this instanceof _Condition)) {
            //Throw Error:: Must be called with new operator.
        } else {
            data = [];

            Object.defineProperty(this, 'data', {
                configurable: true,
                enumerable: false,
                get: function() {
                    return (this.passReference) ? data : data.slice(0);
                }
            });
            Object.defineProperty(this, 'data', {
                configurable: false,
                enumerable: false,
                set: function(/*value*/) {}
            });

            if(ruleOrCondition instanceof _Rule) {
                data.push({
                    'column':   ruleOrCondition.column,
                    'operator': ruleOrCondition.operator,
                    'value':    ruleOrCondition.value
                });
            } else if(ruleOrCondition instanceof _Condition) {
                data.push(ruleOrCondition.data);
            } else {
                //Throw Error:: Invalid Argument
            }
        }
    };

    Object.defineProperty(_Condition.prototype, 'addCondition', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function(type, condition) {
            if(_validTypes.indexOf(type) >= 0 && condition instanceof _Condition) {
                this.passReference = true;
                this.data.push(type);
                this.data.push(condition.data);
                delete this.passReference;
            } else {
                //TODO:: Throw Error
            }

            return this;
        }
    });

    Object.defineProperty(_Condition.prototype, 'addRule', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function(type, rule) {
            if(_validTypes.indexOf(type) >= 0 && rule instanceof _Rule) {
                this.passReference = true;
                this.data.push(type);
                this.data.push({
                    'column':   rule.column,
                    'operator': rule.operator,
                    'value':    rule.value
                });
                delete this.passReference;
            } else {
                //TODO:: Throw Error:: Invalid Arguments
            }

            return this;
        }
    });

    //Any record cannot contain an object as any of its column value
    Object.defineProperty(_Condition.prototype, 'toString', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function() {
            var stringifyCondition = function(condition) {
                var str = '', c = 0, clen = condition.length;

                for(c=0; c<clen; c++) {
                    if(condition[c] instanceof Array) {
                        str += stringifyCondition(condition[c]);
                    } else if(typeof condition[c] === 'string') {
                        str += (' ' + condition[c] + ' ');
                    } else if(typeof condition[c] === 'object' && condition[c]) {
                        str += stringifyRule(condition[c]);
                    }
                }

                return ('(' + str + ')');
            };

            var stringifyRule = function(rule) {
                var str = rule.column + ' ' + rule.operator + ' ';

                if(typeof rule.value === 'string') {
                    //TODO:: Escape all 'backslash', 'doublequote'
                    str += ('\'' + rule.value + '\'');
                } else {
                    str += rule.value;
                }

                return str;
            };

            return stringifyCondition(this.data);
        }
    });


    /***************************************************************************
    *                                                                          *
    ****************************************************************************/
    var _DataBase = function DataBase(db, dbType, dbOpenRequest) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            Object.defineProperty(this, 'db', {
                configurable: false,
                enumerable: false,
                writable: false,
                value: db
            });
            Object.defineProperty(this, 'dbType', {
                configurable: false,
                enumerable: false,
                writable: false,
                value: dbType
            });
            Object.defineProperty(this, 'dbOpenRequest', {
                configurable: true,
                enumerable: false,
                writable: false,
                value: dbOpenRequest
            });
        }
    };


    /***************************************************************************
    *                                                                          *
    ****************************************************************************/
    var _Result = function Result(data) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, index = -1, length = -1;

        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            data = (data instanceof Array) ? data : [];

            Object.defineProperty(this, 'data', {
                configurable: true,
                enumerable: false,
                get: function() {
                    return (this.passReference) ? data : data.slice(0);
                }
            });
            Object.defineProperty(this, 'data', {
                configurable: false,
                enumerable: false,
                set: function(/*value*/) {}
            });


            Object.defineProperty(this, 'length', {
                configurable: true,
                enumerable: false,
                get: function() {
                    if(length === -1) {
                        length = data.length;
                    }

                    return length;
                }
            });
            Object.defineProperty(this, 'length', {
                configurable: false,
                enumerable: false,
                set: function(/*value*/) {}
            });


            Object.defineProperty(this, 'next', {
                configurable: true,
                enumerable: false,
                get: function() {
                    ++index;
                    return (index >= 0 && index < data.length) ? true : false;
                }
            });
            Object.defineProperty(this, 'next', {
                configurable: false,
                enumerable: false,
                set: function(/*value*/) {}
            });


            Object.defineProperty(this, 'record', {
                configurable: true,
                enumerable: false,
                get: function() {
                    return (index >= 0 && index < data.length) ? data[index] : null;
                }
            });
            Object.defineProperty(this, 'record', {
                configurable: false,
                enumerable: false,
                set: function(/*value*/) {}
            });
        }
    };

    Object.defineProperty(_Result.prototype, 'groupBy', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function(columnNames, index) {
            var data = null;

            this.passReference = true;
            data = this.data;
            delete this.passReference;
            var result = {};

            function __prepareMap() {
                var row, name, i, j;
                for(i = 0; i < data.length; i++) {
                    row = data[i];
                    name = '';
                    for(j = 0; j < columnNames.length; j++) {
                        name += row[columnNames[j]];
                        if(j < columnNames.length -1) {
                            name += '&_';
                        }
                    }

                    if(name in result) {
                        result[name].push(row);
                    } else {
                        result[name] = [row];
                    }
                }
                //console.log(result);
            }

            function __prepareResults() {
                var resultSet = [], i, key, finalResult = [];
                for(key in result) {
                    resultSet.push(result[key]);
                }

                if(typeof index === 'number') {
                    for(i = 0; i < resultSet.length; i++) {
                        if(index >= 0) {
                            finalResult.push(resultSet[i][index]);
                        } else {
                            key = resultSet[i].length + index;
                            finalResult.push(resultSet[i][key]);
                        }
                    }
                    return finalResult;
                }
                return resultSet;
            }

            if(columnNames instanceof Array) {
                /* eslint-disable no-useless-catch */
                try{
                    __prepareMap();
                    return __prepareResults();
                } catch(e) {
                    throw e;
                }
                /* eslint-enable no-useless-catch */
            }
        }
    });

    Object.defineProperty(_Result.prototype, 'limit', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function(startIndex, recordCount) {
            var data = null, copy = null, c = 0, clen = 0;

            if(typeof startIndex === 'number'
            && typeof recordCount === 'number'
            && startIndex >= 0 && recordCount >= 0) {
                this.passReference = true;
                data = this.data;
                delete this.passReference;

                copy = data.splice(0);
                clen = copy.length;

                for(c=startIndex; c<=recordCount; c++) {
                    if(c < clen) {
                        data.push(copy[c]);
                    } else {
                        break;
                    }
                }
            } else {
                //Throw Error:: Invalid Arguments
            }

            return this;
        }
    });

    Object.defineProperty(_Result.prototype, 'sort', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function(columnName, order) {
            var data = null;

            function __localsort(data, name, order) {
                data.sort(function(a, b) {
                    a = a[name];
                    b = b[name];
                    if(order === voltmx.nosql.ASCENDING) {
                        return (a > b) ? 1 : (a < b) ? -1 : 0;
                    }
                    return (a > b) ? -1 : (a < b) ? 1 : 0;
                });
            }

            function __groupByName(data, name) {
                var i, result = [], temp = [], value;

                temp.push(data[0]);
                value = data[0][name];

                for(i = 1; i < data.length; i++) {
                    if(data[i][name] === value) {
                        temp.push(data[i]);
                    } else {
                        if(temp.length === 1) {
                            result.push(temp[0]);
                        } else {
                            result.push(temp);
                        }

                        temp = [];
                        value = data[i][name];
                        temp.push(data[i]);
                    }
                }

                result.push(temp);
                return result;
            }

            function __createFlatArray(result) {
                var i, len, temp = [];

                for(i = 0; i < result.length; i++) {
                    if(result[i] instanceof Array) {
                        for(len = 0; len < result[i].length; len++) {
                            temp.push(result[i][len]);
                        }
                    } else {
                        temp.push(result[i]);
                    }
                }

                return temp;
            }

            function __orderBY(data, index, order) {
                var i, result = [], result1 = [];

                if(index >= columnName.length) {
                    return data;
                }

                __localsort(data, columnName[index], order);
                result = __groupByName(data, columnName[index]);

                for(i = 0; i < result.length; i++) {
                    if(result[i] instanceof Array) {
                        result1 = __orderBY(result[i], index+1, order);
                        result[i] = result1;
                    }
                }

                result = __createFlatArray(result);
                return result;
            }

            this.passReference = true;
            data = this.data;
            delete this.passReference;

            if(typeof columnName === 'function') {
                data.sort(columnName);
            } else if(typeof columnName === 'string'
            && _validOrders.indexOf(order) >= 0) {
                data.sort(function(a, b) {
                    a = a[columnName];
                    b = b[columnName];

                    if(order === voltmx.nosql.ASCENDING) {
                        return (a > b) ? 1 : (a < b) ? -1 : 0;
                    }
                    return (a > b) ? -1 : (a < b) ? 1 : 0;
                });
            } else if(columnName instanceof Array
            && _validOrders.indexOf(order) >= 0) {
                var i, sortedData = [];

                sortedData = this.data;
                sortedData = __orderBY(sortedData, 0, order);
                data.splice(0, data.length);

                for(i =0; i < sortedData.length; i++) {
                    data.push(sortedData[i]);
                }
            } else {
                //Throw Error:: Invalid Arguments
            }

            return this;
        }
    });


    /*
    var r1 = new _Rule('col_01', '===', 'A');
    var r2 = new _Rule('col_01', '===', 'B');
    var r3 = new _Rule('col_01', '===', 'C');
    var r4 = new _Rule('col_01', '===', 'D');
    var r5 = new _Rule('col_01', '===', 'E');
    var r6 = new _Rule('col_01', '===', 'F');
    var r7 = new _Rule('col_01', '===', 'G');

    var c1 = new _Condition(r1);
    var c2 = new _Condition(r3);
    var c3 = new _Condition(r4);
    var c4 = new _Condition(r6);

    c1.addRule('&&', r2);
    c3.addRule('||', r5);
    c4.addRule('||', r7);

    c3.addCondition('&&', c4);
    c1.addCondition('||', c2);
    c1.addCondition('||', c3);
    //*/
    /***************************************************************************
    *                                                                          *
    ****************************************************************************/
    var _Rule = function Rule(column, operator, value) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else if(!(this instanceof _Rule)) {
            //Throw Error:: Must be called with new operator.
        } else if(operator === _REGEXP && !(value instanceof RegExp)) {
            throw Error('Invalid arguments.');
        } else if(!(arguments.length === 3
        && typeof column === 'string' && column
        && _validOperators.indexOf(operator) >= 0)) {
            //Throw Error:: Invalid Arguments
        } else {
            Object.defineProperty(this, 'column', {
                configurable: true,
                enumerable: true,
                get: function() {
                    return column;
                }
            });
            Object.defineProperty(this, 'column', {
                configurable: false,
                enumerable: true,
                set: function(val) {
                    column = val;
                }
            });


            Object.defineProperty(this, 'operator', {
                configurable: true,
                enumerable: true,
                get: function() {
                    return operator;
                }
            });
            Object.defineProperty(this, 'operator', {
                configurable: false,
                enumerable: true,
                set: function(val) {
                    operator = val;
                }
            });


            Object.defineProperty(this, 'value', {
                configurable: true,
                enumerable: true,
                get: function() {
                    return value;
                }
            });
            Object.defineProperty(this, 'value', {
                configurable: false,
                enumerable: true,
                set: function(val) {
                    value = val;
                }
            });
        }
    };


    /***************************************************************************
    *                                                                          *
    ****************************************************************************/
    var _Transaction = function Transaction(tx) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            Object.defineProperty(this, 'tx', {
                configurable: false,
                enumerable: false,
                writable: false,
                value: tx
            });
        }
    };


    if(_iDB) {
        _validTypes = [_AND, _OR];
        _validOrders = [_ASCENDING, _DESCENDING];
        _validOperators = [_EQ, _GT, _GTE, _LT, _LTE, _NEQ, _REGEXP];
    }


    $K.defVoltmxProp(_ns, [
        {keey:'addOrReplaceRecords', value:_addOrReplaceRecords},
        {keey:'addRecords', value:_addRecords},
        {keey:'clearTable', value:_clearTable},
        {keey:'closeDatabase', value:_closeDatabase},
        {keey:'Condition', value:_Condition},
        {keey:'createIndices', value:_createIndices},
        {keey:'createTable', value:_createTable},
        {keey:'databaseExists', value:_databaseExists},
        {keey:'databaseVersion', value:_databaseVersion},
        {keey:'deleteDatabase', value:_deleteDatabase},
        {keey:'deleteIndices', value:_deleteIndices},
        {keey:'deleteRecords', value:_deleteRecords},
        {keey:'deleteTable', value:_deleteTable},
        {keey:'fetchRecords', value:_fetchRecords},
        {keey:'getPrimaryKeys', value:_getPrimaryKeys},
        {keey:'getTables', value:_getTables},
        {keey:'openDatabase', value:_openDatabase},
        {keey:'openTransaction', value:_openTransaction},
        {keey:'replaceRecords', value:_replaceRecords},
        {keey:'Rule', value:_Rule},
        {keey:'tableExists', value:_tableExists},
        {keey:'updateRecords', value:_updateRecords},
        //Constants starts from here...
        {keey:'AND', value:_AND},
        {keey:'ASCENDING', value:_ASCENDING},
        {keey:'DESCENDING', value:_DESCENDING},
        {keey:'EQ', value:_EQ},
        {keey:'GT', value:_GT},
        {keey:'GTE', value:_GTE},
        {keey:'LT', value:_LT},
        {keey:'LTE', value:_LTE},
        {keey:'NEQ', value:_NEQ},
        {keey:'OR', value:_OR},
        {keey:'READ', value:_READ},
        {keey:'READ_WRITE', value:_READ_WRITE},
        {keey:'REGEXP', value:_REGEXP}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxos.js' */
Object.defineProperty(voltmx, 'os', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;

    var _buildPrintWindow = function(win, widget, width) {
        var htmlAttrs = document.documentElement.attributes, shim = null,
            doc = win.document, docstylesheets = document.styleSheets,
            html = doc.documentElement, cssText = '', ilen = htmlAttrs.length,
            meta = doc.createElement('META'), i = 0, link = null, view = null,
            shimstyle = {}, stylesheet = 0, style = doc.createElement('STYLE'),
            checkIsWidget = function(obj) {
                var value = false;
                if(typeof obj === 'object' && (typeof obj._kwebfw_ === 'object' && obj._kwebfw_)
                && (typeof obj._kwebfw_.ns === 'string' && obj._kwebfw_.ns)
                && (typeof obj._kwebfw_.name === 'string' && obj._kwebfw_.name)) {
                    value = true;
                }
                return value;
            };

        style.setAttribute('type', 'text/css');
        for(i=0; i<ilen; i++) {
            if(htmlAttrs[i].name !== 'style') {
                html.setAttribute(htmlAttrs[i].name, htmlAttrs[i].value);
            }
        }

        meta.setAttribute('http-equiv', 'Content-Type');
        meta.setAttribute('content', 'text/html; charset=UTF-8');
        style.innerHTML = '*{box-sizing:border-box !important;user-select:none;cursor:inherit;margin:0px;padding:0px;}';
        doc.head.appendChild(meta);
        doc.head.appendChild(style);

        for(stylesheet = 0; stylesheet < docstylesheets.length; stylesheet++) {
            link = null;

            if(docstylesheets[stylesheet].href
            && docstylesheets[stylesheet].href.indexOf('desktopweb/lib/anim.css') === -1
            && docstylesheets[stylesheet].href.indexOf('desktopweb/voltmxdesktop.css') === -1) {
                link = doc.createElement('LINK');
                link.setAttribute('rel', 'stylesheet');
                link.setAttribute('type', 'text/css');

                link.href = docstylesheets[stylesheet].href;
                doc.head.appendChild(link);
            }
        }

        if(checkIsWidget(widget)) {
            view = widget._kwebfw_.view;
            width = (width + 'px !important;');

            cssText += ' top: 0px !important; bottom: 0px !important;';
            cssText += ' left: 0px !important; right: 0px !important;';
            cssText += ' margin-top: 0px !important; margin-bottom: 0px !important;';
            cssText += ' margin-left: 0px !important; margin-right: 0px !important;';
            cssText += (' width: '+width+' min-width: '+width+' max-width: '+width);

            doc.body.innerHTML = view.outerHTML;
            doc.body.firstElementChild.style.cssText = (view.style.cssText+cssText);
        } else if(typeof widget === 'string') {
            doc.body.innerHTML = widget;
        }

        shim = doc.createElement('DIV');
        shimstyle = {
            position:'absolute',
            top:'0px', left:'0px',
            width:'100%', height:'100%',
            zIndex:2147483647,
            backgroundColor:'transparent'
        };

        for(i in shimstyle) {
            shim.style[i] = shimstyle[i];
        }


        doc.body.appendChild(shim);
    };


    var _createUUID = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        return $KU.uuid();
    };

    var _deviceInfo = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, info = {};

        $KU.log({api:'voltmx.os.deviceInfo', enter:true});

        info.category = $KU.browser('name');
        if(info.category === 'msie') info.category = 'IE';
        else info.category = info.category[0].toUpperCase()+info.category.substr(1);
        info.deviceid = (function() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app,
                id = '', store = null, data = null;

            if(window.localStorage && typeof localStorage.getItem === 'function') {
                data = localStorage.getItem($KA.id);

                if(typeof data === 'string' && data) {
                    try{
                        store = JSON.parse(data);
                    } catch(e) {
                        store = data;
                    }
                }

                if(typeof store === 'object' && store) {
                    if(typeof store.deviceId === 'string' && store.deviceId) {
                        id = store.deviceId;
                    } else {
                        store.deviceId = id = $KU.uuid();
                        localStorage.setItem($KA.id, JSON.stringify(store));
                    }
                }
            } else if(typeof $KA.id === 'string' && $KA.id) {
                id = $KU.uuid();
            }

            return id;
        }());
        info.deviceHeight = screen.availHeight;
        info.deviceWidth = screen.availWidth;
        info.hascamera = $KU.browser('supports', 'usermedia');
        info.hasgps = $KU.browser('supports', 'geolocation');
        info.hastouchsupport = $KU.browser('supports', 'touch');
        info.hasorientationsupport = $KU.browser('supports', 'orientation');
        info.httpheaders = '//TODO::';
        info.imagecat = $K.device.resolution;
        info.ip = '';
        info.iswifiavailable = ($KU.is(navigator.onLine, 'boolean') ? navigator.onLine : true);
        info.model = '';
        info.name = 'thinclient';
        info.screenHeight = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight);
        info.screenWidth = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
        info.type = 'spa';
        info.userAgent = navigator.userAgent;
        info.version = $KU.browser('version');

        $KU.log({api:'voltmx.os.deviceInfo', exit:true});

        return info;
    };

    var _freeMemory = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.os.freeMemory', enter:true});
        $KU.log({api:'voltmx.os.freeMemory', exit:true});

        return 0; //Dummy Implementation
    };


    var _getBatteryState = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.os.getBatteryState', enter:true});
        $KU.log({api:'voltmx.os.getBatteryState', exit:true});

        return voltmx.os.BATTERY_STATE_UNKNOWN;
    };


    var _getDeviceCurrentOrientation = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, orientation = '';

        $KU.log({api:'voltmx.os.getDeviceCurrentOrientation', enter:true});

        orientation = $KU.browser('orientation');

        $KU.log({api:'voltmx.os.getDeviceCurrentOrientation', exit:true});

        return (orientation === 'portrait') ? constants.DEVICE_ORIENTATION_PORTRAIT
            : constants.DEVICE_ORIENTATION_LANDSCAPE;
    };


    var _handlePrint = {
        Form2: function(win, info) {
            var _ = this._kwebfw_, uid = _.uid, id = '', k = '', cssText = '',
                dom = win.document.getElementById(uid), cview = null;

            cssText = dom.style.cssText;
            cssText += ' height: auto !important;';
            cssText += ' max-height: none !important;';
            cssText += ' overflow-x: visible !important;';
            cssText += ' overflow-y: visible !important;';
            dom.style.cssText = cssText;

            dom = dom.firstElementChild; //header
            cssText = dom.style.cssText;
            cssText += ' position: relative !important;';
            cssText += ' top: 0px !important;';
            cssText += ' bottom: auto !important;';
            dom.style.cssText = cssText;

            dom = dom.nextElementSibling; //viewport
            cssText = dom.style.cssText;
            cssText += ' position: relative !important;';
            cssText += ' bottom: auto !important;';
            if(this.layoutType === voltmx.flex.FREE_FORM) {
                cssText += ' height: '+info[uid].scrollHeight+'px !important;';
            }
            dom.style.cssText = cssText;

            for(id in info) {
                cview = win.document.getElementById(id);

                for(k in info[id]) {
                    cview.style[k] = info[id][k];
                }
            }

            dom = dom.nextElementSibling; //footer
            cssText = dom.style.cssText;
            cssText += ' position: relative !important;';
            cssText += ' top: 0px !important;';
            cssText += ' bottom: auto !important;';
            dom.style.cssText = cssText;
        }
    };


    var _hasCameraSupport = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

        $KU.log({api:'voltmx.os.hasCameraSupport', enter:true});
        flag = $KU.browser('supports', 'usermedia');
        $KU.log({api:'voltmx.os.hasCameraSupport', exit:true});

        return flag;
    };


    var _hasGPSSupport = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, gps = false;

        $KU.log({api:'voltmx.os.hasGPSSupport', enter:true});
        gps = $KU.browser('supports', 'geolocation');
        $KU.log({api:'voltmx.os.hasGPSSupport', exit:true});

        return gps;
    };


    var _hasOrientationSupport = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, hasOrientation = false;

        $KU.log({api:'voltmx.os.hasOrientationSupport', enter:true});
        hasOrientation = $KU.browser('supports', 'orientation');
        $KU.log({api:'voltmx.os.hasOrientationSupport', exit:true});

        return hasOrientation;
    };


    var _hasTouchSupport = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

        $KU.log({api:'voltmx.os.hasTouchSupport', enter:true});
        flag = $KU.browser('supports', 'touch');
        $KU.log({api:'voltmx.os.hasTouchSupport', exit:true});

        return flag;
    };


    //Applicable only on DesktopWeb
    //Auto-Close is nomore supported, facing technical challenge.
    //TODO:: In IE11 doesn't work, will raise a bug.
    var _print = function(widgetId) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KA = $K.app, info = {}, cf = $KW.model($KA.currentFormUID),
            win = null, widget = null, el = null;

        $KU.log({api:'voltmx.os.print', enter:true});

        win = window.open();

        if(!win) {
            voltmx.print('Allow popup to open for this site.');
        } else if($KU.is(widgetId, 'string') && widgetId) {
            widget = (cf) ? cf[widgetId] : null;

            if(!widget) {
                _buildPrintWindow(win, widgetId);
            } else {
                el = $KW.el(widget);
                _buildPrintWindow(win, widget, el.node.offsetWidth);

                if(_handlePrint[$KW.name(widget)]) {
                    _handlePrint[$KW.name(widget)].call(widget, win);
                }
            }
        } else if(cf) {
            el = $KW.el(cf);
            _buildPrintWindow(win, cf, el.scrolee.clientWidth);

            if(_handlePrint.Form2) {
                $KU.each($KW.children(cf), function(cmodel) {
                    var _ = cmodel._kwebfw_, uid = _.uid,
                        final = _.flex.final, view = _.view;

                    if(final.height && final.height.indexOf('%') > 0) {
                        if(!info[uid]) info[uid] = {};
                        info[uid].height = (view.offsetHeight+'px');
                    }

                    if(cf.layoutType === voltmx.flex.FLOW_VERTICAL) {
                        if(final.top && final.top[0] !== '-'
                        && _.viewPrev && final.top.indexOf('%') > 0) {
                            if(!info[uid]) info[uid] = {};
                            info[uid].marginTop = (_.viewPrev.offsetHeight+'px');
                        }

                        if(final.bottom && final.bottom[0] !== '-'
                        && _.viewNext && final.bottom.indexOf('%') > 0) {
                            if(!info[uid]) info[uid] = {};
                            info[uid].marginBottom = (_.viewNext.offsetHeight+'px');
                        }
                    }
                });

                if(cf.layoutType === voltmx.flex.FREE_FORM) {
                    if(!info[cf._kwebfw_.uid]) {
                        info[cf._kwebfw_.uid] = {};
                    }

                    info[cf._kwebfw_.uid].scrollHeight = el.scrolee.scrollHeight;
                    _handlePrint.Form2.call(cf, win, info);
                } else {
                    _handlePrint.Form2.call(cf, win, info);
                }
            }
        }

        if(win) {
            setTimeout(function() {
                win.print();win.document.close();
                win.focus();win.close();win = null;
            }, 250);
        }

        $KU.log({api:'voltmx.os.print', exit:true});
    };

    var _userAgent = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.os.userAgent', enter:true});
        $KU.log({api:'voltmx.os.userAgent', exit:true});

        return navigator.userAgent;
    };

    $K.defVoltmxProp(_ns, [
        {keey:'BATTERY_STATE_UNKNOWN', value:'unknown'},
        {keey:'createUUID', value:_createUUID},
        {keey:'deviceInfo', value:_deviceInfo},
        {keey:'freeMemory', value:_freeMemory},
        {keey:'getBatteryState', value:_getBatteryState},
        {keey:'getDeviceCurrentOrientation', value:_getDeviceCurrentOrientation},
        {keey:'hasCameraSupport', value:_hasCameraSupport},
        {keey:'hasGPSSupport', value:_hasGPSSupport},
        {keey:'hasOrientationSupport', value:_hasOrientationSupport},
        {keey:'hasTouchSupport', value:_hasTouchSupport},
        {keey:'print', value:_print},
        {keey:'userAgent', value:_userAgent}
    ]);

    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxphone.js' */
/* global FileError */
/* global Uint8Array */

Object.defineProperty(voltmx, 'phone', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$, _form = null, _input = null, _scrap = null;


    var _dial = function(phoneno) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            version = $KU.browser('osversion'),
            device = $KU.browser('device'), href = '';

        $KU.log({api:'voltmx.phone.dial', enter:true});

        if(device === 'iphone' && version >= 5 && version < 8) {
            href = ('tel://' + phoneno);
        } else {
            href = ('tel:' + phoneno);
        }

        window.location.href = href;

        $KU.log({api:'voltmx.phone.dial', exit:true});
    };


    var _openMediaGallery = function(onselectioncallback, querycontext/*, widgetref*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, $KG = $K.globals;

        $KU.log({api:'voltmx.phone.openMediaGallery', enter:true});

        if(window.File && window.FileReader && window.FileList) {
            if(!_scrap) _scrap = $KG.appScrap;

            if(!_form && !_input) {
                _form = $KD.create('form');
                _input = $KD.create('input', {type:'file'});

                $KD.on(_input, 'change', 'change', function(/*e*/) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    if($KU.is(onselectioncallback, 'function')) {
                        var reader = new FileReader(), info = null,
                            file = this.files[0], mimetype = file.type;

                        reader.readAsArrayBuffer(file);

                        reader.onload = function(evt) {
                            var chars = new Uint8Array(evt.target.result),
                                CHUNK_SIZE = 0x8000, index = 0, result = '', slice;

                            while(index < chars.length) {
                                slice = chars.subarray(index, Math.min(index + CHUNK_SIZE, chars.length));
                                result += String.fromCharCode.apply(null, slice);
                                index += CHUNK_SIZE;
                            }

                            info = new voltmx.utils.voltmxRawBytes(result, 'utf8');

                            onselectioncallback(info, voltmx.application.PERMISSION_GRANTED, mimetype);
                        };

                        reader.onerror = function(evt) {
                            if(evt.target.error instanceof FileError) { // Read error code in case of error is of FileError type
                                switch(evt.target.error.code) {
                                    case FileError.NOT_FOUND_ERR:
                                        voltmx.print('openMediaGallery error:: The file resource couldn\'t be found at the time the read was processed.');
                                        break;
                                    case FileError.NOT_READABLE_ERR:
                                        voltmx.print('openMediaGallery error:: 2101, The resource couldn\'t be read. Insufficient Permissions.');
                                        break;
                                    case FileError.ENCODING_ERR:
                                        voltmx.print('openMediaGallery error:: The resource couldn\'t be encoded.');
                                        break;
                                    case FileError.SECURITY_ERR:
                                    default:
                                        voltmx.print('openMediaGallery error:: The file resource is unsafe/changed/other unspecified security error.');
                                }
                            } else { //Read error name & message in case error is of DOMError type
                                voltmx.print('openMediaGallery error:: ' + evt.target.error.name + ', ' + evt.target.error.message);
                            }
                        };
                    }
                });

                $KD.add(_form, _input);
                $KD.add(_scrap, _form);
            }

            if(querycontext && querycontext.mimetype) { //add mime type
                $KD.setAttr(_input, 'accept', querycontext.mimetype);
            } else {
                $KD.removeAttr(_input, 'accept');
            }

            _input.click();

            $KU.log({api:'voltmx.phone.openMediaGallery', exit:true});
        } else {
            voltmx.print('openMediaGallery error:: 2103, Cannot open media gallery. Not supported.');
        }
    };


    $K.defVoltmxProp(_ns, [
        {keey:'dial', value:_dial},
        {keey:'openMediaGallery', value:_openMediaGallery}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxpush.js' */


Object.defineProperty(voltmx, 'push', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$, $KU = $K.utils;

    var onsuccessfulregistration, onfailureregistration,
        onlinenotification,
        onsuccessfulderegistration, onfailurederegistration, messaging;

    //eslint-disable-next-line no-unused-vars
    var offlinenotification;

    (function() {
        var config = localStorage.getItem(voltmx.$kwebfw$.app.id + '_' + 'pushConfig');
        if(config) {
            config = JSON.parse(config);
            if(!messaging) {
                firebase.initializeApp(config);
                messaging = firebase.messaging();
                messaging.usePublicVapidKey(config.publicKey);
            }
            messaging.onMessage(function(payload) {
                $KU.log('Push notification received data is '+ JSON.stringify(payload));
                onlinenotification && onlinenotification(payload);
            });
        }
    })();


    function __getPermission(config) {
        messaging.requestPermission().then(function() {
            $KU.log('Notification permission granted.');
            //voltmxSwRegistration at PWA level.
            if(voltmxSwRegistration) {
                $KU.log('Service worker registration succeeded.');
                messaging.useServiceWorker(voltmxSwRegistration);
                localStorage.setItem(voltmx.$kwebfw$.app.id + '_' + 'pushConfig', JSON.stringify(config));
                __getToken(messaging);
            } else {
                $KU.log('Service worker registration failed:');
                onfailureregistration && onfailureregistration({'errorCode' : '1406',
                    'errormessage' : 'Service worker registration failed'});
            }
        }).catch(function(err) {
            $KU.log('Unable to get permission to notify.'+ err);
            onfailureregistration && onfailureregistration({'errorCode' : '1403',
                'errormessage' : 'permission is not available'});
        });
    }


    function __getToken(messaging) {
        messaging.getToken().then(function(token) {
            if(token) {
                localStorage.setItem(voltmx.$kwebfw$.app.id + '_' + 'pushId', token);
                $KU.log('token is '+ token);
                messaging.onMessage(function(payload) {
                    $KU.log('Push notification received. Data is '+ JSON.stringify(payload));
                    onlinenotification && onlinenotification(payload);
                });
                onsuccessfulregistration(token);
            } else {
                $KU.log('No Instance ID token available. Request permission to generate one.');
                onfailureregistration && onfailureregistration({'errorCode' : '1403',
                    'errormessage' : 'Unknown Error'});
            }
        }).catch(function(err) {
            $KU.log('An error occurred while retrieving token. '+ err);
            onfailureregistration && onfailureregistration({'errorCode' : '1402',
                'errormessage' : 'PNS token is not available'});
        });
    }


    var deRegister = function() {
        $KU.log({api:'voltmx.push.deRegister', enter:true});
        var config = localStorage.getItem(voltmx.$kwebfw$.app.id + '_' + 'pushConfig');
        config = JSON.parse(config);
        var token =localStorage.getItem(voltmx.$kwebfw$.app.id + '_' + 'pushId');

        if(config && token) {
            $KU.log('voltmx.push.deRegister');
            messaging.deleteToken(token).then(function() {
                $KU.log('succssfully unregistered from FCM.');
                onsuccessfulderegistration && onsuccessfulderegistration();
                localStorage.removeItem(voltmx.$kwebfw$.app.id + '_' + 'pushId');
                localStorage.removeItem(voltmx.$kwebfw$.app.id + '_' + 'pushConfig');
            }).catch(function(err) {
                //eslint-disable-next-line no-console
                console.error('unable to unregister from FCM. '+ JSON.stringify(err));
                onfailurederegistration && onfailurederegistration();
            });
        } else {
            //eslint-disable-next-line no-console
            console.warn('User is not subscribed for FCM');
        }
        $KU.log({api:'voltmx.push.deRegister', exit:true});
    };


    var register = function(config) {
        $KU.log({api:'voltmx.push.register', enter:true});
        if(!firebase.messaging.isSupported()) {
            //eslint-disable-next-line no-console
            console.warn('Browser does not have the Push Notifications support');
            return;
        }
        if(!messaging) {
            firebase.initializeApp(config);
            messaging = firebase.messaging();
            messaging.usePublicVapidKey(config.publicKey);
            __getPermission(config);
        }
        $KU.log({api:'voltmx.push.register', exit:true});
    };


    var setCallbacks = function(data) {
        $KU.log({api:'voltmx.push.setCallbacks', enter:true});
        //$KU.log('voltmx.push.setCallbacks', data);
        onsuccessfulregistration = data.onsuccessfulregistration;
        onfailureregistration = data.onfailureregistration;
        onlinenotification = data.onlinenotification;
        offlinenotification = data.offlinenotification;
        onsuccessfulderegistration = data.onsuccessfulderegistration;
        onfailurederegistration = data.onfailurederegistration;
        $KU.log({api:'voltmx.push.setCallbacks', exit:true});
    };


    $K.defVoltmxProp(_ns, [
        {keey:'setCallbacks', value:setCallbacks},
        {keey:'register', value:register},
        {keey:'deRegister', value:deRegister}
    ]);

    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxtheme.js' */
Object.defineProperty(voltmx, 'theme', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, _remoteUrl = {}, _appLoadThemeCall = true, $K = voltmx.$kwebfw$;


    var _applyStyleSheet = function(identifier) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app,
            index = $KA.supportedThemes.indexOf(identifier),
            enabled = false, disabled = false;

        if(index >= 0 && identifier !== $KA.currentTheme) {
            $KU.each(document.styleSheets, function(sheet) {
                var $K = voltmx.$kwebfw$, $KA = $K.app, theme = '';

                if(sheet.ownerNode.tagName === 'LINK'
                && sheet.ownerNode.hasAttribute('ktheme')) {
                    theme = sheet.ownerNode.getAttribute('ktheme');

                    if(enabled && disabled) {
                        return true;
                    }
                    if(theme === identifier) {
                        enabled = true;
                        sheet.disabled = false;
                    } else if($KA.currentTheme === theme) {
                        disabled = true;
                        sheet.disabled = true;
                    }
                }
            });

            $KA.currentTheme = identifier;
        }
    };


    var _createTheme = function(url, identifier, onsuccesscallback, onerrorcallback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.theme.createTheme', enter:true});

        //NOTE:: From VIZ, sometime we get 'defaultTheme' and sometime 'default'
        if(identifier === 'defaultTheme') identifier = 'default';

        if($KA.supportedThemes.indexOf(identifier) >= 0) {
            $KU.log({api:'voltmx.theme.createTheme', exit:true});

            if($KU.is(onsuccesscallback, 'function')) {
                onsuccesscallback();
            }
        } else {
            $KU.loadStyle(url, {ktheme:identifier},
                function() {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app,
                        stylesheet = $KU.getThemeStyleSheet(identifier);

                    if(stylesheet) {
                        stylesheet.disabled = true;
                        _remoteUrl[identifier] = url;
                        $KA.supportedThemes.push(identifier);
                        $KU.log({api:'voltmx.theme.createTheme', exit:true});

                        if($KU.is(onsuccesscallback, 'function')) {
                            onsuccesscallback();
                        }
                    } else {
                        $KU.log({api:'voltmx.theme.createTheme', exit:true});

                        if($KU.is(onerrorcallback, 'function')) {
                            onerrorcallback();
                        }
                    }
                },

                function() {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.log({api:'voltmx.theme.createTheme', exit:true});

                    if($KU.is(onerrorcallback, 'function')) {
                        onerrorcallback();
                    }
                }
            );
        }
    };


    var _deleteTheme = function(identifier, onsuccesscallback, onerrorcallback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KA = $K.app, link = null, index = -1;

        $KU.log({api:'voltmx.theme.deleteTheme', enter:true});

        if(_remoteUrl[identifier]) {
            delete _remoteUrl[identifier];
            $KA.supportedThemes.splice(index, 1);

            if(identifier === $KA.currentTheme) {
                _setCurrentTheme('default');
            }

            link = document.head.querySelector('link[ktheme="'+identifier+'"]');
            link && document.head.removeChild(link);
            $KU.log({api:'voltmx.theme.deleteTheme', exit:true});

            if($KU.is(onsuccesscallback, 'function')) {
                onsuccesscallback();
            }
        } else {
            if($KU.is(onerrorcallback, 'function')) {
                onerrorcallback();
            }
            $KU.log({api:'voltmx.theme.deleteTheme', exit:true});
        }
    };


    var _getAllThemes = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.theme.getAllThemes', enter:true});
        $KU.log({api:'voltmx.theme.getAllThemes', exit:true});

        return $KA.supportedThemes.slice(0);
    };


    var _getCurrentTheme = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.theme.getCurrentTheme', enter:true});
        $KU.log({api:'voltmx.theme.getCurrentTheme', exit:true});

        return $KA.currentTheme;
    };


    var _getCurrentThemeData = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'voltmx.theme.getCurrentThemeData', enter:true});
        $KU.log({api:'voltmx.theme.getCurrentThemeData', exit:true});

        return null;
    };

    var _isThemePresent = function(identifier) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app;

        $KU.log({api:'voltmx.theme.isThemePresent', enter:true});
        //NOTE:: From VIZ, sometime we get 'defaultTheme' and sometime 'default'
        if(identifier === 'defaultTheme') identifier = 'default';
        $KU.log({api:'voltmx.theme.isThemePresent', exit:true});

        return ($KA.supportedThemes.indexOf(identifier) >= 0) ? true : false;
    };


    var _packagedthemes = function(themes) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, index = -1;

        $KU.log({api:'voltmx.theme.packagedthemes', enter:true});

        //NOTE:: From VIZ, sometime we get 'defaultTheme' and sometime 'default'
        index = themes.indexOf('defaultTheme');

        if(index !== -1) {
            themes.splice(index, 1);

            if(themes.indexOf('default') === -1) {
                themes.splice(index, 0, 'default');
            }
        }

        $KA.supportedThemes = themes;

        $KU.log({api:'voltmx.theme.packagedthemes', exit:true});
    };


    var _setCurrentTheme = function(identifier, onsuccesscallback, onerrorcallback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KG = $K.globals, $KA = $K.app, src = '', kofUrl = '';

        $KU.log({api:'voltmx.theme.setCurrentTheme', enter:true});

        //NOTE:: From VIZ, sometime we get 'defaultTheme' and sometime 'default'
        if(identifier === 'defaultTheme') identifier = 'default';

        if($KA.supportedThemes.indexOf(identifier) === -1) {
            $KU.log({api:'voltmx.theme.setCurrentTheme', exit:true});

            if($KU.is(onerrorcallback, 'function')) {
                onerrorcallback(); //Theme not supported
            }
        } else if(identifier === $KA.currentTheme) {
            $KU.log({api:'voltmx.theme.setCurrentTheme', exit:true});

            if($KU.is(onsuccesscallback, 'function')) {
                onsuccesscallback(); //Asked theme is same as current theme
            }
        } else if($KU.getThemeStyleSheet(identifier)) {
            _applyStyleSheet(identifier); //Theme was used once previously
            $KU.log({api:'voltmx.theme.setCurrentTheme', exit:true});

            if($KU.is(onsuccesscallback, 'function')) {
                onsuccesscallback();
            }
        } else { //Theme was never used, so loading it from network
            src = ($KG.platform + '/themes/' + identifier + '/theme.css');

            if($KU.loadedFromOtherFramework()) {
                kofUrl = $KG.kof.appUrl+'/desktopweb';
                src = (kofUrl + '/themes/' + identifier + '/theme.css');
            }

            $KU.loadStyle(src, {ktheme:identifier},
                function() {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    _applyStyleSheet(identifier);
                    $KU.log({api:'voltmx.theme.setCurrentTheme', exit:true});

                    if(!_appLoadThemeCall && $KU.is(onsuccesscallback, 'function')) {
                        onsuccesscallback(); //Successfully loaded theme from network
                    }

                    _appLoadThemeCall = false;
                },

                function() {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.log({api:'voltmx.theme.setCurrentTheme', exit:true});

                    if(!_appLoadThemeCall && $KU.is(onerrorcallback, 'function')) {
                        onerrorcallback(); //Failed to load theme from network
                    }

                    _appLoadThemeCall = false;
                }
            );

            if(_appLoadThemeCall && $KU.is(onsuccesscallback, 'function')) {
                onsuccesscallback();
            }
        }
    };

    var _setSkinsProperties = function(skinObj) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, $KW = $K.widget,
            stylesheet = null, rules, skins = Object.keys(skinObj),
            _handlers = $KW.skinHandlers();

        stylesheet = $KU.getThemeStyleSheet($KA.currentTheme);

        rules = stylesheet.cssRules || stylesheet.rules;
        $KU.each(skins, function(skin) {
            $KU.each(rules, function(rule) {
                if(rule.selectorText && rule.selectorText.indexOf(skin + ',') === 1) {
                    $KU.each(skinObj[skin], function(value, keey) {
                        _handlers[keey] && _handlers[keey]({rule: rule, config: value});
                    });
                    return true;
                }
            });
        });
    };

    $K.defVoltmxProp(_ns, [
        {keey:'createTheme', value:_createTheme},
        {keey:'deleteTheme', value:_deleteTheme},
        {keey:'getAllThemes', value:_getAllThemes},
        {keey:'getCurrentTheme', value:_getCurrentTheme},
        {keey:'getCurrentThemeData', value:_getCurrentThemeData},
        {keey:'isThemePresent', value:_isThemePresent},
        {keey:'packagedthemes', value:_packagedthemes},
        {keey:'setCurrentTheme', value:_setCurrentTheme},
        {keey:'setSkinsProperties', value:_setSkinsProperties}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxtimer.js' */
Object.defineProperty(voltmx, 'timer', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, _map = {}, $K = voltmx.$kwebfw$;


    var _cancel = function(id) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, timer = null, func = null;

        $KU.log({api:'voltmx.timer.cancel', enter:true});

        if((($KU.is(id, 'string') && id) || $KU.is(id, 'number'))) {
            id = ('' + id);

            if(Object.prototype.hasOwnProperty.call(_map, id)) {
                timer = _map[id];
                func = (timer.repeat) ? 'clearInterval' : 'clearTimeout';

                window[func](timer.id);
                delete _map[id];
                $KU.log({api:'voltmx.timer.cancel', exit:true});
            } else {
                $KU.log('warn', 'No timer found with id="'+id+'".');
                $KU.log({api:'voltmx.timer.cancel', exit:true});
                return null;
            }
        } else {
            $KU.log({api:'voltmx.timer.cancel', exit:true});
        }
    };


    var _schedule = function(id, callback, interval, repeat) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, func = null;

        $KU.log({api:'voltmx.timer.schedule', enter:true});

        if((($KU.is(id, 'string') && id)
                || $KU.is(id, 'number'))
        && $KU.is(callback, 'function')
        && $KU.is(interval, 'number')) {
            id = ('' + id);

            if(!$KU.is(repeat, 'boolean')) {
                repeat = false;
            }

            _map[id] = {callback:callback, repeat:repeat};
            func = (repeat) ? 'setInterval' : 'setTimeout';

            _map[id].id = window[func](function() {
                _map[id] && _map[id].callback();
                !repeat && _cancel(id);
            }, (interval*1000));
        }

        $KU.log({api:'voltmx.timer.schedule', exit:true});
    };


    var _setCallBack = function(id, callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, timer = null;

        $KU.log({api:'voltmx.timer.setCallBack', enter:true});

        if((($KU.is(id, 'string') && id)
                || $KU.is(id, 'number'))
        && $KU.is(callback, 'function')) {
            timer = _map[(''+id)];

            if(timer) {
                timer.callback = callback;
            } else {
                //LOG:: WARN
            }
        }

        $KU.log({api:'voltmx.timer.setCallBack', exit:true});
    };


    $K.defVoltmxProp(_ns, [
        {keey:'cancel', value:_cancel},
        {keey:'schedule', value:_schedule},
        {keey:'setCallBack', value:_setCallBack}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/apis/voltmxworker.js' */
Object.defineProperty(voltmx, 'worker', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$;


    var _addEventListener = function Worker$_addEventListener(sName, fListener) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'worker.addEventListener', enter:true});
        if(arguments.length < 2) {
            $KU.log('addEventListener: MissingMandatoryParameter. Mandatory arguments missing');
            throw new VoltmxError(3001, 'WorkerThreadError', 'addEventListener: MissingMandatoryParameter. Mandatory arguments missing');
        }
        if(typeof sName !== 'string' || typeof fListener !== 'function') {
            $KU.log('addEventListener: InvalidParameter. Invalid arguments');
            throw new VoltmxError(3002, 'WorkerThreadError', 'addEventListener: InvalidParameter. Invalid arguments');
        }
        if(sName !== 'message' && sName !== 'error') {
            $KU.log('addEventListener: InvalidParameter. Invalid arguments');
            throw new VoltmxError(3002, 'WorkerThreadError', 'addEventListener: InvalidParameter. Invalid arguments');
        }
        $KU.log('worker.addEventListener', sName, fListener);
        fListener = fListener ? fListener : this.defaultListener;
        Worker.prototype.addEventListener.call(this.oWorker, sName, fListener, false);
        if('error' === sName) {
            Worker.prototype.removeEventListener.call(this.oWorker, 'error', this.defaultErrorListener, false);
        }

        $KU.log({api:'worker.addEventListener', exit:true});
    };


    var _hasWorkerThreadSupport = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, workerSupport = true;

        $KU.log({api:'voltmx.worker.hasWorkerThreadSupport', enter:true});

        if(typeof Worker === 'undefined') {
            $KU.log('Worker not defined');
            workerSupport = false;
        }

        $KU.log({api:'voltmx.worker.hasWorkerThreadSupport', exit:true});

        return workerSupport;
    };


    var _postMessage = function Worker$_postMessage(vMsg) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'worker.postMessage', enter:true});
        if(vMsg === undefined || vMsg === null || vMsg === '') {
            $KU.log('postMessage: MissingMandatoryParameter. Message undefined');
            throw new VoltmxError(3001, 'WorkerThreadError', 'postMessage: MissingMandatoryParameter. Message undefined');
        }
        if(typeof vMsg === 'number' || typeof vMsg === 'boolean' || typeof vMsg === 'function') {
            $KU.log('postMessage: InvalidParameter. Invalid Message');
            throw new VoltmxError(3002, 'WorkerThreadError', 'postMessage: InvalidParameter. Invalid Message');
        }
        $KU.log('worker.postMessage', vMsg);
        try{
            Worker.prototype.postMessage.call(this.oWorker, vMsg);
            $KU.log({api:'worker.postMessage', exit:true});
        } catch(err) {
            $KU.log('postMessage: InvalidParameter. Invalid Message');
            voltmx.print('Error occured in WorkerThread postMessage: ' + err.message);
            throw new VoltmxError(3002, 'WorkerThreadError', 'postMessage: InvalidParameter. Invalid Message');
        }
    };


    var _removeEventListener = function Worker$_removeEventListener(sName, fListener) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'worker.removeEventListener', enter:true});
        if(arguments.length < 2) {
            $KU.log('removeEventListener: MissingMandatoryParameter. Mandatory arguments missing');
            throw new VoltmxError(3001, 'WorkerThreadError', 'removeEventListener: MissingMandatoryParameter. Mandatory arguments missing');
        }
        if(typeof sName !== 'string' || typeof fListener !== 'function') {
            $KU.log('removeEventListener: InvalidParameter. Invalid arguments');
            throw new VoltmxError(3002, 'WorkerThreadError', 'removeEventListener: InvalidParameter. Invalid arguments');
        }
        if(sName !== 'message' && sName !== 'error') {
            $KU.log('removeEventListener: InvalidParameter. Invalid arguments');
            throw new VoltmxError(3002, 'WorkerThreadError', 'removeEventListener: InvalidParameter. Invalid arguments');
        }
        $KU.log('worker.removeEventListener', sName, fListener);
        Worker.prototype.removeEventListener.call(this.oWorker, sName, fListener, false);
        if('error' === sName) {
            Worker.prototype.addEventListener.call(this.oWorker, 'error', this.defaultErrorListener, false);
        }
        $KU.log({api:'worker.removeEventListener', exit:true});
    };


    var _terminate = function Worker$_terminate() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'worker.terminate', enter:true});
        Worker.prototype.terminate.call(this.oWorker);
        $KU.log({api:'worker.terminate', exit:true});
    };

    //eslint-disable-next-line no-global-assign,no-implicit-globals
    var VoltmxError = function(errorcode, name, message) {
        this.errorCode = this.errorcode = errorcode;
        this.name = name;
        this.message = message;
    };
    VoltmxError.prototype = new Error();
    VoltmxError.prototype.constructor = VoltmxError;

    var _WorkerThread = function(workerjs, fDefListener, fOnError) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KG = $K.globals, workerInstance = this,
            isFMSupported = false, workerInitPath = $KG.platform+'/lib/';

        if($K.ecmaEnable) {
            workerInitPath = $KG.platform+'/es5lib/';
        }

        $KU.log({api:'voltmx.worker.WorkerThread', enter:true});

        if(workerjs === undefined || workerjs === null || workerjs === '') {
            $KU.log('Invalid parameters');
            throw new Error(3001, 'WorkerThreadError', 'WorkerThread: MissingMandatoryParameter. Failed to construct WorkerThread');
        }
        if(typeof workerjs !== 'string') {
            $KU.log('Invalid parameters');
            throw new Error(3002, 'WorkerThreadError', 'WorkerThread: InvalidParameter. Invalid script name');
        }
        $KU.log('voltmx.worker.WorkerThread', workerjs, fDefListener, fOnError);

        if(typeof nestedWorker === 'undefined') {
            this.oWorker = new Worker(workerInitPath + 'voltmxworkerinit.js');
        } else {
            this.oWorker = new Worker('voltmxworkerinit.js');
        }


        this.oWorker.postMessage({
            moduleName: workerjs,
            platform: $KG.platform,
            kgAppMode: 'kgAppMode', // TODO
            kgAppID: 'kgAppID', // TODO
            isFMSupported: isFMSupported,
            kgUserAgent: voltmx.os.userAgent()
        }),

        workerInstance.defaultListener = fDefListener || function(event) {
            voltmx.print('Data: ' + event.data);
        };

        workerInstance.defaultErrorListener = fOnError || function(e) {
            voltmx.print(e.message + ' : in file - ' + e.filename + ' at location :' + e.lineno + ',' + e.colno);
        };

        this.oWorker.addEventListener('error', workerInstance.defaultErrorListener);


        $K.defVoltmxProp(workerInstance, [
            {keey:'addEventListener', value:_addEventListener},
            {keey:'postMessage', value:_postMessage},
            {keey:'removeEventListener', value:_removeEventListener},
            {keey:'terminate', value:_terminate}
        ]);

        $KU.log({api:'voltmx.worker.WorkerThread', exit:true});
    };


    $K.defVoltmxProp(_ns, [
        {keey:'hasWorkerThreadSupport', value:_hasWorkerThreadSupport},
        {keey:'WorkerThread', value:_WorkerThread}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/utils/voltmxwidget.js' */
/* Attribute's meaning
 * -------------------------------------------------------------------------------------------------
 * kcl --------> Volt MX layout type (hflex / vflex / fflex)
 * kdir -------> voltmx direction type (ltr / rtl)
 * kfb --------> This is value of kr attribute, which means voltmx-fake-border
 * ko ---------> Volt MX orientation for widgets like, CheckBoxGroup/RadioButtonGroup/Slider etc.
 * kr ---------> Volt MX role name for our internal plugins/sub role
 * kt ---------> Volt MX theme, for widgets like Calendar/Switch etc.
 * kv ---------> Volt MX widget view type, for widgets like SegmentedUI2 etc.
 * kw ---------> Volt MX widget name
 * kwf --------> Volt MX widget fragment, like calendar popup can render in any context
 * kwg --------> Volt MX widget gesture, can be found in Slider/Images2 etc.
 * kwh --------> Volt MX widget handler
 * kwi --------> Volt MX widget index (e.g. widget inside segment)
 * kwo --------> Volt MX widget owner (widgets inside segment template will have this)
 * kwp --------> Volt MX widget path for automation purpose (e.g. formId_segmentId[0,0]_templateId_buttonId)
 * -------------------------------------------------------------------------------------------------
 */
Object.defineProperty(voltmx.$kwebfw$, 'widget', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = voltmx.$kwebfw$, _specialARIAkeys = ['lang', 'role'];


    //TODO:: To be verified for each and every widget
    var _a11y = {
            a11yLabel: function(model) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, label = model.placeholder,
                    a11y = model._kwebfw_.prop.accessibilityConfig;

                if(!$KU.is(label, 'string')) label = '';

                return (a11y) ? _a11y.prepareLabel(a11y, label) : '';
            },

            a11yHint: function(model, a11yHint) {
                _a11y.createHint(a11yHint, (model._kwebfw_.uid+'_hint'));
            },

            apply: function(model, view, a11y) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, a11yLabel = '';

                if(a11y) {
                    $KU.each(a11y.a11yARIA, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KD = $K.dom, rmodel = null;

                        if(key.indexOf('aria-') === 0 || _specialARIAkeys.indexOf(key) >= 0) {
                            if(['aria-labelledby', 'aria-describedby'].indexOf(key) >= 0) {
                                rmodel = _rmodel(model);

                                if(rmodel && $KU.is(rmodel[value], 'widget')) {
                                    $KD.setAttr(view, key, rmodel[value]._kwebfw_.uid);
                                }
                            } else if(key === 'role') {
                                if(_isAriaRoleAllowed(model, value)) {
                                    $KD.setAttr(view, key, value);
                                }
                            } else {
                                if($KU.is(value, 'i18n')) {
                                    value = $KU.getI18Nvalue(value);
                                }

                                $KD.setAttr(view, key, value);
                            }
                        }
                    });

                    if(!$KD.hasAttr(view, 'tabindex') && _interactable(model)
                    && ['A', 'IMG', 'INPUT', 'SELECT', 'TEXTAREA'].indexOf(view.tagName) !== -1) {
                        $KD.setAttr(view, 'tabindex', 0);
                    }

                    if(!(a11y.a11yARIA && a11y.a11yARIA['aria-label']
                    && $KU.is(a11y.a11yARIA['aria-label'], 'string'))) {
                        a11yLabel = _a11y.a11yLabel(model);
                    }

                    if($KU.is(model, 'widget', 'Image2')) {
                        $KD.setAttr(view, 'alt', a11yLabel);
                    } else if(a11yLabel) {
                        $KD.setAttr(view, 'aria-label', a11yLabel);
                    }

                    if(!(a11y.a11yARIA && a11y.a11yARIA['aria-describedby']
                    && $KU.is(a11y.a11yARIA['aria-describedby'], 'string'))) {
                        if($KU.is(a11y.a11yHint, 'string')) {
                            _a11y.a11yHint(model, a11y.a11yHint);
                            $KD.setAttr(view, 'aria-describedby', (model._kwebfw_.uid + '_hint'));
                        }
                    }

                    if(!(a11y.a11yARIA && a11y.a11yARIA['aria-hidden']
                    && $KU.is(a11y.a11yARIA['aria-hidden'], 'boolean'))) {
                        if(a11y.a11yHidden === true) {
                            $KD.setAttr(view, 'aria-hidden', true);
                        }
                    }

                    if(!(a11y.a11yARIA && a11y.a11yARIA['aria-required']
                    && $KU.is(a11y.a11yARIA['aria-required'], 'boolean'))) {
                        if(a11y.required === true) {
                            $KD.setAttr(view, 'aria-required', true);
                        }
                    }
                }
            },

            clean: function(model, view, a11y) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    div = document.getElementById((model._kwebfw_.uid+'_hint'));

                if(a11y && a11y.a11yARIA) {
                    $KU.each(a11y.a11yARIA, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KD = $K.dom;

                        if(key === 'tabindex' || key.indexOf('aria-') === 0
                        || _specialARIAkeys.indexOf(key) >= 0) {
                            $KD.removeAttr(view, key);
                        }
                    });
                }

                if(div) $KD.remove(div);
                $KD.removeAttr(view, 'aria-describedby');
                $KD.removeAttr(view, 'aria-hidden');
                $KD.removeAttr(view, 'aria-label');
                $KD.removeAttr(view, 'aria-required');
            },

            createHint: function(a11yHint, hintId) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    $KG = $K.globals, label = null;

                if($KU.is(a11yHint, 'i18n')) {
                    a11yHint = $KU.getI18Nvalue(a11yHint);
                }

                a11yHint = a11yHint.trim();
                label = document.getElementById(hintId);

                if(label) {
                    $KD.text(label, a11yHint);
                } else {
                    label = $KD.create('LABEL', {id:hintId, hidden:''});
                    $KD.text(label, a11yHint);
                    $KD.add($KG.appScrap, label);
                }
            },

            prepareLabel: function(a11y, label) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    a11yLabel = '', a11yValue = '';

                if($KU.is(a11y.a11yValue, 'string')) {
                    if($KU.is(a11y.a11yValue, 'i18n')) {
                        a11yValue = $KU.getI18Nvalue(a11y.a11yValue);
                    } else {
                        a11yValue = a11y.a11yValue;
                    }
                    a11yValue = a11yValue.trim();
                }

                if($KU.is(a11y.a11yLabel, 'string')) {
                    a11yLabel = a11y.a11yLabel;
                } else if($KU.is(a11y.a11yHint, 'string')) {
                    a11yLabel = a11y.a11yHint;
                }

                if($KU.is(a11yLabel, 'string')) {
                    if($KU.is(a11yLabel, 'i18n')) {
                        a11yLabel = $KU.getI18Nvalue(a11yLabel);
                    }
                    a11yLabel = a11yLabel.trim();
                }

                if(!a11yLabel && label) a11yLabel = label.trim();

                if(a11yLabel && a11yValue) {
                    a11yLabel = a11yLabel + ' ' + a11yValue;
                } else if(!a11yLabel && a11yValue) {
                    a11yLabel = a11yValue;
                } else if(!a11yLabel && !a11yValue) {
                    a11yLabel = '';
                }

                return a11yLabel;
            },

            view: {
                Calendar: function (view, tagName) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;
                    if (!tagName || tagName === 'IMG') {
                        tagName = 'ICON';
                    }

                    return $KW.el(view, (tagName).toLocaleLowerCase());
                },

                DataGrid: function(view) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    return $KW.el(view, 'table');
                },

                Image2: function(view) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    return $KW.el(view, 'image');
                },

                ListBox: function(view) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    if(view.tagName === 'SELECT') {
                        return view;
                    }
                    return $KW.el(view, 'input');
                },

                SegmentedUI2: function(view) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    return $KW.el(view, 'scrolee');
                },

                Slider: function(view) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    return $KW.el(view, 'thumb');
                },

                Switch: function(view) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    return $KW.el(view, 'switch');
                },

                Video: function(view) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    return $KW.el(view, 'video');
                }
            }
        },
        __el = {
            Browser: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view}, iframe = $KD.first(view);

                if(iframe) hash.iframe = iframe;

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Button: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Calendar: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, picker:model._kwebfw_.picker, input:null, icon:null},
                    input = $KD.first(view), icon = $KD.next(input);

                if(icon.tagName === 'IMG') {
                    hash.icon = icon;
                    hash.input = input;
                } else {
                    hash.icon = input;
                    hash.input = icon;
                }

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Canvas: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, canvas: $KD.first(view)};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Camera: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, video: $KD.first(view)};

                hash.canvas = $KD.next(hash.video);

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            CheckBoxGroup: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            CollectionView: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                if($KU.scrollType() === 'native') {
                    hash.viewport = $KD.first(hash.node);
                    hash.scrolee = hash.viewport;
                } else {
                    hash.viewport = hash.node;
                    hash.scrolee = $KD.first(hash.node);
                }

                hash.docker = $KD.next(hash.scrolee);
                hash.blocker = $KD.first(hash.docker);
                //hash.pageNav = $KD.next(hash.docker);
                //TODO:: pull/push will come and sit here
                hash.vScroll = $KD.last(hash.node);
                hash.hScroll = $KD.prev(hash.vScroll);

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            CustomWidget: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            DataGrid: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, table:$KD.first(view)};

                hash.docker = $KD.next(hash.table);
                hash.viewport = hash.node;
                if(model.dockingHeader) {
                    hash.dockedheader = $KD.first(hash.docker);
                }
                hash.header = $KD.first(hash.table);

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            FlexContainer: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            FlexScrollContainer: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, viewport:view};

                if($KU.scrollType() === 'native') {
                    hash.scrolee = hash.viewport;
                } else {
                    hash.scrolee = $KD.first(hash.viewport);
                    hash.hScroll = $KD.next(hash.scrolee);
                    hash.vScroll = $KD.next(hash.hScroll);
                }

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Form2: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, header:$KD.first(view)};

                hash.viewport = $KD.next(hash.header);

                if($KU.scrollType() === 'native') {
                    hash.scrolee = hash.viewport;
                } else {
                    hash.scrolee = $KD.first(hash.viewport);
                    hash.hScroll = $KD.next(hash.scrolee);
                    hash.vScroll = $KD.next(hash.hScroll);
                }

                hash.footer = $KD.next(hash.viewport);

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Image2: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, image:$KD.first(view)};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Label: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            ListBox: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                if($KU.is(model, 'widget', 'ListBox')
                && model.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                    hash.input = $KD.first(hash.node);
                    hash.icon = $KD.next(hash.input);
                }

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Map: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            RadioButtonGroup: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            RichText: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            SegmentedUI2: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                hash.topscrolee = $KD.first(hash.node);
                hash.viewport = hash.node;
                hash.scrolee = $KD.next(hash.topscrolee);
                hash.bottomscrolee = $KD.next(hash.scrolee);

                hash.docker = $KD.next(hash.bottomscrolee);
                hash.blocker = $KD.first(hash.docker);
                hash.pageNav = $KD.next(hash.docker);
                //TODO:: pull/push will come and sit here
                hash.vScroll = $KD.last(hash.node);
                hash.hScroll = $KD.prev(hash.vScroll);

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Slider: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, slider:$KD.first(view)},
                    children = $KD.children(hash.slider);

                hash.minLabel = children[0];
                hash.seekbar = children[1];
                hash.maxLabel = children[2];

                children = $KD.children(hash.seekbar);

                hash.min = children[0];
                hash.max = children[1];
                hash.thumb = children[2];

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Switch: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, switch:$KD.first(view)},
                    children = $KD.children(hash.switch);

                hash.left = children[0];
                hash.right = children[1];

                hash.thumb = $KD.last(hash.node);
                hash.thumb = $KD.first(hash.thumb);

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            TabPane: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, wrapper:$KD.first(view)};

                hash.tabs = $KD.find(hash.wrapper, '[kr="tabs"]')[0];
                hash.viewport = $KD.find(hash.wrapper, '[kr="viewport"]')[0];

                if($KU.scrollType() === 'native') {
                    hash.scrolee = $KD.find(hash.wrapper, '[kr="viewport"]')[0];
                } else {
                    hash.scrolee = $KD.first(hash.viewport);
                    hash.hScroll = $KD.next(hash.scrolee);
                    hash.vScroll = $KD.next(hash.hScroll);
                }

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            TextArea2: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            TextBox2: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            },

            Video: function(model, view, $KU, $KW, $KD, key) {
                var hash = {node:view, video:$KD.first(view)};

                return (typeof key === 'string' && key) ? hash[key] : hash;
            }
        },
        _modal = {
            collectAllModals: function(fmodel) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, children = null,
                    queue = [], modals = [], info = null, infoList = null;

                if(fmodel.isVisible && fmodel.zIndex !== voltmx.flex.ZINDEX_AUTO) {
                    queue = [{model: fmodel, path: [0], zIndex: [0]}];
                }

                //This while loop do a breadth first search iteration
                while(queue.length) {
                    infoList = [];
                    info = _modal.dequeue(queue);
                    children = _children(info.model);

                    $KU.each(children, function(cmodel, index) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            path = null, zIndex = null, meta = null;

                        if(cmodel.zIndex !== voltmx.flex.ZINDEX_AUTO
                        && cmodel.isVisible && !cmodel._kwebfw_.oid
                        && ($KU.is(cmodel, 'widget', 'component')
                        || $KU.is(cmodel, 'widget', 'FlexContainer')
                        || $KU.is(cmodel, 'widget', 'FlexScrollContainer'))) {
                            //Container inside TabPane to be excluded
                            if(!_tpmodel(cmodel)) {
                                path = this.path.slice(0);
                                path.push(index);

                                zIndex = this.zIndex.slice(0);
                                zIndex.push(cmodel.zIndex);

                                meta = {model:cmodel, path:path, zIndex:zIndex};
                                infoList.push(meta);
                                cmodel.isModalContainer && modals.push(meta);
                            }
                        }
                    }, info);

                    infoList = _modal.filterOutModals(infoList);
                    queue = _modal.enqueue(queue, infoList);
                }

                return modals;
            },

            deduceFinalModal: function(modals) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    final = (modals.length) ? modals.shift() : null;

                $KU.each(modals, function(modal) {
                    if(final.zIndex[1] <= modal.zIndex[1]) {
                        final = modal;
                    }
                });

                return (final) ? final.model : null;
            },

            dequeue: function(queue) {
                return queue.shift();
            },

            enqueue: function(queue, items) {
                queue = queue.concat(items);

                return queue;
            },

            filterOutModals: function(modals) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    filtered = [], listLength = -1;

                if(modals.length <= 1) {
                    filtered = modals;
                } else {
                    //Taking first item from modals as every items...
                    //... zIndex array size is same
                    listLength = (modals[0].zIndex.length - 1);

                    //Sorting modals, based on zIndex
                    //Higher zIndex has higher priority
                    //For same zIndex, last added modal has higher priority
                    modals.sort(function(a, b) {
                        a = a.zIndex[listLength];
                        b = b.zIndex[listLength];

                        if(a > b) return -1;
                        return 1;
                    });


                    //Filtering out modal, based on zIndex
                    $KU.each(modals, function(modal) {
                        filtered.push(modal);

                        if(modal.model.isModalContainer) {
                            return true;
                        }
                    });


                    //Sorting filtered list, based on path
                    //Modal added later in sequence has higher priority
                    filtered.sort(function(a, b) {
                        a = a.path[listLength];
                        b = b.path[listLength];

                        if(a <= b) return -1;
                        return 1;
                    });
                }

                return filtered;
            }
        },
        _onrender = {
            CustomWidget: function() {
                var $K = voltmx.$kwebfw$;

                $K.ui.CustomWidget.onRender.call(this);
            },

            FlexScrollContainer : function() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    _ = this._kwebfw_, prop = _.prop;

                if(prop.retainScrollPosition === true) {
                    _retainScrollPosition(this, true);
                } else if(prop.contentOffset) {
                    $KW.setContentOffset(this, prop.contentOffset, true);
                }
            },

            Form2 : function() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    _ = this._kwebfw_, prop = _.prop;

                if(prop.retainScrollPosition === true) {
                    _retainScrollPosition(this, true);
                } else if(prop.contentOffset) {
                    $KW.setContentOffset(this, prop.contentOffset, true);
                }
            },

            Label: function() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, _ = this._kwebfw_,
                    prop = _.prop, view = _.view, fontSize = null, lineSpacing = 0;

                if(prop.textStyle && Object.prototype.hasOwnProperty.call(prop.textStyle, 'lineSpacing')) {
                    lineSpacing = prop.textStyle.lineSpacing;

                    //Similar IF block can be found in voltmxlabel.js file Label$_view_textStyle function
                    fontSize = $KD.style(view, 'font-size').replace('px', '');

                    if($KU.is(fontSize, 'numeric')) {
                        fontSize = parseInt(fontSize, 10);
                        $KD.style(view, 'lineHeight', ((fontSize+lineSpacing)+'px'));
                    } else {
                        $KD.style(view, 'line-height', null);
                    }
                }
            },

            ListBox: function() {
                var _ = this._kwebfw_, prop = _.prop, view = _.view;

                if(prop.viewType === constants.LISTBOX_VIEW_TYPE_LISTVIEW && !prop.selectedKey) {
                    view.value = prop.selectedKey;
                }
            },

            SegmentedUI2 : function() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    _ = this._kwebfw_, prop = _.prop;

                if(prop.retainScrollPositionMode === constants.SEGUI_SCROLL_POSITION_RETAIN) {
                    _retainScrollPosition(this, true);
                } else if(prop.contentOffset) {
                    $KW.setContentOffset(this, prop.contentOffset, true);
                }
            }
        };


    //All the functions will be called in the scope of widget instance
    var _args = {
        Calendar: {
            onDone: function(payload) {
                var args = [];

                if(payload) {
                    args.push(payload.isValidDateSelected);
                }

                return args;
            },

            onSelection: function(payload) {
                var args = [];

                if(payload) {
                    args.push(payload.isValidDateSelected);
                }

                return args;
            }
        },

        Camera: {
            onCapture: function(payload) {
                var args = [];

                if(payload) {
                    args.push(payload);
                }

                return args;
            },

            onCaptureFailed: function(payload) {
                var args = [];

                if(payload) {
                    args.push(payload);
                }

                return args;
            },

            onFailure: function(payload) {
                var args = [];

                if(payload) {
                    args.push(payload);
                }

                return payload;
            }
        },

        CollectionView: {
            onItemSelect: function(payload) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, args = [], item = null,
                    _ = this._kwebfw_, prop = _.prop, data = prop.data;

                if(payload.secIndex === -1) {
                    item = data[payload.itemIndex];
                } else if(payload.itemIndex === -1) {
                    item = data[payload.secIndex][0];
                } else if(payload.itemIndex === -2) {
                    item = data[payload.secIndex][2];
                } else {
                    item = data[payload.secIndex][1][payload.itemIndex];
                }

                args.push(payload.secIndex, item, payload.itemIndex);
                //TODO
                if(prop.selectionBehavior !== constants.SEGUI_DEFAULT_BEHAVIOR) {
                    args.push(false);

                    $KU.each(_.selectedRows, function(index) {
                        if(index[0] === payload.secIndex
                        && index[1] === payload.itemIndex) {
                            args[(args.length - 1)] = true;
                            return true;
                        }
                    });
                }

                //TODO:: If any of args[2] and args[3] value is -1
                //       And needs to be set to 0, then do here, at last.

                return args;
            },

            onItemDisplay: function(payload) {
                return [payload.sectionIndex, payload.itemIndex, payload.itemModel];
            }
        },

        DataGrid: {
            onRowSelected: function() {
                var args = [];

                //

                return args;
            },

            columnOnClick: function(payload) {
                var args = [];

                if(payload) {
                    args.push(payload.cellIndex);
                }

                return args;
            }

        },

        FlexContainer: {
            onBreakpointHandler: function(/*payload*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, args = [];

                if($KU.is(this, 'widget', 'component')) {
                    args = [$KA.currentBreakpoint];
                }

                return args;
            },

            onBreakpointChange: function(/*payload*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, args = [];

                if($KU.is(this, 'widget', 'component')) {
                    args = [$KA.currentBreakpoint];
                }

                return args;
            }
        },

        FlexScrollContainer: {
            onBreakpointHandler: function(/*payload*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, args = [];

                if($KU.is(this, 'widget', 'component')) {
                    args = [$KA.currentBreakpoint];
                }

                return args;
            },

            onBreakpointChange: function(/*payload*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app, args = [];

                if($KU.is(this, 'widget', 'component')) {
                    args = [$KA.currentBreakpoint];
                }

                return args;
            }
        },

        Form2: {
            onBreakpointHandler: function(/*payload*/) {
                var $K = voltmx.$kwebfw$, $KA = $K.app,
                    args = [$KA.currentBreakpoint];

                return args;
            },

            onBreakpointChange: function(/*payload*/) {
                var $K = voltmx.$kwebfw$, $KA = $K.app,
                    args = [$KA.currentBreakpoint];

                return args;
            }
        },

        Image2: {
            onDownloadComplete: function(payload) {
                var args = [];

                if(payload) {
                    args.push(payload.src);
                    args.push(payload.isSuccess);
                }

                return args;
            }
        },

        ListBox: {
            onSelection: function(/*payload*/) {
                var args = [];

                //

                return args;
            }
        },

        Map: {
            onPinClick: function(payload) {
                var args = [];

                args.push(payload.locationData);

                return args;
            },
            onClick: function(payload) {
                var args = [];

                if(payload) {
                    args.push(payload.latLng);
                }

                return args;
            }
        },

        RichText: {
            onClick: function(/*payload*/) {
                var args = [];

                //

                return args;
            }
        },

        SegmentedUI2: {
            onRowClick: function(payload) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, args = [], item = null,
                    _ = this._kwebfw_, prop = _.prop, data = prop.data;

                if(payload.secIndex === -1) {
                    item = data[payload.rowIndex];
                } else if(payload.rowIndex === -1) {
                    item = data[payload.secIndex][0];
                } else {
                    item = data[payload.secIndex][1][payload.rowIndex];
                }

                args.push(payload.secIndex, item, payload.rowIndex);

                if(prop.selectionBehavior !== constants.SEGUI_DEFAULT_BEHAVIOR) {
                    args.push(false);

                    $KU.each(_.selectedRows, function(index) {
                        if(index[0] === payload.secIndex
                        && index[1] === payload.rowIndex) {
                            args[(args.length - 1)] = true;
                            return true;
                        }
                    });
                }

                //TODO:: If any of args[2] and args[3] value is -1
                //       And needs to be set to 0, then do here, at last.

                return args;
            },

            onRowDisplay: function(payload) {
                return Object.values(payload);
            },

            onSwipe: function(payload) {
                var data = this._kwebfw_.prop.data, args = [];

                args.push(data[payload.rowIndex], -1, payload.rowIndex);
                //TODO:: withSections needs to be handled properly otherwise will lead to errors.

                return args;
            }
        },

        Slider: {
            onSelection: function(/*payload*/) {
                var args = [];

                //

                return args;
            },

            onSlide: function(/*payload*/) {
                var args = [];

                //

                return args;
            }
        },

        Switch: {
            onSlide: function(/*payload*/) {
                var args = [];

                //

                return args;
            }
        },

        TabPane: {
            onTabClick: function(payload) {
                var args = [];

                if(payload) {
                    args.push(payload.tabIndex);
                }

                return args;
            }
        },

        TextArea2: {
            onBeginEditing: function(/*payload*/) {
                var args = [];

                //

                return args;
            },

            onEndEditing: function(/*payload*/) {
                var args = [];

                //

                return args;
            },

            onKeyDown: function(/*payload*/) {
                var args = [];
                /*
                if(payload) {
                    args.push({
                        altKey: payload.altKey,
                        ctrlKey: payload.ctrlKey,
                        metaKey: payload.metaKey,
                        shiftKey: payload.shiftKey,
                        keyCode: payload.keyCode
                    });
                }
                //*/
                return args;
            },

            onKeyUp: function(/*payload*/) {
                var args = [];
                /*
                if(payload) {
                    args.push({
                        altKey: payload.altKey,
                        ctrlKey: payload.ctrlKey,
                        metaKey: payload.metaKey,
                        shiftKey: payload.shiftKey,
                        keyCode: payload.keyCode
                    });
                }
                //*/
                return args;
            },

            onTextChange: function(/*payload*/) {
                var args = [];

                //

                return args;
            }
        },

        TextBox2: {
            onBeginEditing: function(/*payload*/) {
                var args = [];

                //

                return args;
            },

            onEndEditing: function(/*payload*/) {
                var args = [];

                //

                return args;
            },

            onKeyDown: function(/*payload*/) {
                var args = [];
                /*
                if(payload) {
                    args.push({
                        altKey: payload.altKey,
                        ctrlKey: payload.ctrlKey,
                        metaKey: payload.metaKey,
                        shiftKey: payload.shiftKey,
                        keyCode: payload.keyCode
                    });
                }
                //*/
                return args;
            },

            onKeyUp: function(/*payload*/) {
                var args = [];
                /*
                if(payload) {
                    args.push({
                        altKey: payload.altKey,
                        ctrlKey: payload.ctrlKey,
                        metaKey: payload.metaKey,
                        shiftKey: payload.shiftKey,
                        keyCode: payload.keyCode
                    });
                }
                //*/
                return args;
            },

            onTextChange: function(/*payload*/) {
                var args = [];

                //

                return args;
            }
        }
    };


    //All the functions will be called in the scope of widget instance
    var _change = {
        CollectionView: function(model, key, old) {
            var index = model._kwebfw_.ii.split(','),
                secIndex = parseInt(index[0], 10),
                rowIndex = parseInt(index[1], 10);

            if(secIndex < -1) secIndex = -1;
            if(rowIndex < -2) rowIndex = -2;

            this.setDataAt(model, key, old, rowIndex, secIndex);
        },

        DataGrid: function(model, key, old) {
            var index = model._kwebfw_.ii.split(','),
                rowIndex = parseInt(index[0], 10),
                colIndex = parseInt(index[1], 10);

            this.setDataAt(model, key, old, rowIndex, colIndex);
        },

        MenuContainer: function(/*model, key, old*/) {
            //
        },

        SegmentedUI2: function(model, key, old) {
            var index = model._kwebfw_.ii.split(','),
                secIndex = parseInt(index[0], 10),
                rowIndex = parseInt(index[1], 10);

            if(secIndex < -1) secIndex = -1;
            if(rowIndex < -1) rowIndex = -1;

            this.setDataAt(model, key, old, rowIndex, secIndex);
        }

    };


    //All the functions will be called in the scope of widget instance
    var _context = {
        CollectionView: function(/*model*/) {
            //
        },

        DataGrid: function(/*model*/) {
            //
        },

        MenuContainer: function(/*model*/) {
            //
        },

        SegmentedUI2: function(model) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                index = null, secIndex = -1, rowIndex = -1;

            if($KU.is(model, 'widget')) {
                index = model._kwebfw_.ii.split(',');
            } else if($KU.is(model, 'object')) {
                index = [model.secIndex, model.rowIndex];
            }

            if(index) {
                secIndex = parseInt(index[0], 10);
                rowIndex = parseInt(index[1], 10);

                if(secIndex < -1) secIndex = -1;
                if(rowIndex < -1) rowIndex = -1;
            }

            return {rowIndex:rowIndex, sectionIndex:secIndex, widgetInfo:this};
        }
    };


    //All the functions will be called in the scope of widget instance
    var _infoAtIndex = {
        CollectionView: function(/*index*/) {
            //
        },

        DataGrid: function(/*index*/) {
            //
        },

        MenuContainer: function(/*index*/) {
            //
        },

        SegmentedUI2: function(index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, oid = '',
                template = null, info = null, prop = this._kwebfw_.prop, ii = '',
                data = this.data, clones = this._kwebfw_.clones;

            if($KU.is(data, 'array')) {
                oid = this._kwebfw_.uid;
                ii = (index[0] + ','+index[1]);

                if(index[0] >= 0 && index[1] >= 0) { //Row inside section
                    if($KU.is(data[index[0]], 'array')
                    && $KU.is(data[index[0]][1], 'array')
                    && $KU.is(data[index[0]][1][index[1]], 'object')) {
                        info = {data:data[index[0]][1][index[1]], index:index, template:null};

                        if($KU.is(clones[index[0]][1][index[1]], 'widget')) {
                            info.template = clones[index[0]][1][index[1]];
                        } else {
                            template = info.data.template || this.rowTemplate;
                            if($KU.is(template, 'string')) {
                                template = $KW.getTemplate(this, template);
                            }
                            info.template = $KW.cloneTemplate(template, info.data, prop.widgetDataMap, function(widget/*, pwidget, windex*/) {
                                widget._kwebfw_.oid = oid;
                                widget._kwebfw_.ii = ii;
                            });
                            clones[index[0]][1][index[1]] = info.template;
                        }
                    }
                } else if(index[0] >= 0 && index[1] < 0) { //Section not row
                    if($KU.is(data[index[0]], 'array')
                    && $KU.is(data[index[0]][0], 'object')) {
                        info = {data:data[index[0]][0], index:index, template:null};

                        if($KU.is(clones[index[0]][0], 'widget')) {
                            info.template = clones[index[0]][0];
                        } else {
                            template = info.data.template || this.sectionHeaderTemplate;
                            if($KU.is(template, 'string')) {
                                template = $KW.getTemplate(this, template);
                            }
                            info.template = $KW.cloneTemplate(template, info.data, prop.widgetDataMap, function(widget/*, pwidget, windex*/) {
                                widget._kwebfw_.oid = oid;
                                widget._kwebfw_.ii = ii;
                            });
                            clones[index[0]][0] = info.template;
                        }
                    }
                } else if(index[0] < 0 && index[1] >= 0) { //Row that does not have a section
                    if($KU.is(data[index[1]], 'object')) {
                        info = {data:data[index[1]], index:index, template:null};

                        if($KU.is(clones[index[1]], 'widget')) {
                            info.template = clones[index[1]];
                        } else {
                            template = info.data.template || this.rowTemplate;
                            if($KU.is(template, 'string')) {
                                template = $KW.getTemplate(this, template);
                            }
                            info.template = $KW.cloneTemplate(template, info.data, prop.widgetDataMap, function(widget/*, pwidget, windex*/) {
                                widget._kwebfw_.oid = oid;
                                widget._kwebfw_.ii = ii;
                            });
                            clones[index[1]] = info.template;
                        }
                    }
                }
            }

            return info;
        }
    };


    var _accessibility = function $KW_accessibility(model, clone) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            _ = null, prop = null, el = null, dom = null, old = null;

        model = $KW.model(model);

        if(model) {
            _ = model._kwebfw_;
            prop = _.prop;
            el = _el(model);

            if(el.node) {
                if($KU.is(clone, 'object') && !$KU.is(clone, 'widget')) {
                    old = clone;
                }
                if(!$KU.is(clone, 'boolean')) clone = false;

                if (_name(model) === 'Calendar') {
                    for (var index of Object.keys(el.node.children)) {
                        dom = _focusableElement(model, el.node.children[index].tagName);
                        _a11y.clean(model, dom, old);
                        _setupUIInteraction(model, dom, clone);
                        if ($KU.shouldApplyA11Y()) {
                            _a11y.apply(model, dom, prop.accessibilityConfig);
                        }
                    }
                } else {
                    dom = _focusableElement(model);
                    _a11y.clean(model, dom, old);
                    _setupUIInteraction(model, dom, clone);

                    if ($KU.shouldApplyA11Y()) {
                        _a11y.apply(model, dom, prop.accessibilityConfig);
                    }
                }
            }
        }
    };


    var _addSkin = function $KW_addSkin(skin, node) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

        if($KU.is(node, 'dom')) {
            if($KU.is(skin, 'string') && skin) {
                $KD.addCls(node, skin);
            } else if($KU.is(skin, 'object')) {
                $KU.each(skin, function(val, key) {
                    $KD.style(node, key, val);
                });
            }
        }
    };


    var _addToView = function $KW_addToView(view, dom) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, last = null;

        if($KU.is(view, 'dom') && ($KU.is(dom, 'dom') || $KU.is(dom, 'fragment'))) {
            if(['scrolee', 'viewport'].indexOf($KD.getAttr(view, 'kr')) >= 0) {
                $KD.add(view, dom);
            } else if($KD.hasAttr(view, 'kw')) {
                last = $KD.last(view);

                if($KU.is(last, 'dom') && ['kfb'].indexOf($KD.getAttr(last, 'kr')) >= 0) {
                    $KD.before(last, dom);
                } else {
                    $KD.add(view, dom);
                }
            }
        }
    };


    var _applyGroupA11Y = function $KW_applyGroupA11Y(node, a11y, label, hintId) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, a11yHint = '',
            a11yLabel = (a11y) ? _a11y.prepareLabel(a11y, label) : label;

        if(a11yLabel) {
            $KD.setAttr(node, 'aria-label', a11yLabel);
        }

        if(a11y && $KU.is(a11y.a11yHint, 'string')) {
            a11yHint = a11y.a11yHint.trim();
        }

        if(a11yHint) {
            _a11y.createHint(a11yHint, hintId);
            $KD.setAttr(node, 'aria-describedby', hintId);
        }
    };

    /*eslint-disable no-console*/
    var _auditFakeBorders = function $KW_auditFakeBorders() {
        console.log('***************************** FAKE BORDER STARTS *****************************');

        document.querySelectorAll('[kr="kfb"]').forEach(function(fakeBorder) {
            if(fakeBorder.nextElementSibling) {
                console.log(fakeBorder);
            }
        });

        console.log('****************************** FAKE BORDER ENDS ******************************');
    };
    /*eslint-enable no-console*/


    var _auditFlexDetails = function $KW_auditFlexDetails(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            pmodel = null, details = {}, k = '',
            prepare = function(widget, who) {
                var flex = [];

                if(!details.info) {
                    details = {
                        id: {},
                        info: {},
                        path: {},
                        flex: {},
                        height: {},
                        width: {},
                        horizontal: {},
                        vertical: {},
                        zindex: {}
                    };
                }

                for(k in widget._kwebfw_.flex.final) {
                    if(Object.prototype.hasOwnProperty.call(widget._kwebfw_.flex.final, k)) {
                        (function(value, key) {
                            if(key !== 'zIndex') {
                                flex.push((key+'=<'+value+'>'));
                            }
                        }(widget._kwebfw_.flex.final[k], k));
                    }
                }

                if(!details.info[who]) details.info[who] = {};

                details.id[who] = ('uid=<'+widget._kwebfw_.uid+'>, id=<'+widget.id+'>');
                details.info[who] = ('widget=<'+widget._kwebfw_.name+'>, layout=<'+_layout(widget)+'>');
                details.path[who] = ('<'+widget._kwebfw_.wap.split('_').join('.')+'>');
                details.flex[who] = flex.join(', ');
                details.height[who] = ('minHeight=<'+widget.minHeight+'>, height=<'+widget.height+'>, maxHeight=<'+widget.maxHeight+'>');
                details.width[who] = ('minWidth=<'+widget.minWidth+'>, width=<'+widget.width+'>, maxWidth=<'+widget.maxWidth+'>');
                details.horizontal[who] = ('left=<'+widget.left+'>, centerX=<'+widget.centerX+'>, right=<'+widget.right+'>');
                details.vertical[who] = ('top=<'+widget.top+'>, centerY=<'+widget.centerY+'>, bottom=<'+widget.bottom+'>');
                details.zindex[who] = ('actual=<'+widget.zIndex+'>, final=<'+widget._kwebfw_.flex.final.zIndex+'>');
            };

        model = $KW.model(model);

        if(!model) {
            throw new Error('Unable to derive widget model.');
        } else {
            pmodel = _pmodel(model);

            prepare(model, 'me');
            pmodel && prepare(pmodel, 'parent');
            /*eslint-disable no-console*/
            console.clear('');
            console.table(details);
            /*eslint-enable no-console*/
        }
    };


    /*eslint-disable*/
    var _auditModelAnomalies = function $KW_auditModelAnomalies(arg0) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app,
            model = $KW.model(arg0) || $KW.model($KA.currentFormUID);

        //TODO::
    };
     /*eslint-enable*/


    var _children = function $KW_children(model, arg1) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            children = [], config = ($KU.is(arg1, 'object') ? arg1 : {});

        if(!$KU.is(config.tabs, 'boolean')) config.tabs = false;

        model = _proxy($KW.model(model));

        if(_isContainer(model)) {
            $KU.each(model.widgets(), function(widget) {
                children.push(_proxy(widget));
            });
        } else if(config.tabs && $KU.is(model, 'widget', 'TabPane')) {
            $KU.each(model._kwebfw_.tabs, function(tab) {
                children.push(this[tab.id]);
            }, model);
        }

        return children;
    };


    var _clearGroupA11y = function $KW_clearGroupA11y(model, masterData, masterDataMap) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, uid = model._kwebfw_.uid;

        if(masterData) {
            $KU.each(masterData, function(data) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    hintId = null, div = null;

                if(data[2]) {
                    hintId = (uid+'_'+data[0]+'_hint');
                    div = document.getElementById(hintId);
                    div && $KD.remove(div);
                }
            });
        }

        if(masterDataMap && masterDataMap[0]) {
            $KU.each(masterDataMap[0], function(data) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    hintId = null, div = null;

                if(data['accessibilityConfig']) {
                    hintId = (uid+'_'+data[masterDataMap[1]]+'_hint');
                    div = document.getElementById(hintId);
                    div && $KD.remove(div);
                }
            });
        }
    };


    var _cloneTemplate = function $KW_cloneTemplate(tpl, data, widgetDataMap, callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, clone = null, isCloned = false;

        if($KW.isContainer(tpl)) {
            clone = tpl._voltmxControllerName ? tpl : $KU.clone(tpl);
            isCloned = (tpl._kwebfw_.is.cloned === true) ? true : false;

            if($KU.is(data, 'object')) {
                $KW.iterate(clone, function(model, pmodel, index) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils, defaultProp = null, dataId = '',
                        wap = null, _ = model._kwebfw_, prop = undefined,
                        userwidget = (_.uwi instanceof voltmx.ui.UserWidget) ? _.uwi : null;

                    if(!isCloned) {
                        _.is.cloned = true;

                        if(userwidget) {
                            userwidget._kwebfw_.is.cloned = true;
                        }
                    }

                    wap = _getWidgetDataMapPath(model);

                    //This is needed, to avoid "onTextChange" event being fired
                    //Example, for TextBox2 widget, after clonning the widget...
                    //masterdata specific "text" is set, which fires "onTextChange"
                    _.skip = {event:true};

                    dataId = widgetDataMap[wap];

                    if($KU.is(dataId, 'string') && dataId
                    && Object.prototype.hasOwnProperty.call(data, dataId)) {
                        prop = data[dataId];
                    }

                    if(!$KU.is(prop, 'undefined') && !$KU.is(prop, 'object')) {
                        defaultProp = _getDefaultProperty(model);
                        prop = {};
                        prop[defaultProp] = data[dataId];
                    }

                    if($KU.is(prop, 'object')) {
                        if($K.F.EIWP) {
                            if($KU.is(model, 'widget', 'ListBox')) {
                                if($KU.is(prop.selectedKeys, 'null') && !model.multiSelect) {
                                    delete prop.selectedKeys;
                                }
                            }
                        }

                        $KU.each(prop, function(value, key) {
                            var container = null, controller = null;

                            if(['metaInfo'].indexOf(key) < 0) {
                                if($KU.is(value, 'i18n')) {
                                    value = $KU.getI18Nvalue(value);
                                }

                                if(userwidget) {
                                    userwidget[key] = value;
                                } else {
                                    container = _rmodel(model);

                                    if($KU.is(value, 'string') && value
                                    && container._kwebfw_.is.component
                                    && $KU.hasEventProperty(model, key)) {
                                        controller = _voltmx.mvc.getComponentController(container._voltmxControllerName, container.appName);
                                        //this condition is for setting string as callback in masterdata
                                        if(controller && $KU.is(controller[value], 'function')) {
                                            model._kwebfw_.prop[key] = controller[value];
                                        }// todo: for User widget pass through events
                                    } else {
                                        if(!(model instanceof voltmx.ui.GroupWidget && ['selectedKeyValue', 'selectedKeyValues'].indexOf(key) !== -1)) {
                                            model[key] = value;
                                        }
                                    }
                                }
                            }
                        });
                    } else {
                        //Log Info
                    }

                    if($KU.is(callback, 'function')) {
                        callback(model, pmodel, index);
                    }

                    delete _.skip;

                    if(userwidget) return true;
                }, {tabs:false});
            } else if($KU.is(data, 'string')
            && clone.id === 'flxkwebfwHeader'
            && clone.labelkwebfwHeader) {
                //This is needed, to avoid "onTextChange" event being fired
                //Example, for TextBox2 widget, after clonning the widget...
                //masterdata specific "text" is set, which fires "onTextChange"
                clone._kwebfw_.skip = {event:true};
                clone.labelkwebfwHeader.text = data;

                if($KU.is(callback, 'function')) {
                    callback(clone);
                }

                delete clone._kwebfw_.skip;
            }
        }

        return clone;
    };


    //This iterate over model.parent
    var _closest = function $KW_closest(model, callback, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            pmodel = null, omodel = null, flag = null;

        if(!$KU.is(config, 'object')) config = {};
        if(!Object.prototype.hasOwnProperty.call(config, 'scope')) config.scope = this;
        if(!$KU.is(config.owner, 'boolean')) config.owner = true;
        if(!$KU.is(config.tabs, 'boolean')) config.tabs = true;

        pmodel = model = _proxy(model);
        omodel = _omodel(model);

        while(pmodel) {
            flag = callback.call(config.scope, pmodel);

            if(flag === true) {
                return pmodel;
            } else if(flag === false) {
                return null;
            }
            pmodel = _pmodel(pmodel, {tabs:config.tabs});

            if(!pmodel && omodel
                && config.owner === true) {
                pmodel = omodel;
                omodel = null;
            }
        }

        return null;
    };


    var _closestScrollableWidget = function $KW_closestScrollableWidget(model) {
        var scrollableModel = null;

        while(model) {
            if(_isScrollableWidget(model)) {
                scrollableModel = model;
                break;
            }

            model = _pmodel(model);
        }

        return scrollableModel;
    };


    var _cmodel = function $KW_cmodel(model, childIdOrIndex) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, id = '';

        model = $KW.model(model);

        if(_isContainer(model)) {
            model = _proxy(model);

            if($KU.is(childIdOrIndex, 'number') && childIdOrIndex >= 0
            && childIdOrIndex < model._kwebfw_.children.length) {
                id = model._kwebfw_.children[childIdOrIndex].id;
            } else if($KU.is(childIdOrIndex, 'string') && childIdOrIndex) {
                id = childIdOrIndex;
            }
        }

        return (id && $KU.is(model[id], 'widget')) ? model[id] : null;
    };


    var _component = function $KW_component(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            _ = null, component = null, rmodel = null;

        model = $KW.model(model);

        if(model) {
            rmodel = _rmodel(model);

            if(rmodel) {
                _ = rmodel._kwebfw_;

                if(_.uwi instanceof voltmx.ui.UserWidget) {
                    component = _.uwi;
                } else if(rmodel instanceof voltmx.ui.UserWidget) {
                    component = rmodel;
                }
            }
        }

        return component;
    };


    var _contains = function $KW_contains(model, target, owner) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, flag = false;

        if(!$KU.is(owner, 'boolean')) owner = true;

        model = _proxy(model);
        target = _proxy(target);

        if(model && target) {
            _closest(target, function(widget) {
                if(widget === this) {
                    flag = true;
                    return true;
                }
            }, {owner:owner, scope:model});
        }

        return flag;
    };


    var _deduceModalContainer = function $KW_deduceModalContainer(fmodel) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KA = $K.app,
            cf = $KW.model($KA.currentFormUID), modals = null, modalContainer = null;

        if($KU.is(fmodel, 'widget', 'Form2') && fmodel === cf) {
            modals = _modal.collectAllModals(fmodel);
            modalContainer = _modal.deduceFinalModal(modals);
        }

        return modalContainer;
    };


    var _details = function $KW_details(omodel, index, model, view) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, i = 0,
            len = 0, info= null, details = null;

        if($KU.is(index, 'string')) {
            index = index.split(',');
        }

        if($KU.is(index, 'array')) {
            len = index.length;
            for(i=0; i<len; i++) {
                index[i] = parseInt(index[i], 10);
            }
        }

        if($KU.is(index, 'array') && index.length > 0 && $KU.is(view, 'dom')
        && $KU.is(omodel, 'widget') && $KU.is(model, 'widget')
        && $KU.is(_infoAtIndex[_name(omodel)], 'function')) {
            info = _infoAtIndex[_name(omodel)].call(omodel, index);

            if(info) {
                details = {template:info.template, data:info.data, index:info.index};

                if($KU.is(view, 'dom')) {
                    details.view = view;
                }

                if($KU.is(model, 'widget')) {
                    details.wdata = info.data[model.id];
                    details.model = info.template[model.id];
                }
            }
        }

        return details;
    };


    var _disabled = function $KW_disabled(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, omodel = null, disabled = false;

        model = $KW.model(model);
        omodel = (model) ? $KW.omodel(model) : null;

        if(model) {
            disabled = model._kwebfw_.disabled;

            if(!disabled && omodel) {
                disabled = omodel._kwebfw_.disabled;
            }
        }

        return disabled;
    };


    var _dismissPickers = function $KW_dismissPickers(fmodel) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            pickers = _pickers(fmodel), targetModel =_getRootNode(fmodel);

        $KU.each(pickers, function(uid) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                model = $KW.model(uid), _ = null;

            if(model) {
                _ = model._kwebfw_;
                $KD.remove(_.picker);
                delete _.picker;
            }
        });

        delete targetModel._kwebfw_.pickers;
    };

    var _dismissPicker = function $KW_dismissPicker(model) {
        var pickers = _pickers(model);

        if(pickers[model._kwebfw_.uid]) {
            delete pickers[model._kwebfw_.uid];
        }
    };


    var _el = function $KW_el(model, key) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, name = '', view = null;

        if(typeof key !== 'string') key = '';

        if($KU.is(model, 'widget')) {
            model = _proxy(model);

            view = model._kwebfw_.view;
        } else if($KU.is(model, 'dom')) {
            view = model;
            model = $KW.model(view);
        }

        name = _name(model);

        if(name && $KU.is(__el[name], 'function')) {
            if($KU.is(view, 'dom') && $KU.is(model, 'widget')) {
                return __el[name](model, view, $KU, $KW, $KD, key);
            }
            return {node:null};
        }
        return {node:null};
    };


    var _evaluateScrollPosition = function $KW_evaluateScrollPosition(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, e = 0,
            elen = 0, myself = null, elements = [], selector = '',
            renderCheck = false, evaluate = function(dom, check) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    widget = null, prop = null;

                if(!check || document.getElementById(dom.id)) {
                    widget = $KW.model(dom);
                    prop = widget._kwebfw_.prop;

                    if($KU.is(widget, 'widget', 'SegmentedUI2')
                    || $KU.is(widget, 'widget', 'CollectionView')) {
                        _retainSelection(widget);
                    } else {
                        _retainScrollPosition(widget, prop.retainScrollPosition);
                    }
                }
            };

        if($KU.is(model, 'list')) {
            elements = model;
            renderCheck = true;
        } else if(!arguments.length
        || ($KU.is(model, 'widget')
        && model._kwebfw_.ui.scroll
        && _isRendered(model))) {
            selector = 'form[kw="Form2"],div[kw="FlexScrollContainer"],div[kw="SegmentedUI2"],div[kw="CollectionView"]';
        }

        if(selector) {
            if(arguments.length) {
                myself = model._kwebfw_.view;
                elements = $KD.find(myself, selector);
            } else {
                elements = $KD.find(document, selector);
            }
        }

        if(myself) evaluate(myself, renderCheck);

        elen = elements.length;
        for(e=0; e<elen; e++) {
            evaluate(elements[e], renderCheck);
        }
    };


    var _fire = function $KW_fire(model, type, scope, payload, callbacks) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KAR = $K.automation.recorder, item = null,
            omodel = $KW.omodel(model), args = [model], context = null,
            cf = _getRootNode(model),
            noForceLayoutEventList = ['onInit', 'preShow', 'onBreakpointHandler', 'onBreakpointChange'];

        if(model._kwebfw_.skip && model._kwebfw_.skip.event) return false;

        if(arguments.length === 4 && $KU.is(payload, 'array')) {
            callbacks = payload;
            payload = null;
        }

        if($KU.is(_args[_name(model)], 'object')
        && $KU.is(_args[_name(model)][type], 'function')) {
            args = args.concat(_args[_name(model)][type].call(model, payload));

            if(payload) {
                if($KU.is(model, 'widget', 'SegmentedUI2')) {
                    item = args[2];
                    args.splice(2, 1);
                } else if($KU.is(model, 'widget', 'DataGrid')) {
                    item = args[1];
                    args.splice(1, 1);
                } else if($KU.is(model, 'widget', 'RichText')) {
                    args.push(payload.name, payload.href);
                }
            }
        }

        if(omodel) {
            context = _context[_name(omodel)].call(omodel, model, args);
            args.push(context);
        }

        if(payload && ['onTouchStart', 'onTouchMove', 'onTouchEnd'].indexOf(type) >= 0) {
            args.splice(($KU.is(args[0], 'widget') ? 1 : 0), 0, payload.x, payload.y);
        }

        if(type === 'onScrollWidgetPosition') {
            args.splice(($KU.is(args[0], 'widget') ? 1 : 0), 0, payload.positionLeft, payload.positionTop, payload.x, payload.y);
        }

        if(type === 'onFocus') {
            args[1] = document.activeElement.tagName;
        }

        if(type === 'onHover') {
            $KU.each(context, function(value, key) {
                payload[key] = value;
            });
            args.splice(($KU.is(args[0], 'widget') ? 1 : 0), (context? 1 : 0), payload);
        }
        $KAR && $KAR.sendRecording(model, type, payload, true);

        if($KU.is(callbacks, 'array')) {
            $KU.each(callbacks, function(callback) {
                callback.apply(scope, args);
            });

            if(noForceLayoutEventList.indexOf(type) === -1) {
                cf.forceLayout();
            }

            return true;
        } else if(($KU.is(model, 'widget', 'SegmentedUI2') || $KU.is(model, 'widget', 'CollectionView'))
        && $KU.is(item, 'object') && $KU.is(item[type], 'function')) {
            if(args[1] === -1) args[1] = 0;
            if(args[2] !== -1) item[type].apply(scope, args);
        //} else if() {
            //We can have another else if like this to support...
            //...other owner widget whose event comes as a part of item data
        } else if($KU.is(model[type], 'function')
        || (model.scrollingEvents && $KU.is(model.scrollingEvents[type], 'function'))) {
            if(omodel) {
                if($KU.is(omodel, 'widget', 'SegmentedUI2')
                && args[(args.length-1)].sectionIndex === -1) {
                    args[(args.length-1)].sectionIndex = 0;
                }
            }

            if(model[type]) {
                if($KU.is(model, 'widget', 'SegmentedUI2') && type === 'onRowClick') {
                    if(args[1] === -1) args[1] = 0;
                    if(args[2] !== -1) {
                        model[type].apply(scope, args);
                    }
                } else if($KU.is(model, 'widget', 'CollectionView') && type === 'onItemSelect') {
                    if(args[1] === -1) args[1] = 0;
                    if(args[2] !== -1 && args[2] !== -2) { //TODO:
                        model[type].apply(scope, args);
                    }
                } else {
                    model[type].apply(scope, args);
                }
            } else if(model.scrollingEvents && model.scrollingEvents[type]) {
                model.scrollingEvents[type].apply(scope, args);
            }

            if(noForceLayoutEventList.indexOf(type) === -1) {
                cf.forceLayout();
            }

            return true;
        } else if($KU.is(model, 'widget', 'DataGrid')
        && type === 'columnOnClick' && $KU.is(item, 'integer')
        && $KU.is(model['columnHeadersConfig'][item][type], 'function')) {
            model['columnHeadersConfig'][item][type].call(scope, args);
        } else if(type === 'onTabClick' && $KU.is(model, 'widget', 'TabPane')) {
            cf.forceLayout();

            return true;
        } else {
            return false;
        }
    };


    var _fmodel = function $KW_fmodel(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, hmodel = _hmodel(model);

        while(hmodel && !$KU.is(hmodel, 'widget', 'Form2')) {
            hmodel = _hmodel(_pmodel(hmodel));
        }

        return ($KU.is(hmodel, 'widget', 'Form2')) ? hmodel : null;
    };


    var _focus = function $KW_focus(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            dom = _focusableElement(model), tabindex = -1;

        if(dom) {
            if(!$KD.hasAttr(dom, 'tabindex')) {
                $KD.focus(dom);
            } else {
                tabindex = parseInt($KD.getAttr(dom, 'tabindex'), 10);

                if($KU.is(tabindex, 'integer') && tabindex >= 0) {
                    $KD.focus(dom);
                }
            }
        }
    };


    var _focusableElement = function $KW_focusableElement(model, tagName) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            dom = null, el = null;

        model = $KW.model(model);

        if(model) {
            el = _el(model);

            if(el.node) {
                if($KU.is(_a11y.view[_name(model)], 'function')) {
                    dom = _a11y.view[_name(model)](el.node, tagName);
                } else {
                    dom = el.node;
                }
            }
        }

        return dom;
    };


    var _getContentOffsetValues = function $KW_getContentOffsetValues(model, offset) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, x = 0, y = 0;

        if($KU.is(offset, 'object')) {
            if($KU.is(offset.x, 'number')) {
                offset.x += model._kwebfw_.layoutUnit || voltmx.flex.DEFAULT_UNIT;
            }
            if($KU.is(offset.y, 'number')) {
                offset.y += model._kwebfw_.layoutUnit || voltmx.flex.DEFAULT_UNIT;
            }
        }

        if($KU.is(offset, 'object')
        && $KU.is(offset.x, 'string')
        && $KU.is(offset.x, 'size')
        && $KU.is(offset.y, 'string')
        && $KU.is(offset.y, 'size')) {
            x = offset.x;
            y = offset.y;

            if(x.indexOf('dp') > 0) {
                x = parseFloat(x.replace('dp', ''), 10);
            } else if(x.indexOf('px') > 0) {
                x = parseFloat(x.replace('px', ''), 10);
                x = (x/$K.device.DPI);
            } else if(x.indexOf('%') > 0) {
                x = parseFloat(x.replace('%', ''), 10);
                x = (x / 100) * model._kwebfw_.view.offsetWidth;
            }

            if(y.indexOf('dp') > 0) {
                y = parseFloat(y.replace('dp', ''), 10);
            } else if(y.indexOf('px') > 0) {
                y = parseFloat(y.replace('px', ''), 10);
                y = (y/$K.device.DPI);
            } else if(y.indexOf('%') > 0) {
                y = parseFloat(y.replace('%', ''), 10);
                y = (y / 100) * model._kwebfw_.view.offsetHeight;
            }

            if(x < 0) x = 0;
            if(y < 0) y = 0;
        }
        return {x: x, y: y};
    };


    var _getAccessibilityConfig = function $KW_getAccessibilityConfig(accessibilityConfig) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            a11y = (accessibilityConfig) ? {} : null;

        $KU.each(accessibilityConfig, function(value, keey) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            if(value && keey === 'a11yARIA') {
                a11y[keey] = {};

                $KU.each(value, function(v, k) {
                    if($KU.is(v, 'i18n')) {
                        a11y[keey][k] = $KU.getI18Nvalue(v);
                    } else {
                        a11y[keey][k] = v;
                    }
                });
            } else if($KU.is(value, 'i18n')) {
                a11y[keey] = $KU.getI18Nvalue(value);
            } else if($KU.is(value, 'string')
            || $KU.is(value, 'number') || $KU.is(value, 'boolean')) {
                a11y[keey] = value;
            }
        });

        return a11y;
    };


    var _getDefaultHeight = function $KW_getDefaultHeight(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, omodel = null,
            _ = null, prop = null, height = '0dp', name = '',
            widgetsHeightMap = {
                Calendar: '40dp',
                CheckBoxGroup: '120dp',
                DataGrid: '120dp',
                ListBox: '40dp',
                Map: '75%',
                RadioButtonGroup: '40dp',
                SegmentedUI2: '120dp',
                Slider: '100dp',
                TextArea2: '120dp',
                TextBox2: '40dp'
            };

        model = $KW.model(model);

        if(model) {
            name = _name(model);
            _ = model._kwebfw_;
            prop = _.prop;

            if(_isTextDrivenWidget(model) || name === 'Image2') {
                height = null;
            } else if(widgetsHeightMap[name]) {
                height = widgetsHeightMap[name];
            } else {
                omodel = _omodel(model);

                if($KW.inPercent(prop.height) && _.is.template
                   && omodel && omodel.autogrowMode === voltmx.flex.AUTOGROW_HEIGHT) {
                    height = '100dp';
                } else {
                    height = '220dp';
                }
            }
        }

        return height;
    };


    var _getDefaultWidth = function $KW_getDefaultWidth(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            width = '0dp', name = '', widgetsWidthMap = {
                Calendar: '200dp',
                CollectionView: '120dp',
                CustomWidget: '200dp',
                ListBox: '260dp',
                RadioButtonGroup: '260dp',
                Slider: '260dp',
                Switch: '200dp',
                TextBox2: '260dp',
                TextArea2: '260dp'
            };

        model = $KW.model(model);

        if(model) {
            name = _name(model);

            if(_isTextDrivenWidget(model)
            || $KU.is(model, 'widget', 'Image2')) {
                width = null;
            } else if(widgetsWidthMap[name]) {
                width = widgetsWidthMap[name];
            } else {
                width = '100%';
            }
        }

        return width;
    };


    var _getDefaultProperty = function $KW_getDefaultProperty(model) {
        var defaultProperty = 'text', name = _name(model);

        if(name === 'Image2') {
            defaultProperty = 'src';
        } else if(name === 'Switch') {
            defaultProperty = 'selectedIndex';
        } else if(name === 'Slider') {
            defaultProperty = 'selectedValue';
        } else if(name === 'Calendar') {
            defaultProperty = 'dateComponents';
        } else if(['CheckBoxGroup', 'RadioButtonGroup', 'ListBox'].indexOf(name) > -1) {
            defaultProperty = 'masterData';
        }

        return defaultProperty;
    };


    var _getFlexProperties = function $KW_getFlexProperties() {
        var props = [
            'left', 'centerX', 'right',
            'top', 'centerY', 'bottom',
            'height', 'minHeight', 'maxHeight',
            'width', 'minWidth', 'maxWidth'
        ];

        return props;
    };


    var _getGroupSelectedKeyValueByKey = function $KW_getGroupSelectedKeyValueByKey(model, key) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, keyValue = null,
            prop = model._kwebfw_.prop, masterdata = model.masterData;

        if(!masterdata && prop.masterDataMap) {
            masterdata = model.masterDataMap[0];
        }

        if($KU.is(key, 'string')) {
            $KU.each(masterdata, function(data) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if($KU.is(data, 'array')) {
                    if(data[0] === key) {
                        keyValue = [data[0], data[1]];
                        return true;
                    }
                } else {
                    if(data[prop.masterDataMap[1]] === key) {
                        keyValue = [data[prop.masterDataMap[1]], data[prop.masterDataMap[2]]];
                        return true;
                    }
                }
            }, model);
        }

        return keyValue;
    };


    var _getModelByNode = function $KW_getModelByNode(node) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KW = $K.widget, $KD = $K.dom, model = null;

        if($KU.is(node, 'dom')) {
            model = $KD.closest(node, function(dom) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if($KD.hasAttr(dom, 'kw')
                || $KD.hasAttr(dom, 'kwf')) {
                    return true;
                }
            });

            if(model) {
                model = $KD.getAttr(model, 'kwf') || $KD.getAttr(model, 'id');
                model = (model) ? $KW.model(model) : null;
            }
        }

        return model;
    };


    var _getModelByPath = function UI$_getModelByPath(path) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            startSquareBracketIndex = -1, endSquareBracketIndex = -1,
            info = null, fmodel = null, omodel = null, model = null;

        if($KU.is(path, 'array')) path = path.join('_');

        if($KU.is(path, 'string') && path) {
            startSquareBracketIndex = path.indexOf('[');
            endSquareBracketIndex = path.indexOf(']');

            if(startSquareBracketIndex === -1) {
                fmodel = path.indexOf('_');
                fmodel = path.substr(0, fmodel);
                fmodel = $KW.root(fmodel);

                if(fmodel) {
                    model = path.split('_');
                    model.shift();
                    model = (!model.length) ? fmodel : $KU.get(model, fmodel);
                }
            } else if(startSquareBracketIndex > 0
            && endSquareBracketIndex > startSquareBracketIndex) {
                fmodel = path.indexOf('_');
                fmodel = path.substr(0, fmodel);
                fmodel = $KW.root(fmodel);

                if(fmodel) {
                    omodel = path.substr(0, startSquareBracketIndex);
                    omodel = omodel.split('_');
                    omodel.shift();
                    omodel = (!omodel.length) ? fmodel : $KU.get(omodel, fmodel);

                    if(_isOwnerWidget(omodel)) {
                        info = path.substr(
                            (startSquareBracketIndex+1),
                            (endSquareBracketIndex-startSquareBracketIndex-1)
                        );

                        if($KU.is(_infoAtIndex[_name(omodel)], 'function')) {
                            info = _infoAtIndex[_name(omodel)].call(omodel, info.split(','));

                            if(info && info.template) {
                                model = path.substr(
                                    (endSquareBracketIndex+2),
                                    (path.length-endSquareBracketIndex-2)
                                );
                                model = model.split('_');
                                model.shift();
                                model = (!model.length) ? info.template
                                    : $KU.get(model, info.template);
                            }
                        }
                    }
                }
            }
        }

        return ($KU.is(model, 'widget') ? model : null);
    };


    var _getNonConstructorProperties = function $KW_getNonConstructorProperties(widgetName) {
        var props = [], properties = {
            CheckBoxGroup: ['masterDataMap'],
            CollectionView: ['contentOffsetMeasured'],
            FlexScrollContainer: ['contentOffsetMeasured', 'contentSizeMeasured'],
            Form2: ['contentOffsetMeasured', 'contentSizeMeasured'],
            ListBox: ['masterDataMap'],
            Map: ['address'],
            RadioButtonGroup: ['masterDataMap'],
            SegmentedUI2: ['contentOffsetMeasured'],
            UserWidget: ['anchorPoint', 'backgroundColor', 'toolTip', 'transform']
        };

        if(Object.prototype.hasOwnProperty.call(properties, widgetName)) {
            props = properties[widgetName].slice(0);
            props.push('frame', 'parent');
        }

        return props;
    };


    var _getTemplate = function $KW_getTemplate(omodel, tpl) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KA = $K.app,
            _ = $KU.is(omodel, 'widget') ? omodel._kwebfw_ : null;

        if(tpl) {
            if($KU.is(tpl, 'string')) {
                $KA.allowSetter_voltmxControllerName = true;
                tpl = _voltmx.mvc.initializeSubViewController(tpl);
                delete $KA.allowSetter_voltmxControllerName;

                tpl._kwebfw_.is.template = true;
                $KW.root(tpl, 'template');
                _ && $KU.defineProperty(tpl._kwebfw_, 'owner', _.uid, null);
            } else if(!tpl._kwebfw_.is.template) {
                tpl._kwebfw_.is.template = true;
                $KW.root(tpl, 'template');
                _ && $KU.defineProperty(tpl._kwebfw_, 'owner', _.uid, null);
            }
        }

        return tpl;
    };


    var _getWidgetDataMapPath = function $KW_getWidgetDataMapPath(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, tmodel = null, path = [];

        model = $KW.model(model);

        if(model && model._kwebfw_.is.cloned) {
            tmodel = (model._kwebfw_.is.template)
                ? model : _rmodel(_pmodel(model));

            path.splice(0, 0, model.id);

            while(tmodel && !tmodel._kwebfw_.is.template) {
                path.splice(0, 0, tmodel.id);
                tmodel = _rmodel(_pmodel(tmodel));
            }
        }

        return path.join('.');
    };


    var _handleTabPaneEnablement = function $KW$_handleTabPaneEnablement(model, setupUIInteraction) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(!$KU.is(setupUIInteraction, 'boolean')) {
            setupUIInteraction = false;
        }

        if($KU.is(model, 'widget', 'TabPane')) {
            $KU.each(model._kwebfw_.tabs, function(tab) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    disabled = this._kwebfw_.disabled,
                    tabContainer = this[tab.id];

                $KW.iterate(tabContainer, function(widget) {
                    var _ = widget._kwebfw_;

                    if(disabled && !_.disabled) {
                        _.disabled = true;
                        _handleTabPaneEnablement(widget);

                        if(setupUIInteraction) {
                            _setupUIInteraction(widget, _focusableElement(widget));
                        }
                    } else {
                        return true; //Break the loop
                    }
                }, {scope:tabContainer, tabs:false});
            }, model);
        }
    };


    var _handleOnScrollWidgetPosition = function $KW_handleOnScrollWidgetPosition() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils, $KW = $K.widget, onScrollWidgets = [],
            _updateOnScrollWidgets = function(widget) {
                $KU.each(widget.widgets(), function(model) {
                    if(model.onScrollWidgetPosition) onScrollWidgets.push(model);
                    if($KW.isFlexContainer(model)) _updateOnScrollWidgets(model);
                });
            };

        _updateOnScrollWidgets(this);

        $KU.each(onScrollWidgets, function(model) {
            var view = model._kwebfw_.view,
                position = $KD.point(model._kwebfw_.view);

            $KW.fire(model, 'onScrollWidgetPosition', model, {
                positionLeft: position.x,
                positionTop: position.y,
                x: view.offsetLeft,
                y: view.offsetTop
            });
        });
    };


    var _hmodel = function $KW_hmodel(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, omodel = null, hmodel = null;

        model = $KW.model(model);

        omodel = (model) ? _omodel(model) : null;
        hmodel = (omodel) ? _rmodel(omodel) : _rmodel(model);

        //TODO:: This can be handled in a better way in future
        if(hmodel && hmodel._kwebfw_.tpid) {
            hmodel = $KW.model(hmodel._kwebfw_.tpid);
        }

        return hmodel;
    };


    var _holder = function $KW_holder(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            el = $KW.el(model), holder = null;

        holder = el.scrolee || el.viewport || el.node;

        return holder;
    };


    var _inComponent = function $KW_inComponent(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            rmodel = null, hmodel = null, flag = false;

        model = $KW.model(model);

        if(model) {
            rmodel = _rmodel(model);

            if(rmodel && rmodel._kwebfw_.is.component) {
                flag = true;
            } else {
                hmodel = _hmodel(model);

                if(hmodel && hmodel._kwebfw_.is.component) {
                    flag = true;
                }
            }
        }

        return flag;
    };


    var _index = function $KW_index(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, proxy = null,
            pmodel = null, c = 0, clen = 0, index = -1, widgets = [];

        model = $KW.model(model);

        if(model) {
            proxy = _proxy(model);
            pmodel = _pmodel(proxy);
            widgets = _children(pmodel);
            clen = widgets.length;

            for(c=0; c<clen; c++) {
                if(widgets[c] === proxy) {
                    index = c; break;
                }
            }
        }

        return index;
    };


    var _inheritedProperties = function $KW_inheritedProperties(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, prop = {};

        model = $KW.model(model);

        if($KU.is(model, 'widget', 'inherited')) {
            $KU.each(Object.getOwnPropertyNames(model), function(value) {
                if(value !== '_kwebfw_' && !Object.prototype.hasOwnProperty.call(this._kwebfw_.prop, value)) {
                    prop[value] = this[value];
                }
            }, model);
        }

        return prop;
    };


    var _inModalContainer = function $KW_inModalContainer(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, omodel = null, flag = false;

        model = $KW.model(model);
        omodel = (model) ? $KW.omodel(model) : null;

        if(model) {
            flag = model._kwebfw_.inModalContainer;

            if(flag && omodel) {
                flag = omodel._kwebfw_.inModalContainer;
            }
        }

        return flag;
    };


    var _inPercent = function $KW_inPercent(value) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false, len = 0;

        if($KU.is(value, 'string') && value) {
            len = value.length;

            if(value.substr((len-1), 1) === '%') {
                value = value.substr(0, (len-1));
                value = parseFloat(value, 10);

                if(!isNaN(value)) {
                    flag = true;
                }
            }
        }

        return flag;
    };


    var _inTemplate = function $KW_inTemplate(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, rmodel = null, flag = false;

        model = $KW.model(model);

        if(model) {
            rmodel = _rmodel(model);

            if(rmodel && rmodel._kwebfw_.is.template) {
                flag = true;
            }
        }

        return flag;
    };


    var _interactable = function $KW_interactable(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

        model = $KW.model(model);

        if(model) {
            flag = !_disabled(model);

            if(flag) {
                flag = _inModalContainer(model);
            }
        }

        return flag;
    };


    var _invokeLifeCycleEvent = function $KW_invokeLifeCycleEvent(model, type, reverse) {
        _iterate(model, function(widget) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = widget._kwebfw_, proxy = null;

            if(_.is.component || $KU.is(widget, 'widget', 'Form2')) {
                if(_.is.component) {
                    proxy = _.proxy;
                }

                _fire((proxy || widget), type, (proxy || widget));
            }
        }, {reverse:reverse, tabs:false});
    };


    var _isAriaRoleAllowed = function $KW_isAriaRoleAllowed(model, role) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, a11y = null, name = '', flag = false;

        model = $KW.model(model);

        if(model) {
            name = _name(model);
            a11y = model._kwebfw_.prop.accessibilityConfig;

            if(name === 'Button' && ['link'].indexOf(role) >= 0) {
                flag = true;
            } else if(['FlexContainer', 'FlexScrollContainer'].indexOf(name) >= 0) {
                flag = true;
            } else if(name === 'SegmentedUI2' && ['table', 'grid', 'button'].indexOf(role) >= 0) {
                if(a11y && a11y.tagName
                && a11y.tagName.toLowerCase() === 'div') {
                    flag = true;
                }
            }
        }

        return flag;
    };


    var _isClonable = function $KW_isClonable(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, flag = true;

        model = $KW.model(model);

        if(!model || $KU.is(model, 'widget', 'Form2')) {
            flag = false;
        }

        return flag;
    };


    var _isContainer = function $KW_isContainer(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

        model = $KW.model(model);

        if(model && model instanceof voltmx.ui.ContainerWidget) {
            flag = true;
        }

        return flag;
    };


    var _isFixedHeight = function $KW_isFixedHeight(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, final = null, flag = false;

        model = $KW.model(model);

        if(model) {
            final = model._kwebfw_.flex.final;

            if(final.height || _isImplicitHeight(model)) {
                flag = true;
            }
        }

        return flag;
    };


    //TODO::
    var _isFixedHeightWidget = function $KW_isFixedHeightWidget(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

        model = $KW.model(model);

        if(model) {
            //E.g. Slider, Switch etc.
        }

        return flag;
    };


    var _isFixedWidth = function $KW_isFixedWidth(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, final = null, flag = false;

        model = $KW.model(model);

        if(model) {
            final = model._kwebfw_.flex.final;

            if(final.width || _isImplicitWidth(model)) {
                flag = true;
            }
        }

        return flag;
    };


    //TODO::
    var _isFixedWidthWidget = function $KW_isFixedWidthWidget(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

        model = $KW.model(model);

        if(model) {
            //Switch etc.
        }

        return flag;
    };


    var _isFlexContainer = function $KW_isFlexContainer(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false,
            prop = null, layoutList = [
                voltmx.flex.FREE_FORM, voltmx.flex.FLOW_HORIZONTAL,
                voltmx.flex.FLOW_VERTICAL, voltmx.flex.RESPONSIVE_GRID
            ];

        model = $KW.model(model);

        if(model) {
            prop = model._kwebfw_.prop;

            if(model instanceof voltmx.ui.FlexContainer
            || (model instanceof voltmx.ui.Form2
            && layoutList.indexOf(prop.layoutType) >= 0)) {
                flag = true;
            }
        }

        return flag;
    };


    var _isFlexPropertyDefined = function $KW_isFlexPropertyDefined(prop, name) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

        if(name === 'zIndex') {
            flag = $KU.is(prop[name], 'number') ? true : false;
        } else {
            if($KU.is(prop[name], 'number')
            || ($KU.is(prop[name], 'string') && prop[name])) {
                flag = true;
            }
        }

        return flag;
    };


    var _isFlexWidget = function $KW_isFlexWidget(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

        model = $KW.model(model);

        if(model) {
            if($KW.isFlexContainer(model) || $KW.isFlexContainer(_pmodel(model))) {
                flag = true;
            }
        }

        return flag;
    };


    //TODO::
    var _isGreedyWidget = function $KW_isGreedyWidget(/*model*/) {
        var flag = false;

        return flag;
    };


    var _isImplicitHeight = function $KW_isImplicitHeight(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            pmodel = null, final = null, flag = false;

        model = $KW.model(model);

        if(model) {
            final = model._kwebfw_.flex.final;
            pmodel = $KW.pmodel(model);

            if($KW.layout(pmodel) === 'fflex' && !final.height) {
                if((final.top && final.bottom)
                || (final.top && final.centerY)
                || (final.centerY && final.bottom)) {
                    flag = true;
                }
            }
        }


        return flag;
    };


    var _isImplicitWidth = function $KW_isImplicitWidth(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            pmodel = null, final = null, flag = false;

        model = $KW.model(model);

        if(model) {
            final = model._kwebfw_.flex.final;
            pmodel = $KW.pmodel(model);

            if($KW.layout(pmodel) === 'fflex' && !final.width) {
                if((final.left && final.right)
                || (final.left && final.centerX)
                || (final.centerX && final.right)) {
                    flag = true;
                }
            }
        }

        return flag;
    };


    var _isOwnerWidget = function $KW_isOwnerWidget(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, flag = false;

        model = $KW.model(model);

        if($KU.is(model, 'widget', 'SegmentedUI2')
        || $KU.is(model, 'widget', 'CollectionView')) {
            flag = true;
        }

        return flag;
    };


    var _isRendered = function $KW_isRendered(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            _ = model._kwebfw_, flag = false;

        model = $KW.model(model);

        if(model && (model.isVisible || $K.F.RIVW) && _.view) {
            if(document.getElementById(_.uid)) {
                flag = true;
            }
        }

        return flag;
    };


    var _isResponsiveContainer = function $KW_isResponsiveContainer(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KF = voltmx.flex, flag = false, prop = null;

        model = $KW.model(model);

        if(model) {
            prop = model._kwebfw_.prop;

            if(prop.layoutType === $KF.RESPONSIVE_GRID && _isFlexContainer(model)) {
                flag = true;
            }
        }

        return flag;
    };


    var _isScrollableWidget = function $KW_isScrollableWidget(model, scrollDirection) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            flag = false, prop = model._kwebfw_.prop;

        if($KU.is(model, 'widget', 'FlexScrollContainer') || $KU.is(model, 'widget', 'Form2')) {
            if(prop.enableScrolling && !_disabled(model)) {
                flag = true;
            }
        } else if($KU.is(model, 'widget', 'CollectionView')) {
            if(prop.scrollDirection !== voltmx.flex.SCROLL_NONE && !_disabled(model)) {
                flag = true;
            }
        } else if($KU.is(model, 'widget', 'SegmentedUI2')) {
            if((prop.showScrollbars || _isFixedHeight(model)) && !_disabled(model)) {
                flag = true;
            }
        } else if($KU.is(model, 'widget', 'DataGrid')) {
            if(prop.scrollable && !_disabled(model)) {
                flag = true;
            }
        }
        if(scrollDirection && !_disabled(model)
        && ($KU.is(model, 'widget', 'FlexScrollContainer') || $KU.is(model, 'widget', 'Form2'))) {
            if(prop.scrollDirection === voltmx.flex.SCROLL_VERTICAL
            && prop.scrollDirection === scrollDirection) {
                flag = true;
            } else if(prop.scrollDirection === voltmx.flex.SCROLL_HORIZONTAL
            && prop.scrollDirection === scrollDirection) {
                flag = true;
            } else if(prop.scrollDirection === voltmx.flex.SCROLL_BOTH
            && prop.scrollDirection === scrollDirection) {
                flag = true;
            } else {
                flag = false;
            }
        }
        return flag;
    };


    /*eslint-disable*/
    //TODO::
    var _isTemplatable = function $KW_isTemplatable(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

        model = $KW.model(model);

        return flag;
    };
    /*eslint-enable*/


    var _isTextDrivenWidget = function $KW_isTextDrivenWidget(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

        if($KU.is(model, 'widget') && [
            'Button', 'Label', 'RichText'
        ].indexOf(_name(model)) >= 0) {
            flag = true;
        }

        return flag;
    };


    //This iterate over model and its children
    var _iterate = function $KW_iterate(model, callback, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, _ = null, output = null;

        model = $KW.model(model);

        if(model && $KU.is(callback, 'function')) {
            model = _proxy(model);
            _ = model._kwebfw_;
            if(!$KU.is(config, 'object')) config = {};
            if(!Object.prototype.hasOwnProperty.call(config, 'scope')) config.scope = this;
            if(!$KU.is(config.reverse, 'boolean')) config.reverse = false;
            if(!$KU.is(config.owner, 'boolean')) config.owner = false;
            if(!$KU.is(config.clones, 'boolean')) config.clones = false;
            if(!$KU.is(config.tabs, 'boolean')) config.tabs = true;

            if(!config.reverse) {
                output = callback.call(config.scope, model);

                if(config.owner && $KU.is(_iterateOwner[_.name], 'function')) {
                    _iterateOwner[_.name](model, callback, {
                        scope: config.scope,
                        reverse: config.reverse,
                        owner: config.owner,
                        clones: config.clones,
                        tabs: config.tabs
                    });
                }
            }

            if(output !== true) {
                $KU.each(_children(model, {tabs:config.tabs}), function(widget) {
                    _iterate(widget, callback, {
                        scope: config.scope,
                        reverse: config.reverse,
                        owner: config.owner,
                        clones: config.clones,
                        tabs: config.tabs
                    });
                }, config.scope);
            }

            if(config.reverse) {
                output = callback.call(config.scope, model);

                if(config.owner && $KU.is(_iterateOwner[_.name], 'function')) {
                    _iterateOwner[_.name](model, callback, {
                        scope: config.scope,
                        reverse: config.reverse,
                        owner: config.owner,
                        clones: config.clones,
                        tabs: config.tabs
                    });
                }
            }
        }
    };


    var _iterateOwner = {};


    var _isWithinViewport = function $KW_isWithinViewport(model, parent) {
        var el = _el(model), pel = _el(parent), flag = false,
            elCord = null, pelCord = null;

        if(el.node && pel.node) {
            elCord = el.node.getBoundingClientRect();
            pelCord = pel.node.getBoundingClientRect();

            if(elCord.top >= pelCord.top && elCord.left >= pelCord.left
            && elCord.bottom <= pelCord.bottom && elCord.right <= pelCord.right) {
                flag = true;
            }
        }

        return flag;
    };


    var _layout = function $KW_layout(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, layout = '',
            list = ['fflex', 'hflex', 'vflex', 'rflex'];

        if($KU.is(model, 'widget')) {
            if(_isContainer(model)) {
                layout = model.layoutType;
                if(!layout) layout = list[0];
            }
        } else if($KU.is(model, 'number')) {
            layout = list[model];
        } else if($KU.is(model, 'string') && model) {
            layout = (list.indexOf(model) >= 0) ? model : list[0];
        }

        return layout;
    };


    var _markRelayout = function $KW_markRelayout(model) {
        var cf = _getRootNode(model), relayout = null;

        if(cf) {
            if(!cf._kwebfw_.relayout) {
                cf._kwebfw_.relayout = {};
            }

            relayout = cf._kwebfw_.relayout;
            relayout[model._kwebfw_.uid] = model;
        }
    };

    var _getRootNode = function $_getRootNode(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
            $KA = $K.app, rmodel = null, pmodel = null, rootModel = null;

        if(!$KU.loadedFromOtherFramework()) {
            rootModel = $KW.model($KA.currentFormUID);
        } else {
            if(model) {
                rmodel = $KW.rmodel(model);
                if(rmodel) {
                    pmodel = $KW.pmodel(rmodel);
                    if(pmodel) {
                        rootModel = _getRootNode(pmodel);
                    } else {
                        rootModel = rmodel;
                    }
                }
            }
        }

        return rootModel;
    };

    //This function remove the given model from the relayout
    var _removeMarkedLayout = function $KW_removeMarkedLayout(model) {
        var cf = _getRootNode(model), relayout = null;

        if(cf) {
            relayout = cf._kwebfw_.relayout;

            //if the give model's uid is defined in the relayout, then delete
            if(relayout[model._kwebfw_.uid]) {
                delete relayout[model._kwebfw_.uid];
            }
        }
    };


    var _modifySelectedIndexes = function $KW_modifySelectedIndexes(selectedIndexes, depth, position, count) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, indexesToBeRemoved = [];

        if($KU.is(depth, 'integer') && depth >= 0
        && $KU.is(count, 'integer') && count !== 0
        && $KU.is(position, 'integer') && position >= 0
        && $KU.is(selectedIndexes, 'array')) {
            $KU.each(selectedIndexes, function(value, index) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, vlen = -1;

                if($KU.is(value, 'integer') && depth === 0) {
                    if(value >= position) {
                        this[index] = (value + count);

                        if(this[index] < 0) {
                            indexesToBeRemoved.push(index);
                        }
                    }
                } else if($KU.is(value, 'array')) {
                    vlen = value.length;

                    if(depth < vlen && $KU.is(value[depth], 'integer')
                    && value[depth] >= 0 && value[depth] >= position) {
                        value[depth] = (value[depth] + count);

                        if(value[depth] < 0) {
                            indexesToBeRemoved.push(index);
                        }
                    }
                }
            }, selectedIndexes);

            $KU.each(indexesToBeRemoved, function(value, index) {
                this.splice((value-index), 1);
            }, selectedIndexes);
        }
    };


    var _name = function $KW_name(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, name = '';

        model = _proxy($KW.model(model));

        if(model) {
            name = model._kwebfw_.name;

            if(['ComponentWithContract', 'ComponentWithoutContract'].indexOf(name) >= 0) {
                if(model instanceof voltmx.ui.FlexScrollContainer) {
                    name = 'FlexScrollContainer';
                } else if(model instanceof voltmx.ui.FlexContainer) {
                    name = 'FlexContainer';
                }
            }
        }

        return name;
    };


    var _nextVisible = function $KW_nextVisible(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            children = null, next = null, index = -1;

        model = $KW.model(model);

        if(model) {
            index = _index(model);

            if(index >= 0) {
                children = _children(_pmodel(model));
                next = children[++index];

                while(next && !next.isVisible) {
                    next = children[++index];
                }
            }
        }

        return next || null;
    };


    var _omodel = function $KW_omodel(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, omodel = null;

        model = $KW.model(model);

        if(model && model._kwebfw_.oid && model._kwebfw_.ii && model._kwebfw_.is.cloned) {
            omodel = $KW.model(model._kwebfw_.oid);
        }

        return omodel;
    };


    var _onPropertyChange = function $KW_onPropertyChange(model, key, old) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, owner = _omodel(model);

        if($KU.is(owner, 'widget') && $KU.is(_change[_name(owner)], 'function')) {
            _change[_name(owner)].call(owner, model, key, old);
        }
    };


    var _onRender = function $KW_onRender(nodes) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(nodes, 'dom')) nodes = [nodes];

        $KU.each(nodes, function(view) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                model = $KW.model(view), name = _name(model), selector = '';

            _onrender[name] && _onrender[name].call(model);

            selector += '[kw="CustomWidget"],';
            selector += '[kw="FlexScrollContainer"],';
            selector += '[kw="Label"],';
            selector += '[kw="ListBox"],';
            selector += '[kw="SegmentedUI2"]';

            $KU.each($KD.find(view, selector), function(node) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    widget = $KW.model(node), name = _name(widget);

                _onrender[name] && _onrender[name].call(widget);
            });
        });
    };

    var _pickers = function $KW_pickers(model) {
        var pickers = {}, fmodel =_getRootNode(model);

        if(!fmodel._kwebfw_.pickers) {
            fmodel._kwebfw_.pickers = {};
        }
        pickers = fmodel._kwebfw_.pickers;

        return pickers;
    };

    var _pmodel = function $KW_pmodel(model, arg1) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, _ = null,
            pmodel = null, config = ($KU.is(arg1, 'object') ? arg1 : {});

        if(!$KU.is(config.tabs, 'boolean')) config.tabs = false;

        model = $KW.model(model);

        if(model) {
            _ = model._kwebfw_;

            if(config.tabs && _.is.tab === true && _.tpid
            && $KU.is(model, 'widget', 'FlexContainer')) {
                pmodel = $KW.model(_.tpid);
            } else if(_.pid) {
                pmodel = $KW.model(_.pid);
            } else if(_.is.component) {
                pmodel = _component(model);

                if(pmodel) {
                    _ = pmodel._kwebfw_;
                    pmodel = null;

                    if(_.pid) {
                        pmodel = $KW.model(_.pid);
                    }
                }
            }
        }

        return pmodel;
    };


    var _populateScrollDetails = function $KW_populateScrollDetails(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KW = $K.widget, el = null, scroll = null;

        model = $KW.model(model);

        if(model) {
            el = _el(model);
            scroll = model._kwebfw_.ui.scroll;

            if(el.viewport) {
                if($KU.scrollType() === 'native') {
                    scroll.minX = scroll.minY = 0;

                    scroll.height = el.viewport.scrollHeight;
                    scroll.width = el.viewport.scrollWidth;

                    scroll.maxX = (scroll.width - el.viewport.offsetWidth);
                    scroll.maxY = (scroll.height - el.viewport.offsetHeight);
                    scroll.maxX = (scroll.maxX > 0) ? scroll.maxX : 0;
                    scroll.maxY = (scroll.maxY > 0) ? scroll.maxY : 0;
                }
            }
        }
    };


    var _prevVisible = function $KW_prevVisible(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            children = null, prev = null, index = -1;

        model = $KW.model(model);

        if(model) {
            index = _index(model);

            if(index >= 0) {
                children = _children(_pmodel(model));
                prev = children[--index];

                while(prev && !prev.isVisible) {
                    prev = children[--index];
                }
            }
        }

        return prev || null;
    };


    var _proxy = function $KW_proxy(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, proxy = $KW.model(model);

        if(proxy && proxy instanceof voltmx.ui.UserWidget) {
            proxy = proxy._kwebfw_.proxy;

            if(!(proxy instanceof voltmx.ui.FlexContainer
            || proxy instanceof voltmx.ui.FlexScrollContainer)) {
                proxy = null;
            }
        }

        return proxy;
    };


    var _registerForIdleTimeout = function $KW_registerForIdleTimeout() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KA = $K.app, cf = $KW.model($KA.currentFormUID);

        if($KU.is($KA.idleTime, 'number') && $KA.idleTime > 0
        && $KU.is($KA.idleCallback, 'function')) {
            if($KA.idleTimeout) {
                clearTimeout($KA.idleTimeout);
                $KA.lastInteractionAt = $KA.idleTimeout = null;
            }

            if(cf && cf.enabledForIdleTimeout) {
                $KA.lastInteractionAt = new Date();

                $KA.idleTimeout = setTimeout(function() {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app,
                        cf = $KW.model($KA.currentFormUID);

                    clearTimeout($KA.idleTimeout);
                    $KA.lastInteractionAt = $KA.idleTimeout = null;

                    cf && $KA.idleCallback(cf);
                }, $KA.idleTime);
            }
        }
    };


    var _registerNativeScrollEvent = function $KW_registerNativeScrollEvent(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, el = $KW.el(model), onReachingFired = false,
            timer = null, scrolled = false, dirX = '', dirY = '';

        if($KU.scrollType() !== 'native' || !el.viewport) return;

        $KD.on(el.viewport, 'scroll', 'wscroll', function(e) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, $KU = $K.utils,
                widget = $KD.closest(this, 'kw'), prop = null, scroll = null,
                scrollX = this.scrollLeft, scrollY = this.scrollTop, _ = null,
                reachOffsetInPixel = {x:50, y:50}, reachOffsetInPercent = {x:8, y:8},
                maxScrollReach = null;

            //eslint-disable-next-line
             var reachBeginingOffset = null, reachEndOffset = null;

            if(widget) {
                widget = $KW.model(widget);
                _ = widget._kwebfw_;
                scroll = _.ui.scroll;
                prop = _.prop;
                maxScrollReach = {
                    x: Math.max(reachOffsetInPixel.x, (scroll.maxX / reachOffsetInPercent.x)),
                    y: Math.max(reachOffsetInPixel.y, (scroll.maxY / reachOffsetInPercent.y))
                };
                if(scroll.x !== scrollX || scroll.y !== scrollY) {
                    timer && clearTimeout(timer); timer = null;

                    dirX = (scrollX < scroll.x) ? 'left'
                        : (scrollX > scroll.x) ? 'right' : '';
                    dirY = (scrollY < scroll.y) ? 'top'
                        : (scrollY > scroll.y) ? 'bottom' : '';

                    if(scroll.status === 'ended') {
                        scroll.status = 'started'; //console.error(scroll.status);
                        onReachingFired = false; scrolled = true;
                        _populateScrollDetails(widget);
                        $KW.fire(widget, 'onScrollStart', widget);

                        scroll.status = 'scrolling'; //console.error(scroll.status);
                        scroll.x = scrollX; scroll.y = scrollY;
                        $KW.fire(widget, 'onScrolling', widget);
                    } else {
                        scroll.status = 'scrolling'; //console.error(scroll.status);
                        scroll.x = scrollX; scroll.y = scrollY;
                        $KW.fire(widget, 'onScrolling', widget);
                    }

                    if(widget.reachingBeginningOffset) {
                        reachBeginingOffset = widget.reachingBeginningOffset;
                    }

                    if(widget.reachingEndOffset) {
                        reachEndOffset = widget.reachingEndOffset;
                    }

                    if(!onReachingFired) {
                        if((dirX === 'left' && scroll.maxX && scroll.x <= maxScrollReach.x)
                        || (dirY === 'top' && scroll.maxY && scroll.y <= maxScrollReach.y)) {
                            onReachingFired = true; //console.error('onReachingBegining');

                            if(prop.scrollingEvents
                            && prop.scrollingEvents.onReachingBegining) {
                                $KW.fire(widget, 'onReachingBegining', widget);
                            }
                        } else if((dirX === 'right' && scroll.maxX
                        && ((scroll.maxX - scroll.x) <= maxScrollReach.x))
                        || (dirY === 'bottom' && scroll.maxY
                        && ((scroll.maxY - scroll.y) <= maxScrollReach.y))) {
                            onReachingFired = true; //console.error('onReachingEnd');

                            if(prop.scrollingEvents
                            && prop.scrollingEvents.onReachingEnd) {
                                $KW.fire(widget, 'onReachingEnd', widget);
                            }
                        }
                    }
                }

                if(widget.enableOnScrollWidgetPositionForSubwidgets) {
                    _handleOnScrollWidgetPosition.call(widget);
                }
                if($KU.is(widget, 'widget', 'DataGrid')) {
                    $KD.style(el.docker, 'top', el.viewport.scrollTop + 'px');
                }
                if($KU.is(widget, 'widget', 'CollectionView')) {
                    $K.ui[$KW.name(widget)].handleOnItemDisplay.call(widget);
                }
                timer = setTimeout(function() {
                    if(scroll.status !== 'ended'
                    && scroll.x === e.target.scrollLeft
                    && scroll.y === e.target.scrollTop) {
                        scroll.status = 'ended'; //console.error(scroll.status);
                        onReachingFired = false;
                        $KW.fire(widget, 'onScrollEnd', widget);
                    }

                    clearTimeout(timer); timer = null;
                }, 250);
            }
        }, {passive:false});

        $KD.on(el.viewport, 'touchstart', 'wtscroll', function(/*e*/) {
            scrolled = false;

            $KD.on(el.viewport, 'touchend touchcancel', 'wtscroll', function(/*e*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    widget = $KD.closest(this, 'kw');

                $KD.off(el.viewport, 'touchend touchcancel', 'wtscroll');

                if(widget) {
                    widget = $KW.model(widget);

                    if(scrolled) {
                        $KW.fire(widget, 'onScrollTouchReleased', widget);
                    }
                }
            }, {passive:false});
        }, {passive:false});
    };


    //NOTE:: This function deals with skins, that are applied on el.node
    //       All types of skin, from all widgets are considered here
    var _removeAllSkinsFromUI = function $KW_removeAllSkinsFromUI(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = null, el = null;

        model = $KW.model(model);

        if(model) {
            prop = model._kwebfw_.prop;
            el = _el(model);

            _removeSkin(prop.skin, el.node);
            _removeSkin(prop.focusSkin, el.node);
            _removeSkin(prop.hoverSkin, el.node);
            _removeSkin(prop.placeholderSkin, el.node);
        }
    };


    var _removeSkin = function $KW_removeSkin(skin, node) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

        if($KU.is(node, 'dom')) {
            if($KU.is(skin, 'string') && skin) {
                $KD.removeCls(node, skin);
            } else if($KU.is(skin, 'object')) {
                $KU.each(skin, function(val, key) {
                    $KD.style(node, key, null);
                });
            }
        }
    };


    //This function will replace wap index within square bracket for given model
    //e.g. frm_seg[1,0]_btnId with frm_seg[1,1]_btnId where 1,1 index provided
    var _replaceWAPIndex = function $KW_replaceWAPIndex(model, index) {
        var regPattern = /\[.*?\]\s?/g;

        model._kwebfw_.wap = model._kwebfw_.wap.replace(regPattern, '['+index+']');
    };


    var _removeView = function $KW_removeView(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            $KD = $K.dom, _ = null, a11yHint = null;

        model = $KW.model(model);

        if(model) {
            model = _proxy(model);
            _ = model._kwebfw_;
            a11yHint = document.getElementById((_.uid+'_hint'));

            if(_.viewPrev && $KD.parent(_.viewPrev)) {
                $KD.remove(_.viewPrev);
            }

            if(_.view && $KD.parent(_.view)) {
                $KD.remove(_.view);
            }

            if(_.viewNext && $KD.parent(_.viewNext)) {
                $KD.remove(_.viewNext);
            }

            if(a11yHint) $KD.remove(a11yHint);
        }
    };


    var _retainScrollPosition = function $KW_retainScrollPosition(model, retainScrollPosition) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, el = $KW.el(model),
            viewport = null, scroll = null, scrollX = -1, scrollY = -1, _ = model._kwebfw_;

        if(_.ui.scroll && el.viewport) {
            viewport = el.viewport;
            scroll = _.ui.scroll;
            scroll.status = 'ended';

            if($KU.scrollType() === 'native') {
                scrollX = viewport.scrollLeft;
                scrollY = viewport.scrollTop;

                scroll.width = viewport.scrollWidth;
                scroll.height = viewport.scrollHeight;
                scroll.minX = scroll.minY = 0;
                scroll.maxX = (viewport.scrollWidth - viewport.offsetWidth);
                scroll.maxY = (viewport.scrollHeight - viewport.offsetHeight);

                if($K.flag.navigated && retainScrollPosition !== true) {
                    scroll.x = scroll.y = 0;
                } else {
                    if(scroll.x > scroll.maxX) {
                        scroll.x = scroll.maxX;
                    } else if(scroll.x < scroll.minX) {
                        scroll.x = scroll.minX;
                    }

                    if(scroll.y > scroll.maxY) {
                        scroll.y = scroll.maxY;
                    } else if(scroll.y < scroll.minY) {
                        scroll.y = scroll.minY;
                    }
                }

                if(scroll.x !== scrollX) viewport.scrollLeft = scroll.x;
                if(scroll.y !== scrollY) viewport.scrollTop = scroll.y;
            }
        }
    };

    /*eslint-disable*/
    var _retainSelection = function $KW_retainSelection(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            _ = model._kwebfw_, prop = _.prop, row = null, rowView = null,
            secIndex = null, rowIndex = null;

        if($KU.is(model, 'widget', 'SegmentedUI2')) {
            if($K.flag.navigated && _isFixedHeight(model) && prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
                if(prop.retainScrollPositionMode === constants.SEGUI_SCROLL_POSITION_RETAIN) {
                    _retainScrollPosition(model, true);
                } else if(prop.retainSelection && prop.selectedRowIndex) {
                    model.selectedRowIndex = model.selectedRowIndex;
                }
            }
        }

        if($KU.is(model, 'widget', 'CollectionView')) {
            if($K.flag.navigated) {
                if(prop.retainSelection && prop.selectedItemIndex) {
                    model.selectedItemIndex = model.selectedItemIndex;
                }
            }
        }
    };


    var _returnPosition = function $KW_returnPosition(position, dimension) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, result = 0,
            patt1 = /\d+%/g, patt2 = /\d+px/g,
            operand1 = '', operand2 = '', flag = '',
            str = '', op1 = null, op2 = null, opr1 = null, opr2 = null;

        var convertToNumber = function(value) {
            return Number(value);
        };

        if(position) {
            str = position;
            str = str.replace(/\s/g, '');
            op1 = str.match(patt1);
            op2 = str.match(patt2);

            if(op1 && op1.length === 1 && $KU.is(op2, 'null')) {
                op1 = op1[0].slice(0, -1);
                if($KU.is(op1, 'numeric')) {
                    result = (convertToNumber(op1) * dimension)/100;
                }
            } else if(op2 && op2.length === 1 && $KU.is(op1, 'null')) {
                op2 = op2[0].slice(0, -1);
                if($KU.is(op2, 'numeric')) {
                    result = dimension - convertToNumber(op2);
                }
            } else if(op1 && op1.length > 1) {
                opr1 = op1[0].slice(0, -1);
                opr2 = op1[1].slice(0, -1);
                if($KU.is(opr1, 'numeric') && $KU.is(opr2, 'numeric')) {
                    operand1 = ((convertToNumber(opr1)) * dimension) / 100;
                    operand2 = ((convertToNumber(opr2)) * dimension) / 100;
                }
            } else if(op2 && op2.length > 1) {
                flag = 'px';
                opr1 = op2[0].slice(0, -1);
                opr2 = op2[1].slice(0, -1);
                if($KU.is(opr1, 'numeric') && $KU.is(opr2, 'numeric')) {
                    operand1 = (convertToNumber(opr1));
                    operand2 = (convertToNumber(opr2));
                }
            } else {
                op1 = op1[0].slice(0, -1);
                op2 = op2[0].slice(0, -1);
                if($KU.is(op1[0], 'numeric') && $KU.is(op2[0], 'numeric')) {
                    operand1 = ((convertToNumber(op1)) * dimension) / 100;
                    operand2 = convertToNumber(op2);
                }
            }

            if(operand1 && operand2) {
                if(str.indexOf(operand2) < str.indexOf(operand1)) {
                    operand1 = operand2;
                    operand2 = operand1;
                }
                if(str.indexOf('+') > 0)
                    result = operand1 + operand2;
                else
                    result = operand1 - operand2;
                if(flag === 'px')
                    result = dimension - result;
            }
        }
        return result;
    };
    /*eslint-enable*/

    var _rmodel = function $KW_rmodel(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, rmodel = null;

        model = $KW.model(model);

        if(model) {
            if((voltmx.application.getCurrentForm() == null || voltmx.application.getCurrentForm().id != currentFormName) && model instanceof voltmx.ui.FlexContainer) {
                rmodel = $KW.model(model._kwebfw_.uid);
                rmodel.childHierarchy = true;
            } else {
                rmodel = $KW.model(model._kwebfw_.rid);
            }
        }
        if(model instanceof voltmx.ui.Form2)
            currentFormName = model.id;

        return rmodel;
    };


    var _scrollBy = function $KW_scrollBy(model, x, y, duration) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, scroll = null;

        model = $KW.model(model);
        if(!model) return; //Widget not found

        scroll = model._kwebfw_.ui;
        scroll = (scroll.scroll) ? scroll.scroll : null;
        if(!scroll) return; //This widget is not scrollable

        _scrollTo(model, (scroll.x + x), (scroll.y + y), duration);
    };


    var _scrollTo = function $KW_scrollTo(model, x, y, duration, algo) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, el = null,
            forced = false, startTime = new Date().getTime(), scroll = null;

        var animate = function() {
            var currentTime = new Date().getTime(), left = 0,
                diffTime = currentTime - startTime, top = 0;

            if(diffTime < duration && (scroll.x !== x || scroll.y !== y)) {
                left = parseInt(ease[algo](diffTime, scroll.x, x, duration), 10);
                top = parseInt(ease[algo](diffTime, scroll.y, y, duration), 10);

                scrollTo(left, top, scroll, el.viewport, el.hScroll, el.vScroll, forced);

                if(scroll.action !== 'stop' && animate) {
                    requestAnimationFrame(animate);
                } else {
                    delete scroll.action; animate = null; //For GC
                }
            } else {
                scrollTo(x, y, scroll, el.node, el.hScroll, el.vScroll, forced);
                delete scroll.action; animate = null; //For GC
            }
        };

        var ease = {
            InOutQuad: function(diffTime, oldValue, newValue, duration) {
                var change = newValue - oldValue;

                diffTime = diffTime / (duration / 2);

                if(diffTime < 1) {
                    return ((change / 2) * (diffTime * diffTime)) + oldValue;
                }
                diffTime--;
                return (((change / 2) * -1) * (diffTime * (diffTime - 2) - 1)) + oldValue;
            }
        };

        var scrollTo = function(left, top, offset, view, hbar, vbar, forced) {
            var hstyle = '', vstyle = '', hleft = 0, vtop = 0, gap = 1;

            if(forced || left !== offset.x) {
                offset.x = (left < 0) ? 0 : (left > offset.maxX) ? offset.maxX : left;
                if(view) view.scrollLeft = offset.x;
            }

            if(forced || top !== offset.y) {
                offset.y = (top < 0) ? 0 : (top > offset.maxY) ? offset.maxY : top;
                if(view) view.scrollTop = offset.y;
            }

            if(hbar) {
                hleft = parseInt(((offset.hmax / offset.maxX) * offset.x), 10);
                hleft = (hleft < 0) ? 0 : (hleft > offset.hmax) ? offset.hmax : hleft;

                hstyle = hbar.style.cssText;
                //hstyle += 'bottom:'+((gap > 0) ? gap : ('-'+offset.y))+'px;'; //Do not delete this line
                //TODO:: Achieve below line with transfor:translate
                hstyle += 'bottom:-'+(offset.y - gap)+'px;';
                hstyle += 'left:'+(offset.x + hleft)+'px;';
                //hstyle += 'transform:translate('+(offset.x + hleft)+'px, 0px);';
                hstyle += 'width:'+offset.hsize+'px;';

                hbar.style.cssText = hstyle;
            }

            if(vbar) {
                vtop = parseInt(((offset.vmax / offset.maxY) * offset.y), 10);
                vtop = (vtop < 0) ? 0 : (vtop > offset.vmax) ? offset.vmax : vtop;

                vstyle = vbar.style.cssText;
                vstyle += 'top:'+(offset.y + vtop)+'px;';
                //vstyle += 'transform:translate(0px, '+(offset.y + vtop)+'px);';
                //TODO:: Achieve below line with transfor:translate
                vstyle += 'right:'+((gap > 0) ? gap : ('-'+offset.x))+'px;';
                //vstyle += 'right:-'+(offset.x - 1)+'px;'; //Do not delete this line
                vstyle += 'height:'+offset.vsize+'px;';

                vbar.style.cssText = vstyle;
            }
        };

        if(!$KU.is(x, 'number') || !$KU.is(y, 'number')) return;

        model = $KW.model(model);
        if(!model) return; //Widget not found

        scroll = model._kwebfw_.ui;
        scroll = (scroll.scroll) ? scroll.scroll : null;
        if(!scroll) return; //This widget is not scrollable

        if($KU.is(duration, 'boolean')) forced = duration;

        //Normalizing algo
        if(!$KU.is(algo, 'string') || !algo
        || !$KU.is(ease[algo], 'function')) {
            algo = 'InOutQuad';
        }

        //Normalizing duration (in miliseconds)
        if($KU.is(duration, 'number')) {
            duration = (duration >= 0) ? duration : 0;
        } else if($KU.is(duration, 'object')) {
            if(!$KU.is(duration.x, 'number')) {
                duration.x = 0;
            }
            if(!$KU.is(duration.y, 'number')) {
                duration.y = 0;
            }

            duration = Math.max(duration.x, duration.y);
        } else {
            duration = 0;
        }

        el = _el(model); //Query all DOM needed
        _updateScroll(model);

        x = parseInt(x, 10); y = parseInt(y, 10);

        //Return if no change in scroll position from its previous state
        if(x === scroll.x && y === scroll.y) return;

        if(duration === 0) {
            scrollTo(x, y, scroll, el.node, el.hScroll, el.vScroll, forced);
        } else { //if duration is greater than zero
            animate();
        }
    };


    //temporary usage purpose will be replaced after custom implementation is done
    var _scrollToSetFocus = function $KW_scrollToSetFocus(model, positionObj/*, animate, time*/) {
        var $K = voltmx.$kwebfw$, $KU =$K.utils, scrollableView = null;

        scrollableView = _el(model);

        if(scrollableView.viewport) {
            scrollableView = scrollableView.viewport;
            //native scroll
            if($KU.scrollType() === 'native') {
                //TO DO
                scrollableView.scrollTop = positionObj.y;
                scrollableView.scrollLeft = positionObj.x;
            }
        }
    };


    var _scrollElementToParentScroller = function $KW_scrollElementToParentScroller(model, parentModel) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KD = $K.dom, elView = _el(model), elParentModelView = null,
            parentView = _el(parentModel), focusModel = model, xScroll = 0, yScroll = 0,
            maxLeftScroll = 0, maxTopScroll = 0;

        parentModel = parentModel || _omodel(model) || _pmodel(model);

        if(elView.node && parentView.viewport) {
            elView = elView.node;
            if($KU.is(parentModel, 'widget', 'SegmentedUI2')) {
                elView = $KD.parent(elView);
            }
            parentView = parentView.viewport;
            maxTopScroll = parentView.scrollHeight - parentView.offsetHeight;
            maxLeftScroll = parentView.scrollWidth - parentView.offsetWidth;

            if(_isScrollableWidget(parentModel, voltmx.flex.SCROLL_VERTICAL)
            || _isScrollableWidget(parentModel, voltmx.flex.SCROLL_BOTH)) {
                yScroll = elView.offsetTop;
                model = _pmodel(focusModel) || _omodel(focusModel);

                while(model && (parentModel !== model)) {
                    elParentModelView = _el(model).node;
                    yScroll += elParentModelView.offsetTop;
                    model = _pmodel(model) || _omodel(model);
                }

                if(yScroll > maxTopScroll) {
                    yScroll = maxTopScroll;
                }
                if(yScroll < 0) {
                    yScroll = 0;
                }
            }
            if(_isScrollableWidget(parentModel, voltmx.flex.SCROLL_HORIZONTAL)
            || _isScrollableWidget(parentModel, voltmx.flex.SCROLL_BOTH)) {
                xScroll = elView.offsetLeft;
                model = _pmodel(focusModel) || _omodel(focusModel);

                while(model && (parentModel !== model)) {
                    elParentModelView = _el(model).node;
                    xScroll += elParentModelView.offsetLeft;
                    model = _pmodel(model) || _omodel(model);
                }

                if(xScroll > maxLeftScroll) {
                    xScroll = maxLeftScroll;
                }
                if(xScroll < 0) {
                    xScroll = 0;
                }
            }

            _scrollToSetFocus(parentModel, {x: xScroll, y:yScroll}, true);
        }
    };


    var _setFocus = function $KW_setFocus(model) {
        var parent = null,
            parentScroller = function(gmodel) {
                var pmodel = _pmodel(gmodel) || _omodel(gmodel);

                return _closestScrollableWidget(pmodel);
            };

        parent = parentScroller(model);

        while(parent) {
            if(!_isWithinViewport(model, parent)) {
                _scrollElementToParentScroller(model, parent);
            }
            model = parent;
            parent = parentScroller(model);
        }
    };


    var _setContentOffset = function $KW_setContentOffset(model, offset, animate) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            el = null, widgets = null, value = {};

        widgets = ['Form2', 'FlexScrollContainer', 'SegmentedUI2', 'CollectionView'];
        if(widgets.indexOf($KW.name(model)) >= 0) {
            if(arguments.length === 2 && !$KU.is(animate, 'boolean')) {
                //ERROR:: throw new Error('Invalid parameter passed.');
            } else {
                if(!$KU.is(animate, 'boolean')) {
                    animate = false;
                }

                value = _getContentOffsetValues(model, offset);

                if($KU.is(value.x, 'integer') && $KU.is(value.y, 'integer')) {
                    //TODO:: Make use of animate parameter
                    if($KU.scrollType() !== 'native') {
                        $KW.scrollTo(model, value.x, value.y);
                    } else {
                        el = $KW.el(model);
                        el.viewport.scrollLeft = value.x;
                        el.viewport.scrollTop = value.y;
                    }
                } else {
                    throw new Error('Invalid parameter passed.');
                }
            }
        } else {
            throw new Error('Cannot call <setContentOffset> method on <'+ this._kwebfw_.ns+'>');
        }
    };


    var _setupUIInteraction = function $KW_setupUIInteraction(model, dom, clone) {
        var $K = voltmx.$kwebfw$, $KU =$K.utils, $KW = $K.widget,
            $KD = $K.dom, ui = null, tabindex = '';

        model = $KW.model(model);

        if(model) {
            ui = $K.ui[_name(model)];
            if(!$KU.is(clone, 'boolean')) clone = false;
            tabindex = _tabIndex(model, clone);

            if(dom) {
                if(ui && $KU.is(ui.setupUIInteraction, 'function')) {
                    ui.setupUIInteraction.call(model, dom, clone);
                } else if(_disabled(model)) {
                    $KD.setAttr(dom, 'aria-disabled', 'true');
                    //If tabindex should be -1, then ui.setupUIInteraction should exist
                    $KD.removeAttr(dom, 'tabindex');
                } else if(!_interactable(model)) {
                    //If tabindex should be -1, then ui.setupUIInteraction should exist
                    $KD.removeAttr(dom, 'tabindex');
                } else {
                    $KD.removeAttr(dom, 'aria-disabled');

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        //If tabindex should be -1, then ui.setupUIInteraction should exist
                        $KD.removeAttr(dom, 'tabindex');
                    }
                }
            }
        }
    };


    var _shouldApplyRTL = function $KW_shouldApplyRTL(model, property) {
        var $K = voltmx.$kwebfw$, $KA = $K.app, currentlocale = voltmx.i18n && $KA.currentLocale,
            layoutConfig = $KA.localeLayoutConfig,
            appPropertyName, widgetPropertyName, localeLevelPropertyMap = {
                'flexPosition': 'mirrorFlexPositionProperties',
                'contentAligment': 'mirrorContentAlignment',
                'layoutAlignment': 'mirrorFlowHorizontalAlignment'
            },
            widgetLevelPropertyMap = {
                'flexPosition': 'retainFlexPositionProperties',
                'contentAligment': 'retainContentAlignment',
                'layoutAlignment': 'retainFlowHorizontalAlignment'
            };
        if(model._kwebfw_.isPreValidated) {
            return false;
        }
        if(layoutConfig && currentlocale && layoutConfig[currentlocale]) {
            layoutConfig = layoutConfig[currentlocale];
            appPropertyName = localeLevelPropertyMap[property];
            widgetPropertyName = widgetLevelPropertyMap[property];
            if(layoutConfig[appPropertyName] && !model[widgetPropertyName]) {
                return true;
            }
        }
        return false;
    };

    var _shouldLazyLoad = {
        SegmentedUI2: function() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false, prop = this._kwebfw_.prop;

            if($KW.isFixedHeight(this)
            && this._kwebfw_.prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW
            && (voltmx.$kwebfw$.behavior.enableLazyLoadForSegment || prop.enableLazyLoad)) {
                flag = true;
            }

            return flag; //TODO:: return flag;
        }
    };

    var _siblings = function $KW_siblings(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            pmodel = null, widgets = [], siblings = [];

        model = $KW.model(model);

        if(model) {
            pmodel = _pmodel(model);
            widgets = _children(pmodel);

            $KU.each(widgets, function(widget) {
                if(widget !== model) {
                    siblings.push(widget);
                }
            });
        }

        return siblings;
    };


    var _skinHandlers = function $KU_skinhandlers() {
        return {
            webcss: function(skinObj) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils;

                $KU.each(skinObj.config, function(value, keey) {
                    if(skinObj.rule) {
                        skinObj.rule.style[keey] = value;
                    } else {
                        $KD.style(skinObj.el, keey, value);
                    }
                });
            },

            background: function(skinObj) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, value;

                value = $KW.skinUtils.background(skinObj.config);

                if(value) {
                    if(skinObj.rule) {
                        skinObj.rule.style.background = value;
                        //background color and background priority validation todo
                    } else {
                        $KD.style(skinObj.el, 'background', value);
                    }
                } else {
                    //todo
                }
            },

            border: function(skinObj) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils, $KW = $K.widget,
                    borderObj;

                borderObj = $KW.skinUtils.border(skinObj.config);

                if(borderObj) {
                    borderObj.borderStyle = 'solid';
                    if(skinObj.rule) {
                        $KU.each(borderObj, function(value, keey) {
                            skinObj.rule.style[keey] = value;
                        });
                    } else {
                        $KD.style(skinObj.el, borderObj);
                    }
                } else {
                    //todo
                }
            },

            fonts: function(skinObj) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils, $KW = $K.widget, fontObj,
                    widgets = ['FlexScrollContainer', 'FlexContainer', 'Form2', 'Map', 'Video', 'Browser'];

                if(skinObj.model
                && widgets.indexOf($KW.name(skinObj.model)) !== -1) {
                    return;
                }

                fontObj= $KW.skinUtils.font(skinObj.config);

                if(fontObj) {
                    if(skinObj.rule) {
                        $KU.each(fontObj, function(value, keey) {
                            skinObj.rule.style[keey] = value;
                        });
                    } else {
                        $KD.style(skinObj.el, fontObj);
                    }
                } else {
                    //todo
                }
            },

            shadow: function(skinObj) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, value;

                value = $KW.skinUtils.prepareShadowStyle(skinObj.config);

                if(value) {
                    if(skinObj.rule) {
                        skinObj.rule.style.boxShadow = value;
                    } else {
                        $KD.style(skinObj.el, 'boxShadow', value);
                    }
                } else {
                    //todo
                }
            },

            textShadow: function(skinObj) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                    value = '';

                if(skinObj.model
                && ['Label', 'Button'].indexOf($KW.name(skinObj.model)) === -1) {
                    return;
                }

                value = $KW.skinUtils.prepareTextShadowStyle(skinObj.config);

                if(value) {
                    if(skinObj.rule) {
                        skinObj.rule.style.textShadow = value;
                    } else {
                        $KD.style(skinObj.el, 'textShadow', value);
                    }
                } else {
                    //todo
                }
            }
        };
    };


    var _skinUtils = {
        background: function(config) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                bgType = config.backgroundType, background = null;

            if($KU.is(config, 'skinningConstant')) {
                background = $KW.skinUtils.processColorValue(config);
            } else {
                if(bgType === voltmx.skin.BACKGROUND_TYPE_SINGLE_COLOR && config.backgroundColor) {
                    background = $KW.skinUtils.processColorValue(config.backgroundColor);
                } else if(bgType === voltmx.skin.BACKGROUND_TYPE_IMAGE && config.backgroundImage) {
                    background = 'url("' + $KU.getImageURL(config.backgroundImage) + '")';
                } else if(bgType === voltmx.skin.BACKGROUND_TYPE_MULTI_STEP_GRADIENT) {
                    background = $KW.skinUtils.msGradient(config);
                } else if(bgType === voltmx.skin.BACKGROUND_TYPE_TWO_STEP_GRADIENT) {
                    background = $KW.skinUtils.twoStepGradient(config);
                }
            }

            return background;
        },

        border: function(config) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                border = {}, sknConst = '',

                borderSpecificSkinConstants = function(sknConst, border) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    if($KW.skinUtils.getConstantValue(sknConst+'-border-top')) {
                        border.borderTop = 'var(--'+sknConst+'-border-top)';
                    }
                    if($KW.skinUtils.getConstantValue(sknConst+'-border-bottom')) {
                        border.borderBottom = 'var(--'+sknConst+'-border-bottom)';
                    }
                    if($KW.skinUtils.getConstantValue(sknConst+'-border-left')) {
                        border.borderLeft = 'var(--'+sknConst+'-border-left)';
                    }
                    if($KW.skinUtils.getConstantValue(sknConst+'-border-right')) {
                        border.borderRight = 'var(--'+sknConst+'-border-right)';
                    }
                    if($KW.skinUtils.getConstantValue(sknConst+'-border-top-left-radius')) {
                        border.borderTopLeftRadius = 'var(--'+sknConst+'-border-top-left-radius)';
                    }
                    if($KW.skinUtils.getConstantValue(sknConst+'-border-top-right-radius')) {
                        border.borderTopRightRadius = 'var(--'+sknConst+'-border-top-right-radius)';
                    }
                    if($KW.skinUtils.getConstantValue(sknConst+'-border-bottom-left-radius')) {
                        border.borderBottomLeftRadius = 'var(--'+sknConst+'-border-top-left-radius)';
                    }
                    if($KW.skinUtils.getConstantValue(sknConst+'-border-bottom-right-radius')) {
                        border.borderBottomRightRadius = 'var(--'+sknConst+'-border-bottom-right-radius)';
                    }
                };

            if($KU.is(config, 'skinningConstant')) {
                sknConst = config.substring(1);
                if($KW.skinUtils.getConstantValue(sknConst)) {
                    border.border = 'var(--'+sknConst+')';
                    if($KW.skinUtils.getConstantValue(sknConst+'-border-radius')) {
                        border.borderRadius = 'var(--'+sknConst+'-border-radius)';
                    } else {
                        border.borderRadius = '';
                        border.borderTopLeftRadius = '';
                        border.borderTopRightRadius = '';
                        border.borderBottomLeftRadius = '';
                        border.borderBottomRightRadius = '';
                    }
                } else {
                    borderSpecificSkinConstants(sknConst, border);
                }
            } else {
                if(config.borderType === voltmx.skin.BORDER_TYPE_SINGLE_COLOR && config.borderColor) {
                    border.borderColor = $KW.skinUtils.processColorValue(config.borderColor);
                }

                if($KU.is(config.borderWidth, 'number')) {
                    border.borderWidth = config.borderWidth + 'px';
                } else if($KU.is(config.borderWidth, 'string')) {
                    border.borderWidth = config.borderWidth;
                } else if($KU.is(config.borderWidth, 'object')) {
                    border.borderWidth
                        = (config.borderWidth.top || 0) + 'px'
                        + ' ' + (config.borderWidth.right || 0) + 'px'
                        + ' ' + (config.borderWidth.bottom || 0) + 'px'
                        + ' ' + (config.borderWidth.left || 0) + 'px';
                }

                if($KU.is(config.cornerRadius, 'number')) {
                    border.borderRadius = config.cornerRadius + 'px';
                } else if($KU.is(config.cornerRadius, 'string')) {
                    border.borderRadius = config.cornerRadius;
                } else if($KU.is(config.cornerRadius, 'object')) {
                    border.borderRadius
                        = (config.cornerRadius.top || 0) + 'px'
                        + ' ' + (config.cornerRadius.right || 0) + 'px'
                        + ' ' + (config.cornerRadius.bottom || 0) + 'px'
                        + ' ' + (config.cornerRadius.left || 0) + 'px';
                }
            }
            return border;
        },

        font: function(config) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                baseFont, font = {}, skinConst = '', constVal = '';

            if($KU.is(config, 'skinningConstant')) {
                skinConst = config.substring(1);
                font.color = 'var(--'+skinConst+'-font-color)';
                font.fontFamily = 'var(--'+skinConst+'-font-family)';
                font.fontSize = 'var(--'+skinConst+'-font-size)';
                constVal = $KW.skinUtils.getConstantValue(skinConst+'-font-style').trim();
                if(constVal === voltmx.skin.FONT_STYLE_UNDERLINE) {
                    font.textDecoration = 'var(--'+skinConst+'-font-style)';
                    font.fontStyle = '';
                } else {
                    font.fontStyle = 'var(--'+skinConst+'-font-style)';
                    font.textDecoration = '';
                }
                font.fontWeight = 'var(--'+skinConst+'-font-weight)';
            } else {
                if($KW.skinUtils.validColorValue(config.fontColor)) {
                    font.color = $KW.skinUtils.processColorValue(config.fontColor);
                }

                if($KU.is(config.fontFamily, 'string')) {
                    font.fontFamily = $KW.skinUtils.processFontFamily(config.fontFamily);
                }

                if($KU.is(config.fontSize, 'number')) {
                    baseFont = $KW.skinUtils.getBaseFontSize();
                    font.fontSize = Math.round((config.fontSize * baseFont) /100) + 'px';
                }

                if($KU.is(config.fontStyle, 'string')) {
                    if(config.fontStyle === voltmx.skin.FONT_STYLE_UNDERLINE) {
                        font.textDecoration = config.fontStyle;
                        font.fontStyle = '';//need to test
                    } else {
                        font.fontStyle = config.fontStyle;
                    }
                }

                if($KU.is(config.fontWeight, 'string')) {
                    font.fontWeight = config.fontWeight;
                }
            }

            return font;
        },

        getBaseFontSize: function() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app,
                stylesheet = null, rules, baseFontSize = 16;

            stylesheet = $KU.getThemeStyleSheet($KA.currentTheme);

            if(stylesheet) {
                rules = stylesheet.cssRules || stylesheet.rules;
                $KU.each(rules, function(rule) {
                    if(rule.selectorText === '.voltmxcustomcss') {
                        baseFontSize = parseInt(rule.style.fontSize);
                        return true;
                    }
                });
            }

            return baseFontSize;
        },

        getConstantValue: function(constant) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, el = document.documentElement,
                value = '';

            value = $KD.style(el, '--'+constant);

            return value;
        },

        msGradient: function(config) {
            var $K = voltmx.$kwebfw$, i = 0, $KW = $K.widget,
                msColor = config.backgroundColorMultiStepGradient, gradient;

            if(msColor) {
                gradient = 'to ' + ['top', 'right', 'bottom', 'left'][[
                    voltmx.skin.MULTI_STEP_GRADIENT_TYPE_TO_BOTTOM,
                    voltmx.skin.MULTI_STEP_GRADIENT_TYPE_TO_LEFT,
                    voltmx.skin.MULTI_STEP_GRADIENT_TYPE_TO_TOP,
                    voltmx.skin.MULTI_STEP_GRADIENT_TYPE_TO_RIGHT
                ].indexOf(msColor.gradientType)] + ', ';

                for(i=0; i<msColor.colors.length && i<msColor.colorStops.length; i++) {
                    gradient += $KW.skinUtils.processColorValue(msColor.colors[i]) +' '+ msColor.colorStops[i]+'%,';
                }

                if(gradient.trim().endsWith(',')) {
                    gradient= gradient.substring(0, gradient.lastIndexOf(','));
                }

                return 'linear-gradient(' + gradient + ')';
            }
        },

        prepareTextShadowStyle: function(config) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
                style = '', shadowColor = config.textShadowColor || '#000000',
                shadowRadius = '', shadowOffsetX = '', shadowOffsetY = '';

            if($KU.is(config, 'skinningConstant')) {
                style = 'var(--'+config.substring(1)+')';
            } else {
                if(config.textShadowOffset) {
                    shadowRadius = (config.textShadowRadius || 0) + 'px';

                    shadowOffsetX = config.textShadowOffset.x + 'px';
                    shadowOffsetY = config.textShadowOffset.y + 'px';

                    if($KW.skinUtils.validColorValue(config.textShadowColor)) {
                        shadowColor = $KW.skinUtils.processColorValue(config.textShadowColor);
                    } else {
                        shadowColor = $KW.skinUtils.processColorValue(shadowColor);
                    }

                    style = shadowOffsetX + ' ' + shadowOffsetY + ' ' + shadowRadius + ' ' + shadowColor;
                }
            }

            return style;
        },

        prepareShadowStyle: function(config) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
                style = '', shadowColor = config.shadowColor || '#000000',
                shadowRadius = '', shadowOffsetX = '', shadowOffsetY = '';

            if($KU.is(config, 'skinningConstant')) {
                style = 'var(--'+config.substring(1)+')';
            } else {
                if(config.shadowOffset) {
                    shadowRadius = (config.shadowRadius || 0) + 'px';

                    if(config.shadowOffset) {
                        shadowOffsetX = config.shadowOffset.x + 'px';
                        shadowOffsetY = config.shadowOffset.y + 'px';
                    }

                    if($KW.skinUtils.validColorHexValue(config.shadowColor)) {
                        shadowColor = $KW.skinUtils.processColorValue(config.shadowColor);
                    } else {
                        shadowColor = $KW.skinUtils.processColorValue(shadowColor);
                    }

                    style = shadowOffsetX + ' ' + shadowOffsetY + ' ' + shadowRadius + ' ' + shadowColor;
                }
            }
            return style;
        },

        stringifyAnchorPoint: function(value) {
            var x = '', y = '';
            x = ((value.x * 100) + '%');
            y = ((value.y * 100) + '%');

            return x+' '+y;
        },

        stringifyTrasnsform:  function(value) {
            var transform = '', t = '';

            if(value) {
                t = value.transform;

                //Order of these IF condition is important
                if(t.perspective) {
                    transform += t.perspective;
                }
                if(t.scale) {
                    transform += (transform) ? (' '+t.scale) : t.scale;
                }
                if(t.translate) {
                    transform += (transform) ? (' '+t.translate) : t.translate;
                }
                if(t.rotate) {
                    transform += (transform) ? (' '+t.rotate) : t.rotate;
                }
            }

            return transform;
        },

        twoStepGradient: function(config) {
            var $K = voltmx.$kwebfw$, bottomcolor = '', gradient = null, topcolor = '',
                tsColor = config.backgroundColorTwoStepGradient, $KW = $K.widget, percentage = null;

            if(tsColor) {
                percentage = (tsColor.style === voltmx.skin.TWO_STEP_GRADIENT_STYLE_VERTICAL_SPLIT
                || tsColor.style === voltmx.skin.TWO_STEP_GRADIENT_STYLE_HORIZONTAL_SPLIT) ? '50%' : '';

                topcolor = $KW.skinUtils.processColorValue(tsColor.topColor);
                bottomcolor = $KW.skinUtils.processColorValue(tsColor.bottomColor);

                gradient = 'to ' + ['bottom', 'bottom', 'right', 'right'][[
                    voltmx.skin.TWO_STEP_GRADIENT_STYLE_VERTICAL_GRADIENT,
                    voltmx.skin.TWO_STEP_GRADIENT_STYLE_VERTICAL_SPLIT,
                    voltmx.skin.TWO_STEP_GRADIENT_STYLE_HORIZONTAL_GRADIENT,
                    voltmx.skin.TWO_STEP_GRADIENT_STYLE_HORIZONTAL_SPLIT
                ].indexOf(tsColor.style)] + ', ';

                gradient += topcolor+ ' '+ percentage +',' + bottomcolor + ' '+ percentage;

                return 'linear-gradient(' + gradient + ')';
            }
        },

        validColorHexValue: function(value) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

            if($KU.is(value, 'string')) {
                value = value.toUpperCase();

                flag = $KU.is(value, 'color');
            }

            return (flag ? [value, flag] : flag);
        },

        validColorValue: function(value) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, flag = false;

            if($KW.skinUtils.validColorHexValue(value) || $KU.is(value, 'null') || $KU.is(value, 'skinningConstant')) {
                flag = true;
            }

            return flag;
        },

        processColorValue: function(value) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                processedValue = '';

            if($KU.is(value, 'skinningConstant')) {
                processedValue = 'var(--' + value.substring(1) +')';
            } else if($KW.skinUtils.validColorHexValue(value)) {
                processedValue = $KU.convertHexToRGBA(value);
            }

            return processedValue;
        },

        processFontFamily: function(value) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                processedValue = '';

            if($KU.is(value, 'skinningConstant')) {
                processedValue = 'var(--' + value.substring(1) +')';
            } else {
                processedValue = value;
            }

            return processedValue;
        }
    };


    var _removeSensitiveText = function $KW_removeSensitiveText(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget;

        $KW.iterate(model, function(widget) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, templates = null;

            if($KU.is(widget, 'widget', 'SegmentedUI2')
            || $KU.is(widget, 'widget', 'CollectionView')) {
                if($KU.is(widget, 'widget', 'SegmentedUI2')) {
                    templates = widget._kwebfw_.rows;
                } else {
                    templates = widget._kwebfw_.items;
                }

                $KU.each(templates, function(widgetRef) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;
                    $KW.iterate(widgetRef, function(widgetModel) {
                        _removeSensitiveTextFromHeap(widgetModel);
                    });
                });
            } else {
                _removeSensitiveTextFromHeap(widget);
            }
        });
    };

    var _removeSensitiveTextFromHeap = function $KW_removeSensitiveTextFromHeap(widget) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;
        if($KU.is(widget, 'widget', 'TextBox2')
        || $KU.is(widget, 'widget', 'TextArea2')) {
            if(widget.isSensitiveText) {
                widget.text = '';
            }
        }
    };

    var _tabIndex = function $KW_tabIndex(model, clone) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            a11y = null, tabindex = '', rmodel = null, _ = null;

        model = $KW.model(model);

        if(model) {
            _ = model._kwebfw_;
            tabindex = _.tabIndex;
            if(!$KU.is(clone, 'boolean')) clone = false;

            //START:: Override with a11ARIA.tabindex value
            a11y = model.accessibilityConfig;
            a11y = (a11y) ? a11y.a11yARIA : null;

            if(a11y && $KU.is(a11y.tabindex, 'integer')) {
                tabindex = a11y.tabindex;
            }
            //END:: Override with a11ARIA.tabindex value

            //START:: set to 0 if a11y is defined and no tabindex exisits.
            if(!$KU.is(tabindex, 'integer') && model.accessibilityConfig) {
                tabindex = 0;
            }
            //END:: set to 0 if a11y is defined and no tabindex exisits.

            //START:: Deducing with other widget heuristic
            if(!$KU.is(tabindex, 'integer')) {
                if($KU.is(model.onClick, 'function')) {
                    tabindex = 0;
                } else {
                    rmodel = _fmodel(model); //Here rmodel is fmodel
                    if(rmodel && model === rmodel._kwebfw_.modalContainer) {
                        tabindex = 0;
                    }
                }
            }
            //END:: Deducing with other widget heuristic


            //START:: Override if widget belongs to any owner widget
            if($KU.is(tabindex, 'integer') && _.is.cloned && !clone) {
                rmodel = _rmodel(model);
                rmodel = (rmodel) ? rmodel._kwebfw_ : null;

                if(rmodel && rmodel.is.cloned && rmodel.is.template) {
                    tabindex = $KU.is(_.tabIndex, 'integer') ? -1 : '';
                }
            }
            //END:: Override if widget belongs to any owner widget
        }

        return tabindex;
    };


    var _tmodel = function $KW_tmodel(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, tmodel = null;

        model = $KW.model(model);

        if(model) {
            tmodel = (model._kwebfw_.is.template)
                ? model : _rmodel(_pmodel(model));

            while(tmodel && !tmodel._kwebfw_.is.template) {
                tmodel = _rmodel(_pmodel(tmodel));
            }
        }

        return tmodel;
    };


    var _toggleChildren = function $KW_toggleChildren(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            _ = model._kwebfw_, dom = _.view, disabled = _.disabled,
            shouldBeDisabled = ['BUTTON', 'FIELDSET', 'INPUT', 'OPTGROUP', 'OPTION', 'OBJECT', 'SELECT', 'TEXTAREA', 'A', 'AREA', 'IFRAME', 'DETAILS', 'AUDIO', 'VIDEO', '[tabindex]', '[voltmx-bkp-tabindex]'],
            listOfElements = dom.querySelectorAll(shouldBeDisabled);

        $KU.each(listOfElements, function(item) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, disabled = model._kwebfw_.disabled;

            if(disabled) {
                if($KD.hasAttr(item, 'tabindex')) {
                    $KD.setAttr(item, 'voltmx-bkp-tabindex', $KD.getAttr(item, 'tabindex'));
                    $KD.removeAttr(item, 'tabindex');
                }

                if(['BUTTON', 'FIELDSET', 'INPUT', 'OPTGROUP', 'OPTION', 'SELECT', 'TEXTAREA'].indexOf(item.tagName) >= 0) {
                    if($KD.hasAttr(item, 'disabled')) {
                        $KD.setAttr(item, 'voltmx-bkp-disabled', 'disabled');
                    } else {
                        $KD.setAttr(item, 'voltmx-dev-disabled', 'disabled');
                    }
                    $KD.setAttr(item, 'disabled', 'disabled');
                } else if(['A', 'AREA', 'IFRAME', 'DETAILS'].indexOf(item.tagName) >= 0) {
                    $KD.setAttr(item, 'tabindex', -1);
                    $KD.setAttr(item, 'voltmx-dev-tabindex', -1);
                }
            } else {
                if(['BUTTON', 'FIELDSET', 'INPUT', 'OPTGROUP', 'OPTION', 'SELECT', 'TEXTAREA'].indexOf(item.tagName) >= 0) {
                    if($KD.hasAttr(item, 'voltmx-dev-disabled')) {
                        $KD.removeAttr(item, 'disabled');
                        $KD.removeAttr(item, 'voltmx-dev-disabled');
                    } else if($KD.hasAttr(item, 'voltmx-bkp-disabled')) {
                        $KD.setAttr(item, 'disabled', $KD.getAttr(item, 'voltmx-bkp-disabled'));
                        $KD.removeAttr(item, 'voltmx-bkp-disabled');
                    }
                } else if(['A', 'AREA', 'IFRAME', 'DETAILS'].indexOf(item.tagName) >= 0) {
                    if($KD.hasAttr(item, 'voltmx-dev-tabindex')) {
                        $KD.removeAttr(item, 'tabindex');
                        $KD.removeAttr(item, 'voltmx-dev-tabindex');
                    }
                }

                if($KD.hasAttr(item, 'voltmx-bkp-tabindex')) {
                    $KD.setAttr(item, 'tabindex', $KD.getAttr(item, 'voltmx-bkp-tabindex'));
                    $KD.removeAttr(item, 'voltmx-bkp-tabindex');
                }
            }
        });

        if(disabled) {
            $KD.addCls(dom, '-voltmx-blocker');
        } else {
            $KD.removeCls(dom, '-voltmx-blocker');
        }
    };


    var _tpmodel = function $KW_tpmodel(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = null, tpmodel = null;

        model = $KW.model(model);

        if(model) {
            tpmodel = (model._kwebfw_.is.tab && model._kwebfw_.tpid)
                ? model : _rmodel(_pmodel(model));
            _ = (tpmodel) ? tpmodel._kwebfw_ : null;

            while(tpmodel && !(_.is.tab && _.tpid)) {
                tpmodel = _rmodel(_pmodel(tpmodel));
                _ = (tpmodel) ? tpmodel._kwebfw_ : null;
            }

            if(_ && _.is.tab && _.tpid) {
                tpmodel = $KW.model(_.tpid);
            }
        }

        return tpmodel;
    };


    var _updateModalContainer = function $KW_updateModalContainer(fmodel, modalContainer) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KA = $K.app, cf = $KW.model($KA.currentFormUID);

        if($KU.is(fmodel, 'widget', 'Form2') && fmodel === cf) {
            if($KU.is(modalContainer, 'null')
            || $KU.is(modalContainer, 'widget', 'component')
            || $KU.is(modalContainer, 'widget', 'FlexContainer')
            || $KU.is(modalContainer, 'widget', 'FlexScrollContainer')) {
                if(modalContainer !== fmodel._kwebfw_.modalContainer) {
                    fmodel._kwebfw_.modalContainer = modalContainer;

                    _iterate(fmodel, function(widget) {
                        var _ = widget._kwebfw_, dom = null;

                        if(!modalContainer) {
                            _.inModalContainer = true;
                        } else if(fmodel === widget) {
                            _.inModalContainer = false;
                        } else if(modalContainer === widget) {
                            _.inModalContainer = true;
                        } else if(_pmodel(widget)._kwebfw_.inModalContainer) {
                            _.inModalContainer = true;
                        } else {
                            _.inModalContainer = false;
                        }

                        if(_.view) {
                            dom = _focusableElement(widget);
                            _setupUIInteraction(widget, dom);
                        }
                    }, {tabs:false});

                    modalContainer && _focus(modalContainer);
                }
            }
        }
    };


    var _updateScroll = function $KW_updateScroll(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            scroll = model._kwebfw_.ui.scroll, el = _el(model), size = -1;

        if(!scroll || $KU.scrollType() === 'native') return;

        //Calculate scroll.width and scroll.height if any of their value is -1
        //The same IF BLOCK is there in "voltmxwidget.js" file "_scrollTo" function
        if((scroll.width === -1 || scroll.height === -1)
        && el.viewport && $KD.contains($KD.body(), el.viewport)) {
            if(scroll.width === -1) {
                size = el.scrolee.offsetWidth;
                scroll.width = Math.max(el.scrolee.scrollWidth, size);
                el.viewport.setAttribute('k_offset_width', size);
                el.viewport.setAttribute('k_scroll_width', scroll.width);
                if(el.hScroll) scroll.hmin = el.hScroll.offsetHeight;
                scroll.maxX = scroll.width - size;
                scroll.maxX = (scroll.maxX > 0) ? scroll.maxX : 0;

                scroll.hsize = (size / scroll.width) * size;
                if(scroll.hsize < scroll.hmin) scroll.hsize = scroll.hmin;

                if(el.hScroll) {
                    if(scroll.hsize === size) {
                        el.hScroll.style.height = '0px';
                        el.hScroll.style.border = 'none';
                    } else {
                        el.hScroll.style.removeProperty('height');
                        el.hScroll.style.removeProperty('border');
                    }
                }

                scroll.hmax = size - scroll.hsize;
            }

            if(scroll.height === -1) {
                size = el.scrolee.offsetHeight;
                scroll.height = Math.max(el.scrolee.scrollHeight, size);
                el.viewport.setAttribute('k_offset_height', size);
                el.viewport.setAttribute('k_scroll_height', scroll.height);
                if(el.vScroll) scroll.vmin = el.vScroll.offsetWidth;
                scroll.maxY = scroll.height - size;
                scroll.maxY = (scroll.maxY > 0) ? scroll.maxY : 0;

                scroll.vsize = (size / scroll.height) * size;
                if(scroll.vsize < scroll.vmin) scroll.vsize = scroll.vmin;

                if(el.vScroll) {
                    if(scroll.vsize === size) {
                        el.vScroll.style.width = '0px';
                        el.vScroll.style.border = 'none';
                    } else {
                        el.vScroll.style.removeProperty('width');
                        el.vScroll.style.removeProperty('border');
                    }
                }

                scroll.vmax = size - scroll.vsize;
            }
        }
    };


    var _visible = function $KW_visible(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, rmodel = null,
            omodel = null, tpmodel = null, invisible = null, activeTabs = null;

        model = $KW.model(model);
        rmodel = (model) ? $KW.rmodel(model) : null;
        omodel = (model) ? $KW.omodel(model) : null;
        tpmodel = (model) ? $KW.tpmodel(model) : null;

        if(model) {
            invisible = $KW.closest(model, function(widget) {
                return (!widget.isVisible) ? true : null;
            }, {owner:true, tabs:true});

            if(!invisible) {
                if(omodel) {
                    invisible = $KW.closest(omodel, function(widget) {
                        return (!widget.isVisible) ? true : null;
                    }, {owner:true, tabs:true});
                } else if(tpmodel) {
                    activeTabs = [];

                    $KU.each(tpmodel.activeTabs, function(pos) {
                        activeTabs.push(this._kwebfw_.tabs[pos].id);
                    }, tpmodel);

                    if(activeTabs.indexOf(rmodel.id) === -1) {
                        invisible = true;
                    } else {
                        invisible = $KW.closest(tpmodel, function(widget) {
                            return (!widget.isVisible) ? true : null;
                        }, {owner:true, tabs:true});
                    }
                }
            }
        }

        return (invisible) ? false : true;
    };


    var _normalizeGroupMasterData = function $KW_normalizeGroupMasterData(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = model._kwebfw_.prop.masterData;

        if(data) {
            $KU.each(data, function(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, keey = value[0];

                if($KU.is(keey, 'integer')) {
                    value[0] = (''+keey);
                } else if(!$KU.is(keey, 'string')) {
                    throw new Error('Invalid value passed to property <masterData> of widget <'+ this._kwebfw_.ns+'>.');
                }
            }, model);
        }
    };


    var _normalizeGroupMasterDataMap = function $KW_normalizeGroupMasterDataMap(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = model._kwebfw_.prop.masterDataMap;

        if(data) {
            $KU.each(data[0], function(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, keey = value[data[1]];

                if($KU.is(keey, 'integer')) {
                    value[data[1]] = (''+keey);
                } else if(!$KU.is(keey, 'string')) {
                    throw new Error('Invalid value passed to property <masterDataMap> of widget <'+ this._kwebfw_.ns+'>.');
                }
            }, model);
        }
    };


    $K.defVoltmxProp(_ns, [
        {keey:'accessibility', value:_accessibility},
        {keey:'addSkin', value:_addSkin},
        {keey:'addToView', value:_addToView},
        {keey:'applyGroupA11Y', value:_applyGroupA11Y},
        {keey:'auditFakeBorders', value:_auditFakeBorders},
        {keey:'auditFlexDetails', value:_auditFlexDetails},
        {keey:'auditModelAnomalies', value:_auditModelAnomalies},
        {keey:'children', value:_children},
        {keey:'clearGroupA11y', value:_clearGroupA11y},
        {keey:'cloneTemplate', value:_cloneTemplate},
        {keey:'closest', value:_closest},
        {keey:'closestScrollableWidget', value:_closestScrollableWidget},
        {keey:'cmodel', value:_cmodel},
        {keey:'component', value:_component},
        {keey:'contains', value:_contains},
        {keey:'deduceModalContainer', value:_deduceModalContainer},
        {keey:'details', value:_details},
        {keey:'disabled', value:_disabled},
        {keey:'dismissPickers', value:_dismissPickers},
        {keey:'dismissPicker', value:_dismissPicker},
        {keey:'el', value:_el},
        {keey:'evaluateScrollPosition', value:_evaluateScrollPosition},
        {keey:'fire', value:_fire},
        {keey:'fmodel', value:_fmodel},
        {keey:'focus', value:_focus},
        {keey:'focusableElement', value:_focusableElement},
        {keey:'getContentOffsetValues', value:_getContentOffsetValues},
        {keey:'getAccessibilityConfig', value:_getAccessibilityConfig},
        {keey:'getDefaultHeight', value:_getDefaultHeight},
        {keey:'getDefaultWidth', value:_getDefaultWidth},
        {keey:'getDefaultProperty', value:_getDefaultProperty},
        {keey:'getFlexProperties', value:_getFlexProperties},
        {keey:'getGroupSelectedKeyValueByKey', value:_getGroupSelectedKeyValueByKey},
        {keey:'getModelByNode', value:_getModelByNode},
        {keey:'getModelByPath', value:_getModelByPath},
        {keey:'getNonConstructorProperties', value:_getNonConstructorProperties},
        {keey:'getTemplate', value:_getTemplate},
        {keey:'getWidgetDataMapPath', value:_getWidgetDataMapPath},
        {keey:'handleTabPaneEnablement', value:_handleTabPaneEnablement},
        {keey:'hmodel', value:_hmodel},
        {keey:'holder', value:_holder},
        {keey:'inComponent', value:_inComponent},
        {keey:'index', value:_index},
        {keey:'inheritedProperties', value:_inheritedProperties},
        {keey:'inModalContainer', value:_inModalContainer},
        {keey:'inPercent', value:_inPercent},
        {keey:'inTemplate', value:_inTemplate},
        {keey:'interactable', value:_interactable},
        {keey:'invokeLifeCycleEvent', value:_invokeLifeCycleEvent},
        {keey:'isClonable', value:_isClonable},
        {keey:'isContainer', value:_isContainer},
        {keey:'isFixedHeight', value:_isFixedHeight},
        {keey:'isFixedHeightWidget', value:_isFixedHeightWidget},
        {keey:'isFixedWidth', value:_isFixedWidth},
        {keey:'isFixedWidthWidget', value:_isFixedWidthWidget},
        {keey:'isFlexContainer', value:_isFlexContainer},
        {keey:'isFlexPropertyDefined', value:_isFlexPropertyDefined},
        {keey:'isFlexWidget', value:_isFlexWidget},
        {keey:'isGreedyWidget', value:_isGreedyWidget},
        {keey:'isImplicitHeight', value:_isImplicitHeight},
        {keey:'isImplicitWidth', value:_isImplicitWidth},
        {keey:'isOwnerWidget', value:_isOwnerWidget},
        {keey:'isRendered', value:_isRendered},
        {keey:'isResponsiveContainer', value:_isResponsiveContainer},
        {keey:'isScrollableWidget', value:_isScrollableWidget},
        {keey:'isTemplatable', value:_isTemplatable},
        {keey:'isTextDrivenWidget', value:_isTextDrivenWidget},
        {keey:'iterate', value:_iterate},
        {keey:'layout', value:_layout},
        {keey:'markRelayout', value:_markRelayout},
        {keey:'getRootNode', value:_getRootNode},
        {keey:'modifySelectedIndexes', value:_modifySelectedIndexes},
        {keey:'name', value:_name},
        {keey:'nextVisible', value:_nextVisible},
        {keey:'normalizeGroupMasterData', value:_normalizeGroupMasterData},
        {keey:'normalizeGroupMasterDataMap', value:_normalizeGroupMasterDataMap},
        {keey:'omodel', value:_omodel},
        {keey:'onPropertyChange', value:_onPropertyChange},
        {keey:'onRender', value:_onRender},
        {keey:'pickers', value:_pickers},
        {keey:'pmodel', value:_pmodel},
        {keey:'populateScrollDetails', value:_populateScrollDetails},
        {keey:'prevVisible', value:_prevVisible},
        {keey:'proxy', value:_proxy},
        {keey:'registerForIdleTimeout', value:_registerForIdleTimeout},
        {keey:'registerNativeScrollEvent', value:_registerNativeScrollEvent},
        {keey:'removeAllSkinsFromUI', value:_removeAllSkinsFromUI},
        {keey:'removeMarkedLayout', value:_removeMarkedLayout},
        {keey:'removeSensitiveText', value:_removeSensitiveText},
        {keey:'removeSkin', value:_removeSkin},
        {keey:'removeView', value:_removeView},
        {keey:'replaceWAPIndex', value:_replaceWAPIndex},
        {keey:'rmodel', value:_rmodel},
        {keey:'scrollBy', value:_scrollBy},
        {keey:'scrollElementToParentScroller', value:_scrollElementToParentScroller},
        {keey:'scrollTo', value:_scrollTo},
        {keey:'setFocus', value:_setFocus},
        {keey:'setContentOffset', value:_setContentOffset},
        {keey:'setupUIInteraction', value:_setupUIInteraction},
        {keey:'shouldApplyRTL', value:_shouldApplyRTL},
        {keey:'shouldLazyLoad', value:_shouldLazyLoad},
        {keey:'siblings', value:_siblings},
        {keey:'skinHandlers', value:_skinHandlers},
        {keey:'skinUtils', value:_skinUtils},
        {keey:'tabIndex', value:_tabIndex},
        {keey:'tmodel', value:_tmodel},
        {keey:'toggleChildren', value:_toggleChildren},
        {keey:'tpmodel', value:_tpmodel},
        {keey:'updateModalContainer', value:_updateModalContainer},
        {keey:'updateScroll', value:_updateScroll},
        {keey:'visible', value:_visible}
    ]);


    return _ns;
}())});


/* FILE PATH :: 'lib/utils/voltmxevent.js' */
(function() {
    var _getInternalHandlers = function $KE_getInternalHandlers(evt) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, target = null;

        target = $KD.closest(evt.target, function(dom) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom;

            if($KD.hasAttr(dom, ('kwh-'+evt.type))) {
                return true;
            } else if($KD.hasAttr(dom, 'kw')) {
                return false;
            }
        });

        return (target) ? $KD.getAttr(target, ('kwh-'+evt.type)) : '';
    };


    var _getVoltmxEventType = function $KE_getVoltmxEventType(evt) {
        var event = {
            click:       'onClick',
            focusin:     'onFocus',
            focusout:    'onBlur',
            keydown:     'onKeyDown',
            keyup:       'onKeyUp',
            mousedown:   'onTouchStart',
            mousemove:   'onTouchMove',
            mouseout:    'onTouchEnd',
            mouseup:     'onTouchEnd',
            touchend:    'onTouchEnd',
            touchmove:   'onTouchMove',
            touchstart:  'onTouchStart',
            touchcancel: 'onTouchEnd'
        };

        return event[evt.type] || evt.type;
    };


    var _handleKeyBoardClick = function $KE_handleKeyBoardClick(evt, model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, prioritisedSkin = '';

        model.onClick && $KD.preventDefault(evt);
        if(evt.type === 'keydown') {
            _handleSkinEvent.focusModel = model;
            _handleSkinEvent.focusNode = evt.target;

            prioritisedSkin = _handleSkinEvent.getPrioritisedSkinType(model);
            if(prioritisedSkin === 'focusSkin') {
                _handleSkinEvent.setSkinRecursively(model, 'focus');
                _handleSkinEvent.resetSkinRecursively(model, 'active');
                _handleSkinEvent.resetSkinRecursively(model, 'hover');
            }
        } else if(evt.type === 'keyup') {
            _handleSkinEvent.focusModel = null;
            _handleSkinEvent.focusNode = null;

            _handleSkinEvent.resetSkinRecursively(model, 'focus');

            prioritisedSkin = _handleSkinEvent.getPrioritisedSkinType(model);
            if(prioritisedSkin === 'hoverSkin') {
                _handleSkinEvent.setSkinRecursively(model, 'hover');
            } else if(prioritisedSkin === 'activeStateSkin') {
                _handleSkinEvent.setSkinRecursively(model, 'active');
            }

            $KW.fire(model, 'onClick', model);
        }
    };


    var _handleOwnerItemBlur = function $KE_handleOwnerItemBlur(evt, model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
            omodel = null, item = null, prevItem = null, nextItem = null,
            rmodel = null, prevRmodel = null, nextRmodel = null;

        if($KD.getAttr(evt.target, 'kr') === 'item') {
            model = $KD.first(evt.target);
            model = (model) ? $KW.model(model) : null;
        }

        if(model && model._kwebfw_.view) {
            omodel = $KW.omodel(model);
            rmodel = $KW.rmodel(model);
            item = $KD.closest(model._kwebfw_.view, 'kr', 'item');

            if(omodel && rmodel && item) {
                prevItem = $KD.prev(item);
                nextItem = $KD.next(item);

                $KD.setAttr(item, 'tabindex', -1);
                $KW.iterate(rmodel, function(widget) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    $KW.setupUIInteraction(widget, $KW.focusableElement(widget), false);
                }, {tabs:false});

                if(prevItem) {
                    prevRmodel = $KW.model(prevItem);
                    if(!prevRmodel) {
                        prevRmodel = $KW.model($KD.first(prevItem));
                    }

                    $KD.setAttr(prevItem, 'tabindex', -1);
                    $KW.iterate(prevRmodel, function(widget) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget;

                        $KW.setupUIInteraction(widget, $KW.focusableElement(widget), false);
                    }, {tabs:false});
                }

                if(nextItem) {
                    nextRmodel = $KW.model(nextItem);
                    if(!nextRmodel) {
                        nextRmodel = $KW.model($KD.first(nextItem));
                    }

                    $KD.setAttr(nextItem, 'tabindex', -1);
                    $KW.iterate(nextRmodel, function(widget) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget;

                        $KW.setupUIInteraction(widget, $KW.focusableElement(widget), false);
                    }, {tabs:false});
                }
            }
        }
    };


    var _handleOwnerItemClick = function $KE_handleOwnerItemClick(evt, model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, omodel = null,
            $KW = $K.widget, $KD = $K.dom, nonTemplated = false;

        if($KU.is(model, 'widget', 'DataGrid')
        && (['IMG', 'DIV'].indexOf(evt.target.tagName) >= 0)) {
            nonTemplated = true;
        } else if($KD.getAttr(evt.target, 'kr') === 'item') {
            model = $KD.first(evt.target);
            model = (model) ? $KW.model(model) : null;
        }

        if(model && model._kwebfw_.view && $KW.interactable(model)) {
            if(nonTemplated) {
                _setOwnerSelectedIndex[$KW.name(model)].call(model, evt.target);
            } else {
                omodel = $KW.omodel(model);

                if(omodel && $KU.is(_setOwnerSelectedIndex[$KW.name(omodel)], 'function')) {
                    _setOwnerSelectedIndex[$KW.name(omodel)].call(omodel, model);
                }
            }
        }
    };


    var _handleOwnerItemEvents = function $KE_handleOwnerItemEvents(evt, model, code) {
        if(evt.type === 'click'
        || (evt.type === 'keyup' && ([13, 32].indexOf(code) >= 0))) {
            _handleOwnerItemClick(evt, model);
        } else if(evt.type === 'focusin') {
            _handleOwnerItemFocus(evt, model);
        } else if(evt.type === 'focusout') {
            _handleOwnerItemBlur(evt, model);
        }
    };


    var _handleOwnerItemFocus = function $KE_handleOwnerItemFocus(evt, model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
            omodel = null, tabindex = '', item = null, prevItem = null, nextItem = null,
            rmodel = null, prevRmodel = null, nextRmodel = null, nonTemplated = false;

        if($KU.is(model, 'widget', 'DataGrid')
        && (['IMG', 'DIV'].indexOf(evt.target.tagName) >= 0)) {
            nonTemplated = true;
        } else if($KD.getAttr(evt.target, 'kr') === 'item') {
            model = $KD.first(evt.target);
            model = (model) ? $KW.model(model) : null;
        }

        if(model && model._kwebfw_.view && $KW.interactable(model)) {
            if(nonTemplated) {
                tabindex = $KW.tabIndex(model);

                if($KU.is(tabindex, 'integer') && tabindex >= 0) {
                    $KD.setAttr(evt.target, 'tabindex', tabindex);
                }
            } else {
                omodel = $KW.omodel(model);
                rmodel = $KW.rmodel(model);
                item = $KD.closest(model._kwebfw_.view, 'kr', 'item');

                if(omodel && rmodel && item) {
                    tabindex = $KW.tabIndex(omodel);

                    if($KU.is(tabindex, 'integer') && tabindex >= 0) {
                        prevItem = $KD.prev(item);
                        nextItem = $KD.next(item);

                        $KD.setAttr(item, 'tabindex', tabindex);
                        $KW.iterate(rmodel, function(widget) {
                            var $K = voltmx.$kwebfw$, $KW = $K.widget;

                            $KW.setupUIInteraction(widget, $KW.focusableElement(widget), true);
                        }, {tabs:false});

                        if(prevItem) {
                            prevRmodel = $KW.model(prevItem);
                            if(!prevRmodel) {
                                prevRmodel = $KW.model($KD.first(prevItem));
                            }

                            $KD.setAttr(prevItem, 'tabindex', tabindex);
                            $KW.iterate(prevRmodel, function(widget) {
                                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                                $KW.setupUIInteraction(widget, $KW.focusableElement(widget), true);
                            }, {tabs:false});
                        }

                        if(nextItem) {
                            nextRmodel = $KW.model(nextItem);
                            if(!nextRmodel) {
                                nextRmodel = $KW.model($KD.first(nextItem));
                            }

                            $KD.setAttr(nextItem, 'tabindex', tabindex);
                            $KW.iterate(nextRmodel, function(widget) {
                                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                                $KW.setupUIInteraction(widget, $KW.focusableElement(widget), true);
                            }, {tabs:false});
                        }
                    }
                }
            }
        }
    };


    var _handleSkinEvent = {
        target: null,

        mouseOverModel: null,

        focusModel: null,

        hoverModel: null,

        activeModel: null,

        focusNode: null,

        hoverNode: null,

        activeTargetNode: null,

        dealWithActiveStateSkin: function(evt) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, model = null,
                prioritisedSkin = '';


            model = $KD.closest(evt.target, function(node) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if($KD.hasAttr(node, 'kw') || $KD.hasAttr(node, 'kwf')) {
                    return true;
                }
            });

            if(model) {
                if($KD.hasAttr(model, 'kw')) {
                    model = $KW.model(model);
                } else if($KD.hasAttr(model, 'kwf')) {
                    model = $KW.model($KD.getAttr(model, 'kwf'));
                }

                if(['focusin'].indexOf(evt.type) >= 0) {
                    _handleSkinEvent.activeModel = model;
                    _handleSkinEvent.activeTargetNode = evt.target;

                    prioritisedSkin = _handleSkinEvent.getPrioritisedSkinType(model);

                    if(prioritisedSkin === 'activeStateSkin') {
                        _handleSkinEvent.resetSkinRecursively(model, 'active');
                        _handleSkinEvent.setSkinRecursively(model, 'active');
                    }
                } else if(['focusout'].indexOf(evt.type) >= 0) {
                    _handleSkinEvent.resetSkinRecursively(model, 'active');

                    _handleSkinEvent.activeModel = null;
                    _handleSkinEvent.activeTargetNode = null;
                }
            }
        },

        dealWithCalendarHoverSkin: function(model) {//deal with calendar picker
            var skin = '';

            skin = _handleSkinEvent.getHoverSkinForCalendar(model);// skin to be reset
            _handleSkinEvent.resetSkinForCalendar(model, (skin +'-hover'), 'hover');

            skin = _handleSkinEvent.getHoverSkinForCalendar(model);// skin to be set
            _handleSkinEvent.setSkinForCalendar(model, (skin+'-hover'), 'hover');
        },

        dealWithFocusSkin: function(evt) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, model = null, prioritisedSkin = '';
            _handleSkinEvent.target = evt.target;

            model = $KD.closest(evt.target, function(node) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if($KD.hasAttr(node, 'kw') || $KD.hasAttr(node, 'kwf')) {
                    return true;
                }
            });

            if(model) {
                if($KD.hasAttr(model, 'kw')) {
                    model = $KW.model(model);
                } else if($KD.hasAttr(model, 'kwf')) {
                    model = $KW.model($KD.getAttr(model, 'kwf'));
                }

                if(['mousedown', 'touchstart'].indexOf(evt.type) >= 0) {
                    _handleSkinEvent.focusModel = model;
                    _handleSkinEvent.focusNode = evt.target;

                    _handleSkinEvent.resetSkinRecursively(model, 'active');

                    prioritisedSkin = _handleSkinEvent.getPrioritisedSkinType(model);
                    if(prioritisedSkin === 'focusSkin') {
                        _handleSkinEvent.setSkinRecursively(model, 'focus');
                        _handleSkinEvent.resetSkinRecursively(model, 'hover');
                    } else if(prioritisedSkin === 'activeStateSkin') {
                        _handleSkinEvent.setSkinRecursively(model, 'active'); //to set activeStateSkin on rows of cbg/rbg
                    }
                } else if(['touchend', 'touchcancel', 'mouseup', 'mouseout'].indexOf(evt.type) >= 0) {
                    _handleSkinEvent.focusModel = null;
                    _handleSkinEvent.focusNode = null;

                    _handleSkinEvent.resetSkinRecursively(model, 'focus');

                    prioritisedSkin = _handleSkinEvent.getPrioritisedSkinType(model);
                    if(prioritisedSkin === 'hoverSkin') {
                        _handleSkinEvent.resetSkinRecursively(model, 'active');
                        _handleSkinEvent.setSkinRecursively(model, 'hover');
                    } else if(prioritisedSkin === 'activeStateSkin') {
                        _handleSkinEvent.resetSkinRecursively(model, 'hover');
                        _handleSkinEvent.resetSkinRecursively(model, 'active');
                        _handleSkinEvent.setSkinRecursively(model, 'active');
                    }
                }
            }
        },


        dealWithGroupWidgetHoverSkin: function(model) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                $KD = $K.dom, option = null, hSkin = '', aSkin = '',
                isListBoxWidget = $KU.is(model, 'widget', 'ListBox'),
                commonNode = model._kwebfw_.fSkinNode || model._kwebfw_.hSkinNode;

            if((isListBoxWidget && model.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW)
            || ['CheckBoxGroup', 'RadioButtonGroup'].indexOf($KW.name(model)) >= 0) {
                if(isListBoxWidget && model.itemHoverSkin !== '') {
                    hSkin = model.itemHoverSkin+'-hover';
                } else if(model.hoverSkin !== '') {
                    hSkin = model.hoverSkin+'-hover';
                }

                if(model.activeStateSkin !== '') {
                    aSkin = model.activeStateSkin+'-active';
                }

                option = $KD.closest(_handleSkinEvent.target, function(node) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    if($KD.getAttr(node, 'kr') === 'option') {
                        return true;
                    } else if($KD.hasAttr(node, 'kw') || $KD.hasAttr(node, 'kwf')) {
                        if(model._kwebfw_.hSkinNode && $KD.hasAttr(node, 'kw')) {
                            _handleSkinEvent.resetSkin(model, hSkin, 'hover');
                        }

                        if((_handleSkinEvent.activeModel === model) && aSkin) {
                            _handleSkinEvent.setSkin(model, aSkin, 'active');
                        }

                        return false;
                    }
                });


                if(hSkin && option && model._kwebfw_.hSkinNode !== option) {
                    _handleSkinEvent.resetSkin(model, hSkin, 'hover');

                    commonNode = model._kwebfw_.fSkinNode || model._kwebfw_.hSkinNode;

                    if((_handleSkinEvent.activeModel === model)
                    && (_handleSkinEvent.activeTargetNode !== commonNode)) {
                        _handleSkinEvent.setSkin(model, aSkin, 'active');
                    }
                }

                if(hSkin && (isListBoxWidget || (option && commonNode !== option))) {
                    _handleSkinEvent.setSkin(model, hSkin, 'hover');

                    if((_handleSkinEvent.activeTargetNode === model._kwebfw_.hSkinNode) || isListBoxWidget) {
                        _handleSkinEvent.resetSkin(model, aSkin, 'active');
                    }
                }
            }
        },

        dealWithHoverSkin: function(evt) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                model = null, relatedModel = null, commonModel = null, target = null,
                prioritisedSkin = '';

            _handleSkinEvent.target = evt.target;
            _handleSkinEvent.hoverNode = evt.target;

            model = $KD.closest(evt.target, function(node) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if($KD.hasAttr(node, 'kw') || $KD.hasAttr(node, 'kwf')) {
                    return true;
                }
            });

            if(model) {
                target = model;

                if($KD.hasAttr(model, 'kw')) {
                    model = $KW.model(model);
                } else if($KD.hasAttr(model, 'kwf')) {
                    model = $KW.model($KD.getAttr(model, 'kwf'));
                }

                _handleSkinEvent.hoverModel = model;
                relatedModel = _handleSkinEvent.mouseOverModel;

                if(model !== relatedModel) {
                    commonModel = _handleSkinEvent.getLCA(model, relatedModel);
                    _handleSkinEvent.executeHoverEvent(
                        model, constants.ONHOVER_MOUSE_ENTER, evt, commonModel
                    );

                    if(relatedModel) {
                        _handleSkinEvent.executeHoverEvent(
                            relatedModel, constants.ONHOVER_MOUSE_LEAVE, evt, commonModel
                        );
                    }

                    _handleSkinEvent.executeHoverEvent(
                        commonModel, constants.ONHOVER_MOUSE_MOVE, evt
                    );
                } else {
                    _handleSkinEvent.executeHoverEvent(
                        model, constants.ONHOVER_MOUSE_MOVE, evt
                    );
                }

                if(relatedModel === model) {
                    if(model instanceof voltmx.ui.GroupWidget) {
                        _handleSkinEvent.dealWithGroupWidgetHoverSkin(model);
                    } else if($KU.is(model, 'widget', 'Calendar') && model._kwebfw_.picker === target) {
                        _handleSkinEvent.dealWithCalendarHoverSkin(model);
                    } else if($KU.is(model, 'widget', 'DataGrid')) {
                        _handleSkinEvent.resetSkinRecursively(model, 'hover');
                        _handleSkinEvent.setSkinRecursively(model, 'hover');
                    }
                } else {
                    if(relatedModel) {
                        if($KU.is(relatedModel, 'widget', 'Calendar') && relatedModel._kwebfw_.hSkinNode) {
                            _handleSkinEvent.dealWithCalendarHoverSkin(relatedModel);//handle for picker
                        } else {
                            if(_handleSkinEvent.activeModel === relatedModel) {
                                _handleSkinEvent.setSkinRecursively(relatedModel, 'active');
                            }

                            _handleSkinEvent.resetSkinRecursively(
                                relatedModel, 'hover', commonModel
                            );
                        }
                    }

                    if(($KU.is(model, 'widget', 'Calendar') && model._kwebfw_.picker === target)) {
                        _handleSkinEvent.dealWithCalendarHoverSkin(model);//handle for picker
                    } else {
                        prioritisedSkin = _handleSkinEvent.getPrioritisedSkinType(model);
                        if(prioritisedSkin === 'hoverSkin') {
                            _handleSkinEvent.setSkinRecursively(model, 'hover', commonModel);
                            _handleSkinEvent.resetSkinRecursively(model, 'active');
                        }
                    }
                }

                _handleSkinEvent.mouseOverModel = model;
            }
        },

        dealWithSkinStateConfig: function(model, el, type, action) {
            var _ = model._kwebfw_,
                props = {
                    hover: 'hoverStateSkinProperties',
                    focus: 'focusStateSkinProperties'
                };

            if(model[props[type]]) {
                if(action === 'set') {
                    _.skinStateObj[type] = el.style.cssText;
                    _handleSkinEvent.setSkinConfig(el, model[props[type]], _.skinStateObj[type], model);
                } else if(action === 'reset') {
                    el.style.cssText = _.skinStateObj[type];
                    _.skinStateObj[type] = {};
                }
            }
        },

        executeHoverEvent: function(model, type, evt, commonModel) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget;

            if(model && model._kwebfw_.view) {
                $KW.closest(model, function(widget) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, payload, touch;

                    if(!$KW.interactable(widget)) {
                        return false;
                    } else if(commonModel && commonModel === widget) {
                        return false;
                    }
                    if(!payload) payload = {};

                    payload.eventType = type;
                    payload.pageX = evt.pageX || evt.clientX;
                    payload.pageY = evt.pageY || evt.clientY;
                    touch = $KD.point(model._kwebfw_.view);
                    payload.pageX = (payload.pageX - touch.x);
                    payload.pageY = (payload.pageY - touch.y);

                    payload.screenX = evt.clientX || null;
                    payload.screenY = evt.clientY || null;

                    $KW.fire(widget, 'onHover', widget, payload);
                }, {owner:true, tabs:true});
            }
        },

        getHoverSkinForCalendar: function(model) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                _ = model._kwebfw_, prop = _.prop, el = '', kr = '',
                viewConfig = prop.viewConfig ? prop.viewConfig.gridConfig : null, skin = '',
                cellHoverSkin = viewConfig ? viewConfig.gridCellHoverSkin : null,
                monthYearHoverSkin = viewConfig ? viewConfig.gridMonthYearHoverSkin : null;

            if(model._kwebfw_.hSkinNode) {
                el = model._kwebfw_.hSkinNode;
            } else {
                el = $KD.parent(_handleSkinEvent.target);
            }

            kr = $KD.getAttr(el, 'kr');

            if(kr === 'date' && $KD.getAttr(el, 'cellskintype') !== 'gridCellInactiveDaysSkin') {
                if($KU.is(cellHoverSkin, 'string')) {
                    skin = cellHoverSkin;
                } else {
                    skin = '-voltmx-calendar-cell';
                }
            } else if(kr === 'month' || kr === 'year') {
                if($KU.is(monthYearHoverSkin, 'string')) {
                    skin = monthYearHoverSkin;
                } else {
                    skin = '-voltmx-calendar-cell';
                }
            } else if($KD.getAttr(el, 'kw') === 'Calendar') {
                skin = prop.hoverSkin;
            }

            return skin;
        },

        getLCA: function(toModel, fromModel) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app, i = 0,
                toPath = [], fromPath = [], LCA = $KW.model($KA.currentFormUID);

            $KW.closest(fromModel, function(widget) {
                fromPath.splice(0, 0, widget);
            }, {owner:true, tabs:true});

            $KW.closest(toModel, function(widget) {
                toPath.splice(0, 0, widget);
            }, {owner:true, tabs:true});

            for(i = 0; i < fromPath.length && i < toPath.length; i++) {
                if(fromPath[i] !== toPath[i]) {
                    break;
                }
                LCA = fromPath[i];
            }

            return LCA;
        },

        getPrioritisedSkinType: function(model) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, skinType = '',
                aSkin = model.activeStateSkin, fSkin = model.focusSkin, hSkin = model.hoverSkin,
                aModel = _handleSkinEvent.activeModel, fModel = _handleSkinEvent.focusModel,
                hModel = _handleSkinEvent.hoverModel, currModel = model, pModel = null,
                aNode = null, fNode = null, hNode = null, currNode = null, nodes = null;
			
			if (model) {
				const kwebfw = model._kwebfw_;			
				if (kwebfw.oid && kwebfw.ii && kwebfw.is && kwebfw.is.cloned) {
					pModel = $KW.model(kwebfw.oid);
				} else if (kwebfw.rid && kwebfw.tpid) {
					pModel = $KW.model(kwebfw.tpid).parent;
				} else {
					pModel = model.parent;
				}
			}

			if(pModel && fSkin === '' ) {
				fSkin = $KU.is(pModel, 'widget', 'SegmentedUI2') ? pModel.rowFocusSkin :
								$KU.is(pModel, 'widget', 'FlexContainer') ? pModel.focusSkin : 
								'';
			}		
			
            if(['CheckBoxGroup', 'RadioButtonGroup'].indexOf($KW.name(model)) >= 0) {
                nodes = _handleSkinEvent.getTargetNodes(model);
                fNode = nodes.fNode;
                hNode = nodes.hNode;
                aNode = nodes.aNode;
                currNode = _handleSkinEvent.activeTargetNode = aNode;

                if(fSkin && fNode && (currNode === fNode)) {
                    skinType = 'focusSkin';
                } else if(hSkin && hNode && (currNode === hNode)) {
                    skinType = 'hoverSkin';
                } else if(aSkin && aNode && (currNode === aNode)) {
                    skinType = 'activeStateSkin';
                }
            } else {
                if(fSkin && fModel && (currModel === fModel)) {
                    skinType = 'focusSkin';
                } else if(hSkin && hModel && (currModel === hModel)) {
                    skinType = 'hoverSkin';
                } else if(aSkin && aModel && (currModel === aModel)) {
                    skinType = 'activeStateSkin';
                }
            }

            return skinType;
        },

        getSkinValueByType: function(model, closestModel, type) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, skin = '';

            if(type === 'active') {
                skin = closestModel.activeStateSkin;
            } else {
                skin = closestModel[(type + 'Skin')];
            }

            if($KU.is(closestModel, 'widget', 'SegmentedUI2')) {
                if(type === 'focus') {
                    skin = closestModel.rowFocusSkin;
                }
            } else if($KU.is(model, 'widget', 'ListBox')) {
                if(closestModel.itemHoverSkin !== ''
                    && model.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                    skin = closestModel.itemHoverSkin;
                }
            } else if($KU.is(closestModel, 'widget', 'TabPane')) {
                skin = closestModel.activeFocusSkin;
            }

            return skin;
        },

        getTargetNodes: function(model) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                fNode = _handleSkinEvent.focusNode, hNode = _handleSkinEvent.hoverNode,
                aNode = _handleSkinEvent.activeTargetNode,
                nodes = {
                    fNode: fNode,
                    hNode: hNode,
                    aNode: aNode
                };

            if(['CheckBoxGroup', 'RadioButtonGroup'].indexOf($KW.name(model)) >= 0) {
                aNode = fNode ? fNode : aNode;
                fNode = fNode && $KD.hasAttr(fNode, 'kw') ? null : fNode;
                hNode = hNode && $KD.hasAttr(hNode, 'kw') ? null : hNode;

                if(aNode && !$KD.hasAttr(aNode, 'kw')
                && ($KD.getAttr(aNode, 'kr') !== 'option')) {
                    aNode = $KD.parent(aNode);
                    fNode = model._kwebfw_.fSkinNode ? model._kwebfw_.fSkinNode : null;
                    hNode = model._kwebfw_.hSkinNode ? model._kwebfw_.hSkinNode : null;
                }

                nodes.fNode = fNode;
                nodes.hNode = hNode;
                nodes.aNode = aNode;
            }

            return nodes;
        },

        isUpperBoundModel: function(widget, upperBoundModel) {
            var flag = false;

            if(upperBoundModel && upperBoundModel._kwebfw_.uid === widget._kwebfw_.uid) {
                flag = true;
            }

            return flag;
        },

        resetSkin: function(model, skin, type) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KD = $K.dom, el = model._kwebfw_.view;

            if(el) {
                if($KU.is(model, 'widget', 'SegmentedUI2')) {
                    if(type === 'focus') {
                        el = $KD.closest(_handleSkinEvent.target, 'kr', 'item');
                    } else if(type === 'active') {
                        el = _handleSkinEvent.activeTargetNode;
                    }
                } else if($KU.is(model, 'widget', 'RadioButtonGroup')
                || $KU.is(model, 'widget', 'CheckBoxGroup')
                || ($KU.is(model, 'widget', 'ListBox')
                && model.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW)) {
                    if($KU.is(model, 'widget', 'ListBox')) {
                        if(type === 'hover' && model.hoverSkin) {
                            $KD.removeCls(el, model.hoverSkin + '-hover');
                        } else if(type === 'focus' && model.focusSkin) {
                            $KD.removeCls(el, model.focusSkin + '-focus');
                        } else if(type === 'active' && model.activeStateSkin) {
                            $KD.removeCls(el, model.activeStateSkin + '-active');
                        }
                    }

                    if(type === 'hover' && model._kwebfw_.hSkinNode) {
                        el = model._kwebfw_.hSkinNode;
                        model._kwebfw_.hSkinNode = null;
                    } else if(type === 'focus' && model._kwebfw_.fSkinNode) {
                        el = model._kwebfw_.fSkinNode;
                        model._kwebfw_.fSkinNode = null;
                    } else if((type === 'active') && model._kwebfw_.aSkinNode) {
                        el = model._kwebfw_.aSkinNode;
                        model._kwebfw_.aSkinNode = null;
                    } else {
                        return;
                    }
                } else if($KU.is(model, 'widget', 'TabPane')) {
                    if(type === 'focus') {
                        el = _handleSkinEvent.target;
                        if(($KD.hasAttr(el, 'kw')) || ($KD.hasAttr(el, 'kr'))) {
                            return;
                        }
                        //To handle the div inside li in case of tab pane (li -> div -> label(tab name))
                        //get the closest el that contains tabid
                        el = $KD.closest(el, 'tabid');
                    } else {
                        return;
                    }
                } else if($KU.is(model, 'widget', 'DataGrid')) {
                    if(type === 'hover' && model._kwebfw_.hSkinNode) {
                        el = $KD.closest(_handleSkinEvent.target, 'kr', 'row');
                        if(el !== model._kwebfw_.hSkinNode) {
                            el = model._kwebfw_.hSkinNode;
                        } else {
                            return;
                        }
                    } else if(type === 'active') {
                        el = _handleSkinEvent.activeTargetNode;
                    }
                } else if(['Image2', 'Video', 'Slider', 'Switch'].indexOf($KW.name(model)) >= 0) {
                    if(type === 'active') {
                        el = _handleSkinEvent.activeTargetNode;
                    }
                }

                _handleSkinEvent.dealWithSkinStateConfig(model, el, type, 'reset');
                el && $KD.removeCls(el, skin);
            }
        },

        resetSkinRecursively: function(model, type, upperBoundModel) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget;

            $KW.closest(model, function(closestModel) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, skin = '';

                if(!_handleSkinEvent.shouldPropagateSkin(closestModel, type)
                || _handleSkinEvent.isUpperBoundModel(closestModel, upperBoundModel)) {
                    return false;
                }
                skin = _handleSkinEvent.getSkinValueByType(model, closestModel, type);
                if(($KU.is(skin, 'string') && skin) || closestModel[type+'StateSkinProperties']) {
                    _handleSkinEvent.resetSkin(closestModel, (skin+'-'+type), type);
                }
            }, {owner:true, tabs:true});
        },

        setSkin: function(model, skin, type) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KD = $K.dom, el = model._kwebfw_.view, disabled = false,
                disabledkeys= model._kwebfw_.prop.disabledKeys;

            if(el) {
                if($KU.is(model, 'widget', 'SegmentedUI2')) {
                    if(type === 'focus') {
                        el = $KD.closest(_handleSkinEvent.target, 'kr', 'item');
                    } else if(type === 'active') {
                        el = _handleSkinEvent.activeTargetNode;
                    }
                } else if($KU.is(model, 'widget', 'RadioButtonGroup')
                || $KU.is(model, 'widget', 'CheckBoxGroup')
                || ($KU.is(model, 'widget', 'ListBox')
                && model.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW)) {
                    if($KU.is(model, 'widget', 'ListBox')) {
                        if(type === 'hover' && model.hoverSkin) {
                            $KD.addCls(el, model.hoverSkin + '-hover');
                        } else if(type === 'focus' && model.focusSkin) {
                            $KD.addCls(el, model.focusSkin + '-focus');
                            return;
                        } else if(type === 'active' && model.activeStateSkin) {
                            $KD.addCls(el, model.activeStateSkin + '-active');
                            return;
                        }
                    }

                    if(type === 'active') {
                        el = _handleSkinEvent.activeTargetNode;
                    } else {
                        el = _handleSkinEvent.target;
                    }

                    if($KU.is(model, 'widget', 'ListBox') && type === 'hover'
                    && $KD.getAttr(el, 'kr') === 'option') {// prevent hover on disabled option
                        if(disabledkeys && disabledkeys.indexOf(el.getAttribute('value')) !== -1) {
                            disabled = true;
                        }
                    }
                    if(type !== 'active') {
                        if($KD.hasAttr(el, 'kw') || $KD.hasAttr(el, 'kwf') || disabled) {
                            return;
                        }
                    }

                    while(!$KD.getAttr(el, 'kr') === 'option') {
                        el = $KD.parent(el);
                    }

                    if(type === 'hover') {
                        model._kwebfw_.hSkinNode = el;
                    } else if(type === 'focus') {
                        model._kwebfw_.fSkinNode = el;
                    } else {
                        model._kwebfw_.aSkinNode = el;
                    }
                } else if($KU.is(model, 'widget', 'TabPane')) {
                    if(type === 'focus') {
                        el = _handleSkinEvent.target;

                        if(($KD.hasAttr(el, 'kw')) || ($KD.hasAttr(el, 'kr'))) {
                            return;
                        }

                        el = $KD.closest(el, 'tabid');
                        $KD.removeCls(el, model.inactiveSkin);
                    } else {
                        return;
                    }
                } else if($KU.is(model, 'widget', 'Calendar')) {
                    if(type === 'focus') {
                        if(model._kwebfw_.picker && $KD.contains(model._kwebfw_.picker, _handleSkinEvent.target)) {
                            return;
                        }
                    }
                } else if($KU.is(model, 'widget', 'DataGrid')) {
                    if(type === 'hover') {
                        el = $KD.closest(_handleSkinEvent.target, 'kr', 'row');

                        if(el) {
                            model._kwebfw_.hSkinNode = el;
                        } else {
                            return;
                        }
                    } else if(type === 'active') {
                        el = _handleSkinEvent.activeTargetNode;
                    }
                } else if(['Image2', 'Video', 'Slider', 'Switch'].indexOf($KW.name(model)) >= 0) {
                    if(type === 'active') {
                        el = _handleSkinEvent.activeTargetNode;
                    }
                }

                _handleSkinEvent.dealWithSkinStateConfig(model, el, type, 'set');
                el && $KD.addCls(el, skin);
            }
        },

        setSkinConfig: function(el, skinObj, stateObj, model) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KW = $K.widget, _handlers = $KW.skinHandlers();

            $KU.each(skinObj, function(value, keey) {
                _handlers[keey] && _handlers[keey]({el: el, config: value, model: model});
            });
        },

        setSkinForCalendar: function(model, skin, type) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom,
                el = '', kr = '', prop = model._kwebfw_.prop,
                viewConfig = prop.viewConfig ? prop.viewConfig.gridConfig : null,
                selectedSkin = '-voltmx-calendar-cell-selected';

            if(type === 'hover') {
                el = $KD.parent(_handleSkinEvent.target);
                kr = $KD.getAttr(el, 'kr');
                if(kr === 'month' || kr === 'year' || kr === 'date') {
                    model._kwebfw_.hSkinNode = el;
                    if($KD.getAttr(el, 'aria-selected')) {
                        if(viewConfig) {
                            if((kr === 'month' || kr === 'year') && viewConfig.gridMonthYearSelectedSkin) {
                                selectedSkin = viewConfig.gridMonthYearSelectedSkin;
                            } else if(kr === 'date' && viewConfig.gridCellSelectedSkin) {
                                selectedSkin = viewConfig.gridCellSelectedSkin;
                            }
                        }
                        $KD.removeCls(el, selectedSkin);
                    }
                } else {
                    return;
                }
                el && $KD.addCls(el, skin);
            }
        },

        resetSkinForCalendar: function(model, skin, type) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom,
                el = '', kr = '', prop = model._kwebfw_.prop,
                viewConfig = prop.viewConfig ? prop.viewConfig.gridConfig : null,
                selectedSkin = '-voltmx-calendar-cell-selected';

            if(type === 'hover' && model._kwebfw_.hSkinNode) {
                el = model._kwebfw_.hSkinNode;
                kr = $KD.getAttr(el, 'kr');
                model._kwebfw_.hSkinNode = null;
                if($KD.getAttr(el, 'aria-selected')) {
                    if(viewConfig) {
                        if(viewConfig.gridMonthYearSelectedSkin && (kr === 'month' || kr === 'year')) {
                            selectedSkin = viewConfig.gridMonthYearSelectedSkin;
                        } else if(kr === 'date' && viewConfig.gridCellSelectedSkin) {
                            selectedSkin = viewConfig.gridCellSelectedSkin;
                        }
                    }
                    /*[MADPSPA-2860] In Calendar 2 months and 2 Years is getting focused at a time.
                    Previously applied classes removed and added selected skin.Please refer git commit description for detailed flow.*/
                    $KD.setAttr(el, 'class', selectedSkin);
                } else {
                    el && $KD.removeCls(el, skin);
                }
            }
        },

        setSkinRecursively: function(model, type, upperBoundModel) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget;

            $KW.closest(model, function(closestModel) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, skin = '';

                if(!_handleSkinEvent.shouldPropagateSkin(closestModel, type)
                || _handleSkinEvent.isUpperBoundModel(closestModel, upperBoundModel)) {
                    return false;
                }
                skin = _handleSkinEvent.getSkinValueByType(model, closestModel, type);

                if(($KU.is(skin, 'string') && skin)
                    || closestModel[type+'StateSkinProperties']) {
                    _handleSkinEvent.setSkin(closestModel, (skin+'-'+type), type);
                }
            }, {owner:true, tabs:true});
        },

        //type can be focus|hover|active
        shouldPropagateSkin: function(model/*, type*/) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = true;

            if(!$KW.interactable(model)) {
                flag = false;
            }

            return flag;
        }
    };


    var _handleSystemEvent = {
        blur: function $KE_handleSystemEvent_blur(/*evt*/) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app,
                cf = $KW.model($KA.currentFormUID);

            $K.apm.send(cf, 'AppTransition', {status: 'Background'});
            $K.apm.send(cf, 'FormExit');
        },

        error: function $KE_handleSystemEvent_error(evt) {
            var $K = voltmx.$kwebfw$, errInfo = {};

            if(evt.errorcode) {
                errInfo.exceptioncode = evt.errorcode;

                if(evt.name) errInfo.exceptionmsg = evt.name;
                if(evt.stack) errInfo.exceptionstacktrace = evt.stack;
                if(evt.fileName) errInfo.exceptionfile = evt.fileName;
                if(evt.lineNumber) errInfo.exceptionline = evt.lineNumber;
                if(evt.message) errInfo.exceptioncustommsg = evt.message;

                $K.apm.send(errInfo.exceptioncode, 'Exception', errInfo);
            } else {
                errInfo.errcode = '';

                if(evt.name) errInfo.errmsg = evt.name;
                if(evt.stack) errInfo.errstacktrace = evt.stack;
                if(evt.fileName) errInfo.errfile = evt.fileName;
                if(evt.lineNumber) errInfo.errline = evt.lineNumber;
                if(evt.message) errInfo.errcustommsg = evt.message;

                $K.apm.send(errInfo.errcode, 'Error', errInfo);
            }
        },

        focus: function $KE_handleSystemEvent_focus(/*evt*/) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app,
                cf = $KW.model($KA.currentFormUID);

            $K.apm.send(cf, 'AppTransition', {status: 'Foreground'});
            $K.apm.send(cf, 'FormEntry');
        },

        hashchange: function $KE_handleSystemEvent_hashchange(/*evt*/) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app,
                hash = location.hash, isFormAlreadyNavigated = null,
                cf = $KW.model($KA.currentFormUID), cfhash = null,
                _getHashString = function(fmodel) {
                    var _hash;
                    if($K.behavior.isCompositeApp) {
                        _hash = '#/'+fmodel.appName+'/'+fmodel.id;
                    } else {
                        _hash = '#_' + fmodel.id;
                    }
                    return _hash;
                },
                _splitHashString = function(hashStr) {
                    return hashStr.split('/');
                },
                formid = null, appName = null;

            $KA.lastInteractionAt = new Date();
            $KW.registerForIdleTimeout();

            cfhash = _getHashString(cf);

            if(hash !== cfhash) {
                hash = hash.substr(2, hash.length);
                isFormAlreadyNavigated = $KW.rootOfForm(hash);

                if(!isFormAlreadyNavigated) {
                    location.hash = cfhash;
                } else {
                    if($KA.blocked || $KW.fire(cf, 'onDeviceBack', cf)) {
                        location.hash = cfhash;
                    } else {
                        hash = _splitHashString(hash);

                        if(window[hash[0]]) {
                            window[hash[0]].show();
                        } else {
                            formid = isFormAlreadyNavigated.id;
                            appName = isFormAlreadyNavigated.appName;
                            _voltmx.mvc.navigate(formid, appName);
                        }
                    }
                }
            }
        },

        orientationchange: function $KE_handleSystemEvent_orientationchange(evt) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KA = $K.app,
                cf = $KW.model($KA.currentFormUID), orientation = '', from = '';

            $KA.lastInteractionAt = new Date();
            $KW.registerForIdleTimeout();

            $K.ui.Form2.onOrientation.call(cf, evt);

            orientation = $KU.browser('orientation');

            if(orientation === 'portrait') {
                from = 'LANDSCAPE_TO_PORTRAIT';
            } else if(orientation === 'landscape') {
                from = 'PORTRAIT_TO_LANDSCAPE';
            }

            $K.apm.send(cf, 'Orientation', {from:from});
        },

        resize: function $KE_handleSystemEvent_resize(evt) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app,
                cf = $KW.model($KA.currentFormUID);

            $KA.lastInteractionAt = new Date();
            $KW.registerForIdleTimeout();
            $K.ui.Form2.onResize.call(cf, evt);
        }
    };


    var _registerEvents = function $KE_registerEvents(ele) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;

        if(!ele) {
            ele = $KD.body();
        }

        _registerSystemEvents();
        _registerNormalEvents(ele);
        _registerTouchEvents(ele);
        _registerSkinEvents(ele);
    };


    var _registerFocusSkinEvent = function $KE_registerFocusSkinEvent(body) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, touchStartFired = false;

        $KD.on(body, ['mousedown', 'touchstart'], 'fskin', function(evt) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                $KA = $K.app, model = null, endEvent = '';

            if(evt.type === 'touchstart') touchStartFired = true;

            if(touchStartFired && evt.type === 'mousedown') {
                touchStartFired = false;
            } else {
                if(evt.type === 'touchstart') {
                    endEvent = ['touchend', 'touchcancel'];
                } else {
                    endEvent = ['mouseup', 'mouseout'];
                }

                //console.error(evt.type+' :: '+touchStartFired); //Don't delete this line
                model = $KW.getModelByNode(evt.target);
                $KA.lastInteractionAt = new Date();
                $KW.registerForIdleTimeout();

                if(model) { //Here evt.type === 'mousedown/touchstart'
                    $KD.on(body, endEvent, 'fskin', function(evt) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, model = null;

                        //console.error(evt.type+' :: '+touchStartFired); //Don't delete this line
                        $KD.off(body, endEvent, 'fskin');
                        model = $KW.getModelByNode(evt.target);

                        if(model) { //Here evt.type === 'mouseup/mouseout/touchend/touchcancel'
                            if(!$KW.interactable(model)) {
                                $KD.preventDefault(evt);
                            } else {
                                _handleSkinEvent.dealWithFocusSkin(evt);
                            }
                        }
                    }, {passive:false});

                    if(!$KW.interactable(model)) {
                        $KD.preventDefault(evt);
                    } else {
                        _handleSkinEvent.dealWithFocusSkin(evt);
                    }
                }
            }
        }, {passive:false});
    };


    var _registerHoverSkinEvent = function $KE_registerHoverSkinEvent(body) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;
        $KD.on(
            body, 'mousemove', 'hskin',
            $KU.debounce(_handleSkinEvent.dealWithHoverSkin, 17),
            {passive:false}
        );
    };


    var _registerNormalEvents = function $KE_registerNormalEvents(body) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, events = [
            'click',
            'dblclick',
            'focusin', //This will map to "focus"
            'focusout', //This will map to "blur"
            'input', //Needed for character restriction, without any flickering
            'keyup',
            'keydown',
            'change'
        ];

        $KD.on(body, events, 'wnevent', function(evt) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app, propagate = true,
                model = $KW.getModelByNode(evt.target), internalHandlers = '',
                $KAR = $K.automation.recorder, code = evt.keyCode || evt.which,
                widgets = ['Button', 'RichText', 'FlexContainer', 'FlexScrollContainer'];

            $KA.lastInteractionAt = new Date();
            $KW.registerForIdleTimeout();
            $KAR && $KAR.normalEventRecording(evt);

            if(model) {
                _handleOwnerItemEvents(evt, model, code);

                if(!$KW.interactable(model)) {
                    $KD.preventDefault(evt);
                } else {
                    if((evt.type === 'focusin') || (evt.type === 'focusout')) {
                        _handleSkinEvent.dealWithActiveStateSkin(evt);
                    } else if([13, 32].indexOf(code) >= 0 //Enter or Space
                    && ['keydown', 'keyup'].indexOf(evt.type) >= 0
                    && widgets.indexOf($KW.name(model)) >= 0) {
                        _handleKeyBoardClick(evt, model);
                    }

                    internalHandlers = _getInternalHandlers(evt);

                    if(internalHandlers) {
                        propagate = _widgetInternalEventCallback(internalHandlers, evt, model);
                    }

                    propagate && _widgetEventCallback(evt, model);
                }
            }
        }, {passive:false});
    };


    var _registerSkinEvents = function $KE_registerSkinEvents(body) {
        _registerFocusSkinEvent(body);
        _registerHoverSkinEvent(body);
    };


    var _registerSystemEvents = function $KE_registerSystemEvents() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils, events = [
                'blur',
                'error',
                'focus',
                'hashchange',
                'orientationchange',
                'resize'
            ], eventsExcluded = ['resize'], i;

        if($KU.loadedFromOtherFramework()) {
            for(i = 0; i < eventsExcluded.length; i++) {
                if(events.indexOf(eventsExcluded[i]) !== -1) {
                    events.splice(events.indexOf(events.indexOf(eventsExcluded[i])), 1);
                }
            }
        }

        $KD.on(window, events, 'sysevent', function(evt) {
            _handleSystemEvent[evt.type](evt);
        });
    };


    var _registerTouchEvents = function $KE_registerTouchEvents(body) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, propagate = true,
            touchStartFired = false, internalHandlers = '';

        $KD.on(body, ['mousedown', 'touchstart'], 'wtevent', function(evt) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                $KA = $K.app, $KAR = $K.automation.recorder,
                model = null, moveEvent = '', endEvent = '';

            if(evt.type === 'touchstart') touchStartFired = true;

            if(touchStartFired && evt.type === 'mousedown') {
                touchStartFired = false;
            } else {
                if(evt.type === 'touchstart') {
                    moveEvent = 'touchmove';

                    endEvent = 'touchend touchcancel';
                } else {
                    moveEvent = 'mousemove';
                    endEvent = 'mouseup mouseout';
                }

                //console.error(evt.type+' :: '+touchStartFired); //Don't delete this line
                model = $KW.getModelByNode(evt.target);
                $KA.lastInteractionAt = new Date();
                $KW.registerForIdleTimeout();
                $KAR && $KAR.touchEventRecording(evt);

                if(model) { //Here evt.type === 'mousedown/touchstart'
                    $KD.on(body, moveEvent, 'wtevent', function(evt) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget,
                            $KD = $K.dom, $KAR = $K.automation.recorder,
                            model = $KW.getModelByNode(evt.target);

                        $KAR && $KAR.touchEventRecording(evt);

                        if(model) { //Here evt.type === 'mousemove/touchmove'
                            if(!$KW.interactable(model)) {
                                $KD.preventDefault(evt);
                            } else {
                                internalHandlers = _getInternalHandlers(evt);

                                if(internalHandlers) {
                                    propagate = _widgetInternalEventCallback(internalHandlers, evt, model);
                                }

                                propagate && _widgetEventCallback(evt, model);
                            }
                        }
                    }, {passive:false});

                    $KD.on(body, endEvent, 'wtevent', function(evt) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                            $KAR = $K.automation.recorder, model = null;

                        //console.error(evt.type+' :: '+touchStartFired); //Don't delete this line
                        propagate = true; //Reinitialize
                        $KD.off(body, moveEvent, 'wtevent');
                        $KD.off(body, endEvent, 'wtevent');
                        model = $KW.getModelByNode(evt.target);
                        $KAR && $KAR.touchEventRecording(evt);

                        if(model) { //Here evt.type === 'mouseup/mouseout/touchend/touchcancel'
                            if(!$KW.interactable(model)) {
                                $KD.preventDefault(evt);
                            } else {
                                internalHandlers = _getInternalHandlers(evt);

                                if(internalHandlers) {
                                    propagate = _widgetInternalEventCallback(internalHandlers, evt, model);
                                }

                                propagate && _widgetEventCallback(evt, model);
                            }
                        }
                    }, {passive:false});

                    if(!$KW.interactable(model)) {
                        $KD.preventDefault(evt);
                    } else {
                        internalHandlers = _getInternalHandlers(evt);

                        if(internalHandlers) {
                            propagate = _widgetInternalEventCallback(internalHandlers, evt, model);
                        }

                        propagate && _widgetEventCallback(evt, model);
                    }
                }
            }
        }, {passive:false});
    };


    //All the functions will be called in the scope of owner widget instance
    var _setOwnerSelectedIndex = {
        CollectionView: function $KE_setOwnerSelectedIndex_CollectionView(model) {
            //TODO
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                _ = this._kwebfw_,
                index = model._kwebfw_.ii.split(',');

            if($KW.isContainer(model)
            || $KU.is(model, 'widget', 'Image2')
            || $KU.is(model, 'widget', 'Label')) {
                index[0] = parseInt(index[0], 10);
                index[1] = parseInt(index[1], 10);

                _.setFocus = false;
                this.selectedItemIndex = [index[0], index[1]];
                delete _.setFocus;
            }
        },

        DataGrid: function $KE_setOwnerSelectedIndex_DataGrid(model) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils,
                $KW = $K.widget, index = null, target = null,
                el = $KW.el(this, 'node');

            if($KU.is(model, 'dom')) { //Here model is evt.target
                $K.ui[$KW.name(this)].performSelection.call(this, model);
            } else if($KU.is(model, 'widget')) {
                //TODO:: need to improve logic
                index = model._kwebfw_.ii.split(',');
                index[0] = parseInt(index[0], 10);
                if(index[0] > -1 && el) {
                    target = $KD.find(el, '[kii="' + model._kwebfw_.ii + '"]')[0];
                    $K.ui[$KW.name(this)].performSelection.call(this, target);
                }
            }
        },

        SegmentedUI2: function $KE_setOwnerSelectedIndex_SegmentedUI2(model) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                _ = this._kwebfw_, prop = _.prop,
                selectedIndex = prop.selectedRowIndex,
                index = model._kwebfw_.ii.split(',');

            if($KW.isContainer(model)
            || $KU.is(model, 'widget', 'Image2')
            || $KU.is(model, 'widget', 'Label')) {
                index[0] = parseInt(index[0], 10);
                index[1] = parseInt(index[1], 10);

                if(prop.viewType !== constants.SEGUI_VIEW_TYPE_TABLEVIEW
                || prop.selectionBehavior === constants.SEGUI_DEFAULT_BEHAVIOR) {
                    if(!selectedIndex
                    || index[0] !== selectedIndex[0]
                    || index[1] !== selectedIndex[1]) {
                        if($KU.is(_.swipeContext, 'null') || !_.swipeContext.ignoreRowSelection) {
                            _.setFocus = false;
                            this.selectedRowIndex = [index[0], index[1]];
                            delete _.setFocus;
                        } else {
                            _.swipeContext.ignoreRowSelection = false;
                        }
                    }
                } else if(prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
                    _.setFocus = false;
                    this.selectedRowIndex = [index[0], index[1]];
                    delete _.setFocus;
                }
            }
        }
    };


    var _shouldPropagate = function $KE_shouldPropagate(voltmxEventType, model, fired) {
        var propogationEvents = ['onTouchStart', 'onTouchMove', 'onTouchEnd'],
            propagate = true, stopPropagation = {
                onClick: function(widget) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                        passList = ['Image2', 'Label'];

                    if($KW.isContainer(widget) && !$KU.is(widget, 'widget', 'Form2')) {
                        return false;
                    } else if(passList.indexOf($KW.name(widget)) >= 0) {
                        return false;
                    }
                    return true;
                }
            };


        if(propogationEvents.indexOf(voltmxEventType) >= 0) {
            propagate = true;
        } else if(fired || (stopPropagation[voltmxEventType]
        && stopPropagation[voltmxEventType](model) === true)) {
            propagate = false;
        }

        return propagate;
    };


    var _widgetEventCallback = function $KE_widgetEventCallback(evt, model) {
        var $K = voltmx.$kwebfw$, $KU= $K.utils, $KW = $K.widget, $KD = $K.dom, payload = null,
            touch = null, voltmxEventType = _getVoltmxEventType(evt), hrefValue = null, el = null, $KAR = $K.automation.recorder;

        if($KAR && $KAR.isAssertMode()) {
            $KAR.handleEventOnWidget(evt, model);
        } else {
            if(voltmxEventType === 'onClick') {
                $K.apm.send(model, 'Touch', {type:(model._kwebfw_.name+'_Click')});
            } else if(['onTouchStart', 'onTouchEnd'].indexOf(voltmxEventType) >= 0) {
                $K.apm.send(model, 'Touch', {type:voltmxEventType});
            }

            if(voltmxEventType === 'onClick' && $KU.is(model, 'widget', 'RichText')) {
                hrefValue = evt.target.getAttribute('href');

                if(hrefValue) {
                    if($KU.is(model.onClick, 'function')) {
                        $KD.preventDefault(evt);
                        if(!payload) payload = {};
                        payload.name = evt.target.innerText;
                        payload.href = {href:hrefValue};
                    } else if(hrefValue.charAt(0) === '#') {
                        $KD.preventDefault(evt);
                        hrefValue = hrefValue.substring(1, hrefValue.length);
                        el = document.getElementById(hrefValue);
                        if(!el) el = document.querySelector('a[name="' + hrefValue + '"]');
                        el && el.scrollIntoView(); //TODO:
                    }
                }
            }

            if(['onTouchStart', 'onTouchMove', 'onTouchEnd'].indexOf(voltmxEventType) >= 0) {
                touch = (evt.touches && evt.touches[0])
                    || (evt.changedTouches && evt.changedTouches[0])
                    || evt;

                if(!payload) payload = {};
                payload.x = touch.pageX || touch.clientX;
                payload.y = touch.pageY || touch.clientY;
                touch = $KD.point(model._kwebfw_.view);
                payload.x = (payload.x - touch.x);
                payload.y = (payload.y - touch.y);
            }

            $KW.closest(model, function(widget) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, $KU = $K.utils,
                    omodel = null, item = null, propagate = true, fired = false;

                if(!$KW.interactable(widget)) {
                    return false;
                }
                fired = $KW.fire(widget, voltmxEventType, widget, payload);

                if(['focusin', 'focusout'].indexOf(evt.type) === -1
                    && !fired && !$KW.pmodel(widget)) { //e.g. To fire Segment onRowClick
                    omodel = $KW.omodel(widget);

                    if(omodel) {
                        if($KU.is(omodel, 'widget', 'CollectionView')
                               && ['click', 'keydown', 'keyup'].indexOf(evt.type) > -1) {
                            item = ['onItemSelect', 'onItemKeyDown', 'onItemKeyUp'][['click', 'keydown', 'keyup'].indexOf(evt.type)];
                            propagate = _widgetInternalEventCallback(item, evt, omodel);
                        } else {
                            item = $KD.closest(widget._kwebfw_.view, 'kr', 'item');

                            if(item && $KD.hasAttr(item, ('kwh-'+evt.type))) {
                                item = $KD.getAttr(item, ('kwh-'+evt.type));
                                propagate = _widgetInternalEventCallback(item, evt, omodel);
                            }
                        }
                    } else {
                        //Handling Tab onclick event for tab header with template
                        item = (widget._kwebfw_.view) ? $KD.parent(widget._kwebfw_.view) : null;

                        if(item && $KD.hasAttr(item, 'tabid') && $KD.hasAttr(item, ('kwh-'+evt.type))) {
                            omodel = $KW.getModelByNode(item);

                            if(omodel) {
                                item = $KD.getAttr(item, ('kwh-'+evt.type));
                                propagate = _widgetInternalEventCallback(item, evt, omodel);
                            }
                        }
                    }
                }

                if(!propagate || !_shouldPropagate(voltmxEventType, widget, fired)) {
                    return false;
                }
            }, {owner:true, tabs:false});
        }
    };


    var _widgetInternalEventCallback = function $KE_widgetInternalEventCallback(handlers, evt, model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, finalPropagation = true, $KAR = $K.automation.recorder;

        if($KAR && $KAR.isAssertMode()) {
            finalPropagation = false;
            $KAR.handleEventOnWidget(evt, model);
        } else {
            $KU.each(handlers.split(','), function(handler) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, propagate = false;

                if(!$KU.is($K.ui[$KW.name(model)], 'object')) {
                    throw new Error('<$K.ui.'+$KW.name(model)+'> is not defined as an object.');
                } else {
                    if(!$KU.is($K.ui[$KW.name(model)][handler], 'function')) {
                        throw new Error('<$K.ui.'+$KW.name(model)+'.'+handler+'> is not defined as a function.');
                    } else {
                        propagate = $K.ui[$KW.name(model)][handler].call(this, evt);

                        if(!$KU.is(propagate, 'boolean')) {
                            throw new Error('Internal event should strictly return a boolean value.');
                        } else if(!propagate) {
                            finalPropagation = false;
                        }
                    }
                }
            }, model);
        }

        return finalPropagation;
    };

    var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

    $K.defVoltmxProp($KW, [
        {
            keey: 'registerEvents', value: function KE$_$KW_registerEvents(el) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                if(!$KU.loadedFromOtherFramework()) {
                    _registerEvents();
                } else {
                    _registerEvents(el);
                }
            }
        }
    ]);

    if(!$KU.loadedFromOtherFramework()) {
        $KW.registerEvents();
    }
}());


/* FILE PATH :: 'lib/apis/voltmxui.js' */
(function() {
    var $K = voltmx.$kwebfw$, $KW = $K.widget, _map = {}, _root = {},
        _dirty = {cascade:{}, widgets:{}, templates:{}},
        _measures = {}, _mutates = [], _doLayoutWidgtsList = [];

    //window.gmap = _map; window.groot = _root;
    /* Mock Data
    _measures = {
        uid: {
            cview: dom, pview: dom,
            cheight: -1, pheight: -1,
            properties: [{position:'centerY'}]
        }
    }
    //*/


    //Here widget can be an instanceof voltmx.ui.BasicWidget or voltmx.ui.UseWidget
    //This function must be called in the scope of widget instance
    var _addRemovedWidget = function UI$_addRemovedWidget(widget) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            proxy = $KW.proxy(widget), _ = proxy._kwebfw_;

        //Instead of deleting "removed" key set it to "false"
        //Indication of, once widget was removed and then added
        _.is.removed = false;

        //Adding widgets back to _map
        $KW.iterate(proxy, function(model) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = model._kwebfw_;

            if(_.uwi instanceof voltmx.ui.UserWidget) {
                _map[_.uwi._kwebfw_.uid] = _.uwi;
            }

            if($KU.is(_.is.removed, 'null')) {
                delete _.is.removed;
            }

            _map[_.uid] = model;
        }, {scope:this, tabs:true});
    };


    //Here widget can be an instanceof voltmx.ui.BasicWidget or voltmx.ui.UseWidget
    //This function must be called in the scope of widget instance
    var _addWidget = function UI$_addWidget(widget, fmodel, rmodel, init, append, index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            proxy = $KW.proxy(widget), iterateForDefaultUnit = true,
            iterateForDisabled = true, iterateForInModalContainer = true;

        if(this._kwebfw_.inModalContainer === true) {
            iterateForInModalContainer = false;
        }

        if(this.layoutType === voltmx.flex.RESPONSIVE_GRID) {
            if(!$KU.is(widget, 'widget', 'FlexContainer')) {
                throw new $KU.error('100', 'Error',
                    'Unable to add widget, invalid widget type, widget id is ' + widget.id);
            }
        }

        if(_isWidgetIdExists(widget.id, this, rmodel)) {
            throw new Error('Duplicate widget ID <'+widget.id+'> encountered.');
        } else if($KU.is(proxy._kwebfw_.is.removed, 'null')) {
            throw new Error('Can\'t add any inner widget of a removed widget.');
        } else {
            if(proxy._kwebfw_.is.removed === true) {
                _addRemovedWidget.call(this, widget);
            }

            this[widget.id] = widget;
            widget._kwebfw_.prop.parent = this;
            widget._kwebfw_.pid = this._kwebfw_.uid;

            if(append) {
                this._kwebfw_.children.push(widget);
            } else {
                this._kwebfw_.children.splice(index, 0, widget);
            }

            if(init) {
                //NOTE:: Similar call, inside a loop, can be found in "$KW.root()" function of this file.
                _createWidgetHierarchy.call(rmodel, widget);
            }

            $KW.iterate(proxy, function(model) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    $KA = $K.app, _ = model._kwebfw_;

                if(iterateForDefaultUnit) {
                    if(_.defaultUnit) {
                        iterateForDefaultUnit = false;
                    } else {
                        _.layoutUnit = this._kwebfw_.defaultUnit;
                    }
                }

                if(iterateForDisabled) {
                    if(this._kwebfw_.disabled && !_.disabled) {
                        _.disabled = true;
                        $KW.handleTabPaneEnablement(model);
                    } else {
                        iterateForDisabled = false;
                    }
                }

                if(iterateForInModalContainer) {
                    _.inModalContainer = false;
                }

                if(fmodel && fmodel === $KW.model($KA.currentFormUID)) {
                    $KW.markRelayout(model);
                }
            }, {scope:this, tabs:false});

            _createFullHierarchy(widget);
        }
    };


    /***************************************************************************
    * Widgets are created and getting added to their parent.                   *
    *     None of the widgets are added to FORM widget yet.                    *
    *         - Expect top-level container, other nested widgets,
    *           will have their parent populated, but not root.                *
    *         - As root is null, widget hierarchy will not be created.         *
    *                                                                          *
    *                                                                          *
    *     Widgets are added directly to FORM/COMPONENT for the first time.     *
    *     ------------------------------ OR -----------------------------      *
    *     Widgets are added to a CONTAINER widget...                           *
    *     ... which is already a part of FORM/COMPONENT widget.                *
    *         - Container to which, widgets getting added has root defined.    *
    *         - Either root===parent or root has children (zero or more)       *
    *         - In either case, widget hierarchy will be created recursively.  *
    ****************************************************************************/
    //Here widgets can hold both widget, which is an instanceof voltmx.ui.BasicWidget/UseWidget
    //This function must be called in the scope of widget instance
    var _addWidgets = function UI$_addWidgets(widgets, index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KA = $K.app, rmodel = $KW.rmodel(this), modal = null,
            fmodel = $KW.fmodel(this), append = false, init = false;

        if(index >= $KW.children(this).length) append = true;

        if($KU.is(rmodel, 'widget')
        && (rmodel === this || $KU.is(rmodel._kwebfw_.children, 'array'))) {
            init = true;
        }

        if(!$KU.is(this._kwebfw_.children, 'array')) {
            $KU.defineProperty(this._kwebfw_, 'children', []);
        }

        $KU.each(widgets, function(widget) {
            _addWidget.call(this, widget, fmodel, rmodel, init, append, index);
        }, this);

        _markRelayoutOnAdd.call(this, index);

        if(fmodel && fmodel === $KW.model($KA.currentFormUID)
        && _shouldDeduceModalContainer.onAdd.call(this)) {
            modal = $KW.deduceModalContainer(fmodel);
            $KW.updateModalContainer(fmodel, modal);
        }

        if(append) {
            _addWidgetsToView.call(this, widgets);
        } else {
            _addWidgetsToView.call(this, widgets, index);
        }
    };


    //This function must be called in the scope of widget instance
    var _addWidgetsToView = function UI$_addWidgetsToView(widgets, index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, fragment = null, holder = null, ref = null,
            fmodel = $KW.fmodel(this), fchildren = null,
            rendered = (fmodel && $KW.isRendered(fmodel));

        if($KU.is(widgets, 'widget')) {
            widgets = [widgets];
        }

        if(rendered) {
            $KU.each(widgets, function(widget) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = widget._kwebfw_;

                if(_.is.component) {
                    $KW.invokeLifeCycleEvent(widget, 'preShow', false);

                    if($K.behavior.responsive === true) {
                        $KW.invokeLifeCycleEvent(widget, 'onBreakpointHandler', true);
                        $KW.invokeLifeCycleEvent(widget, 'onBreakpointChange', true);
                    }
                }
            });
        }

        if(this.isVisible || $K.F.RIVW) {
            holder = $KW.holder(this);

            if(widgets.length > 0 && $KU.is(holder, 'dom')) {
                if(widgets.length > 1) {
                    fragment = document.createDocumentFragment();

                    $KU.each(widgets, function(widget) {
                        if(widget.isVisible || $K.F.RIVW) {
                            if(widget instanceof voltmx.ui.UserWidget) {
                                widget = widget._kwebfw_.proxy;
                            }

                            fragment.appendChild(widget._render());
                        }
                    });

                    if($KD.children(fragment).length === 0) {
                        fragment = null;
                    }
                } else if(widgets[0].isVisible || $K.F.RIVW) {
                    if(widgets[0] instanceof voltmx.ui.UserWidget) {
                        fragment = widgets[0]._kwebfw_.proxy._render();
                    } else {
                        fragment = widgets[0]._render();
                    }
                }

                if(fragment) {
                    if($KU.is(fragment, 'fragment')) {
                        fchildren = Array.prototype.slice.call($KD.children(fragment));
                    }

                    if($KU.is(index, 'number')) {
                        ref = $KW.nextVisible(widgets[widgets.length-1]);

                        if(ref) {
                            $KD.before(ref._kwebfw_.view, fragment);
                        } else {
                            $KW.addToView(holder, fragment);
                        }
                    } else {
                        $KW.addToView(holder, fragment);
                    }

                    rendered && $KW.onRender(fchildren || fragment);
                }
            }
        }

        if(rendered) {
            $KU.each(widgets, function(widget) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = widget._kwebfw_;

                if(_.is.component) {
                    $KW.invokeLifeCycleEvent(widget, 'postShow', true);
                }
            });
        }
    };


    //All the functions will be called in the scope of widget instance
    var _applyFlexCSS = {
        fflex: {
            heightDefined: function UI$_applyFlexCSS_fflex_heightDefined(final, cmodel, pmodel, cview, pview) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.style(cview, 'height', final.height);

                if(final.top && !final.centerY && !final.bottom) {
                    _applyFrame.fflex.heightDefined.withOnlyTop(cmodel, pmodel, cview, pview);
                } else if(final.centerY && !final.top && !final.bottom) {
                    _applyFrame.fflex.heightDefined.withOnlyCenterY(cmodel, pmodel, cview, pview);
                } else if(final.bottom && !final.top && !final.centerY) {
                    _applyFrame.fflex.heightDefined.withOnlyBottom(cmodel, pmodel, cview, pview);
                } else if(final.centerY && final.bottom && !final.top) {
                    _applyFrame.fflex.heightDefined.withCenterYBottom(cmodel, pmodel, cview, pview);
                } else if(final.top && final.bottom && !final.centerY) {
                    _applyFrame.fflex.heightDefined.withTopBottom(cmodel, pmodel, cview, pview);
                }
            },

            heightNotDefined: function UI$_applyFlexCSS_fflex_heightNotDefined(final, cmodel, pmodel, cview, pview) {
                if(final.top && !final.centerY && !final.bottom) {
                    _applyFrame.fflex.heightNotDefined.withOnlyTop(cmodel, pmodel, cview, pview);
                } else if(final.centerY && !final.top && !final.bottom) {
                    _applyFrame.fflex.heightNotDefined.withOnlyCenterY(cmodel, pmodel, cview, pview);
                } else if(final.bottom && !final.top && !final.centerY) {
                    _applyFrame.fflex.heightNotDefined.withOnlyBottom(cmodel, pmodel, cview, pview);
                } else if(final.top && final.centerY && !final.bottom) {
                    _applyFrame.fflex.heightNotDefined.withTopCenterY(cmodel, pmodel, cview, pview);
                } else if(final.centerY && final.bottom && !final.top) {
                    _applyFrame.fflex.heightNotDefined.withCenterYBottom(cmodel, pmodel, cview, pview);
                } else if(final.top && final.bottom && !final.centerY) {
                    _applyFrame.fflex.heightNotDefined.withTopBottom(cmodel, pmodel, cview, pview);
                }
            },

            horizontal: function UI$_applyFlexCSS_fflex_horizontal(cmodel, pmodel, cview, pview, forced, rendered) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, final = null;

                final = cmodel._kwebfw_.flex.final = _deduceFinalFlexPropeties.fflex(cmodel, cmodel._kwebfw_.prop, {}, forced, rendered);

                //Populate style object WRT zIndex
                $KD.style(cview, 'zIndex', final.zIndex);

                if(cmodel.reverseLayoutDirection) {
                    if($KW.layout(cmodel) === 'hflex') {
                        $KD.style(cview, 'flexDirection', 'row-reverse');
                    } else if($KW.layout(cmodel) === 'vflex') {
                        $KD.style(cview, 'flexDirection', 'column-reverse');
                    }
                }

                if(!final.width) {
                    _applyFlexCSS.fflex.widthNotDefined(final, cmodel, pmodel, cview, pview);
                } else {
                    _applyFlexCSS.fflex.widthDefined(final, cmodel, pmodel, cview, pview);
                }
            },

            vertical: function UI$_applyFlexCSS_fflex_vertical(cmodel, pmodel, cview, pview/*, forced, rendered*/) {
                var final = cmodel._kwebfw_.flex.final;

                if(!final.height) {
                    _applyFlexCSS.fflex.heightNotDefined(final, cmodel, pmodel, cview, pview);
                } else {
                    _applyFlexCSS.fflex.heightDefined(final, cmodel, pmodel, cview, pview);
                }
            },

            widthDefined: function UI$_applyFlexCSS_fflex_widthDefined(final, cmodel, pmodel, cview, pview) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.style(cview, 'width', final.width);

                if(final.left && !final.centerX && !final.right) {
                    _applyFrame.fflex.widthDefined.withOnlyLeft(cmodel, pmodel, cview, pview);
                } else if(final.centerX && !final.left && !final.right) {
                    _applyFrame.fflex.widthDefined.withOnlyCenterX(cmodel, pmodel, cview, pview);
                } else if(final.right && !final.left && !final.centerX) {
                    _applyFrame.fflex.widthDefined.withOnlyRight(cmodel, pmodel, cview, pview);
                } else if(final.centerX && final.right && !final.left) {
                    _applyFrame.fflex.widthDefined.withCenterXRight(cmodel, pmodel, cview, pview);
                } else if(final.left && final.right && !final.centerX) {
                    _applyFrame.fflex.widthDefined.withLeftRight(cmodel, pmodel, cview, pview);
                }
            },

            widthNotDefined: function UI$_applyFlexCSS_fflex_widthNotDefined(final, cmodel, pmodel, cview, pview) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom;

                if(final.left && !final.centerX && !final.right) {
                    $KD.style(cview, 'width', $KW.getDefaultWidth(cmodel));
                    _applyFrame.fflex.widthNotDefined.withOnlyLeft(cmodel, pmodel, cview, pview);
                } else if(final.centerX && !final.left && !final.right) {
                    $KD.style(cview, 'width', $KW.getDefaultWidth(cmodel));
                    _applyFrame.fflex.widthNotDefined.withOnlyCenterX(cmodel, pmodel, cview, pview);
                } else if(final.right && !final.left && !final.centerX) {
                    $KD.style(cview, 'width', $KW.getDefaultWidth(cmodel));
                    _applyFrame.fflex.widthNotDefined.withOnlyRight(cmodel, pmodel, cview, pview);
                } else if(final.left && final.centerX && !final.right) {
                    _applyFrame.fflex.widthNotDefined.withLeftCenterX(cmodel, pmodel, cview, pview);
                } else if(final.centerX && final.right && !final.left) {
                    _applyFrame.fflex.widthNotDefined.withCenterXRight(cmodel, pmodel, cview, pview);
                } else if(final.left && final.right && !final.centerX) {
                    _applyFrame.fflex.widthNotDefined.withLeftRight(cmodel, pmodel, cview, pview);
                }
            }
        },

        hflex: {
            heightDefined: function UI$_applyFlexCSS_hflex_heightDefined(final, cmodel, pmodel, cview, pview) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.style(cview, 'height', final.height);

                if(final.top && !final.centerY && !final.bottom) {
                    _applyFrame.hflex.heightDefined.withOnlyTop(cmodel, pmodel, cview, pview);
                } else if(final.centerY && !final.top && !final.bottom) {
                    _applyFrame.hflex.heightDefined.withOnlyCenterY(cmodel, pmodel, cview, pview);
                } else if(final.bottom && !final.top && !final.centerY) {
                    _applyFrame.hflex.heightDefined.withOnlyBottom(cmodel, pmodel, cview, pview);
                } else if(final.centerY && final.bottom && !final.top) {
                    _applyFrame.hflex.heightDefined.withCenterYBottom(cmodel, pmodel, cview, pview);
                } else if(final.top && final.bottom && !final.centerY) {
                    _applyFrame.hflex.heightDefined.withTopBottom(cmodel, pmodel, cview, pview);
                }
            },

            heightNotDefined: function UI$_applyFlexCSS_hflex_heightNotDefined(final, cmodel, pmodel, cview, pview) {
                if(final.top && !final.centerY && !final.bottom) {
                    _applyFrame.hflex.heightNotDefined.withOnlyTop(cmodel, pmodel, cview, pview);
                } else if(final.centerY && !final.top && !final.bottom) {
                    _applyFrame.hflex.heightNotDefined.withOnlyCenterY(cmodel, pmodel, cview, pview);
                } else if(final.bottom && !final.top && !final.centerY) {
                    _applyFrame.hflex.heightNotDefined.withOnlyBottom(cmodel, pmodel, cview, pview);
                } else if(final.top && final.centerY && !final.bottom) {
                    _applyFrame.hflex.heightNotDefined.withTopCenterY(cmodel, pmodel, cview, pview);
                } else if(final.centerY && final.bottom && !final.top) {
                    _applyFrame.hflex.heightNotDefined.withCenterYBottom(cmodel, pmodel, cview, pview);
                } else if(final.top && final.bottom && !final.centerY) {
                    _applyFrame.hflex.heightNotDefined.withTopBottom(cmodel, pmodel, cview, pview);
                }
            },

            horizontal: function UI$_applyFlexCSS_hflex_horizontal(cmodel, pmodel, cview, pview, forced, rendered) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, final = null;

                final = cmodel._kwebfw_.flex.final = _deduceFinalFlexPropeties.hflex(cmodel, cmodel._kwebfw_.prop, {}, forced, rendered);

                //Populate style object WRT zIndex
                $KD.style(cview, 'zIndex', final.zIndex);

                if(cmodel.reverseLayoutDirection) {
                    if($KW.layout(cmodel) === 'hflex') {
                        $KD.style(cview, 'flexDirection', 'row-reverse');
                    } else if($KW.layout(cmodel) === 'vflex') {
                        $KD.style(cview, 'flexDirection', 'column-reverse');
                    }
                }

                if(!final.width) {
                    _applyFlexCSS.hflex.widthNotDefined(final, cmodel, pmodel, cview, pview);
                } else {
                    _applyFlexCSS.hflex.widthDefined(final, cmodel, pmodel, cview, pview);
                }
            },

            vertical: function UI$_applyFlexCSS_hflex_vertical(cmodel, pmodel, cview, pview/*, forced, rendered*/) {
                var final = cmodel._kwebfw_.flex.final;

                if(!final.height) {
                    _applyFlexCSS.hflex.heightNotDefined(final, cmodel, pmodel, cview, pview);
                } else {
                    _applyFlexCSS.hflex.heightDefined(final, cmodel, pmodel, cview, pview);
                }
            },

            widthDefined: function UI$_applyFlexCSS_hflex_widthDefined(final, cmodel, pmodel, cview, pview) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.style(cview, 'width', final.width);

                if(final.left && !final.centerX && !final.right) {
                    _applyFrame.hflex.widthDefined.withOnlyLeft(cmodel, pmodel, cview, pview);
                } else if(final.centerX && !final.left && !final.right) {
                    _applyFrame.hflex.widthDefined.withOnlyCenterX(cmodel, pmodel, cview, pview);
                } else if(final.centerX && final.right && !final.left) {
                    _applyFrame.hflex.widthDefined.withCenterXRight(cmodel, pmodel, cview, pview);
                } else if(final.left && final.right && !final.centerX) {
                    _applyFrame.hflex.widthDefined.withLeftRight(cmodel, pmodel, cview, pview);
                }
            },

            widthNotDefined: function UI$_applyFlexCSS_hflex_widthNotDefined(final, cmodel, pmodel, cview, pview) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom;

                $KD.style(cview, 'width', $KW.getDefaultWidth(cmodel));

                if(final.left && !final.centerX && !final.right) {
                    _applyFrame.hflex.widthNotDefined.withOnlyLeft(cmodel, pmodel, cview, pview);
                } else if(final.centerX && !final.left && !final.right) {
                    _applyFrame.hflex.widthNotDefined.withOnlyCenterX(cmodel, pmodel, cview, pview);
                } else if(final.left && final.centerX && !final.right) {
                    _applyFrame.hflex.widthNotDefined.withLeftCenterX(cmodel, pmodel, cview, pview);
                } else if(final.centerX && final.right && !final.left) {
                    _applyFrame.hflex.widthNotDefined.withCenterXRight(cmodel, pmodel, cview, pview);
                } else if(final.left && final.right && !final.centerX) {
                    _applyFrame.hflex.widthNotDefined.withLeftRight(cmodel, pmodel, cview, pview);
                }
            }
        },

        rflex: {
            //eslint-disable-next-line no-unused-vars
            heightDefined: function UI$_applyFlexCSS_rflex_heightDefined(final, cmodel, pmodel, cview/*, pview*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                //set margin-top  for vertical spacing(gutterY)
                $KD.style(cview, 'margin-top', final.gutterY);

                //set calculated height
                $KD.style(cview, 'height', final.height);
            },

            //eslint-disable-next-line no-unused-vars
            heightNotDefined: function UI$_applyFlexCSS_rflex_heightNotDefined(final, cmodel, pmodel, cview/*, pview*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                //set margin-top  for vertical spacing(gutterY)
                $KD.style(cview, 'margin-top', final.gutterY);
            },

            horizontal: function UI$_applyFlexCSS_rflex_horizontal(cmodel, pmodel, cview, pview, forced, rendered) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, final = null;

                final = cmodel._kwebfw_.flex.final = _deduceFinalFlexPropeties.rflex(cmodel, cmodel._kwebfw_.prop, {}, forced, rendered);

                //Populate style object WRT zIndex
                $KD.style(cview, 'zIndex', final.zIndex);

                //width will be always in case of rflex.
                _applyFlexCSS.rflex.widthDefined(final, cmodel, pmodel, cview, pview);
            },

            vertical: function UI$_applyFlexCSS_rflex_vertical(cmodel, pmodel, cview, pview/*, forced, rendered*/) {
                var final = cmodel._kwebfw_.flex.final;

                if(!final.height) {
                    _applyFlexCSS.rflex.heightNotDefined(final, cmodel, pmodel, cview, pview);
                } else {
                    _applyFlexCSS.rflex.heightDefined(final, cmodel, pmodel, cview, pview);
                }
            },

            //eslint-disable-next-line no-unused-vars
            widthDefined: function UI$_applyFlexCSS_rflex_widthDefined(final, cmodel, pmodel, cview/*, pview*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, calcMarginLeft = '', calcMarginRight = '',
                    calcWidthWithGutterX = '';

                if(final.gutterX) {
                    //Get margin-left by adding gutterX and offset
                    calcMarginLeft = 'calc(' + final.gutterX +' + ' + final.offset + ')';
                    calcMarginRight = final.gutterX;

                    //As spacing should be in the given width, calculate width by reducing the
                    //gutterX * 2(margin left and right) from the final width
                    calcWidthWithGutterX = 'calc('+final.width +' - calc(2 * ' +final.gutterX +'))';
                } else {
                    calcMarginLeft = final.offset;
                    calcMarginRight = '0px';
                    calcWidthWithGutterX = final.width;
                }

                //set margin-left and right for horizontal spacing(gutterX)
                $KD.style(cview, 'margin-left', calcMarginLeft);
                $KD.style(cview, 'margin-right', calcMarginRight);

                //set the calculated width
                $KD.style(cview, 'width', calcWidthWithGutterX);

                //width is not maintaining in flex if it is more than 100%
                $KD.style(cview, 'min-width', calcWidthWithGutterX);
            },

            widthNotDefined: function UI$_applyFlexCSS_rflex_widthNotDefined(/*final, cmodel, pmodel, cview, pview*/) {
                //
            }
        },

        vflex: {
            heightDefined: function UI$_applyFlexCSS_vflex_heightDefined(final, cmodel, pmodel, cview, pview) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                    _ = cmodel._kwebfw_, is = _.is, omodel = null, pnode = null;

                if(!pmodel && is.template && is.cloned && _.oid) {
                    omodel = $KW.omodel(cmodel);
                    pnode = $KD.parent(cview);

                    if(!pnode) {
                        $KD.style(cview, 'height', final.height);
                    } else {
                        if($KU.is(omodel, 'widget', 'SegmentedUI2')) {
                            $KD.style(cview, 'height', '100%');
                            $KD.style(pnode, 'height', final.height); //Here pnode.tagName === 'LI'
                        } else if($KU.is(omodel, 'widget', 'DataGrid')) {
                            $KD.style(cview, 'height', '100%');
                            $KD.style(pnode, 'height', '100%'); //Here pnode.tagName === 'TD'/'TH'
                            pnode = $KD.parent(pnode); //Here pnode.tagName === 'TR'
                            $KD.style(pnode, 'height', final.height);
                        } else { //For all other owner widgets
                            $KD.style(cview, 'height', final.height);
                        }
                    }
                } else {
                    $KD.style(cview, 'height', final.height);
                }

                if(final.top && !final.centerY && !final.bottom) {
                    _applyFrame.vflex.heightDefined.withOnlyTop(cmodel, pmodel, cview, pview);
                } else if(final.centerY && !final.top && !final.bottom) {
                    _applyFrame.vflex.heightDefined.withOnlyCenterY(cmodel, pmodel, cview, pview);
                } else if(final.centerY && final.bottom && !final.top) {
                    _applyFrame.vflex.heightDefined.withCenterYBottom(cmodel, pmodel, cview, pview);
                } else if(final.top && final.bottom && !final.centerY) {
                    _applyFrame.vflex.heightDefined.withTopBottom(cmodel, pmodel, cview, pview);
                }
            },

            heightNotDefined: function UI$_applyFlexCSS_vflex_heightNotDefined(final, cmodel, pmodel, cview, pview) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                    _ = cmodel._kwebfw_, is = _.is, omodel = null, pnode = null;

                if(!pmodel && is.template && is.cloned && _.oid) {
                    omodel = $KW.omodel(cmodel);
                    pnode = $KD.parent(cview);

                    if(pnode) {
                        if($KU.is(omodel, 'widget', 'SegmentedUI2')) {
                            $KD.style(pnode, 'height', null); //Here pnode.tagName === 'LI'
                        } else if($KU.is(omodel, 'widget', 'DataGrid')) {
                            $KD.style(pnode, 'height', null); //Here pnode.tagName === 'TD'/'TH'
                            pnode = $KD.parent(pnode); //Here pnode.tagName === 'TR'
                            $KD.style(pnode, 'height', null);
                        }
                    }
                }

                if(final.top && !final.centerY && !final.bottom) {
                    _applyFrame.vflex.heightNotDefined.withOnlyTop(cmodel, pmodel, cview, pview);
                } else if(final.centerY && !final.top && !final.bottom) {
                    _applyFrame.vflex.heightNotDefined.withOnlyCenterY(cmodel, pmodel, cview, pview);
                } else if(final.top && final.centerY && !final.bottom) {
                    _applyFrame.vflex.heightNotDefined.withTopCenterY(cmodel, pmodel, cview, pview);
                } else if(final.centerY && final.bottom && !final.top) {
                    _applyFrame.vflex.heightNotDefined.withCenterYBottom(cmodel, pmodel, cview, pview);
                } else if(final.top && final.bottom && !final.centerY) {
                    _applyFrame.vflex.heightNotDefined.withTopBottom(cmodel, pmodel, cview, pview);
                }
            },

            horizontal: function UI$_applyFlexCSS_vflex_horizontal(cmodel, pmodel, cview, pview, forced, rendered) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, final = null;

                final = cmodel._kwebfw_.flex.final = _deduceFinalFlexPropeties.vflex(cmodel, cmodel._kwebfw_.prop, {}, forced, rendered);

                //Populate style object WRT zIndex
                $KD.style(cview, 'zIndex', final.zIndex);

                if(cmodel.reverseLayoutDirection) {
                    if($KW.layout(cmodel) === 'hflex') {
                        $KD.style(cview, 'flexDirection', 'row-reverse');
                    } else if($KW.layout(cmodel) === 'vflex') {
                        $KD.style(cview, 'flexDirection', 'column-reverse');
                    }
                }

                if(!final.width) {
                    _applyFlexCSS.vflex.widthNotDefined(final, cmodel, pmodel, cview, pview);
                } else {
                    _applyFlexCSS.vflex.widthDefined(final, cmodel, pmodel, cview, pview);
                }
            },

            vertical: function UI$_applyFlexCSS_vflex_vertical(cmodel, pmodel, cview, pview/*, forced, rendered*/) {
                var final = cmodel._kwebfw_.flex.final;

                if(!final.height) {
                    _applyFlexCSS.vflex.heightNotDefined(final, cmodel, pmodel, cview, pview);
                } else {
                    _applyFlexCSS.vflex.heightDefined(final, cmodel, pmodel, cview, pview);
                }
            },

            widthDefined: function UI$_applyFlexCSS_vflex_widthDefined(final, cmodel, pmodel, cview, pview) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.style(cview, 'width', final.width);

                if(final.left && !final.centerX && !final.right) {
                    _applyFrame.vflex.widthDefined.withOnlyLeft(cmodel, pmodel, cview, pview);
                } else if(final.centerX && !final.left && !final.right) {
                    _applyFrame.vflex.widthDefined.withOnlyCenterX(cmodel, pmodel, cview, pview);
                } else if(final.right && !final.left && !final.centerX) {
                    _applyFrame.vflex.widthDefined.withOnlyRight(cmodel, pmodel, cview, pview);
                } else if(final.centerX && final.right && !final.left) {
                    _applyFrame.vflex.widthDefined.withCenterXRight(cmodel, pmodel, cview, pview);
                } else if(final.left && final.right && !final.centerX) {
                    _applyFrame.vflex.widthDefined.withLeftRight(cmodel, pmodel, cview, pview);
                }
            },

            widthNotDefined: function UI$_applyFlexCSS_vflex_widthNotDefined(final, cmodel, pmodel, cview, pview) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom;

                $KD.style(cview, 'width', $KW.getDefaultWidth(cmodel));

                if(final.left && !final.centerX && !final.right) {
                    _applyFrame.vflex.widthNotDefined.withOnlyLeft(cmodel, pmodel, cview, pview);
                } else if(final.centerX && !final.left && !final.right) {
                    _applyFrame.vflex.widthNotDefined.withOnlyCenterX(cmodel, pmodel, cview, pview);
                } else if(final.right && !final.left && !final.centerX) {
                    _applyFrame.vflex.widthNotDefined.withOnlyRight(cmodel, pmodel, cview, pview);
                } else if(final.left && final.centerX && !final.right) {
                    _applyFrame.vflex.widthNotDefined.withLeftCenterX(cmodel, pmodel, cview, pview);
                } else if(final.centerX && final.right && !final.left) {
                    _applyFrame.vflex.widthNotDefined.withCenterXRight(cmodel, pmodel, cview, pview);
                } else if(final.left && final.right && !final.centerX) {
                    _applyFrame.vflex.widthNotDefined.withLeftRight(cmodel, pmodel, cview, pview);
                }
            }
        }
    };


    //This function must be called in the scope of widget instance
    var _applyFlexRule = function UI$_applyFlexRule(playout, direction, view, forced, rendered) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, horizontalFn = null, verticalFn = null, pview = null,
            cmodel = this, cview = view || cmodel._kwebfw_.view,
            pmodel = $KW.pmodel(cmodel), cfinal = null;

        if(cview) {
            pview = ($KU.is(pmodel, 'widget')) ? pmodel._kwebfw_.view : null;

            if(direction === 'horizontal') {
                _cleanFlexCSS(cmodel, cview, pview);
                horizontalFn = _applyFlexCSS[playout].horizontal;
                horizontalFn(cmodel, pmodel, cview, pview, forced, rendered);

                cfinal = cmodel._kwebfw_.flex.final;
                if(cfinal.minWidth) $KD.style(cview, 'minWidth', cfinal.minWidth);
                if(cfinal.maxWidth) $KD.style(cview, 'maxWidth', cfinal.maxWidth);

                if($KW.isTextDrivenWidget(cmodel)) {
                    if($KW.isFixedWidth(cmodel)) {
                        $KD.style(cview, 'whiteSpace', 'pre-wrap');
                    } else {
                        $KD.style(cview, 'whiteSpace', 'nowrap');
                    }
                }
            } else if(direction === 'vertical') {
                verticalFn = _applyFlexCSS[playout].vertical;
                verticalFn(cmodel, pmodel, cview, pview, forced, rendered);

                cfinal = cmodel._kwebfw_.flex.final;
                if(cfinal.minHeight) $KD.style(cview, 'minHeight', cfinal.minHeight);
                if(cfinal.maxHeight) $KD.style(cview, 'maxHeight', cfinal.maxHeight);

                _flagForMutate(cmodel, cview);
            }
        }
    };


    var _applyFrame = {
        fflex: {
            heightDefined: {
                //eslint-disable-next-line no-unused-vars
                withOnlyTop: function UI$_applyFrame_fflex_heightDefined_withOnlyTop(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'top', cmodel._kwebfw_.flex.final.top);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterY: function UI$_applyFrame_fflex_heightDefined_withOnlyCenterY(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                        calc = '', final = cmodel._kwebfw_.flex.final;

                    calc = ('calc('+final.centerY+' - '+final.height+'/2)');
                    $KD.style(cview, 'top', calc);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyBottom: function UI$_applyFrame_fflex_heightDefined_withOnlyBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'bottom', cmodel._kwebfw_.flex.final.bottom);
                },

                //eslint-disable-next-line no-unused-vars
                withCenterYBottom: function UI$_applyFrame_fflex_heightDefined_withCenterYBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                        calc = '', final = cmodel._kwebfw_.flex.final;

                    calc = ('calc('+final.centerY+' - '+final.height+'/2)');
                    $KD.style(cview, 'top', calc);
                    $KD.style(cview, 'bottom', final.bottom);
                },

                //eslint-disable-next-line no-unused-vars
                withTopBottom: function UI$_applyFrame_fflex_heightDefined_withTopBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'top', final.top);
                    $KD.style(cview, 'bottom', final.bottom);
                }
            },

            heightNotDefined: {
                //eslint-disable-next-line no-unused-vars
                withOnlyTop: function UI$_applyFrame_fflex_heightNotDefined_withOnlyTop(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'top', cmodel._kwebfw_.flex.final.top);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterY: function UI$_applyFrame_fflex_heightNotDefined_withOnlyCenterY(cmodel, pmodel, cview/*, pview*/) {
                    _flagForMeasure(cmodel._kwebfw_.uid, 'centerY', 'vertical', cview);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyBottom: function UI$_applyFrame_fflex_heightNotDefined_withOnlyBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'bottom', cmodel._kwebfw_.flex.final.bottom);
                },

                //eslint-disable-next-line no-unused-vars
                withTopCenterY: function UI$_applyFrame_fflex_heightNotDefined_withTopCenterY(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, calc = '',
                        final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'top', final.top);
                    calc = 'calc(('+final.centerY+' - '+final.top+')*2)';
                    $KD.style(cview, 'height', calc);

                    if(final.minHeight || final.maxHeight) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'centerY', 'vertical', cview);
                    }
                },

                //eslint-disable-next-line no-unused-vars
                withCenterYBottom: function UI$_applyFrame_fflex_heightNotDefined_withCenterYBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, calc = '',
                        final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'bottom', final.bottom);
                    calc = 'calc(('+ '100% - ' + final.centerY+' - '+final.bottom+')*2)';
                    $KD.style(cview, 'height', calc);

                    if(final.minHeight || final.maxHeight) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'centerY', 'vertical', cview, null, true);
                    }
                },

                //eslint-disable-next-line no-unused-vars
                withTopBottom: function UI$_applyFrame_fflex_heightNotDefined_withTopBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils,
                        $KD = $K.dom, final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'top', final.top);
                    $KD.style(cview, 'bottom', final.bottom);

                    if($KU.is(cmodel, 'widget', 'TextBox2')
                    || $KU.is(cmodel, 'widget', 'ListBox')
                    || $KU.is(cmodel, 'widget', 'Button')) {
                        $KD.style(cview, 'height', ('calc(100% - '+final.top+' - '+final.bottom+')'));
                    }
                }
            },

            widthDefined: {

                //eslint-disable-next-line no-unused-vars
                withOnlyLeft: function UI$_applyFrame_fflex_widthDefined_withOnlyLeft(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'left', cmodel._kwebfw_.flex.final.left);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterX: function UI$_applyFrame_fflex_widthDefined_withOnlyCenterX(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                        calc = '', final = cmodel._kwebfw_.flex.final;

                    calc = ('calc('+final.centerX+' - '+final.width+'/2)');
                    $KD.style(cview, 'left', calc);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyRight: function UI$_applyFrame_fflex_widthDefined_withOnlyRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'right', cmodel._kwebfw_.flex.final.right);
                },

                //eslint-disable-next-line no-unused-vars
                withCenterXRight: function UI$_applyFrame_fflex_widthDefined_withCenterXRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                        calc = '', final = cmodel._kwebfw_.flex.final;

                    calc = ('calc('+final.centerX+' - '+final.width+'/2)');
                    $KD.style(cview, 'left', calc);
                    $KD.style(cview, 'right', final.right);
                },

                //eslint-disable-next-line no-unused-vars
                withLeftRight: function UI$_applyFrame_fflex_widthDefined_withLeftRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'left', final.left);
                    $KD.style(cview, 'right', final.right);
                }
            },

            widthNotDefined: {
                //eslint-disable-next-line no-unused-vars
                withOnlyLeft: function UI$_applyFrame_fflex_widthNotDefined_withOnlyLeft(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'left', cmodel._kwebfw_.flex.final.left);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterX: function UI$_applyFrame_fflex_widthNotDefined_withOnlyCenterX(cmodel, pmodel, cview/*, pview*/) {
                    _flagForMeasure(cmodel._kwebfw_.uid, 'centerX', 'horizontal', cview);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyRight: function UI$_applyFrame_fflex_widthNotDefined_withOnlyRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'right', cmodel._kwebfw_.flex.final.right);
                },

                //eslint-disable-next-line no-unused-vars
                withLeftCenterX: function UI$_applyFrame_fflex_widthNotDefined_withLeftCenterX(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, calc = '',
                        final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'left', final.left);
                    calc = 'calc(('+final.centerX+' - '+final.left+')*2)';
                    $KD.style(cview, 'width', calc);

                    if(final.minWidth || final.maxWidth) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'centerX', 'horizontal', cview);
                    }
                },

                //eslint-disable-next-line no-unused-vars
                withCenterXRight: function UI$_applyFrame_fflex_widthNotDefined_withCenterXRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, calc = '',
                        final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'right', final.right);
                    calc = 'calc(('+'100% - ' + final.centerX+' - '+final.right+')*2)';
                    $KD.style(cview, 'width', calc);

                    if(final.minWidth || final.maxWidth) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'centerX', 'horizontal', cview, null, true);
                    }
                },

                //eslint-disable-next-line no-unused-vars
                withLeftRight: function UI$_applyFrame_fflex_widthNotDefined_withLeftRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils,
                        $KD = $K.dom, final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'left', final.left);
                    $KD.style(cview, 'right', final.right);

                    if($KU.is(cmodel, 'widget', 'TextBox2')
                    || $KU.is(cmodel, 'widget', 'ListBox')
                    || $KU.is(cmodel, 'widget', 'Button')) {
                        $KD.style(cview, 'width', ('calc(100% - '+final.left+' - '+final.right+')'));
                    }
                }
            }
        },

        hflex: {
            heightDefined: {
                //Exactly same as that of UI$_applyFrame_hflex_heightNotDefined_withOnlyTop
                //eslint-disable-next-line no-unused-vars
                withOnlyTop: function UI$_applyFrame_hflex_heightDefined_withOnlyTop(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        final = cmodel._kwebfw_.flex.final, property = 'marginTop';

                    if($KW.inPercent(final.top)) property = 'top';

                    $KD.style(cview, property, final.top);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterY: function UI$_applyFrame_hflex_heightDefined_withOnlyCenterY(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, calc = '',
                        final = cmodel._kwebfw_.flex.final, property = 'marginTop';

                    if($KW.inPercent(final.centerY)
                    || $KW.inPercent(final.height)) {
                        property = 'top';
                    }

                    calc = ('calc('+final.centerY+' - '+final.height+'/2)');
                    $KD.style(cview, property, calc);
                },

                //Exactly same as that of UI$_applyFrame_hflex_heightNotDefined_withOnlyBottom
                //eslint-disable-next-line no-unused-vars
                withOnlyBottom: function UI$_applyFrame_hflex_heightDefined_withOnlyBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        final = cmodel._kwebfw_.flex.final, property = 'marginBottom';

                    if($KW.inPercent(final.bottom)) {
                        property = 'bottom';
                        $KD.style(cview, 'top', 'auto');
                    } else {
                        $KD.style(cview, 'marginTop', 'auto');
                    }

                    $KD.style(cview, property, final.bottom);
                    $KD.style(cview, 'alignSelf', 'flex-end');
                },

                //Exactly same (except centerY) as that of UI$_applyFrame_hflex_heightNotDefined_withCenterYBottom
                //eslint-disable-next-line no-unused-vars
                withCenterYBottom: function UI$_applyFrame_hflex_heightDefined_withCenterYBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, calc = '',
                        final = cmodel._kwebfw_.flex.final, property = 'marginTop';

                    if($KW.inPercent(final.centerY)
                    || $KW.inPercent(final.height)) {
                        property = 'top';
                    }

                    calc = ('calc('+final.centerY+' - '+final.height+'/2)');
                    $KD.style(cview, property, calc);

                    property = ($KW.inPercent(final.bottom)) ? 'bottom' : 'marginBottom';
                    $KD.style(cview, property, final.bottom);
                },

                //Exactly same as that of UI$_applyFrame_hflex_heightNotDefined_withTopBottom
                //eslint-disable-next-line no-unused-vars
                withTopBottom: function UI$_applyFrame_hflex_heightDefined_withTopBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        final = cmodel._kwebfw_.flex.final, property = '';

                    property = ($KW.inPercent(final.top)) ? 'top' : 'marginTop';
                    $KD.style(cview, property, final.top);

                    property = ($KW.inPercent(final.bottom)) ? 'bottom' : 'marginBottom';
                    $KD.style(cview, property, final.bottom);
                }
            },

            heightNotDefined: {
                //Exactly same as that of UI$_applyFrame_hflex_heightDefined_withOnlyTop
                //eslint-disable-next-line no-unused-vars
                withOnlyTop: function UI$_applyFrame_hflex_heightNotDefined_withOnlyTop(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        final = cmodel._kwebfw_.flex.final, property = 'marginTop';

                    if($KW.inPercent(final.top)) property = 'top';

                    $KD.style(cview, property, final.top);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterY: function UI$_applyFrame_hflex_heightNotDefined_withOnlyCenterY(cmodel, pmodel, cview/*, pview*/) {
                    _flagForMeasure(cmodel._kwebfw_.uid, 'centerY', 'vertical', cview);
                },

                //Exactly same as that of UI$_applyFrame_hflex_heightDefined_withOnlyBottom
                //eslint-disable-next-line no-unused-vars
                withOnlyBottom: function UI$_applyFrame_hflex_heightNotDefined_withOnlyBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        final = cmodel._kwebfw_.flex.final, property = 'marginBottom';

                    if($KW.inPercent(final.bottom)) {
                        property = 'bottom';
                        $KD.style(cview, 'top', 'auto');
                    } else {
                        $KD.style(cview, 'marginTop', 'auto');
                    }

                    $KD.style(cview, property, final.bottom);
                    $KD.style(cview, 'alignSelf', 'flex-end');
                },

                //Exactly same (except centerY) as that of UI$_applyFrame_hflex_heightDefined_withCenterYBottom
                //eslint-disable-next-line no-unused-vars
                withCenterYBottom: function UI$_applyFrame_hflex_heightNotDefined_withCenterYBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        final = cmodel._kwebfw_.flex.final, property = '';

                    property = ($KW.inPercent(final.bottom)) ? 'bottom' : 'marginBottom';
                    $KD.style(cview, property, final.bottom);

                    _flagForMeasure(cmodel._kwebfw_.uid, 'centerY', 'vertical', cview);
                },

                //Exactly same as that of UI$_applyFrame_hflex_heightDefined_withTopBottom
                //eslint-disable-next-line no-unused-vars
                withTopBottom: function UI$_applyFrame_hflex_heightNotDefined_withTopBottom(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        final = cmodel._kwebfw_.flex.final, property = '';

                    property = ($KW.inPercent(final.top)) ? 'top' : 'marginTop';
                    $KD.style(cview, property, final.top);

                    property = ($KW.inPercent(final.bottom)) ? 'bottom' : 'marginBottom';
                    $KD.style(cview, property, final.bottom);
                }
            },

            widthDefined: {
                //eslint-disable-next-line no-unused-vars
                withOnlyLeft: function UI$_applyFrame_hflex_widthDefined_withOnlyLeft(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'marginLeft', cmodel._kwebfw_.flex.final.left);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterX: function UI$_applyFrame_hflex_widthDefined_withOnlyCenterX(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                        calc = '', final = cmodel._kwebfw_.flex.final;

                    calc = ('calc('+final.centerX+' - '+final.width+'/2)');
                    $KD.style(cview, 'marginLeft', calc);
                },

                //eslint-disable-next-line no-unused-vars
                withCenterXRight: function UI$_applyFrame_hflex_widthDefined_withCenterXRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                        calc = '', final = cmodel._kwebfw_.flex.final;

                    calc = ('calc('+final.centerX+' - '+final.width+'/2)');
                    $KD.style(cview, 'marginLeft', calc);
                    $KD.style(cview, 'marginRight', final.right);
                },

                //eslint-disable-next-line no-unused-vars
                withLeftRight: function UI$_applyFrame_hflex_widthDefined_withLeftRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'marginLeft', final.left);
                    $KD.style(cview, 'marginRight', final.right);
                }
            },

            widthNotDefined: {
                //eslint-disable-next-line no-unused-vars
                withOnlyLeft: function UI$_applyFrame_hflex_widthNotDefined_withOnlyLeft(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'marginLeft', cmodel._kwebfw_.flex.final.left);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterX: function UI$_applyFrame_hflex_widthNotDefined_withOnlyCenterX(cmodel, pmodel, cview/*, pview*/) {
                    _flagForMeasure(cmodel._kwebfw_.uid, 'centerX', 'horizontal', cview);
                },

                //eslint-disable-next-line no-unused-vars
                withCenterXRight: function UI$_applyFrame_hflex_widthNotDefined_withCenterXRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'marginRight', cmodel._kwebfw_.flex.final.right);

                    _flagForMeasure(cmodel._kwebfw_.uid, 'centerX', 'horizontal', cview);
                },

                //eslint-disable-next-line no-unused-vars
                withLeftRight: function UI$_applyFrame_hflex_widthNotDefined_withLeftRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'marginLeft', final.left);
                    $KD.style(cview, 'marginRight', final.right);
                }
            }
        },

        rflex: {
            heightDefined: {

            },

            heightNotDefined: {
            },

            widthDefined: {

            },

            widthNotDefined: {

            }
        },

        vflex: {
            heightDefined: {
                //eslint-disable-next-line no-unused-vars
                withOnlyTop: function UI$_applyFrame_vflex_heightDefined_withOnlyTop(cmodel, pmodel, cview, pview) {
                    var final = cmodel._kwebfw_.flex.final, needMeasure = false;

                    needMeasure = _setTopOrBottomStyleInsideVerticalLayout(final.top, 'top', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'top', 'vertical', cview, pview);
                    }
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterY: function UI$_applyFrame_vflex_heightDefined_withOnlyCenterY(cmodel, pmodel, cview, pview) {
                    var final = cmodel._kwebfw_.flex.final, needMeasure = false;

                    needMeasure = _setCenterYStyleInsideVerticalLayout(final.centerY, 'top', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'centerY', 'vertical', cview, pview);
                    }
                },

                //eslint-disable-next-line no-unused-vars
                withCenterYBottom: function UI$_applyFrame_vflex_heightDefined_withCenterYBottom(cmodel, pmodel, cview, pview) {
                    var final = cmodel._kwebfw_.flex.final, needMeasure = false;

                    needMeasure = _setCenterYStyleInsideVerticalLayout(final.centerY, 'top', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'centerY', 'vertical', cview, pview);
                    }

                    needMeasure = _setTopOrBottomStyleInsideVerticalLayout(final.bottom, 'bottom', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'bottom', 'vertical', cview, pview);
                    }
                },

                //eslint-disable-next-line no-unused-vars
                withTopBottom: function UI$_applyFrame_vflex_heightDefined_withTopBottom(cmodel, pmodel, cview, pview) {
                    var final = cmodel._kwebfw_.flex.final, needMeasure = false;

                    needMeasure = _setTopOrBottomStyleInsideVerticalLayout(final.top, 'top', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'top', 'vertical', cview, pview);
                    }

                    needMeasure = _setTopOrBottomStyleInsideVerticalLayout(final.bottom, 'bottom', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'bottom', 'vertical', cview, pview);
                    }
                }
            },

            heightNotDefined: {
                //eslint-disable-next-line no-unused-vars
                withOnlyTop: function UI$_applyFrame_vflex_heightNotDefined_withOnlyTop(cmodel, pmodel, cview, pview) {
                    var final = cmodel._kwebfw_.flex.final, needMeasure = false;

                    needMeasure = _setTopOrBottomStyleInsideVerticalLayout(final.top, 'top', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'top', 'vertical', cview, pview);
                    }
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterY: function UI$_applyFrame_vflex_heightNotDefined_withOnlyCenterY(cmodel, pmodel, cview, pview) {
                    var final = cmodel._kwebfw_.flex.final, needMeasure = false;

                    needMeasure = _setCenterYStyleInsideVerticalLayout(final.centerY, 'top', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'centerY', 'vertical', cview, pview);
                    }
                },

                //eslint-disable-next-line no-unused-vars
                withCenterYBottom: function UI$_applyFrame_vflex_heightNotDefined_withCenterYBottom(cmodel, pmodel, cview, pview) {
                    var final = cmodel._kwebfw_.flex.final, needMeasure = false;

                    needMeasure = _setCenterYStyleInsideVerticalLayout(final.centerY, 'top', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'centerY', 'vertical', cview, pview);
                    }

                    needMeasure = _setTopOrBottomStyleInsideVerticalLayout(final.bottom, 'bottom', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'bottom', 'vertical', cview, pview);
                    }
                },

                //eslint-disable-next-line no-unused-vars
                withTopBottom: function UI$_applyFrame_vflex_heightNotDefined_withTopBottom(cmodel, pmodel, cview, pview) {
                    var final = cmodel._kwebfw_.flex.final, needMeasure = false;

                    needMeasure = _setTopOrBottomStyleInsideVerticalLayout(final.top, 'top', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'top', 'vertical', cview, pview);
                    }

                    needMeasure = _setTopOrBottomStyleInsideVerticalLayout(final.bottom, 'bottom', cmodel, cview, pview);
                    if(needMeasure) {
                        _flagForMeasure(cmodel._kwebfw_.uid, 'bottom', 'vertical', cview, pview);
                    }
                }
            },

            widthDefined: {
                //eslint-disable-next-line no-unused-vars
                withOnlyLeft: function UI$_applyFrame_vflex_widthDefined_withOnlyLeft(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'marginLeft', cmodel._kwebfw_.flex.final.left);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterX: function UI$_applyFrame_vflex_widthDefined_withOnlyCenterX(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                        calc = '', final = cmodel._kwebfw_.flex.final;

                    calc = ('calc('+final.centerX+' - '+final.width+'/2)');
                    $KD.style(cview, 'marginLeft', calc);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyRight: function UI$_applyFrame_vflex_widthDefined_withOnlyRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'marginRight', cmodel._kwebfw_.flex.final.right);
                    $KD.style(cview, 'alignSelf', 'flex-end');
                },

                //eslint-disable-next-line no-unused-vars
                withCenterXRight: function UI$_applyFrame_vflex_widthDefined_withCenterXRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                        calc = '', final = cmodel._kwebfw_.flex.final;

                    calc = ('calc('+final.centerX+' - '+final.width+'/2)');
                    $KD.style(cview, 'marginLeft', calc);
                    $KD.style(cview, 'marginRight', final.right);
                },

                //eslint-disable-next-line no-unused-vars
                withLeftRight: function UI$_applyFrame_vflex_widthDefined_withLeftRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'marginLeft', final.left);
                    $KD.style(cview, 'marginRight', final.right);
                }
            },

            widthNotDefined: {
                //eslint-disable-next-line no-unused-vars
                withOnlyLeft: function UI$_applyFrame_vflex_widthNotDefined_withOnlyLeft(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'marginLeft', cmodel._kwebfw_.flex.final.left);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyCenterX: function UI$_applyFrame_vflex_widthNotDefined_withOnlyCenterX(cmodel, pmodel, cview/*, pview*/) {
                    _flagForMeasure(cmodel._kwebfw_.uid, 'centerX', 'horizontal', cview);
                },

                //eslint-disable-next-line no-unused-vars
                withOnlyRight: function UI$_applyFrame_vflex_widthNotDefined_withOnlyRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom;

                    $KD.style(cview, 'marginRight', cmodel._kwebfw_.flex.final.right);
                    $KD.style(cview, 'alignSelf', 'flex-end');
                },

                //eslint-disable-next-line no-unused-vars
                withCenterXRight: function UI$_applyFrame_vflex_widthNotDefined_withCenterXRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'marginRight', final.right);

                    _flagForMeasure(cmodel._kwebfw_.uid, 'centerX', 'horizontal', cview);
                },

                //eslint-disable-next-line no-unused-vars
                withLeftRight: function UI$_applyFrame_vflex_widthNotDefined_withLeftRight(cmodel, pmodel, cview/*, pview*/) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, final = cmodel._kwebfw_.flex.final;

                    $KD.style(cview, 'marginLeft', final.left);
                    $KD.style(cview, 'marginRight', final.right);
                }
            }
        }
    };


    var _canMeasureHeight = function UI$_canMeasureHeight(model/*, context*/) {
        //Context says if the model is inside a Segment/CollectionView/Header/Footer
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            _ = model._kwebfw_, pmodel = $KW.pmodel(model), w = 0, wlen = 0, child = null,
            prop = _.prop, widgets = null, flag = false, omodel = null;

        if(model.autogrowMode === voltmx.flex.AUTOGROW_HEIGHT) {
            flag = true;
        } else if($KW.isFlexPropertyDefined(prop, 'height')) {
            omodel = $KW.omodel(model);
            if($KW.inPercent(prop.height) && _.is.template
               && $KU.is(omodel, 'widget', 'SegmentedUI2')
               && omodel.autogrowMode === voltmx.flex.AUTOGROW_HEIGHT) {
                flag = false;
            } else {
                flag = true;
            }
        } else if($KW.isFlexPropertyDefined(prop, 'maxHeight')
        || $KW.isFlexPropertyDefined(prop, 'minHeight')) {
            flag = true;
        } else if($KW.layout(pmodel) === 'fflex') {
            //Condition for implicit height checking
            if(!(($KW.isFlexPropertyDefined(prop, 'top') //Only top defined
            && !$KW.isFlexPropertyDefined(prop, 'centerY')
            && !$KW.isFlexPropertyDefined(prop, 'bottom'))
            || ($KW.isFlexPropertyDefined(prop, 'centerY') //Only centerY defined
            && !$KW.isFlexPropertyDefined(prop, 'top')
            && !$KW.isFlexPropertyDefined(prop, 'bottom'))
            || ($KW.isFlexPropertyDefined(prop, 'bottom') //Only bottom defined
            && !$KW.isFlexPropertyDefined(prop, 'top')
            && !$KW.isFlexPropertyDefined(prop, 'centerY')))) {
                flag = true;
            }
        }

        if(flag && model.autogrowMode === voltmx.flex.AUTOGROW_HEIGHT
        && $KW.isFlexContainer(model) && !$KU.is(model, 'widget', 'Form2')) {
            widgets = $KW.children(model);
            wlen = widgets.length;

            for(w=0; w<wlen; w++) {
                child = widgets[w];
                prop = child._kwebfw_.prop;

                if(($KW.inPercent(prop.top) && prop.top !== '0%')
                || ($KW.inPercent(prop.bottom) && prop.bottom !== '0%')
                || ($KW.inPercent(prop.centerY) && prop.centerY !== '0%')
                || ($KW.inPercent(prop.height) && prop.height !== '0%')
                || ($KW.inPercent(prop.minHeight) && prop.minHeight !== '0%')
                || ($KW.inPercent(prop.maxHeight) && prop.maxHeight !== '0%')) {
                    flag = false;
                    break;
                }
            }
        }

        return flag;
    };


    var _canMeasureWidth = function UI$_canMeasureWidth(model/*, context*/) {
        //Context says if the model is inside a Segment/CollectionView/Header/Footer
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false,
            prop = model._kwebfw_.prop, pmodel = $KW.pmodel(model);

        if($KW.isFlexPropertyDefined(prop, 'width')
        || $KW.isFlexPropertyDefined(prop, 'maxWidth')
        || $KW.isFlexPropertyDefined(prop, 'minWidth')) {
            flag = true;
        } else if($KW.layout(pmodel) === 'fflex') {
            //Condition for implicit width checking
            if(!(($KW.isFlexPropertyDefined(prop, 'left') //Only left defined
            && !$KW.isFlexPropertyDefined(prop, 'centerX')
            && !$KW.isFlexPropertyDefined(prop, 'right'))
            || ($KW.isFlexPropertyDefined(prop, 'centerX') //Only centerX defined
            && !$KW.isFlexPropertyDefined(prop, 'left')
            && !$KW.isFlexPropertyDefined(prop, 'right'))
            || ($KW.isFlexPropertyDefined(prop, 'right') //Only right defined
            && !$KW.isFlexPropertyDefined(prop, 'left')
            && !$KW.isFlexPropertyDefined(prop, 'centerX')))) {
                flag = true;
            }
        }

        return flag;
    };


    //This function must be called in the scope of form instance
    var _cascadeRelayout = function UI$_cascadeRelayout(model, ignoreSiblingCascade) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            slen = 0, index = -1, siblings = [], omodel = null,
            s = 0, pmodel = $KW.pmodel(model, {tabs : true}), templates = null,
            tmodel = null;
        if(model && model._kwebfw_.relayout !== true) {
            model._kwebfw_.relayout = true;
            _dirty.widgets[model._kwebfw_.uid] = model;

            //Populate _dirty.templates
            if(model._kwebfw_.is.cloned) {
                tmodel = $KW.tmodel(model);
                omodel = $KW.omodel(model);

                if(tmodel && omodel) {
                    templates = _dirty.templates;

                    if(!templates[omodel._kwebfw_.uid]) {
                        templates[omodel._kwebfw_.uid] = {};
                    }

                    templates[omodel._kwebfw_.uid][tmodel._kwebfw_.uid] = tmodel;
                }
            }

            //Handle nested children of model
            if(model.isVisible || $K.F.RIVW) {
                $KU.each($KW.children(model), function(widget) {
                    if(_shouldRelayoutChild(widget, model)) {
                        _cascadeRelayout.call(this, widget);
                    }
                }, this);
            }

            if(pmodel) {
                index = $KW.index(model);

                //Handle direct siblings of model
                if(index !== -1 && !ignoreSiblingCascade && _shouldRelayoutSiblings(pmodel)) {
                    siblings = $KW.children(pmodel);
                    slen = siblings.length;

                    if(index < (slen-1)) {
                        for(s=(index+1); s<slen; s++) {
                            _cascadeRelayout.call(this, siblings[s], true);
                        }
                    }
                }

                //Handle direct parent of model
                if(_shouldRelayoutParent(pmodel)) {
                    _cascadeRelayout.call(this, pmodel);
                }
            } else if(model._kwebfw_.is.template && model._kwebfw_.is.cloned) {
                if(omodel && _shouldRelayoutTemplate(model)) {
                    _cascadeRelayout.call(this, omodel);
                }
            }
        }
    };


    var _cleanFlexCSS = function UI$_cleanFlexCSS(cmodel, cview, pview) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            cfinal = cmodel._kwebfw_.flex.final, style = null;

        if(cview) {
            style = {
                'align-self': null,
                'flex-direction': null,
                'margin-bottom': null,
                'margin-left': null,
                'margin-right': null,
                'margin-top': null,
                'bottom': null,
                'left': null,
                'right': null,
                'top': null
            };

            if(cfinal.maxHeight) style['max-height'] = null;
            if(cfinal.maxWidth) style['max-width'] = null;
            if(cfinal.minHeight) style['min-height'] = null;
            if(cfinal.minWidth) style['min-width'] = null;
            if(cfinal.height) style.height = null;
            if(cfinal.width) style.width = null;

            $KD.style(cview, style);

            //NOTE:: Above BLINDLY removed flex-direction style, because...
            //       layoutType of a container MIGHT have modified.
            //       To fix side-effect of above BLIND-ASSUMPTION...
            //       Assigning back correct value of flex-direction style
            if(cmodel instanceof voltmx.ui.ContainerWidget
            && cmodel.reverseLayoutDirection === true) {
                _view.ContainerWidget.reverseLayoutDirection.call(
                    cmodel, {node:cview}, true
                );
            }

            if(pview && $KD.contains(pview, cview)) {
                if($KU.is(cmodel._kwebfw_.viewPrev, 'dom')
                && $KD.contains(pview, cmodel._kwebfw_.viewPrev)) {
                    $KD.remove(cmodel._kwebfw_.viewPrev);
                    delete cmodel._kwebfw_.viewPrev;
                }

                if($KU.is(cmodel._kwebfw_.viewNext, 'dom')
                && $KD.contains(pview, cmodel._kwebfw_.viewNext)) {
                    $KD.remove(cmodel._kwebfw_.viewNext);
                    delete cmodel._kwebfw_.viewNext;
                }
            }
        }
    };


    var _cleanMeasuresAndMutates = function UI$_cleanMeasuresAndMutates(uid) {
        var model = _map[uid], _ = null, index = -1;

        delete _measures[uid];

        if(model) {
            _ = model._kwebfw_;

            if(_.view) {
                index = _mutates.indexOf(_.view);

                if(index !== -1) {
                    _mutates.splice(index, 1);
                }
            }
        }
    };


    //This function must be called in the scope of widget instance
    var _cleanUnderscore = function UI$_cleanUnderscore(meta) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_;

        if(!$KU.is(meta, 'object')) meta = {};

        //iterate and delete each key
        $KU.each(_.context, function(value, key) {
            delete this[key];
        }, _.context);

        //iterate and delete each key
        $KU.each(_.is, function(value, key) {
            var list = ['cloned', 'component', 'removed', 'template'];

            if(list.indexOf(key) === -1) {
                delete this[key];
            }
        }, _.is);

        _.modalContainer = null;
        _.inModalContainer = true;
        _.disabled = !_.prop.enable;

        if(_.flex) { //NOTE:: If "this" is a UserWidget, then _.flex is "undefined"
            _.flex.frame = {x:null, y:null, width:-1, height:-1, doLayout:false};

            //iterate and delete each key
            $KU.each(_.flex.final, function(value, key) {
                delete this[key];
            }, _.flex.final);
        }

        //iterate and delete each key
        $KU.each(_.ui, function(value, key) {
            if(key === 'scroll') {
                this[key] = {x:0, y:0, width:-1, height:-1, registered:false, status:'ended'};
            } else if(key === 'offset') {
                this[key] = {width:-1, height:-1};
            } else if(key === 'size') {
                this.size = 0;
            } else {
                delete this[key];
            }
        }, _.ui);

        if(_.selectedRows) {
            _.selectedRows.splice(0, _.selectedRows.length);
        }

        if(_.selectedItems) {
            _.selectedItems.splice(0, _.selectedItems.length);
        }

        if(_.rows) {
            _.rows.splice(0, _.rows.length);
        }

        if(_.items) {
            _.items.splice(0, _.items.length);
        }

        //TODO:: Other book keeping properties of SegmentedUI2 needs to be cleared

        if(meta.pid !== false) {
            _.pid = '';
            _.prop.parent = null;
        }

        if(meta.rid !== false) {
            _.rid = '';
        }
    };


    var _convertFlexPropertyToCssUnit = function UI$_convertFlexPropertyToCssUnit(value, layoutUnit) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KF = voltmx.flex, unit = '', len = 0;

        if($KU.is(value, 'number')) {
            unit = layoutUnit || $KF.DEFAULT_UNIT;

            if(unit === $KF.PX) {
                value = (value / $K.device.DPI);
                value = Math.round(value);
            } else if(unit === $KF.DP) {
                unit = $KF.PX;
            }
        } else if($KU.is(value, 'string')) {
            len = value.length;

            if(value.substr((len-1), 1) === $KF.PERCENTAGE) {
                unit = $KF.PERCENTAGE;
                value = parseFloat(value.replace($KF.PERCENTAGE, ''), 10);
            } else if(value.substr((len-2), 2) === $KF.PX) {
                unit = $KF.PX;
                value = (parseFloat(value.replace($KF.PX, ''), 10) / $K.device.DPI);
                value = Math.round(value);
            } else if(value.substr((len-2), 2) === $KF.DP) {
                unit = $KF.PX;
                value = parseFloat(value.replace($KF.DP, ''), 10);
            }
        }

        return (value + unit);
    };


    var _createFullHierarchy = function UI$_createFullHierarchy(widget) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            mode = $K.behavior.fullWidgetHierarchy;

        if(mode !== true) {
            return;
        }

        $KW.iterate(widget, function(model) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, id = '',
                pmodel = null, rmodel = null, uid = '';

            if(model._kwebfw_.uwi instanceof voltmx.ui.UserWidget) {
                model = model._kwebfw_.uwi;
            }

            pmodel = $KW.pmodel(model);
            rmodel = $KW.rmodel(model);
            uid = model._kwebfw_.uid;
            id = model.id;

            $KW.closest(model, function(parent) {
                if(parent._kwebfw_.uwi === model) {
                    parent = model;
                }

                if(parent === rmodel) {
                    return true;
                } else if(parent[id] !== _map[uid]) {
                    if(Object.prototype.hasOwnProperty.call(parent, id)) {
                        throw new Error('Key <'+id+'> already exists on container <'+parent.id+'>.');
                    } else if(!(parent === model || parent === pmodel)) {
                        parent[id] = _map[uid];
                    }
                }
            });
        });
    };


    //Though model can be an instanceof voltmx.ui.BasicWidget or voltmx.ui.UseWidget
    //But, ultimately it always operates on widget, which is an instance of voltmx.ui.BasicWidget
    //This function must be called in the scope of widget instance
    //And this widget instance must be a FORM/TAB/TEMPLATE/COMPONENT widget.
    //Here this can never be an instanceof voltmx.ui.UserWidget
    var _createWidgetHierarchy = function UI$_createWidgetHierarchy(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget;

        $KW.iterate(model, function(widget) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                _ = widget._kwebfw_, parent = $KW.pmodel(widget), tabpane = null;

            if(this !== parent && $KU.is(this[widget.id], 'widget') && !widget.childHierarchy) {
                throw new Error('Duplicate widget ID <'+widget.id+'> encountered.\nAlready added to parent with id="'+parent.id+'".');
            } else {
                if(this._kwebfw_.is.tab === true) {
                    tabpane = $KW.model(this._kwebfw_.tpid);

                    if($KU.is(tabpane[widget.id], 'widget')) {
                        throw new Error('Duplicate widget ID <'+widget.id+'> encountered.\nAlready added to TabPane with id="'+tabpane.id+'".');
                    } else {
                        _.wap = ((this._kwebfw_.wap || this.id) + '_' + widget.id);
                    }
                } else {
                    _.wap = ((this._kwebfw_.wap || this.id) + '_' + widget.id);
                }

                if(_.uwi instanceof voltmx.ui.UserWidget) {
                    _.uwi._kwebfw_.wap = _.wap;
                }

                //Not adding Form2 and is.template in the condition, as ...
                //Only component can be placed inside Form2/is.template/component
                _.rid = (_.is.component) ? _.uid : this._kwebfw_.uid;

                if(this !== parent) {
                    if(_.uwi instanceof voltmx.ui.UserWidget) {
                        this[_.uwi.id] = _.uwi;
                    } else {
                        this[widget.id] = widget;
                        widget.childHierarchy = true;
                    }
                }

                if(tabpane) {
                    if(_.uwi instanceof voltmx.ui.UserWidget) {
                        tabpane[_.uwi.id] = _.uwi;
                    } else {
                        tabpane[widget.id] = widget;
                    }
                }

                if(_.is.component) {
                    _updateComponentWidgetPath.call(widget, widget);
                    return true; //Do not loop over component children.
                } else if($KU.is(widget, 'widget', 'TabPane')) {
                    _updateTabPaneWidgetPath.call(widget);
                }
            }
        }, {scope:this, tabs:false});
    };


    var _deduceFinalFlexPropeties = {
        common: function UI$_deduceFinalFlexPropeties_common(model, prop, context, flex, forced, rendered) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                layoutUnit = model._kwebfw_.layoutUnit, minHeight = '',
                maxHeight = '', minWidth = '', maxWidth = '', omodel = null;

            flex.zIndex = prop.zIndex;

            if(!$KU.is(model, 'widget', 'Form2')) {
                if(!_canMeasureWidth(model, context)) {
                    flex.width = $KW.getDefaultWidth(model, context);

                    if($KU.is(flex.width, 'null')) delete flex.width;
                    else flex.width = flex.width.replace('dp', 'px');
                } else if($KW.isFlexPropertyDefined(prop, 'width')) {
                    flex.width = _convertFlexPropertyToCssUnit(prop.width, layoutUnit);
                }

                if(!_canMeasureHeight(model, context)) {
                    flex.height = $KW.getDefaultHeight(model, context);

                    if($KU.is(flex.height, 'null')) delete flex.height;
                    else flex.height = flex.height.replace('dp', 'px');
                } else if($KW.isFlexPropertyDefined(prop, 'height')) {
                    flex.height = _convertFlexPropertyToCssUnit(prop.height, layoutUnit);
                }

                if(model._kwebfw_.is.template) {
                    omodel = $KW.omodel(model);
                    if($KU.is(omodel, 'widget', 'CollectionView')
                    && omodel.layout !== voltmx.collectionview.LAYOUT_CUSTOM) {
                        if($K.ui.CollectionView.isHeaderOrFooter.call(omodel, model)) {
                            // Header/footer behavior for vertical/horizontal layout types - width/height taken from template, height/width inferred from collectionVIew size.
                            if(omodel.layout === voltmx.collectionview.LAYOUT_VERTICAL) {
                                flex.height = '100%';
                            } else {
                                flex.width = '100%';
                            }
                        }
                    }
                }
            }

            if(!flex.width && $KW.isFlexPropertyDefined(prop, 'minWidth')
            && $KW.isFlexPropertyDefined(prop, 'maxWidth')) {
                flex.minWidth = _convertFlexPropertyToCssUnit(prop.minWidth, layoutUnit);
                flex.maxWidth = _convertFlexPropertyToCssUnit(prop.maxWidth, layoutUnit);

                if(($KW.inPercent(flex.minWidth) && $KW.inPercent(flex.maxWidth))
                || (!$KW.inPercent(flex.minWidth) && !$KW.inPercent(flex.maxWidth))) {
                    if($KW.inPercent(minWidth)) {
                        minWidth = flex.minWidth.replace('%', '');
                        maxWidth = flex.maxWidth.replace('%', '');
                    } else {
                        minWidth = flex.minWidth.replace('px', '');
                        maxWidth = flex.maxWidth.replace('px', '');
                    }

                    minWidth = parseFloat(minWidth, 10);
                    maxWidth = parseFloat(maxWidth, 10);

                    if(minWidth > maxWidth) {
                        flex.minWidth = ($KW.inPercent(minWidth)) ? '0%' : '0px';
                    }
                } else if(rendered) {
                    $KU.log('warn', 'KFW-FEP:: Can\'t determine if minWidth is greater than maxWidth or not. << '+model._kwebfw_.wap+' >>');
                }
            }

            if(!flex.height && $KW.isFlexPropertyDefined(prop, 'minHeight')
            && $KW.isFlexPropertyDefined(prop, 'maxHeight')) {
                flex.minHeight = _convertFlexPropertyToCssUnit(prop.minHeight, layoutUnit);
                flex.maxHeight = _convertFlexPropertyToCssUnit(prop.maxHeight, layoutUnit);

                if(($KW.inPercent(flex.minHeight) && $KW.inPercent(flex.maxHeight))
                || (!$KW.inPercent(flex.minHeight) && !$KW.inPercent(flex.maxHeight))) {
                    if($KW.inPercent(minHeight)) {
                        minHeight = flex.minHeight.replace('%', '');
                        maxHeight = flex.maxHeight.replace('%', '');
                    } else {
                        minHeight = flex.minHeight.replace('px', '');
                        maxHeight = flex.maxHeight.replace('px', '');
                    }

                    minHeight = parseFloat(minHeight, 10);
                    maxHeight = parseFloat(maxHeight, 10);

                    if(minHeight > maxHeight) {
                        flex.minHeight = ($KW.inPercent(minHeight)) ? '0%' : '0px';
                    }
                } else if(rendered) {
                    $KU.log('warn', 'KFW-FEP:: Can\'t determine if minHeight is greater than maxHeight or not. << '+model._kwebfw_.wap+' >>');
                }
            }
        },

        fflex: function UI$_deduceFinalFlexPropeties_fflex(model, prop, context, forced, rendered) {
            var flex = {};

            _deduceFinalFlexPropeties.common(model, prop, context, flex, forced, rendered);

            if(!Object.prototype.hasOwnProperty.call(flex, 'width')) {
                _deduceFinalFlexPropeties.fflexWidthNotDefined(model, prop, context, flex);
            } else { //Width is defined
                _deduceFinalFlexPropeties.fflexWidthDefined(model, prop, context, flex);
            }

            if(!Object.prototype.hasOwnProperty.call(flex, 'height')) {
                _deduceFinalFlexPropeties.fflexHeightNotDefined(model, prop, context, flex);
            } else { //Height is defined
                _deduceFinalFlexPropeties.fflexHeightDefined(model, prop, context, flex);
            }

            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

            if(rendered) {
                if(flex.centerX || flex.centerY) {
                    $KU.log('warn', 'KFW-FEP:: centerX/centerY has performance implications on page rendering and has no direct/indirect/cascaded animation effect. << '+model._kwebfw_.wap+' >>');
                }
                if($KU.is(model, 'widget', 'Image2') && !$KW.isFixedHeight(model)) {
                    $KU.log('warn', 'KFW-FEP:: Image with preferred height has performance implications on page rendering. << '+model._kwebfw_.wap+' >>');
                }
                if($KW.layout(model) === 'fflex' && !$KW.isFixedHeight(model)) {
                    $KU.log('warn', 'KFW-FEP:: FreeForm preferred height container has performance implications on page rendering and has no direct/indirect/cascaded animation effect. << '+model._kwebfw_.wap+' >>');
                }
            }

            return flex;
        },

        fflexHeightDefined: function UI$_deduceFinalFlexPropeties_fflexHeightDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'centerY')) {
                flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'top')) {
                flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
            }

            if($KW.isFlexPropertyDefined(prop, 'bottom')) {
                flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
            }
        },

        fflexHeightNotDefined: function UI$_deduceFinalFlexPropeties_fflexHeightNotDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'top')
            && $KW.isFlexPropertyDefined(prop, 'centerY')
            && $KW.isFlexPropertyDefined(prop, 'bottom')) {
                flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
                flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'top')
            && $KW.isFlexPropertyDefined(prop, 'centerY')) {
                flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
                flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'centerY')
            && $KW.isFlexPropertyDefined(prop, 'bottom')) {
                flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
                flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'top')
            && $KW.isFlexPropertyDefined(prop, 'bottom')) {
                flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
                flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
            } else {
                if($KW.isFlexPropertyDefined(prop, 'centerY')) {
                    flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
                } else if($KW.isFlexPropertyDefined(prop, 'top')) {
                    flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
                } else if($KW.isFlexPropertyDefined(prop, 'bottom')) {
                    flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
                } else {
                    flex.top = '0px';
                }
            }

            if(!flex.minHeight && $KW.isFlexPropertyDefined(prop, 'minHeight')) {
                flex.minHeight = _convertFlexPropertyToCssUnit(prop.minHeight, layoutUnit);
            }

            if(!flex.maxHeight && $KW.isFlexPropertyDefined(prop, 'maxHeight')) {
                flex.maxHeight = _convertFlexPropertyToCssUnit(prop.maxHeight, layoutUnit);
            }
        },

        fflexWidthDefined: function UI$_deduceFinalFlexPropeties_fflexWidthDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'centerX')) {
                flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'left')) {
                flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
            }

            if($KW.isFlexPropertyDefined(prop, 'right')) {
                flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
            }
        },

        fflexWidthNotDefined: function UI$_deduceFinalFlexPropeties_fflexWidthNotDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'left')
            && $KW.isFlexPropertyDefined(prop, 'centerX')
            && $KW.isFlexPropertyDefined(prop, 'right')) {
                flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
                flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'left')
            && $KW.isFlexPropertyDefined(prop, 'centerX')) {
                flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
                flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'centerX')
            && $KW.isFlexPropertyDefined(prop, 'right')) {
                flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
                flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'left')
            && $KW.isFlexPropertyDefined(prop, 'right')) {
                flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
                flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
            } else {
                if($KW.isFlexPropertyDefined(prop, 'centerX')) {
                    flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
                } else if($KW.isFlexPropertyDefined(prop, 'left')) {
                    flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
                } else if($KW.isFlexPropertyDefined(prop, 'right')) {
                    flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
                } else {
                    flex.left = '0px';
                }
            }

            if(!flex.minWidth && $KW.isFlexPropertyDefined(prop, 'minWidth')) {
                flex.minWidth = _convertFlexPropertyToCssUnit(prop.minWidth, layoutUnit);
            }

            if(!flex.maxWidth && $KW.isFlexPropertyDefined(prop, 'maxWidth')) {
                flex.maxWidth = _convertFlexPropertyToCssUnit(prop.maxWidth, layoutUnit);
            }
        },

        hflex: function UI$_deduceFinalFlexPropeties_hflex(model, prop, context, forced, rendered) {
            var flex = {};

            _deduceFinalFlexPropeties.common(model, prop, context, flex, forced, rendered);

            if(!Object.prototype.hasOwnProperty.call(flex, 'width')) {
                _deduceFinalFlexPropeties.hflexWidthNotDefined(model, prop, context, flex);
            } else { //Width is defined
                _deduceFinalFlexPropeties.hflexWidthDefined(model, prop, context, flex);
            }

            if(!Object.prototype.hasOwnProperty.call(flex, 'height')) {
                _deduceFinalFlexPropeties.hflexHeightNotDefined(model, prop, context, flex);
            } else { //Height is defined
                _deduceFinalFlexPropeties.hflexHeightDefined(model, prop, context, flex);
            }

            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

            if(rendered) {
                if(flex.centerX || flex.centerY) {
                    $KU.log('warn', 'KFW-FEP:: centerX/centerY has performance implications on page rendering and has no direct/indirect animation effect. << '+model._kwebfw_.wap+' >>');
                }
                if($KU.is(model, 'widget', 'Image2') && !$KW.isFixedHeight(model)) {
                    $KU.log('warn', 'KFW-FEP:: Image with preferred height has performance implications on page rendering. << '+model._kwebfw_.wap+' >>');
                }
                if($KW.layout(model) === 'fflex' && !$KW.isFixedHeight(model)) {
                    $KU.log('warn', 'KFW-FEP:: FreeForm preferred height container has performance implications on page rendering and has no direct/indirect/cascaded animation effect. << '+model._kwebfw_.wap+' >>');
                }
                if($KW.inPercent(model.bottom)) {
                    $KU.log('warn', 'KFW-FEP:: UI reflection doesn\'t work if widget\'s bottom are in %, inside parent with FlowHorizontal layout. << '+model._kwebfw_.wap+' >>');
                }
            }

            return flex;
        },

        hflexHeightDefined: function UI$_deduceFinalFlexPropeties_hflexHeightDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'centerY')) {
                flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'top')) {
                flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
            }

            if($KW.isFlexPropertyDefined(prop, 'bottom')) {
                flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
            }
        },

        hflexHeightNotDefined: function UI$_deduceFinalFlexPropeties_hflexHeightNotDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'top')
            && $KW.isFlexPropertyDefined(prop, 'centerY')) {
                flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);

                if($KW.isFlexPropertyDefined(prop, 'bottom')) {
                    flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
                }
            } else if($KW.isFlexPropertyDefined(prop, 'centerY')
            && $KW.isFlexPropertyDefined(prop, 'bottom')) {
                flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
                flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'top')
            && $KW.isFlexPropertyDefined(prop, 'bottom')) {
                flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
                flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
            } else {
                if($KW.isFlexPropertyDefined(prop, 'centerY')) {
                    flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
                } else if($KW.isFlexPropertyDefined(prop, 'top')) {
                    flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
                }

                if($KW.isFlexPropertyDefined(prop, 'bottom')) {
                    flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
                }
            }

            if(!flex.minHeight && $KW.isFlexPropertyDefined(prop, 'minHeight')) {
                flex.minHeight = _convertFlexPropertyToCssUnit(prop.minHeight, layoutUnit);
            }

            if(!flex.maxHeight && $KW.isFlexPropertyDefined(prop, 'maxHeight')) {
                flex.maxHeight = _convertFlexPropertyToCssUnit(prop.maxHeight, layoutUnit);
            }
        },

        hflexWidthDefined: function UI$_deduceFinalFlexPropeties_hflexWidthDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'centerX')) {
                flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'left')) {
                flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
            }

            if($KW.isFlexPropertyDefined(prop, 'right')) {
                flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);

                if(!flex.left && !flex.centerX) {
                    flex.left = '0' + (($KW.inPercent(flex.right)) ? '%' : 'px');
                }
            }
        },

        hflexWidthNotDefined: function UI$_deduceFinalFlexPropeties_hflexWidthNotDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'left')
            && $KW.isFlexPropertyDefined(prop, 'centerX')) {
                flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);

                if($KW.isFlexPropertyDefined(prop, 'right')) {
                    flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
                }
            } else if($KW.isFlexPropertyDefined(prop, 'centerX')
            && $KW.isFlexPropertyDefined(prop, 'right')) {
                flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
                flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'left')
            && $KW.isFlexPropertyDefined(prop, 'right')) {
                flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
                flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
            } else {
                if($KW.isFlexPropertyDefined(prop, 'centerX')) {
                    flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
                } else if($KW.isFlexPropertyDefined(prop, 'left')) {
                    flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
                }

                if($KW.isFlexPropertyDefined(prop, 'right')) {
                    flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);

                    if(!flex.left && !flex.centerX) {
                        flex.left = '0' + (($KW.inPercent(flex.right)) ? '%' : 'px');
                    }
                }
            }

            if(!flex.minWidth && $KW.isFlexPropertyDefined(prop, 'minWidth')) {
                flex.minWidth = _convertFlexPropertyToCssUnit(prop.minWidth, layoutUnit);
            }

            if(!flex.maxWidth && $KW.isFlexPropertyDefined(prop, 'maxWidth')) {
                flex.maxWidth = _convertFlexPropertyToCssUnit(prop.maxWidth, layoutUnit);
            }
        },

        rflex: function UI$_deduceFinalFlexPropeties_rflex(model, prop, context, forced, rendered) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                layoutUnit = model._kwebfw_.layoutUnit, minHeight = '',
                maxHeight = '', flex = {};

            if($KU.is(prop.zIndex, 'number')) {
                flex.zIndex = prop.zIndex;
            }


            if(!$KU.is(model, 'widget', 'Form2')) {
                if(!_canMeasureHeight(model, context)) {
                    flex.height = $KW.getDefaultHeight(model, context);

                    if($KU.is(flex.height, 'null')) delete flex.height;
                    else flex.height = flex.height.replace('dp', 'px');
                } else if($KW.isFlexPropertyDefined(prop, 'height')) {
                    flex.height = _convertFlexPropertyToCssUnit(prop.height, layoutUnit);
                }
            }

            if(!flex.height && $KW.isFlexPropertyDefined(prop, 'minHeight')
            && $KW.isFlexPropertyDefined(prop, 'maxHeight')) {
                flex.minHeight = _convertFlexPropertyToCssUnit(prop.minHeight, layoutUnit);
                flex.maxHeight = _convertFlexPropertyToCssUnit(prop.maxHeight, layoutUnit);

                if(($KW.inPercent(flex.minHeight) && $KW.inPercent(flex.maxHeight))
                || (!$KW.inPercent(flex.minHeight) && !$KW.inPercent(flex.maxHeight))) {
                    if($KW.inPercent(minHeight)) {
                        minHeight = flex.minHeight.replace('%', '');
                        maxHeight = flex.maxHeight.replace('%', '');
                    } else {
                        minHeight = flex.minHeight.replace('px', '');
                        maxHeight = flex.maxHeight.replace('px', '');
                    }

                    minHeight = parseFloat(minHeight, 10);
                    maxHeight = parseFloat(maxHeight, 10);

                    if(minHeight > maxHeight) {
                        flex.minHeight = ($KW.inPercent(minHeight)) ? '0%' : '0px';
                    }
                } else if(rendered) {
                    $KU.log('warn', 'KFW-FEP:: Can\'t determine if minHeight is greater than maxHeight or not. << '+model._kwebfw_.wap+' >>');
                }
            }

            _deduceFinalFlexPropeties.rflexWidthDefined(model, prop, context, flex);

            if(!Object.prototype.hasOwnProperty.call(flex, 'height')) {
                _deduceFinalFlexPropeties.rflexHeightNotDefined(model, prop, context, flex);
            } else { //Height is defined
                _deduceFinalFlexPropeties.rflexHeightDefined(model, prop, context, flex);
            }

            return flex;
        },

        rflexHeightDefined: function UI$_deduceFinalFlexPropeties_rflexHeightDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit,
                pmodel = $KW.pmodel(model);

            if($KW.isFlexPropertyDefined(pmodel._kwebfw_.prop, 'gutterY')) {
                layoutUnit = pmodel._kwebfw_.layoutUnit;
                flex.gutterY = _convertFlexPropertyToCssUnit(pmodel._kwebfw_.prop.gutterY, layoutUnit);
            } else {
                flex.gutterY = '0px';
            }
        },

        rflexHeightNotDefined: function UI$_deduceFinalFlexPropeties_rflexHeightNotDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit,
                pmodel = $KW.pmodel(model);

            if(!flex.minHeight && $KW.isFlexPropertyDefined(prop, 'minHeight')) {
                flex.minHeight = _convertFlexPropertyToCssUnit(prop.minHeight, layoutUnit);
            }

            if(!flex.maxHeight && $KW.isFlexPropertyDefined(prop, 'maxHeight')) {
                flex.maxHeight = _convertFlexPropertyToCssUnit(prop.maxHeight, layoutUnit);
            }

            if($KW.isFlexPropertyDefined(pmodel._kwebfw_.prop, 'gutterY')) {
                layoutUnit = pmodel._kwebfw_.layoutUnit;
                flex.gutterY = _convertFlexPropertyToCssUnit(pmodel._kwebfw_.prop.gutterY, layoutUnit);
            } else {
                flex.gutterY = '0px';
            }
        },


        rflexWidthDefined: function UI$_deduceFinalFlexPropeties_rflexWidthDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;
            var $KU = $K.utils, $KA = $K.app, curBrkPoint = $KA.currentBreakpoint,
                brkPoints = null, curBrkPointIndex = null, i, cf = $KW.getRootNode(model),
                spanConfig = null, span, offsetConfig = null, offset, pmodel = $KW.pmodel(model);

            if(model.responsiveConfig) {
                spanConfig = model.responsiveConfig.span;
                if(spanConfig) {
                    brkPoints = cf.breakpoints;
                    brkPoints = brkPoints.concat(Object.keys(spanConfig));
                    brkPoints.push(constants.BREAKPOINT_MAX_VALUE);
                    //brkPoints array have duplicates, but it not be a problem.
                    brkPoints.sort(function(a, b) {
                        return a-b;
                    });

                    curBrkPointIndex = brkPoints.indexOf(curBrkPoint);
                    for(i = curBrkPointIndex; i >= 0; i--) {
                        if($KU.is(spanConfig[brkPoints[i]], 'number')) {
                            span = spanConfig[brkPoints[i]];
                            break;
                        }
                    }
                }

                offsetConfig = model.responsiveConfig.offset;
                if(offsetConfig) {
                    brkPoints = cf.breakpoints;
                    brkPoints = brkPoints.concat(Object.keys(offsetConfig));
                    brkPoints.push(constants.BREAKPOINT_MAX_VALUE);
                    brkPoints.sort(function(a, b) {
                        return a-b;
                    });

                    curBrkPointIndex = brkPoints.indexOf(curBrkPoint);
                    for(i = curBrkPointIndex; i >= 0; i--) {
                        if($KU.is(offsetConfig[brkPoints[i]], 'number')) {
                            offset = offsetConfig[brkPoints[i]];
                            break;
                        }
                    }
                }
            }
            if($KU.is(span, 'undefined') || span > 12 || span < 0) {
                span = 12;
            }

            flex.width = (100 * span)/12 + '%';

            if($KU.is(offset, 'undefined') || offset > 12 || offset < 0) {
                offset = 0;
            }
            flex.offset = (100 * offset)/12 + '%';

            if($KW.isFlexPropertyDefined(pmodel._kwebfw_.prop, 'gutterX')) {
                layoutUnit = pmodel._kwebfw_.layoutUnit;
                flex.gutterX = _convertFlexPropertyToCssUnit(pmodel._kwebfw_.prop.gutterX, layoutUnit);
            }
        },

        vflex: function UI$_deduceFinalFlexPropeties_vflex(model, prop, context, forced, rendered) {
            var flex = {};

            _deduceFinalFlexPropeties.common(model, prop, context, flex, forced, rendered);

            if(!Object.prototype.hasOwnProperty.call(flex, 'width')) {
                _deduceFinalFlexPropeties.vflexWidthNotDefined(model, prop, context, flex);
            } else { //Width is defined
                _deduceFinalFlexPropeties.vflexWidthDefined(model, prop, context, flex);
            }

            if(!Object.prototype.hasOwnProperty.call(flex, 'height')) {
                _deduceFinalFlexPropeties.vflexHeightNotDefined(model, prop, context, flex);
            } else { //Height is defined
                _deduceFinalFlexPropeties.vflexHeightDefined(model, prop, context, flex);
            }

            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

            if(rendered) {
                if(flex.centerX || flex.centerY) {
                    $KU.log('warn', 'KFW-FEP:: centerX/centerY has performance implications on page rendering and has no direct/indirect animation effect. << '+model._kwebfw_.wap+' >>');
                }
                if($KU.is(model, 'widget', 'Image2') && !$KW.isFixedHeight(model)) {
                    $KU.log('warn', 'KFW-FEP:: Image with preferred height has performance implications on page rendering. << '+model._kwebfw_.wap+' >>');
                }
                if($KW.layout(model) === 'fflex' && !$KW.isFixedHeight(model)) {
                    $KU.log('warn', 'KFW-FEP:: FreeForm preferred height container has performance implications on page rendering and has no direct/indirect/cascaded animation effect. << '+model._kwebfw_.wap+' >>');
                }
                if($KW.inPercent(model.top) || $KW.inPercent(model.bottom)) {
                    $KU.log('warn', 'KFW-FEP:: Animation doesn\'t work properly if widget\'s top/bottom are in %, inside parent with FlowVertical layout. << '+model._kwebfw_.wap+' >>');

                    if(model.top[0] === '-' || model.bottom[0] === '-') {
                        $KU.log('warn', 'KFW-FEP:: Negetive % of top/bottom, inside parent with FlowVertical layout, has performance implications on page rendering. << '+model._kwebfw_.wap+' >>');
                    }
                }
            }

            return flex;
        },

        vflexHeightDefined: function UI$_deduceFinalFlexPropeties_vflexHeightDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'centerY')) {
                flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'top')) {
                flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
            }

            if($KW.isFlexPropertyDefined(prop, 'bottom')) {
                flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);

                if(!flex.top && !flex.centerY) {
                    flex.top = '0' + (($KW.inPercent(flex.bottom)) ? '%' : 'px');
                }
            }
        },

        vflexHeightNotDefined: function UI$_deduceFinalFlexPropeties_vflexHeightNotDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'top')
            && $KW.isFlexPropertyDefined(prop, 'centerY')) {
                flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);

                if($KW.isFlexPropertyDefined(prop, 'bottom')) {
                    flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
                }
            } else if($KW.isFlexPropertyDefined(prop, 'centerY')
            && $KW.isFlexPropertyDefined(prop, 'bottom')) {
                flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
                flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'top')
            && $KW.isFlexPropertyDefined(prop, 'bottom')) {
                flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
                flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);
            } else {
                if($KW.isFlexPropertyDefined(prop, 'centerY')) {
                    flex.centerY = _convertFlexPropertyToCssUnit(prop.centerY, layoutUnit);
                } else if($KW.isFlexPropertyDefined(prop, 'top')) {
                    flex.top = _convertFlexPropertyToCssUnit(prop.top, layoutUnit);
                }

                if($KW.isFlexPropertyDefined(prop, 'bottom')) {
                    flex.bottom = _convertFlexPropertyToCssUnit(prop.bottom, layoutUnit);

                    if(!flex.top && !flex.centerY) {
                        flex.top = '0' + (($KW.inPercent(flex.bottom)) ? '%' : 'px');
                    }
                }
            }

            if(!flex.minHeight && $KW.isFlexPropertyDefined(prop, 'minHeight')) {
                flex.minHeight = _convertFlexPropertyToCssUnit(prop.minHeight, layoutUnit);
            }

            if(!flex.maxHeight && $KW.isFlexPropertyDefined(prop, 'maxHeight')) {
                flex.maxHeight = _convertFlexPropertyToCssUnit(prop.maxHeight, layoutUnit);
            }
        },

        vflexWidthDefined: function UI$_deduceFinalFlexPropeties_vflexWidthDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'centerX')) {
                flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'left')) {
                flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
            }

            if($KW.isFlexPropertyDefined(prop, 'right')) {
                flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
            }
        },

        vflexWidthNotDefined: function UI$_deduceFinalFlexPropeties_vflexWidthNotDefined(model, prop, context, flex) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, layoutUnit = model._kwebfw_.layoutUnit;

            if($KW.isFlexPropertyDefined(prop, 'left')
            && $KW.isFlexPropertyDefined(prop, 'centerX')) {
                flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);

                if($KW.isFlexPropertyDefined(prop, 'right')) {
                    flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
                }
            } else if($KW.isFlexPropertyDefined(prop, 'centerX')
            && $KW.isFlexPropertyDefined(prop, 'right')) {
                flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
                flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
            } else if($KW.isFlexPropertyDefined(prop, 'left')
            && $KW.isFlexPropertyDefined(prop, 'right')) {
                flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
                flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
            } else {
                if($KW.isFlexPropertyDefined(prop, 'centerX')) {
                    flex.centerX = _convertFlexPropertyToCssUnit(prop.centerX, layoutUnit);
                } else if($KW.isFlexPropertyDefined(prop, 'left')) {
                    flex.left = _convertFlexPropertyToCssUnit(prop.left, layoutUnit);
                }

                if($KW.isFlexPropertyDefined(prop, 'right')) {
                    flex.right = _convertFlexPropertyToCssUnit(prop.right, layoutUnit);
                }
            }

            if(!flex.minWidth && $KW.isFlexPropertyDefined(prop, 'minWidth')) {
                flex.minWidth = _convertFlexPropertyToCssUnit(prop.minWidth, layoutUnit);
            }

            if(!flex.maxWidth && $KW.isFlexPropertyDefined(prop, 'maxWidth')) {
                flex.maxWidth = _convertFlexPropertyToCssUnit(prop.maxWidth, layoutUnit);
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    var _distanceBetweenFromWidgetToWidget = function UI$_distanceBetweenFromWidgetToWidget(point, from, to) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
            pos = null, fpos = null, tpos = null;

        if(!$KW.isRendered(from) || !$KW.isRendered(to)) {
            return {x:'0dp', y:'0dp'};
        }
        pos = {};
        fpos = $KD.point(from._kwebfw_.view);
        tpos = $KD.point(to._kwebfw_.view);

        if(point.x.indexOf('dp') > 0) {
            pos.x = parseFloat(point.x.replace('dp', ''), 10);
        } else if(point.x.indexOf('px') > 0) {
            pos.x = parseFloat(point.x.replace('px', ''), 10);
            pos.x = (pos.x/$K.device.DPI);
        } else if(point.x.indexOf('%') > 0) {
            pos.x = parseFloat(point.x.replace('%', ''), 10);
            pos.x = (pos.x / 100) * from._kwebfw_.view.offsetWidth;
        }

        if(point.y.indexOf('dp') > 0) {
            pos.y = parseFloat(point.y.replace('dp', ''), 10);
        } else if(point.y.indexOf('px') > 0) {
            pos.y = parseFloat(point.y.replace('px', ''), 10);
            pos.y = (pos.y/$K.device.DPI);
        } else if(point.y.indexOf('%') > 0) {
            pos.y = parseFloat(point.y.replace('%', ''), 10);
            pos.y = (pos.y / 100) * from._kwebfw_.view.offsetHeight;
        }

        return {
            x: ((tpos.x - fpos.x - pos.x) + 'dp'),
            y: ((tpos.y - fpos.x - pos.y) + 'dp')
        };
    };


    //This function must be called in the scope of widget instance
    var _doLayout = function UI$_doLayout() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KW = $K.widget, _ = this._kwebfw_,
            view = _.view, prop = _.prop,
            flex = _.flex, frameworkDoLayout = null;

        if($KW.isRendered(this)) {
            if($KU.is($K.ui[$KW.name(this)], 'object')) {
                frameworkDoLayout = $K.ui[$KW.name(this)].doLayout;
            }

            if($KU.is(prop.doLayout, 'function') || $KU.is(frameworkDoLayout, 'function')) {
                if(!$KU.is(prop.frame.x, 'number')) prop.frame.x = view.offsetLeft;
                if(!$KU.is(prop.frame.y, 'number')) prop.frame.y = view.offsetTop;

                if(!$KU.is(prop.frame.width, 'number') || prop.frame.width < 0) {
                    prop.frame.width = view.offsetWidth;
                }
                if(!$KU.is(prop.frame.height, 'number') || prop.frame.height < 0) {
                    prop.frame.height = view.offsetHeight;
                }

                if(prop.frame.x !== flex.frame.x
                || prop.frame.y !== flex.frame.y
                || prop.frame.width !== flex.frame.width
                || prop.frame.height !== flex.frame.height) {
                    //Sync this._kwebfw_.prop.frame and this._kwebfw_.flex.frame
                    flex.frame.x = prop.frame.x;
                    flex.frame.y = prop.frame.y;
                    flex.frame.width = prop.frame.width;
                    flex.frame.height = prop.frame.height;

                    if(frameworkDoLayout) {
                        frameworkDoLayout.call(this, {
                            x:      prop.frame.x,
                            y:      prop.frame.y,
                            width:  prop.frame.width,
                            height: prop.frame.height
                        });
                    }

                    if($KU.is(prop.doLayout, 'function')) {
                        prop.frame.doLayout = true;
                        prop.doLayout.call(this, this);
                    }
                }            }
        }
    };


    var _flagForMeasure = function UI$_flagForMeasure(uid, position, direction, cview, pview, reverse) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, measure = null;

        if(!$KU.is(reverse, 'boolean')) reverse = false;

        if(!_measures[uid]) {
            _measures[uid] = {height:false, width:false, position:{}};
        }

        measure = _measures[uid];

        if(!measure.cview && $KU.is(cview, 'dom')) measure.cview = cview;
        if(!measure.pview && $KU.is(pview, 'dom')) measure.pview = pview;
        if(!$KU.is(measure.cheight, 'number')) measure.cheight = -1;
        if(!$KU.is(measure.pheight, 'number')) measure.pheight = -1;

        if(direction === 'horizontal') measure.width = true;
        else if(direction === 'vertical') measure.height = true;

        measure.position[position] = true;
        measure.position[(position+'_reverse')] = reverse;
    };


    var _flagForMutate = function UI$_flagForMutate(cmodel, cview) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, clayout = $KW.layout(cmodel);

        if(cview && _mutates[0] !== cview && !$KW.isFixedHeight(cmodel)) {
            if(clayout === 'fflex' && $KW.isFlexContainer(cmodel)) {
                _mutates.splice(0, 0, cview);
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        BasicWidget: {
            accessibilityConfig: function BasicWidget$_getter_accessibilityConfig(value) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                return $KW.getAccessibilityConfig(value);
            },

            focusSkin: function BasicWidget$_getter_focusSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return ($KU.is(value, 'null')) ? '' : value;
            },

            focusStateSkinProperties: function BasicWidget$_getter_focusStateSkinProperties(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return ($KU.is(value, 'null')) ? '' : value;
            },

            fontColor: function BasicWidget$_getter_fontColor(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return ($KU.is(value, 'null')) ? '' : value;
            },

            fontFamily: function BasicWidget$_getter_fontFamily(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return ($KU.is(value, 'null')) ? '' : value;
            },

            fontSize: function BasicWidget$_getter_fontSize(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return ($KU.is(value, 'null')) ? '' : value;
            },

            fontStyle: function BasicWidget$_getter_fontStyle(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return ($KU.is(value, 'null')) ? '' : value;
            },

            fontWeight: function BasicWidget$_getter_fontWeight(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return ($KU.is(value, 'null')) ? '' : value;
            },

            frame: function BasicWidget$_getter_frame(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    frame = {x:0, y:0, height:0, width:0};

                if(value.doLayout === true) {
                    if($KU.is(value.x, 'number')) frame.x = value.x;
                    if($KU.is(value.y, 'number')) frame.y = value.y;

                    if($KU.is(value.width, 'number') && value.width >= 0) {
                        frame.width = value.width;
                    }
                    if($KU.is(value.height, 'number') && value.height >= 0) {
                        frame.height = value.height;
                    }
                }

                return frame;
            },

            hoverStateSkinProperties: function BasicWidget$_getter_hoverStateSkinProperties(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return ($KU.is(value, 'null')) ? '' : value;
            },

            padding: function BasicWidget$_getter_padding(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return ($KU.is(value, 'null')) ? [0, 0, 0, 0] : value.slice(0);
            },

            skin: function BasicWidget$_getter_skin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return ($KU.is(value, 'null')) ? '' : value;
            }
        },

        ContainerWidget: {
            reverseLayoutDirection: function ContainerWidget$_getter_reverseLayoutDirection(value) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = this._kwebfw_.prop;

                if((prop.layoutType === voltmx.flex.FLOW_HORIZONTAL
                || prop.layoutType === voltmx.flex.RESPONSIVE_GRID)
                && $KW.shouldApplyRTL(this, 'layoutAlignment')) {
                    return !value;
                }
                return value;
            },

            responsiveConfig: function ContainerWidget$_getter_responsiveConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            }
        },

        GroupWidget: {
            masterDataMap: function GroupWidget$_getter_masterDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            }
        },

        UserWidget: {
            //
        }
    };


    var _handleVisibilityWhen = {
        notVisibleAndHasParent: function(view) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom;

            if($K.F.RIVW) {
                $KD.setAttr(view, 'hidden', true);
            } else if($KD.parent(view)) {
                $KD.remove(view);
            }
        },

        notVisibleAndNoParent: function(view) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

            if($K.F.RIVW || $KU.is(this, 'widget', 'Form2')) {
                $KD.setAttr(view, 'hidden', true);
            } else if($KD.parent(view)) {
                $KD.remove(view);
            }
        },

        visibleAndHasParent: function(view) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                $KD = $K.dom, index = -1, widgets = null,
                pmodel = null, holder = null, next = null;

            if($K.F.RIVW) {
                $KD.removeAttr(view, 'hidden');
            } else {
                holder = $KW.holder($KW.pmodel(this));

                if(holder && !$KD.contains(holder, view)) {
                    index = $KW.index(this);
                    pmodel = $KW.pmodel(this);
                    widgets = $KW.children(pmodel);
                    next = widgets[++index];

                    if(!$K.F.RIVW) {
                        while($KU.is(next, 'widget') && !next.isVisible) {
                            next = widgets[++index];
                        }
                    }

                    if(!$KU.is(next, 'widget')) {
                        $KW.addToView(holder, view);
                    } else {
                        $KD.before(next._kwebfw_.view, view);
                    }

                    _ifContainsMediaWidgetThenPlay(this);
                    _ifContainsSegmentHandleLazyLoad(this);
                }
            }
        },

        visibleAndNoParent: function(view) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KW = $K.widget, $KD = $K.dom, $KG = $K.globals,
                _ = this._kwebfw_, owner = null, holder = null;

            if($K.F.RIVW || $KU.is(this, 'widget', 'Form2')) {
                $KD.removeAttr(view, 'hidden');
            } else if($KU.is(this, 'widget', 'Form2')) {
                $KD.add($KG.appForms, view);
            } else if(_.is.template && _.is.cloned && _.oid) {
                owner = $KW.model(_.oid);
                holder = $KW.holder(owner);

                if(!$KD.contains(holder, view)) {
                    $KD.addAt(holder, view/* , index */); //TODO:: Which index ???
                }
            }
        }
    };


    var _ifContainsMediaWidgetThenPlay = function UI$_ifContainsMediaWidgetThenPlay(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

        if($KU.is(model, 'widget', 'Camera')) {
            _playMediaWidget(model);
        } else if($KU.is(model, 'widget', 'Video')) {
            if(model._kwebfw_.playstate) {
                _playMediaWidget(model);
            }
        } else {
            $KU.each($KW.children(model), function(cmodel) {
                if($KU.is(cmodel, 'widget', 'Camera')) {
                    _playMediaWidget(cmodel);
                } else if($KU.is(cmodel, 'widget', 'Video')) {
                    if(cmodel._kwebfw_.playstate) {
                        _playMediaWidget(cmodel);
                    }
                }
            });
        }
    };

    var _ifContainsSegmentHandleLazyLoad = function UI$_ifContainsSegmentHandleLazyLoad(model) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

        if($KU.is(model, 'widget', 'SegmentedUI2')) {
            if($KW.shouldLazyLoad.SegmentedUI2.call(model)) {
                model.data = model.data; //eslint-disable-line no-self-assign
            }
        } else {
            $KU.each($KW.children(model), function(cmodel) {
                _ifContainsSegmentHandleLazyLoad(cmodel);
            });
        }
    };

    //This functions will be called in the scope of widget instance
    //And this widget instance must be a FORM/COMPONENT widget.
    var _invokeAddWidgets = function UI$_invokeAddWidgets(arg0) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, self = null;

        if(arg0 === true) {
            self = this;

            $KU.defineGetter(window, this.id, function() {
                return self;
            });
        }

        if(!$KU.is(this._kwebfw_.children, 'array')
        && ($KU.is(this.addWidgets, 'function')
        || ($KU.is(this.addWidgets, 'string') && this.addWidgets))) {
            if($KU.is(this.addWidgets, 'function')) {
                if(this instanceof voltmx.ui.Form2)
                    currentFormName = this.id;
                this.addWidgets.call(this, this);
            } else if($KU.is(this.addWidgets, 'string') && this.addWidgets) {
                //Not sure when this condition arises
                window[this.addWidgets].call(this, this);
            }
        }
    };


    var _isWidgetIdExists = function UI$_isWidgetIdExists(id, pmodel, rmodel) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

        if($KU.is(pmodel[id], 'widget')) {
            flag = true;
        } else if($KU.is(rmodel, 'widget')
        && $KU.is(rmodel[id], 'widget')) {
            flag = true;
        }

        return flag;
    };


    //This functions will be called in the scope of widget instance
    var _markRelayoutOnAdd = function UI$_markRelayoutOnAdd(position) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

        if($KW.isFlexContainer(this)) {
            $KW.markRelayout(this);

            if($KW.layout(this) !== 'fflex') {
                $KU.each($KW.children(this), function(cmodel, index) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    if(index > position) {
                        $KW.markRelayout(cmodel);
                    }
                }, this);
            }
        }
    };


    //This functions will be called in the scope of widget instance
    var _markRelayoutOnRemove = function UI$_markRelayoutOnRemove(position) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

        if($KW.isFlexContainer(this)) {
            $KW.markRelayout(this);

            if($KW.layout(this) !== 'fflex') {
                $KU.each($KW.children(this), function(cmodel, index) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    if(index >= position) {
                        $KW.markRelayout(cmodel);
                    }
                }, this);
            }
        }
    };


    //This functions will be called in the scope of widget instance
    var _mirrorContentAlignment = function UI$_mirrorContentAlignment() {
        var prop = this._kwebfw_.prop, mirrorMap = {};

        mirrorMap[constants.CONTENT_ALIGN_TOP_LEFT] = constants.CONTENT_ALIGN_TOP_RIGHT;
        mirrorMap[constants.CONTENT_ALIGN_TOP_CENTER] = constants.CONTENT_ALIGN_TOP_CENTER;
        mirrorMap[constants.CONTENT_ALIGN_TOP_RIGHT] = constants.CONTENT_ALIGN_TOP_LEFT;
        mirrorMap[constants.CONTENT_ALIGN_MIDDLE_LEFT] = constants.CONTENT_ALIGN_MIDDLE_RIGHT;
        mirrorMap[constants.CONTENT_ALIGN_CENTER] = constants.CONTENT_ALIGN_CENTER;
        mirrorMap[constants.CONTENT_ALIGN_MIDDLE_RIGHT] = constants.CONTENT_ALIGN_MIDDLE_LEFT;
        mirrorMap[constants.CONTENT_ALIGN_BOTTOM_LEFT] = constants.CONTENT_ALIGN_BOTTOM_RIGHT;
        mirrorMap[constants.CONTENT_ALIGN_BOTTOM_CENTER] = constants.CONTENT_ALIGN_BOTTOM_CENTER;
        mirrorMap[constants.CONTENT_ALIGN_BOTTOM_RIGHT] = constants.CONTENT_ALIGN_BOTTOM_LEFT;

        prop.contentAlignment = mirrorMap[prop.contentAlignment];
    };


    //This functions will be called in the scope of widget instance
    var _mirrorFlexPosition = function UI$_mirrorFlexPosition() {
        var prop = this._kwebfw_.prop, left = prop.left, right = prop.right;

        prop.left = right;
        prop.right = left;
    };


    //This functions will be called in the scope of widget instance
    var _mirrorPadding = function UI$_mirrorPadding() {
        var prop = this._kwebfw_.prop, left = 0, right = 0;

        if(prop.padding) {
            left = prop.padding[0];
            right = prop.padding[2];
            prop.padding[0] = right;
            prop.padding[2] = left;
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        BasicWidget: function BasicWidget$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) $KU.defineProperty(_, 'ns', 'voltmx.ui.BasicWidget', null);
            if(!_.name) $KU.defineProperty(_, 'name', 'BasicWidget', null);
            if(!_.layoutUnit) $KU.defineProperty(_, 'layoutUnit', '', true);
            if(!_.context) $KU.defineProperty(_, 'context', {}, null);
            if(!_.is) $KU.defineProperty(_, 'is', {}, null);
            if(!_.prop) $KU.defineProperty(_, 'prop', {}, null);
            if(!_.flex) {
                $KU.defineProperty(_, 'flex', {}, null);

                //This stores the resultant/final flex properties to be used.
                $KU.defineProperty(_.flex, 'final', {}, true);

                //This holds widget frame, helps to find if any change happened or not
                $KU.defineProperty(_.flex, 'frame', {x:null, y:null, width:-1, height:-1, doLayout:false});
            }
            if(!_.skinStateObj) $KU.defineProperty(_, 'skinStateObj', {bgType:voltmx.skin.BACKGROUND_TYPE_SINGLE_COLOR}, null);
            if(!_.ui) $KU.defineProperty(_, 'ui', {}, null);
            if(!_.pid) $KU.defineProperty(_, 'pid', '', true);
            if(!_.rid) $KU.defineProperty(_, 'rid', '', true);
            if(!_.uid) $KU.defineProperty(_, 'uid', '', true);
            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', '', true);
            }
            if(typeof _.disabled !== 'boolean') {
                $KU.defineProperty(_, 'disabled', false, true);
            }
            if(typeof _.inModalContainer !== 'boolean') {
                $KU.defineProperty(_, 'inModalContainer', true, true);
            }
        },

        ContainerWidget: function ContainerWidget$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) $KU.defineProperty(_, 'ns', 'voltmx.ui.ContainerWidget', null);
            if(!_.name) $KU.defineProperty(_, 'name', 'ContainerWidget', null);
        },

        GroupWidget: function GroupWidget$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) $KU.defineProperty(_, 'ns', 'voltmx.ui.GroupWidget', null);
            if(!_.name) $KU.defineProperty(_, 'name', 'GroupWidget', null);
        },

        UserWidget: function UserWidget$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) $KU.defineProperty(_, 'ns', 'voltmx.ui.UserWidget', null);
            if(!_.name) $KU.defineProperty(_, 'name', 'UserWidget', null);
            if(!_.context) $KU.defineProperty(_, 'context', {}, null);
            if(!_.is) $KU.defineProperty(_, 'is', {}, null);
            if(!_.prop) $KU.defineProperty(_, 'prop', {}, null);
            if(!_.rid) $KU.defineProperty(_, 'rid', '', true);
            if(!_.uid) $KU.defineProperty(_, 'uid', '', true);
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        BasicWidget: function BasicWidget$_postInitialization(bconfig/*, lconfig, pspconfig*/) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, _ = this._kwebfw_,
                _setRootContextOfForm = function(fmodel, id, appName) {
                    if($K.behavior.isCompositeApp) {
                        if(!_root[appName]) _root[appName] = {};

                        _root[appName][id] = fmodel;
                    } else {
                        _root[id] = fmodel;
                    }
                };

            $KU.defineProperty(_, 'uid', ('K'+$KU.uid()), false);
            $KU.defineProperty(_, 'rid', '', true); //_.rid will be updated in _createWidgetHierarchy function
            _map[_.uid] = this;
            $KU.defineProperty(_, 'wap', '', true); //_.wap will be updated in _createWidgetHierarchy function
            _.disabled = !this.enable;

            if($KW.shouldApplyRTL(this, 'contentAligment')) {
                _mirrorContentAlignment.call(this);
            }

            if($KW.shouldApplyRTL(this, 'flexPosition')) {
                _mirrorPadding.call(this);
                _mirrorFlexPosition.call(this);
            }

            if(_.is.component || $KU.is(this, 'widget', 'Form2')) {
                //NOTE:: Below 3 lines also there, in $KW.root() definition of this file.
                _.rid = _.uid;
                _.wap = _.prop.id;

                if($KU.is(this, 'widget', 'Form2')) {
                    _setRootContextOfForm(this, _.prop.id, bconfig.appName);
                }
            }
        },

        ContainerWidget: function ContainerWidget$_postInitialization(/*bconfig, lconfig, pspconfig*/) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, self = this;

            if(_.is.component || $KU.is(this, 'widget', 'Form2')) {
                if(this._voltmxControllerName) {
                    _invokeAddWidgets.call(this);
                } else if($KU.is(this, 'widget', 'Form2')) {
                    $KU.defineGetter(window, this.id, function() {
                        _invokeAddWidgets.call(self, true);
                        return self;
                    });

                    $KU.defineSetter(window, this.id, function() {
                        return self;
                    });
                }
            }
        },

        UserWidget: function UserWidget$_postInitialization(/*bconfig, lconfig, pspconfig*/) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_;

            $KU.defineProperty(_, 'uid', ('K'+$KU.uid()), false);
            $KU.defineProperty(_, 'rid', '', true); //_.rid will be updated in _createWidgetHierarchy function
            _map[_.uid] = this;
            $KU.defineProperty(_, 'wap', '', true); //_.wap will be updated in _createWidgetHierarchy function

            _.rid = _.uid;
            _.wap = _.prop.id;
        }
    };


    var _playMediaWidget = function UI$_playMediaWidget(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(model);

        if(el.video) {
            if(el.video.src || el.video.srcObject || model.source) {
                el.video.play();
            }
        }
    };


    //This functions will be called in the scope of widget instance
    var _preparePaddingStyle = function UI$_preparePaddingStyle() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            padding = this.padding, unit = '', style = '';

        if(padding) {
            if($KU.is(this, 'widget', 'Button')
            || $KU.is(this, 'widget', 'Browser')
            || $KU.is(this, 'widget', 'Calendar')
            || $KU.is(this, 'widget', 'CheckBoxGroup')
            || $KU.is(this, 'widget', 'Label')
            || $KU.is(this, 'widget', 'ListBox')
            || $KU.is(this, 'widget', 'RadioButtonGroup')
            || $KU.is(this, 'widget', 'RichText')
            || $KU.is(this, 'widget', 'TextArea2')
            || $KU.is(this, 'widget', 'TextBox2')
            || $KU.is(this, 'widget', 'DataGrid')
            || $KW.isResponsiveContainer(this)) {
                padding = this.padding;
                unit = (this.paddingInPixel ? 'px' : '%');

                style += (padding[1]+unit+' '+ padding[2]+unit
                    +' '+ padding[3]+unit +' '+ padding[0]+unit);
            }
        }

        return style;
    };


    //This function must be called in the scope of form instance
    var _relayout = function UI$_relayout(model, forced, callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, playout = '',
            _ = model._kwebfw_, pmodel = null, frameworkDoLayout = null;

        if(_.view && (model.isVisible || $K.F.RIVW)) {
            forced = (forced === true) ? true : false;

            if(!forced && _.relayout !== true
            && $KW.isOwnerWidget(model)
            && _dirty.templates[_.uid]) {
                _relayoutOwner.call(this, model, forced, callback);
            } else if(forced || _.relayout === true) {
                pmodel = $KW.pmodel(model);

                if(pmodel) {
                    playout = $KW.layout(pmodel);
                } else if(model === this || _.is.tab === true || _.is.template === true) {
                    playout = $KW.layout(voltmx.flex.FLOW_VERTICAL);
                }

                if($KU.is($K.ui[$KW.name(model)], 'object')) {
                    frameworkDoLayout = $K.ui[$KW.name(model)].doLayout;
                }

                if((forced || _.relayout === true)
                && ($KU.is(model.doLayout, 'function')
                || $KU.is(frameworkDoLayout, 'function'))) {
                    _doLayoutWidgtsList.push(model);
                }

                delete _.relayout;
                delete _dirty.cascade[_.uid];
                delete _dirty.widgets[_.uid];

                _.prop.frame = {x:null, y:null, width:-1, height:-1, doLayout:false};


                _applyFlexRule.call(model, playout, 'horizontal', null, forced, true);
                _applyFlexRule.call(model, playout, 'vertical', null, forced, true);

                _relayoutOwner.call(this, model, true, callback);

                if($KU.is(callback, 'function')) {
                    callback(model);
                }
            }
        }
    };


    //This function must be called in the scope of form instance
    var _relayoutOwner = function UI$_relayoutOwner(model, forced, callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            _ = model._kwebfw_, relayoutTemplate = null;

        if($KW.isOwnerWidget(model)) {
            //This function must be called in the scope of form instance
            relayoutTemplate = function(tpl, cb) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                $KW.iterate(tpl, function(widget) {
                    var $K = voltmx.$kwebfw$, _ = widget._kwebfw_;

                    if(_.view && (widget.isVisible || $K.F.RIVW)) {
                        _relayout.call(this, widget, forced, cb);
                    } else {
                        delete _.relayout;
                        return true;
                    }
                }, {scope:this, tabs:false});
            };

            if(forced) {
                $KU.each(_.rows, function(tmodel) {
                    relayoutTemplate.call(this, tmodel, callback);
                }, this);

                $KU.each(_.items, function(tmodel) {
                    relayoutTemplate.call(this, tmodel, callback);
                }, this);
            } else {
                $KU.each(_dirty.templates[_.uid], function(tmodel) {
                    relayoutTemplate.call(this, tmodel, callback);
                }, this);
            }

            delete _dirty.templates[_.uid];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        BasicWidget: function BasicWidget$_relayoutActiveTriggerer() {
            return [
                'bottom', 'centerX', 'centerY', 'height',
                'isVisible', 'left', 'maxHeight',
                'maxWidth', 'minHeight', 'minWidth', 'right',
                'top', 'width'
            ];
        },

        ContainerWidget: function ContainerWidget$_relayoutActiveTriggerer() {
            return ['layoutType', 'reverseLayoutDirection'];
        },

        GroupWidget: function GroupWidget$_relayoutActiveTriggerer() {
            return [];
        },

        UserWidget: function UserWidget$_relayoutActiveTriggerer() {
            //
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        BasicWidget: function BasicWidget$_relayoutPassiveTriggerer() {
            return ['activeStateSkin', 'focusSkin', 'hoverSkin', 'skin'];
        },

        ContainerWidget: function ContainerWidget$_relayoutPassiveTriggerer() {
            return [];
        },

        GroupWidget: function GroupWidget$_relayoutPassiveTriggerer() {
            return [];
        },

        UserWidget: function UserWidget$_relayoutPassiveTriggerer() {
            //
        }
    };


    var _removeFullHierarchy = function UI$_removeFullHierarchy(widget) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            mode = $K.behavior.fullWidgetHierarchy;

        if(mode !== true) {
            return;
        }

        $KW.iterate(widget, function(model) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget,
                pmodel = null, rmodel = null, id = '';

            if(model._kwebfw_.uwi instanceof voltmx.ui.UserWidget) {
                model = model._kwebfw_.uwi;
            }

            pmodel = $KW.pmodel(model);
            rmodel = $KW.rmodel(model);
            id = model.id;

            $KW.closest(model, function(parent) {
                if(parent._kwebfw_.uwi === model) {
                    parent = model;
                }

                if(parent === rmodel) {
                    return true;
                } else if(parent[id] === model) {
                    if(!(parent === model || parent === pmodel)) {
                        delete parent[id];
                    }
                }
            });
        });
    };


    //This function must be called in the scope of widget instance
    var _removeWidget = function UI$_removeWidget(widget) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KA = $K.app,
            fmodel = $KW.fmodel(this), rmodel = null, widgets = null,
            proxy = $KW.proxy(widget), pmodel = $KW.pmodel(proxy), wlen = -1,
            _ = (proxy) ? proxy._kwebfw_ : null, modal = null, index = -1;

        if($KU.is(proxy, 'widget')) {
            if(pmodel === this) {
                index = $KW.index(proxy);
                widgets = $KW.children(this);
                wlen = widgets.length;
            }

            if(index >= 0 && index < wlen) {
                rmodel = $KW.rmodel(this);
                _removeWidgetFromView.call(proxy);
                _removeFullHierarchy(widget);
                this._kwebfw_.children.splice(index, 1);

                if(_.uwi instanceof voltmx.ui.UserWidget) {
                    delete this[_.uwi.id];
                } else {
                    delete this[proxy.id];
                }

                _removeWidgetHierarchy.call(this, proxy, rmodel, true);

                _markRelayoutOnRemove.call(this, index);

                if(fmodel && fmodel === $KW.model($KA.currentFormUID)
                && $KW.contains(widget, fmodel._kwebfw_.modalContainer, false)) {
                    modal = $KW.deduceModalContainer(fmodel);
                    $KW.updateModalContainer(fmodel, modal);
                }
            }
        }
    };


    //This function must be called in the scope of widget instance
    var _removeWidgetFromView = function UI$_removeWidgetFromView() {
        var $K = voltmx.$kwebfw$, $KW = $K.widget;

        $KW.removeView(this);
    };


    //Here cmodel can never be an instanceof voltmx.ui.UserWidget
    //This function must be called in the scope of widget instance
    var _removeWidgetHierarchy = function UI$_removeWidgetHierarchy(cmodel, rmodel, remove) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, _ = cmodel._kwebfw_;

        if($KU.is(rmodel, 'widget')) {
            if(remove === true) {
                _.is.removed = true;
            }

            $KW.iterate(cmodel, function(widget) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    _ = widget._kwebfw_, meta = {pid:false, rid:false},
                    tpmodel = null;

                if(remove === false || _.is.removed !== true) {
                    _.is.removed = null;
                }

                if(remove === true) {
                    if(!_.is.component && !(_.is.tab === true && _.tpid)) {
                        meta.rid = true;
                    }

                    if(_.is.removed === true) {
                        meta.pid = true;
                    }

                    tpmodel = (!_.is.component) ? rmodel : $KW.rmodel($KW.pmodel(widget));

                    if(tpmodel && tpmodel._kwebfw_.is.tab && tpmodel._kwebfw_.tpid) {
                        tpmodel = $KW.model(tpmodel._kwebfw_.tpid);
                    } else tpmodel = null; //IMPORTANT:: Don't remove this else condition

                    if(tpmodel) delete tpmodel[widget.id];

                    if(_.uwi instanceof voltmx.ui.UserWidget) {
                        delete rmodel[_.uwi.id];
                        _.uwi._kwebfw_.wap = '';
                        _cleanUnderscore.call(_.uwi, meta);
                    } else {
                        delete rmodel[widget.id];
                    }

                    _.wap = '';
                    _cleanUnderscore.call(widget, meta);

                    if(_.is.component || $KU.is(widget, 'widget', 'TabPane')) {
                        $KU.each($KW.children(widget, {tabs:true}), function(model) {
                            _removeWidgetHierarchy.call(this, model, this, false);
                        }, widget);

                        widget._flush();
                        return true;
                    }
                }

                widget._flush();
            }, {scope:this, tabs:false});
        }
    };


    var _resolveMeasures = function UI$_resolveMeasures() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        //Populate height/width
        $KU.each(_measures, function $each_resolveMeasures_height_width_pheight(info/*, uid*/) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, pelement = null;

            if(info.cview) {
                if(info.height && (!$KU.is(info.cheight, 'number') || info.cheight < 0)) {
                    info.cheight = info.cview.offsetHeight;
                }

                if(info.width && (!$KU.is(info.cwidth, 'number') || info.cwidth < 0)) {
                    info.cwidth = info.cview.offsetWidth;
                }
            }

            if(info.pview) {
                if(!$KU.is(info.pheight, 'number') || info.pheight < 0) {
                    if(!pelement) pelement = $KW.el(info.pview);

                    if($KU.is(pelement.scrolee, 'dom')) {
                        info.pheight = pelement.scrolee.offsetHeight;
                    } else if($KU.is(pelement.viewport, 'dom')) {
                        info.pheight = pelement.viewport.offsetHeight;
                    } else if($KU.is(pelement.node, 'dom')) {
                        info.pheight = pelement.node.offsetHeight;
                    }
                }
            }
        });

        $KU.each(_measures, function $each_resolveMeasures_position(info, uid) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, calc = '',
                $KW = $K.widget, $KD = $K.dom, sprop = '',
                cfinal = null, cmodel = null, pmodel = null, playout = '';

            if(info.cview) {
                cmodel = $KW.model(uid);
                pmodel = $KW.pmodel(cmodel);
                playout = $KW.layout(pmodel);

                $KU.each(info.position, function(flag, position) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget;

                    if(flag === true && position.indexOf('_reverse') === -1) {
                        cfinal = cmodel._kwebfw_.flex.final;

                        if(position === 'centerX') {
                            if(playout === 'fflex') {
                                if(info.position[(position+'_reverse')] === true) {
                                    calc = 'calc(100% - '+info.cwidth+'px - ('+cfinal.centerX+' - '+info.cwidth+'px/2))';
                                    sprop = 'right';
                                } else {
                                    calc = 'calc('+cfinal.centerX+' - '+info.cwidth+'px/2)';
                                    sprop = 'left';
                                }
                            } else {
                                calc = 'calc('+cfinal.centerX+' - '+info.cwidth+'px/2)';
                                sprop = 'marginLeft';
                            }

                            $KD.style(info.cview, sprop, calc);
                        } else if(position === 'centerY') {
                            if(playout === 'vflex') {
                                if($KW.inPercent(cfinal.centerY)) {
                                    sprop = cfinal.centerY.replace('%', '');
                                    sprop = parseFloat(sprop, 10);
                                    sprop = ((sprop * info.pheight) / 100);
                                } else {
                                    sprop = cfinal.centerY.replace('px', '');
                                    sprop = parseFloat(sprop, 10);
                                }
                                calc = 'calc('+sprop+'px - '+info.cheight+'px/2)';
                                sprop = 'marginTop';
                            } else if(playout === 'fflex') {
                                if(info.position[(position+'_reverse')] === true) {
                                    calc = 'calc(100% - '+info.cheight+'px - ('+cfinal.centerY+' - '+info.cheight+'px/2))';
                                    sprop = 'bottom';
                                } else {
                                    calc = 'calc('+cfinal.centerY+' - '+info.cheight+'px/2)';
                                    sprop = 'top';
                                }
                            } else if(playout === 'hflex') {
                                calc = 'calc('+cfinal.centerY+' - '+info.cheight+'px/2)';
                                sprop = ($KW.inPercent(cfinal.centerY)) ? 'top' : 'marginTop';
                            }

                            $KD.style(info.cview, sprop, calc);
                        } else if(playout === 'vflex'
                        && ['top', 'bottom'].indexOf(position) >= 0) {
                            calc = cfinal[position].replace('%', '');
                            calc = parseFloat(calc, 10);
                            calc = ((calc * info.pheight) / 100);
                            sprop = (position === 'top') ? 'marginTop' : 'marginBottom';

                            $KD.style(info.cview, sprop, (calc+'px'));
                        }
                    }
                });
            }
        });

        _measures = {}; //Reset
    };


    var _resolveMutates = function UI$_resolveMutates() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, cacheOverflowY = {};

        //Save scroll position, before setting height to zero
        if($KU.scrollType() === 'native') {
            $KU.each(_mutates, function $each_resolveMutates_getScrollPosition(view) {
                var $K = voltmx.$kwebfw$, scroll = null, el = null,
                    $KW = $K.widget, model = $KW.model(view);

                if(view && $KW.isFlexContainer(model)
                && $KW.name(model) !== 'FlexContainer') {
                    el = $KW.el(view);
                    scroll = model._kwebfw_.ui.scroll;

                    scroll.left = el.viewport.scrollLeft;
                    scroll.top = el.viewport.scrollTop;
                }
            });
        }

        //Set height to zero
        $KU.each(_mutates, function $each_resolveMutates_setHeightToZero(view) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                $KD = $K.dom, model = $KW.model(view);

            if(view) {
                $KD.style(view, 'height', '0px');

                $KU.each($KW.children(model), function $each_resolveMutates_cacheOverflowY(cmodel) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = cmodel._kwebfw_, overflow = '';

                    if(_.view && (cmodel.isVisible || $K.F.RIVW)) {
                        overflow = $KD.style(_.view, 'overflow-y');

                        if(overflow !== 'hidden') {
                            cacheOverflowY[_.uid] = overflow;
                            $KD.style(_.view, 'overflowY', 'hidden');
                        }
                    }
                });
            }
        });

        //Set height to scrollHeight
        $KU.each(_mutates, function $each_resolveMutates_setToScrollHeight(view) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom;

            view && $KD.style(view, 'height', (view.scrollHeight+'px'));
        });

        $KU.each(cacheOverflowY, function $each_resolveMutates_applyOverflowY(value, uid) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                model = $KW.model(uid), _ = model._kwebfw_;

            if(value) {
                $KD.style(_.view, 'overflowY', value);
            } else {
                $KD.style(_.view, 'overflow-y', null);
            }
        });

        //Reassign scroll position
        $KU.each(_mutates, function $each_resolveMutates_setScrollPosition(view) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, scroll = null,
                $KW = $K.widget, model = $KW.model(view), el = null;

            if(view && $KW.isFlexContainer(model)
            && $KW.name(model) !== 'FlexContainer') {
                el = $KW.el(view);
                scroll = model._kwebfw_.ui.scroll;

                if($KU.scrollType() === 'native') {
                    el.viewport.scrollLeft = scroll.left;
                    el.viewport.scrollTop = scroll.top;
                    delete scroll.left; delete scroll.top;
                } else {
                    //TODO:: Scroll instance x,y to be set
                }
            }
        });

        _mutates = []; //Reset
    };


    var _setCenterYStyleInsideVerticalLayout = function UI$_setCenterYStyleInsideVerticalLayout(value, fprop, cmodel, cview, pview) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, flag = true,
            inPercent = false, final = cmodel._kwebfw_.flex.final, size = final.height;

        if($KU.is(value, 'number')) value += 'px';
        inPercent = $KW.inPercent(value);

        if(size) {
            if((inPercent && $KW.inPercent(size))
            ||(!inPercent && !$KW.inPercent(size))) {
                value = parseFloat(value.replace('%', ''), 10);
                size = parseFloat(size.replace('%', ''), 10);
                value = (value - (size / 2));

                if(!inPercent || (inPercent && value > 0)) {
                    value += (inPercent) ? '%' : 'px';
                    flag = _setTopOrBottomStyleInsideVerticalLayout(value, fprop, cmodel, cview, pview);
                }
            }
        }

        return flag;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        BasicWidget: {
            accessibilityConfig: function BasicWidget$_setter_accessibilityConfig(old) {
                var prop = this._kwebfw_.prop, a11y = prop.accessibilityConfig;

                if(!old && a11y && a11y.tagName) {
                    delete a11y.tagName;
                } else if(old && old.tagName && !a11y) {
                    prop.accessibilityConfig = {tagName: old.tagName};
                } else if(old && a11y) {
                    if(!old.tagName && a11y.tagName) {
                        delete a11y.tagName;
                    } else if(old.tagName && !a11y.tagName) {
                        a11y.tagName = old.tagName;
                    } else if(old.tagName && a11y.tagName) {
                        a11y.tagName = old.tagName;
                    }
                }
            },

            contentAligment: function BasicWidget$_setter_contentAligment() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                if($KW.shouldApplyRTL(this, 'contentAligment')
                    && $K.behavior.rtlMirroringInWidgetPropertySetter === true) {
                    _mirrorContentAlignment.call(this);
                }
            },

            enable: function BasicWidget$_setter_enable(/*old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                $KW.iterate(this, function(model) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget,
                        _ = model._kwebfw_, pmodel = $KW.pmodel(model);

                    _.disabled = !model.enable;
                    $KW.handleTabPaneEnablement(model, true);
                    $KW.setupUIInteraction(model, $KW.focusableElement(model));

                    if(pmodel) {
                        if(pmodel._kwebfw_.disabled && !_.disabled) {
                            _.disabled = true;

                            $KW.handleTabPaneEnablement(model, true);
                            //For performance, not to again iterate over each widget again
                            //Calling DOM manipulation API "$KW.setupUIInteraction()" here.
                            $KW.setupUIInteraction(model, $KW.focusableElement(model));
                        }
                    } else {
                        return true; //Break the loop
                    }
                }, {scope:this, tabs:false});
            },

            isVisible: function BasicWidget$_setter_isVisible(old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                if(old === false) {
                    $KW.iterate(this, function(model) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget;

                        if(model !== this) {
                            if(model.isVisible) {
                                $KW.markRelayout(model);
                            } else {
                                return true; //Break the loop
                            }
                        }
                    }, {scope:this, tabs:true});
                }
            },

            left: function BasicWidget$_setter_left(old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    prop = this._kwebfw_.prop,
                    left = prop.left;

                if($KW.shouldApplyRTL(this, 'flexPosition')
                    && $K.behavior.rtlMirroringInWidgetPropertySetter === true) {
                    prop.right = left;
                    prop.left = old;
                }
            },

            padding: function BasicWidget$_setter_padding() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                if($KW.shouldApplyRTL(this, 'flexPosition')
                && $K.behavior.rtlMirroringInWidgetPropertySetter === true) {
                    _mirrorPadding.call(this);
                }
            },

            right: function BasicWidget$_setter_right(old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    prop = this._kwebfw_.prop, right = prop.right;

                if($KW.shouldApplyRTL(this, 'flexPosition')
                && $K.behavior.rtlMirroringInWidgetPropertySetter === true) {
                    prop.left = right;
                    prop.right = old;
                }
            }
        },

        ContainerWidget: {
            addWidgets: function ContainerWidget$_setter_addWidgets(/*old*/) {
                delete this._kwebfw_.children;
            },

            layoutType: function ContainerWidget$_setter_layoutType(/*old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

                if($KW.isFlexContainer(this)) {
                    $KU.each($KW.children(this), function(cmodel) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget;

                        $KW.markRelayout(cmodel);
                    });
                }
            },

            gutterX: function ContainerWidget$_setter_gutterX() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
                    prop = this._kwebfw_.prop;

                if(prop.layoutType === voltmx.flex.RESPONSIVE_GRID) {
                    $KU.each($KW.children(this), function(cmodel) {
                        $KW.markRelayout(cmodel);
                    }, this);
                }
            },

            gutterY: function ContainerWidget$_setter_gutterY() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
                    prop = this._kwebfw_.prop;

                if(prop.layoutType === voltmx.flex.RESPONSIVE_GRID) {
                    $KU.each($KW.children(this), function(cmodel) {
                        $KW.markRelayout(cmodel);
                    }, this);
                }
            }
        },

        GroupWidget: {
            //
        },

        UserWidget: {
            //
        }
    };


    var _setTopOrBottomStyleInsideVerticalLayout = function UI$_setTopOrBottomStyleInsideVerticalLayout(value, fprop, cmodel, cview, pview) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, shim = null, sprop = '', flag = true;

        if($KU.is(value, 'number')) value += 'px';

        if(!$KW.inPercent(value) || value === '0%') { //value not in percentage
            sprop = (fprop === 'top') ? 'marginTop' : 'marginBottom';
            $KD.style(cview, sprop, value);

            flag = false;
        } else if(value[0] !== '-') { //value in +ve percentage
            if((!$KU.is(cmodel._kwebfw_.viewPrev, 'dom') && fprop === 'top')
            || (!$KU.is(cmodel._kwebfw_.viewNext, 'dom') && fprop === 'bottom')) {
                shim = $KD.create('DIV');
                $KD.setAttr(shim, 'kr', 'spacer');
            }

            if(!$KU.is(cmodel._kwebfw_.viewPrev, 'dom') && fprop === 'top') {
                cmodel._kwebfw_.viewPrev = shim;
            } else if(!$KU.is(cmodel._kwebfw_.viewNext, 'dom') && fprop === 'bottom') {
                cmodel._kwebfw_.viewNext = shim;
            }

            if($K.F.RIVW) {
                if(cmodel.isVisible) {
                    if(fprop === 'bottom') {
                        $KD.removeAttr(cmodel._kwebfw_.viewNext, 'hidden');
                    } else if(fprop === 'top') {
                        $KD.removeAttr(cmodel._kwebfw_.viewPrev, 'hidden');
                    }
                } else {
                    if(fprop === 'bottom') {
                        $KD.setAttr(cmodel._kwebfw_.viewNext, 'hidden', true);
                    } else if(fprop === 'top') {
                        $KD.setAttr(cmodel._kwebfw_.viewPrev, 'hidden', true);
                    }
                }
            }

            if(pview && $KD.contains(pview, cview)) {
                if(fprop === 'top') {
                    if(!$KD.contains(pview, cmodel._kwebfw_.viewPrev)) {
                        $KD.before(cview, cmodel._kwebfw_.viewPrev);
                        $KD.style(cmodel._kwebfw_.viewPrev, 'height', value);
                    }
                } else if(fprop === 'bottom') {
                    if(!$KD.contains(pview, cmodel._kwebfw_.viewNext)) {
                        $KD.next(cview, cmodel._kwebfw_.viewNext);
                        $KD.style(cmodel._kwebfw_.viewNext, 'height', value);
                    }
                }
            }

            flag = false;
        }

        return flag;
    };


    //All the functions will be called in the scope of widget instance
    var _shouldDeduceModalContainer = {
        onAdd: function UI$_shouldDeduceModalContainer_onAdd() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

            $KW.iterate(this, function(widget) {
                if(widget.isModalContainer) {
                    flag = true;
                    return true;
                }
            }, {tabs:false});

            return flag;
        },

        onZindexChange: function UI$_shouldDeduceModalContainer_onZindexChange(newVal, oldVal) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, flag = false,
                fmodel = $KW.fmodel(this), modal = fmodel._kwebfw_.modalContainer;

            if(modal) {
                if($KU.is(newVal, 'integer') && oldVal === voltmx.flex.ZINDEX_AUTO) {
                    flag = true;
                } else if($KU.is(oldVal, 'integer') && newVal === voltmx.flex.ZINDEX_AUTO) {
                    if(this.isModalContainer || $KW.contains(this, modal, false)) {
                        flag = true;
                    }
                } else if($KU.is(newVal, 'integer') && $KU.is(oldVal, 'integer')) {
                    if($KW.contains(this, modal, false) && (newVal < oldVal)) {
                        flag = true;
                    } else if((newVal > oldVal) && this.isModalContainer) {
                        flag = true;
                    }
                }
            }

            return flag;
        }
    };


    var _shouldRelayoutChild = function UI$_shouldRelayoutChild(model, pmodel) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            possibilityOfParentHeightChange = false,
            possibilityOfParentWidthChange = false,
            pfinal = pmodel._kwebfw_.flex.final,
            flag = false, final = model._kwebfw_.flex.final;

        if(!flag) {
            if(!pfinal.height
            || pfinal.height !== pmodel.height
            || $KW.isImplicitHeight(pmodel)) {
                possibilityOfParentHeightChange = true;
            }

            if(possibilityOfParentHeightChange) {
                if((final.height && $KW.inPercent(final.height) && final.height !== '0%')
                || (final.minHeight && $KW.inPercent(final.minHeight) && final.minHeight !== '0%')
                || (final.maxHeight && $KW.inPercent(final.maxHeight) && final.maxHeight !== '0%')
                || (final.centerY && $KW.inPercent(final.centerY) && final.centerY !== '0%')
                || (final.top && $KW.inPercent(final.top) && final.top !== '0%')
                || final.bottom || $KW.isImplicitHeight(model)) {
                    flag = true;
                }
            }
        }

        if(!flag) {
            if((pfinal.width !== pmodel.width
            && !(pfinal.width === '100%' && !pmodel.width))
            || $KW.isImplicitWidth(pmodel)) {
                possibilityOfParentWidthChange = true;
            }

            if(possibilityOfParentWidthChange) {
                if((final.width && $KW.inPercent(final.width) && final.width !== '0%')
                || (final.minWidth && $KW.inPercent(final.minWidth) && final.minWidth !== '0%')
                || (final.maxWidth && $KW.inPercent(final.maxWidth) && final.maxWidth !== '0%')
                || (final.centerX && $KW.inPercent(final.centerX) && final.centerX !== '0%')
                || (final.left && $KW.inPercent(final.left) && final.left !== '0%')
                || final.right || $KW.isImplicitWidth(model)) {
                    flag = true;
                }
            }
        }

        return flag;
    };


    var _shouldRelayoutParent = function UI$_shouldRelayoutParent(pmodel) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

        if(!$KW.isFixedHeight(pmodel) || !$KW.isFixedWidth(pmodel)) {
            flag = true;
        }

        return flag;
    };


    var _shouldRelayoutSiblings = function UI$_shouldRelayoutSiblings(pmodel) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

        if(['hflex', 'vflex'].indexOf($KW.layout(pmodel) >= 0)) {
            flag = true;
        }

        return flag;
    };


    var _shouldRelayoutTemplate = function UI$_shouldRelayoutTemplate(tmodel) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

        if(!$KW.isFixedHeight(tmodel)) {
            flag = true;
        }

        return flag;
    };


    //Here model can never be an instance of voltmx.ui.UserWidget
    //This function must be called in the scope of widget instance
    var _updateComponentWidgetPath = function UI$_updateComponentWidgetPath(model) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget;

        $KW.iterate(model, function(widget) {
            var _ = widget._kwebfw_;

            if(widget !== this) {
                _.wap = (this._kwebfw_.wap + '_' + widget.id);

                if(_.uwi instanceof voltmx.ui.UserWidget) {
                    _.uwi._kwebfw_.wap = _.wap;
                }

                if(_.is.component) {
                    _updateComponentWidgetPath.call(widget, widget);
                    return true; //Do not loop over component children.
                }
            }
        }, {scope:this, tabs:false});
    };


    //This function must be called in the scope of TabPane widget instance
    var _updateTabPaneWidgetPath = function UI$_updateTabPaneWidgetPath() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_;

        $KU.each(_.tabs, function(tab/*, index*/) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget;

            $KW.iterate(this[tab.id], function(model) {
                var _ = model._kwebfw_;

                _.wap = (this._kwebfw_.wap + _.wap);

                if(_.uwi instanceof voltmx.ui.UserWidget) {
                    _.uwi._kwebfw_._wap = _.wap;
                }
            }, {scope:this, tabs:false});
        }, this);
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        BasicWidget: {
            accessibilityConfig: function BasicWidget$_valid_accessibilityConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    $KW = $K.widget, flag = false, tag = '',
                    name = '', supportedTags = {
                        FlexContainer: ['div', 'th', 'td', 'tr'],
                        FlexScrollContainer: ['div', 'th', 'td'],
                        Label: ['label', 'div', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
                        SegmentedUI2: ['ul', 'ol', 'div', 'table']
                    };

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;

                    if(value && Object.prototype.hasOwnProperty.call(value, 'tagName')) {
                        tag = value.tagName;
                        name = $KW.name(this);

                        if(!($KU.is(tag, 'string') && supportedTags[name]
                        && supportedTags[name].indexOf(tag.toLowerCase()) >= 0)) {
                            flag = false;
                        }
                    }
                }

                return flag;
            },

            activeStateSkin: function BasicWidget$_valid_activeStateSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            anchorPoint: function BasicWidget$_valid_anchorPoint(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')
                && $KU.is(value.x, 'number')
                && value.x >= 0 && value.x <= 1
                && $KU.is(value.y, 'number')
                && value.y >= 0 && value.y <= 1) {
                    flag = true;
                }

                return flag;
            },

            autogrowMode: function BasicWidget$_valid_autogrowMode(value) {
                var flag = false;

                if(value === voltmx.flex.AUTOGROW_HEIGHT
                || value === voltmx.flex.AUTOGROW_NONE) {
                    flag = true;
                }

                return flag;
            },

            backgroundColor: function BasicWidget$_valid_backgroundColor(value) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                return $KW.skinUtils.validColorValue(value);
            },

            backgroundColorMultiStepGradient: function BasicWidget$_valid_backgroundColorMultiStepGradient(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            backgroundColorTwoStepGradient: function BasicWidget$_valid_backgroundColorTwoStepGradient(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            backgroundImage: function BasicWidget$_valid_backgroundImage(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            blur: function BasicWidget$_valid_blur(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.enabled, 'boolean')
                && $KU.is(value.value, 'number')) {
                    flag = true;
                }
                if(flag) {
                    if(value.value < 0) {
                        flag = [{enabled:value.enabled, value: 0}, true];
                    } else if(value.value > 100) {
                        flag = [{enabled:value.enabled, value: 100}, true];
                    }
                }

                return flag;
            },

            borderColor: function BasicWidget$_valid_borderColor(value) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                return $KW.skinUtils.validColorValue(value);
            },

            borderWidth: function BasicWidget$_valid_borderWidth(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return _validPositionalUnit(value, true) || $KU.is(value, 'object') || $KU.is(value, 'null');
            },

            blockedUISkin: function BasicWidget$_valid_blockedUISkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            bottom: function BasicWidget$_valid_bottom(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            centerX: function BasicWidget$_valid_centerX(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            centerY: function BasicWidget$_valid_centerY(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            contentAlignment: function BasicWidget$_valid_contentAlignment(value) {
                var flag = false, options = [
                    constants.CONTENT_ALIGN_BOTTOM_CENTER,
                    constants.CONTENT_ALIGN_BOTTOM_LEFT,
                    constants.CONTENT_ALIGN_BOTTOM_RIGHT,
                    constants.CONTENT_ALIGN_MIDDLE_LEFT,
                    constants.CONTENT_ALIGN_MIDDLE_RIGHT,
                    constants.CONTENT_ALIGN_TOP_CENTER,
                    constants.CONTENT_ALIGN_TOP_LEFT,
                    constants.CONTENT_ALIGN_TOP_RIGHT,
                    constants.CONTENT_ALIGN_CENTER
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            cornerRadius: function BasicWidget$_valid_cornerRadius(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return _validPositionalUnit(value, true) || $KU.is(value, 'object') || $KU.is(value, 'null');
            },

            cursorType: function BasicWidget$_valid_cursorType(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            doLayout: function BasicWidget$_valid_doLayout(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            enable: function BasicWidget$_valid_enable(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            focusSkin: function BasicWidget$_valid_focusSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            focusStateSkinProperties: function BasicWidget$_valid_focusStateSkinProperties(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            fontColor: function BasicWidget$_valid_fontColor(value) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                return $KW.skinUtils.validColorValue(value);
            },

            fontFamily: function BasicWidget$_valid_fontFamily(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            fontSize: function BasicWidget$_valid_fontSize(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            fontStyle: function BasicWidget$_valid_fontStyle(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false, options = [
                    '',
                    voltmx.skin.FONT_STYLE_ITALIC,
                    voltmx.skin.FONT_STYLE_NONE,
                    voltmx.skin.FONT_STYLE_UNDERLINE
                ];

                if(($KU.is(value, 'string')&& (options.indexOf(value) >= 0))
                || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            fontWeight: function BasicWidget$_valid_fontWeight(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false, options = [
                    '',
                    voltmx.skin.FONT_WEIGHT_BOLD,
                    voltmx.skin.FONT_WEIGHT_NORMAL
                ];

                if(($KU.is(value, 'string')&& (options.indexOf(value) >= 0))
                || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            frame: function BasicWidget$_valid_frame(value) {
                var flag = false, $K = voltmx.$kwebfw$, $KU = $K.utils;

                if($KU.is(value, 'object')
                && ($KU.is(value.x, 'null') || $KU.is(value.x, 'number'))
                && ($KU.is(value.y, 'null') || $KU.is(value.y, 'number'))
                && ($KU.is(value.height, 'null') || ($KU.is(value.height, 'number') && value.height >= 0))
                && ($KU.is(value.width, 'null') || ($KU.is(value.width, 'number') && value.width >= 0))) {
                    flag = true;
                }

                return flag;
            },

            //It specifies, height of the widget and measured along the y-axis.
            height: function BasicWidget$_valid_height(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            hoverSkin: function BasicWidget$_valid_hoverSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            hoverStateSkinProperties: function BasicWidget$_valid_hoverStateSkinProperties(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {//todo
                    flag = true;
                }

                return flag;
            },


            id: function BasicWidget$_valid_id(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, regexp = null, flag = false;

                regexp = /^[a-zA-Z][a-zA-Z0-9]*$/;

                if($KU.is(value, 'string') && value && regexp.test(value)) {
                    flag = true;
                }

                if(flag && ['metaInfo', 'template', 'onRowClick', 'onItemSelect'].indexOf(value) >= 0) {
                    flag = false;
                }

                return flag;
            },

            info: function BasicWidget$_valid_info(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')) {
                    flag = true;
                } else if(!flag && $K.F.EIWP && $KU.is(value, 'null')) {
                    flag = [null, true];
                }

                return flag;
            },

            isVisible: function BasicWidget$_valid_isVisible(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                } else if(!flag && $K.F.EIWP) {
                    flag = [!!value, true];
                }

                return flag;
            },

            left: function BasicWidget$_valid_left(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            maxHeight: function BasicWidget$_valid_maxHeight(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            maxWidth: function BasicWidget$_valid_maxWidth(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            minHeight: function BasicWidget$_valid_minHeight(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            minWidth: function BasicWidget$_valid_minWidth(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            onBlur: function BasicWidget$_valid_onBlur(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onClick: function BasicWidget$_valid_onClick(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    flag = false, widgets = [
                        'Button', 'Map', 'RichText',
                        'FlexContainer', 'FlexScrollContainer'
                    ];

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'function')
                && ($KU.is(this, 'widget', 'CustomWidget')
                || widgets.indexOf($KW.name(this)) === -1)) {
                    flag = false;
                } else if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onFocus: function BasicWidget$_valid_onFocus(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onHover: function BasicWidget$_valid_onHover(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    flag = false, widgets = ['FlexContainer'];

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'function')
                && ($KU.is(this, 'widget', 'CustomWidget')
                || widgets.indexOf($KW.name(this)) === -1)) {
                    flag = false;
                } else if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onScrollWidgetPosition: function BasicWidget$_valid_onScrollWidgetPosition(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'function')
                && ($KU.is(this, 'widget', 'CustomWidget'))) {
                    flag = false;
                } else if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onTouchEnd: function BasicWidget$_valid_onTouchEnd(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'function')
                && ($KU.is(this, 'widget', 'CustomWidget'))) {
                    flag = false;
                } else if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onTouchMove: function BasicWidget$_valid_onTouchMove(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'function')
                && ($KU.is(this, 'widget', 'CustomWidget'))) {
                    flag = false;
                } else if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onTouchStart: function BasicWidget$_valid_onTouchStart(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'function')
                && ($KU.is(this, 'widget', 'CustomWidget'))) {
                    flag = false;
                } else if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            opacity: function BasicWidget$_valid_opacity(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number')) {
                    flag = true;
                }

                if(flag) {
                    if(value < 0) {
                        flag = [0, true];
                    } else if(value > 1) {
                        flag = [1, true];
                    }
                }

                return flag;
            },

            padding: function BasicWidget$_valid_padding(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'array') && value.length === 4
                && $KU.is(value[0], 'number') && value[0] >= 0
                && $KU.is(value[1], 'number') && value[1] >= 0
                && $KU.is(value[2], 'number') && value[2] >= 0
                && $KU.is(value[3], 'number') && value[3] >= 0) {
                    flag = true;
                }

                return flag;
            },

            paddingInPixel: function BasicWidget$_valid_paddingInPixel(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = true;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            parent: function BasicWidget$_valid_parent(value) {
                var flag = false, $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

                if($KW.isContainer(value) || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            retainContentAlignment: function BasicWidget$_valid_retainContentAlignment(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            retainFlexPositionProperties: function BasicWidget$_valid_retainFlexPositionProperties(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            right: function BasicWidget$_valid_right(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            shadowColor: function BasicWidget$_valid_shadowColor(value) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                return $KW.skinUtils.validColorValue(value);
            },

            shadowOffset: function BasicWidget$_valid_shadowOffset(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')) {
                    if($KU.is(value.x, 'number')
                    && $KU.is(value.y, 'number')) {
                        flag = true;
                    }
                }

                return flag;
            },

            shadowRadius: function BasicWidget$_valid_shadowRadius(value) {
                return _validPositionalUnit(value, true);
            },

            skin: function BasicWidget$_valid_skin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            textShadowColor: function BasicWidget$_valid_textShadowColor(value) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                return $KW.skinUtils.validColorValue(value);
            },

            textShadowOffset: function BasicWidget$_valid_textShadowOffset(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')) {
                    if($KU.is(value.x, 'number')
                    && $KU.is(value.y, 'number')) {
                        flag = true;
                    }
                }

                return flag;
            },

            textShadowRadius: function BasicWidget$_valid_textShadowRadius(value) {
                return _validPositionalUnit(value, true);
            },

            top: function BasicWidget$_valid_top(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            transform: function BasicWidget$_valid_transform(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')
                || value instanceof voltmx.$kwebfw$.Transform) {
                    flag = true;
                }

                return flag;
            },

            width: function BasicWidget$_valid_width(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            zIndex: function BasicWidget$_valid_zIndex(value) {
                var flag = false, $K = voltmx.$kwebfw$, $KU = $K.utils;

                if(value === voltmx.flex.ZINDEX_AUTO
                || ($KU.is(value, 'integer') && value <= 2147482647)) {
                    flag = true;
                }

                return flag;
            }
        },

        ContainerWidget: {
            _voltmxControllerName: function ContainerWidget$_valid__voltmxControllerName(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') && value
                && (!this._voltmxControllerName
                || value === this._voltmxControllerName)) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'FlexContainer')) {
                        if($K.app.allowSetter_voltmxControllerName
                        || this._kwebfw_.is.template || _root[this.id]) {
                            flag = true;
                        }
                    }
                }

                return flag;
            },

            addWidgets: function ContainerWidget$_valid_addWidgets(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    }
                }

                return flag;
            },

            appName: function ContainerWidget$_valid_appName(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') && value) {
                    flag = true;
                }

                return flag;
            },

            gutterX : function ContainerWidget$_valid_gutterX(value) {
                return _validPositionalUnit(value, true);
            },

            gutterY: function ContainerWidget$_valid_gutterY(value) {
                return _validPositionalUnit(value, true);
            },

            init: function ContainerWidget$_valid_init(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    }
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            layoutType: function ContainerWidget$_valid_layoutType(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KA = $K.app,
                    $KF = voltmx.flex, flag = false, children = null, options = [
                        $KF.FREE_FORM,
                        $KF.FLOW_HORIZONTAL,
                        $KF.FLOW_VERTICAL,
                        $KF.VBOX_LAYOUT,
                        $KF.RESPONSIVE_GRID
                    ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }
                if(value === voltmx.flex.RESPONSIVE_GRID
                && $KA.allowSetter_responsiveGridLayoutType !== true) {
                    children = $KW.children(this);
                    $KU.each(children, function(child) {
                        if(!$KU.is(child, 'widget', 'FlexContainer')) {
                            throw new $KU.error(
                                '100', 'Error',
                                'Unable to change layout, invalid widget ' + child.id
                            );
                        }
                    });
                }

                return flag;
            },

            onBreakpointHandler: function ContainerWidget$_valid_onBreakpointHandler(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    }
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onBreakpointChange: function ContainerWidget$_valid_onBreakpointChange(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    }
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onDestroy: function ContainerWidget$_valid_onDestroy(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    }
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onHide: function ContainerWidget$_valid_onHide(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    }
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onInit: function ContainerWidget$_valid_onInit(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                //This is applicable if this container is a TAB_CONTAINER
                //It's validity is checked at basic__render function
                if($KU.is(value, 'null') || $KU.is(value, 'function')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onResize: function ContainerWidget$_valid_onResize(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    }
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            postShow: function ContainerWidget$_valid_postShow(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    }
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            preShow: function ContainerWidget$_valid_preShow(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    }
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            responsiveConfig: function ContainerWidget$_valid_responsiveConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            retainFlowHorizontalAlignment: function ContainerWidget$_valid_retainFlowHorizontalAlignment(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, flag = false;

                if($KW.isFlexContainer(this) && $KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            reverseLayoutDirection: function ContainerWidget$_valid_reverseLayoutDirection(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, flag = false;

                if($KW.isFlexContainer(this) && $KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            }
        },

        GroupWidget: {
            onSelection: function GroupWidget$_valid_onSelection(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            }
        },

        UserWidget: {
            addWidgets: function UserWidget$_valid_addWidgets(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    }
                }

                return flag;
            },

            anchorPoint: function UserWidget$_valid_anchorPoint(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')
                && $KU.is(value.x, 'number')
                && value.x >= 0 && value.x <= 1
                && $KU.is(value.y, 'number')
                && value.y >= 0 && value.y <= 1) {
                    flag = true;
                }

                return flag;
            },

            appName: function UserWidget$_valid_appName(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') && value) {
                    flag = true;
                }

                return flag;
            },

            backgroundColor: function UserWidget$_valid_backgroundColor(value) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                return $KW.skinUtils.validColorValue(value);
            },

            backgroundColorMultiStepGradient: function UserWidget$_valid_backgroundColorMultiStepGradient(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            backgroundColorTwoStepGradient: function UserWidget$_valid_backgroundColorTwoStepGradient(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            backgroundImage: function UserWidget$_valid_backgroundImage(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            borderColor: function UserWidget$_valid_borderColor(value) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                return $KW.skinUtils.validColorValue(value);
            },

            borderWidth: function UserWidget$_valid_borderWidth(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return _validPositionalUnit(value, true) || $KU.is(value, 'object') || $KU.is(value, 'null');
            },

            bottom: function UserWidget$_valid_bottom(value) {
                return _validPositionalUnit(value);
            },

            centerX: function UserWidget$_valid_centerX(value) {
                return _validPositionalUnit(value);
            },

            centerY: function UserWidget$_valid_centerY(value) {
                return _validPositionalUnit(value);
            },

            contentAlignment: function UserWidget$_valid_contentAlignment(value) {
                var flag = false, options = [
                    constants.CONTENT_ALIGN_BOTTOM_CENTER,
                    constants.CONTENT_ALIGN_BOTTOM_LEFT,
                    constants.CONTENT_ALIGN_BOTTOM_RIGHT,
                    constants.CONTENT_ALIGN_MIDDLE_LEFT,
                    constants.CONTENT_ALIGN_MIDDLE_RIGHT,
                    constants.CONTENT_ALIGN_TOP_CENTER,
                    constants.CONTENT_ALIGN_TOP_LEFT,
                    constants.CONTENT_ALIGN_TOP_RIGHT,
                    constants.CONTENT_ALIGN_CENTER
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            cornerRadius: function UserWidget$_valid_cornerRadius(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return _validPositionalUnit(value, true) || $KU.is(value, 'object') || $KU.is(value, 'null');
            },

            focusSkin: function UserWidget$_valid_focusSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            focusStateSkinProperties: function UserWidget$_valid_focusStateSkinProperties(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            doLayout: function UserWidget$_valid_doLayout(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            frame: function UserWidget$_valid_frame(value) {
                var flag = false, $K = voltmx.$kwebfw$, $KU = $K.utils;

                if($KU.is(value, 'object')
                && ($KU.is(value.x, 'null') || $KU.is(value.x, 'number'))
                && ($KU.is(value.y, 'null') || $KU.is(value.y, 'number'))
                && ($KU.is(value.height, 'null') || ($KU.is(value.height, 'number') && value.height >= 0))
                && ($KU.is(value.width, 'null') || ($KU.is(value.width, 'number') && value.width >= 0))) {
                    flag = true;
                }

                return flag;
            },

            //It specifies, height of the widget and measured along the y-axis.
            height: function UserWidget$_valid_height(value) {
                return _validPositionalUnit(value, true);
            },

            hoverStateSkinProperties: function UserWidget$_valid_hoverStateSkinProperties(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            id: function UserWidget$_valid_id(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, regexp = null, flag = false;

                regexp = new RegExp('^[a-zA-Z][a-zA-Z0-9]*$');

                if($KU.is(value, 'string') && value && regexp.test(value)) {
                    flag = true;
                }

                if(flag && ['metaInfo', 'template', 'onRowClick', 'onItemSelect'].indexOf(value) >= 0) {
                    flag = false;
                }

                return flag;
            },

            info: function UserWidget$_valid_info(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')) {
                    flag = true;
                } else if(!flag && $K.F.EIWP && $KU.is(value, 'null')) {
                    flag = [null, true];
                }

                return flag;
            },

            init: function UserWidget$_valid_init(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'function')) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        flag = true;
                    } else if($KU.is(this, 'widget', 'component')) {
                        flag = true;
                    }
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            isVisible: function UserWidget$_valid_isVisible(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                } else if(!flag && $K.F.EIWP) {
                    flag = [!!value, true];
                }

                return flag;
            },

            left: function UserWidget$_valid_left(value) {
                return _validPositionalUnit(value);
            },

            maxHeight: function UserWidget$_valid_maxHeight(value) {
                return _validPositionalUnit(value, true);
            },

            maxWidth: function UserWidget$_valid_maxWidth(value) {
                return _validPositionalUnit(value, true);
            },

            minHeight: function UserWidget$_valid_minHeight(value) {
                return _validPositionalUnit(value, true);
            },

            minWidth: function UserWidget$_valid_minWidth(value) {
                return _validPositionalUnit(value, true);
            },

            onTouchEnd: function UserWidget$_valid_onTouchEnd(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'function')
                && ($KU.is(this, 'widget', 'CustomWidget'))) {
                    flag = false;
                } else if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onTouchMove: function UserWidget$_valid_onTouchMove(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'function')
                && ($KU.is(this, 'widget', 'CustomWidget'))) {
                    flag = false;
                } else if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onTouchStart: function UserWidget$_valid_onTouchStart(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'function')
                && ($KU.is(this, 'widget', 'CustomWidget'))) {
                    flag = false;
                } else if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            opacity: function UserWidget$_valid_opacity(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number')) {
                    flag = true;
                }

                if(flag) {
                    if(value < 0) {
                        flag = [0, true];
                    } else if(value > 1) {
                        flag = [1, true];
                    }
                }

                return flag;
            },

            padding: function UserWidget$_valid_padding(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'array') && value.length === 4
                && $KU.is(value[0], 'number') && value[0] >= 0
                && $KU.is(value[1], 'number') && value[1] >= 0
                && $KU.is(value[2], 'number') && value[2] >= 0
                && $KU.is(value[3], 'number') && value[3] >= 0) {
                    flag = true;
                }

                return flag;
            },

            paddingInPixel: function UserWidget$_valid_paddingInPixel(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = true;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            parent: function UserWidget$_valid_parent(value) {
                var flag = false, $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

                if($KW.isContainer(value) || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            right: function UserWidget$_valid_right(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    flag = _validPositionalUnit(value);

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')
                    || $KU.is(value, 'undefined')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            skin: function UserWidget$_valid_skin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            top: function UserWidget$_valid_top(value) {
                return _validPositionalUnit(value);
            },

            transform: function UserWidget$_valid_transform(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')
                || value instanceof voltmx.$kwebfw$.Transform) {
                    flag = true;
                }

                return flag;
            },

            width: function UserWidget$_valid_width(value) {
                return _validPositionalUnit(value, true);
            },

            zIndex: function UserWidget$_valid_zIndex(value) {
                var flag = false, $K = voltmx.$kwebfw$, $KU = $K.utils;

                if(value === voltmx.flex.ZINDEX_AUTO
                || ($KU.is(value, 'integer') && value <= 2147482647)) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    var _validPositionalUnit = function UI$_validPositionalUnit(value, positive) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

        if($KU.is(value, 'string')) {
            value = value.toLowerCase();

            if($K.F.EIWP && $KU.is(value, 'numeric')) {
                value = parseFloat(value, 10);
            }
        }

        flag = $KU.is(value, 'size', positive);

        return (flag ? [value, flag] : flag);
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        BasicWidget: {
            accessibilityConfig: function BasicWidget$_view_accessibilityConfig(/*el, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                $KW.accessibility(this);
            },

            activeStateSkin: function BasicWidget$_view_activeStateSkin(/*el, old*/) {},

            anchorPoint: function BasicWidget$_view_anchorPoint(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, tOrigin = '50% 50%';

                if(this.anchorPoint) {
                    tOrigin = $KW.skinUtils.stringifyAnchorPoint(this.anchorPoint);
                }
                $KD.style(el.node, 'transformOrigin', tOrigin);
            },

            autogrowMode: false,

            backgroundColor: function BasicWidget$_view_backgroundColor(el, old) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom, backgroundStyle;

                this._kwebfw_.skinStateObj.bgType = voltmx.skin.BACKGROUND_TYPE_SINGLE_COLOR;

                backgroundStyle = $KW.skinUtils.background({
                    backgroundType: this._kwebfw_.skinStateObj.bgType,
                    backgroundColor: this.backgroundColor,
                    backgroundImage: this.backgroundImage,
                    backgroundColorMultiStepGradient: this.backgroundColorMultiStepGradient,
                    backgroundColorTwoStepGradient: this.backgroundColorTwoStepGradient
                });

                if(backgroundStyle) {
                    $KD.style(el.node, 'background', backgroundStyle);
                } else if(!$KU.is(old, 'null') && old !== '') {
                    $KD.style(el.node, 'background', null);
                }
            },


            backgroundColorMultiStepGradient: function BasicWidget$_view_backgroundColorMultiStepGradient(el, old) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom, backgroundStyle;

                this._kwebfw_.skinStateObj.bgType = voltmx.skin.BACKGROUND_TYPE_MULTI_STEP_GRADIENT;

                backgroundStyle = $KW.skinUtils.background({
                    backgroundType: this._kwebfw_.skinStateObj.bgType,
                    backgroundColor: this.backgroundColor,
                    backgroundImage: this.backgroundImage,
                    backgroundColorMultiStepGradient: this.backgroundColorMultiStepGradient,
                    backgroundColorTwoStepGradient: this.backgroundColorTwoStepGradient
                });

                if(backgroundStyle) {
                    $KD.style(el.node, 'background', backgroundStyle);
                } else if(!$KU.is(old, 'null') && old !== '') {
                    $KD.style(el.node, 'background', null);
                }
            },

            backgroundColorTwoStepGradient: function BasicWidget$_view_backgroundColorTwoStepGradient(el, old) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom, backgroundStyle;

                this._kwebfw_.skinStateObj.bgType = voltmx.skin.BACKGROUND_TYPE_TWO_STEP_GRADIENT;

                backgroundStyle = $KW.skinUtils.background({
                    backgroundType: this._kwebfw_.skinStateObj.bgType,
                    backgroundColor: this.backgroundColor,
                    backgroundImage: this.backgroundImage,
                    backgroundColorMultiStepGradient: this.backgroundColorMultiStepGradient,
                    backgroundColorTwoStepGradient: this.backgroundColorTwoStepGradient
                });

                if(backgroundStyle) {
                    $KD.style(el.node, 'background', backgroundStyle);
                } else if(!$KU.is(old, 'null') && old !== '') {
                    $KD.style(el.node, 'background', null);
                }
            },

            backgroundImage: function BasicWidget$_view_backgroundImage(el, old) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom, backgroundStyle;

                this._kwebfw_.skinStateObj.bgType = voltmx.skin.BACKGROUND_TYPE_IMAGE;

                backgroundStyle = $KW.skinUtils.background({
                    backgroundType: this._kwebfw_.skinStateObj.bgType,
                    backgroundColor: this.backgroundColor,
                    backgroundImage: this.backgroundImage,
                    backgroundColorMultiStepGradient: this.backgroundColorMultiStepGradient,
                    backgroundColorTwoStepGradient: this.backgroundColorTwoStepGradient
                });

                if(backgroundStyle) {
                    $KD.style(el.node, 'background', backgroundStyle);
                } else if(!$KU.is(old, 'null') && old !== '') {
                    $KD.style(el.node, 'background', null);
                }
            },

            blur: function BasicWidget$_view_blur(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, filter = '';

                if(this.blur.enabled) {
                    filter = ('blur(' + this.blur.value + 'px)');
                    $KD.style(el.node, 'filter', filter);
                } else {
                    $KD.style(el.node, 'filter', null);
                }
            },

            borderColor: function BasicWidget$_view_borderColor(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom;

                if(this.borderColor) {
                    $KD.style(el.node, 'borderStyle', 'solid');
                    $KD.style(el.node, 'borderColor', $KW.skinUtils.processColorValue(this.borderColor));
                } else {
                    $KD.style(el.node, 'border-style', null);
                    $KD.style(el.node, 'border-color', null);
                }
            },

            borderWidth: function BasicWidget$_view_borderWidth(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, value;

                if($KU.is(this.borderWidth, 'number')) {
                    $KD.style(el.node, 'borderWidth', (this.borderWidth+'px'));
                } else if($KU.is(this.borderWidth, 'string')) {
                    if(this.borderWidth) {
                        $KD.style(el.node, 'borderWidth', this.borderWidth);
                    } else {
                        $KD.style(el.node, 'border-width', 'null');
                    }
                } else if($KU.is(this.borderWidth, 'object')) {
                    value = (this.borderWidth.top || 0) + 'px'
                        + ' ' + (this.borderWidth.right || 0) + 'px'
                        + ' ' + (this.borderWidth.bottom || 0) + 'px'
                        + ' ' + (this.borderWidth.left || 0) + 'px';

                    $KD.style(el.node, 'borderWidth', value);
                }
            },

            blockedUISkin: function BasicWidget$_view_blockedUISkin(/*el, old*/) {},

            bottom: function BasicWidget$_view_bottom(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            centerX: function BasicWidget$_view_centerX(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            centerY: function BasicWidget$_view_centerY(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            contentAlignment: function BasicWidget$_view_contentAlignment(el, old) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                if($KU.is(this, 'widget', 'Button')
                || $KU.is(this, 'widget', 'Label')
                || $KU.is(this, 'widget', 'ListBox')
                || $KU.is(this, 'widget', 'RichText')
                || $KU.is(this, 'widget', 'TextArea2')
                || $KU.is(this, 'widget', 'TextBox2')) {
                    $KD.removeCls(el.node, ('-voltmx-ca-'+old));
                    $KD.addCls(el.node, ('-voltmx-ca-'+this.contentAlignment));
                } else if($KU.is(this, 'widget', 'Calendar')) {
                    $KD.removeCls(el.input, ('-voltmx-ca-'+old));
                    $KD.addCls(el.input, ('-voltmx-ca-'+this.contentAlignment));
                }
            },

            cornerRadius: function BasicWidget$_view_cornerRadius(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, value;

                if($KU.is(this.cornerRadius, 'number')) {
                    $KD.style(el.node, 'borderRadius', (this.cornerRadius+'px'));
                } else if($KU.is(this.cornerRadius, 'string')) {
                    if(this.cornerRadius) {
                        $KD.style(el.node, 'borderRadius', this.cornerRadius);
                    } else {
                        $KD.style(el.node, 'border-radius', null);
                    }
                } else if($KU.is(this.cornerRadius, 'object')) {
                    value = (this.cornerRadius.top || 0) + 'px'
                    + ' ' + (this.cornerRadius.right || 0) + 'px'
                    + ' ' + (this.cornerRadius.bottom || 0) + 'px'
                    + ' ' + (this.cornerRadius.left || 0) + 'px';

                    $KD.style(el.node, 'borderRadius', value);
                }
            },

            cursorType: function BasicWidget$_view_cursorType(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.cursorType) {
                    $KD.style(el.node, 'cursor', this.cursorType);
                } else {
                    $KD.style(el.node, 'cursor', null);
                }
            },

            doLayout: function BasicWidget$_view_doLayout(/*el, old*/) {},

            enable: true,

            focusSkin: function BasicWidget$_view_focusSkin(/*el, old*/) {},

            focusStateSkinProperties: true,

            fontColor: function BasicWidget$_view_fontColor(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    widgets = ['FlexScrollContainer', 'FlexContainer', 'Form2', 'Map', 'Video', 'Browser'];

                if(widgets.indexOf($KW.name(this)) !== -1) return;

                if(this.fontColor) {
                    $KD.style(el.node, 'color', $KW.skinUtils.processColorValue(this.fontColor));
                } else {
                    $KD.style(el.node, 'color', null);
                }
            },

            fontFamily: function BasicWidget$_view_fontFamily(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                    widgets = ['FlexScrollContainer', 'FlexContainer', 'Form2', 'Map', 'Video', 'Browser'];

                if(widgets.indexOf($KW.name(this)) !== -1) return;

                if(this.fontFamily) {
                    $KD.style(el.node, 'fontFamily', $KW.skinUtils.processFontFamily(this.fontFamily));
                } else {
                    $KD.style(el.node, 'font-family', null);
                }
            },

            fontSize: function BasicWidget$_view_fontSize(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                    baseFont, value,
                    widgets = ['FlexScrollContainer', 'FlexContainer', 'Form2', 'Map', 'Video', 'Browser'];

                if(widgets.indexOf($KW.name(this)) !== -1) return;

                if(this.fontSize) {
                    baseFont = $KW.skinUtils.getBaseFontSize();
                    value = Math.round((this.fontSize * baseFont) /100) + 'px';
                    $KD.style(el.node, 'fontSize', value);
                } else {
                    $KD.style(el.node, 'font-size', null);
                }
            },

            fontStyle: function BasicWidget$_view_fontStyle(el, old) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, fontStyle = this.fontStyle,
                    widgets = ['FlexScrollContainer', 'FlexContainer', 'Form2', 'Map', 'Video', 'Browser'],
                    textStyle = this.textStyle ? this.textStyle.strikeThrough : null;

                if(widgets.indexOf($KW.name(this)) !== -1
                || ($KW.name(this) === 'Label' && textStyle
                && fontStyle === voltmx.skin.FONT_STYLE_UNDERLINE)) {
                    return;
                }

                if(old === voltmx.skin.FONT_STYLE_UNDERLINE) {
                    $KD.style(el.node, 'text-decoration', null);//todo
                }

                if(this.fontStyle) {
                    if(fontStyle === voltmx.skin.FONT_STYLE_UNDERLINE) {//TODO: label has to verify
                        $KD.style(el.node, 'textDecoration', this.fontStyle);
                        $KD.style(el.node, 'font-style', null);
                    } else {
                        $KD.style(el.node, 'fontStyle', this.fontStyle);
                    }
                } else {
                    $KD.style(el.node, 'font-style', null);
                }
            },

            fontWeight: function BasicWidget$_view_fontWeight(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                    widgets = ['FlexScrollContainer', 'FlexContainer', 'Form2', 'Map', 'Video', 'Browser'];

                if(widgets.indexOf($KW.name(this)) !== -1) return;

                if(this.fontWeight) {
                    $KD.style(el.node, 'fontWeight', this.fontWeight);
                } else {
                    $KD.style(el.node, 'font-weight', null);
                }
            },

            frame: false,

            height: function BasicWidget$_view_height(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            hoverSkin: function BasicWidget$_view_hoverSkin(/*el, old*/) {},

            hoverStateSkinProperties: true,

            id: false,

            info: true,

            isVisible: function BasicWidget$_view_isVisible(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KA = $K.app, init = true, modal = null,
                    fmodel = $KW.fmodel(this), view = el.node;

                if(view || this.isVisible) {
                    if(!view && this.isVisible) {
                        init = false;
                        view = this._render();
                    }

                    if($KU.is($KW.pmodel(this), 'widget')) {
                        if(this.isVisible) {
                            _handleVisibilityWhen.visibleAndHasParent.call(this, view);
                        } else { //this.isVisible = false
                            _handleVisibilityWhen.notVisibleAndHasParent.call(this, view);
                        }
                    } else { //Form2 or top level templates of 'SegmentedUI2', 'CollectionView', 'DataGrid' or 'MenuContainer'
                        if(this.isVisible) {
                            _handleVisibilityWhen.visibleAndNoParent.call(this, view);
                        } else { //this.isVisible = false
                            _handleVisibilityWhen.notVisibleAndNoParent.call(this, view);
                        }
                    }

                    if(!init && this.isVisible) {
                        $KW.onRender(view);
                    }
                }

                if(fmodel && fmodel === $KW.model($KA.currentFormUID)) {
                    modal = fmodel._kwebfw_.modalContainer;

                    if(!modal) {
                        modal = $KW.deduceModalContainer(fmodel);
                    }

                    if(modal) {
                        if(this.isVisible) {
                            if(_shouldDeduceModalContainer.onAdd.call(this)) {
                                modal = $KW.deduceModalContainer(fmodel);
                                $KW.updateModalContainer(fmodel, modal);
                            }
                        } else if($KW.contains(this, modal, false)) {
                            modal = $KW.deduceModalContainer(fmodel);
                            $KW.updateModalContainer(fmodel, modal);
                        }
                    }
                }
            },

            left: function BasicWidget$_view_left(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            maxHeight: function BasicWidget$_view_maxHeight(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            maxWidth: function BasicWidget$_view_maxWidth(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            minHeight: function BasicWidget$_view_minHeight(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            minWidth: function BasicWidget$_view_minWidth(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            onBlur: function BasicWidget$_view_onBlur(/*el, old*/) {},

            onClick: function BasicWidget$_view_onClick(/*el, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                $KW.setupUIInteraction(this, $KW.focusableElement(this));
            },

            onFocus: function BasicWidget$_view_onFocus(/*el, old*/) {},

            onHover: function BasicWidget$_view_onHover(/*el, old*/) {},

            onScrollWidgetPosition: function BasicWidget$_view_onScrollWidgetPosition(/*el, old*/) {},

            onTouchEnd: function BasicWidget$_view_onTouchEnd(/*el, old*/) {},

            onTouchMove: function BasicWidget$_view_onTouchMove(/*el, old*/) {},

            onTouchStart: function BasicWidget$_view_onTouchStart(/*el, old*/) {},

            opacity: function BasicWidget$_view_opacity(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.style(el.node, 'opacity', this.opacity);
            },

            padding: function BasicWidget$_view_padding(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, padding = '', target = el.node, self = null;

                padding = _preparePaddingStyle.call(this);

                if($KU.is(this, 'widget', 'ListBox')
                && this.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                    target = el.input;
                } else if($KW.isResponsiveContainer(this)) {
                    target = el.viewport || el.node;
                }

                if(padding) {
                    if($KU.is(this, 'widget', 'DataGrid')) {
                        self = this;

                        $KU.each(el.table, function(tr) {
                            $KU.each($KD.children(tr), function(td, index) {
                                if(self.columnHeadersConfig[index].columnType !== 'template'
                                || !self.columnHeadersConfig[index].columnHeaderTemplate) {
                                    $KD.style(td, 'padding', padding);
                                }
                            });
                        });
                        if(self.dockingHeader) {
                            $KU.each(el.docker, function(tr) {
                                $KU.each($KD.children(tr), function(td, index) {
                                    if(!self.columnHeadersConfig[index].columnHeaderTemplate) {
                                        $KD.style(td, 'padding', padding);
                                    }
                                });
                            });
                        }
                    } else {
                        $KD.style(target, 'padding', padding);
                    }
                } else {
                    $KD.style(target, 'padding', null);
                }
            },

            paddingInPixel: false,

            parent: false,

            retainContentAlignment: false,

            retainFlexPositionProperties: false,

            right: function BasicWidget$_view_right(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            shadowColor: function BasicWidget$_view_shadowColor(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, shadowStyle = '';

                shadowStyle = $KW.skinUtils.prepareShadowStyle({
                    shadowColor: this.shadowColor,
                    shadowOffset: this.shadowOffset,
                    shadowRadius: this.shadowRadius
                });

                if(shadowStyle) {
                    $KD.style(el.node, 'boxShadow', shadowStyle);
                } else {
                    $KD.style(el.node, 'box-shadow', null);
                }
            },

            shadowOffset: function BasicWidget$_view_shadowOffset(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, shadowStyle = '';

                shadowStyle = $KW.skinUtils.prepareShadowStyle({
                    shadowColor: this.shadowColor,
                    shadowOffset: this.shadowOffset,
                    shadowRadius: this.shadowRadius
                });

                if(shadowStyle) {
                    $KD.style(el.node, 'boxShadow', shadowStyle);
                } else {
                    $KD.style(el.node, 'box-shadow', null);
                }
            },

            shadowRadius: function BasicWidget$_view_shadowRadius(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, shadowStyle = '';

                shadowStyle = $KW.skinUtils.prepareShadowStyle({
                    shadowColor: this.shadowColor,
                    shadowOffset: this.shadowOffset,
                    shadowRadius: this.shadowRadius
                });

                if(shadowStyle) {
                    $KD.style(el.node, 'boxShadow', shadowStyle);
                } else {
                    $KD.style(el.node, 'box-shadow', null);
                }
            },

            skin: function BasicWidget$_view_skin(el, old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = this._kwebfw_.prop;

                $KW.removeAllSkinsFromUI(this);
                $KW.removeSkin(old, el.node);
                $KW.addSkin(prop.skin, el.node);
            },

            textShadowColor: function BasicWidget$_view_textShadowColor(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, shadowStyle = '';

                if(['Label', 'Button'].indexOf($KW.name(this)) === -1) return;

                shadowStyle = $KW.skinUtils.prepareTextShadowStyle({
                    textShadowColor: this.textShadowColor,
                    textShadowOffset: this.textShadowOffset,
                    textShadowRadius: this.textShadowRadius
                });

                if(shadowStyle) {
                    $KD.style(el.node, 'textShadow', shadowStyle);
                } else {
                    $KD.style(el.node, 'text-shadow', null);
                }
            },

            textShadowOffset: function BasicWidget$_view_textShadowOffset(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, shadowStyle = '';

                if(['Label', 'Button'].indexOf($KW.name(this)) === -1) return;

                shadowStyle = $KW.skinUtils.prepareTextShadowStyle({
                    textShadowColor: this.textShadowColor,
                    textShadowOffset: this.textShadowOffset,
                    textShadowRadius: this.textShadowRadius
                });

                if(shadowStyle) {
                    $KD.style(el.node, 'textShadow', shadowStyle);
                } else {
                    $KD.style(el.node, 'text-shadow', null);
                }
            },

            textShadowRadius: function BasicWidget$_view_textShadowRadius(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, shadowStyle = '';

                if(['Label', 'Button'].indexOf($KW.name(this)) === -1) return;

                shadowStyle = $KW.skinUtils.prepareTextShadowStyle({
                    textShadowColor: this.textShadowColor,
                    textShadowOffset: this.textShadowOffset,
                    textShadowRadius: this.textShadowRadius
                });

                if(shadowStyle) {
                    $KD.style(el.node, 'textShadow', shadowStyle);
                } else {
                    $KD.style(el.node, 'text-shadow', null);
                }
            },

            top: function BasicWidget$_view_top(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            transform: function BasicWidget$_view_transform(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    transform = '';

                transform = $KW.skinUtils.stringifyTrasnsform(this.transform);

                if(transform) {
                    $KD.style(el.node, 'transform', transform);
                } else {
                    $KD.style(el.node, 'transform', null);
                }
            },

            width: function BasicWidget$_view_width(/*el, old*/) {}, //Not required, because change in flex layout properties does not reflect immediately

            zIndex: function BasicWidget$_view_zIndex(el, old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    fmodel = $KW.fmodel(this), modal = null;

                $KD.style(el.node, 'zIndex', this.zIndex);

                if(fmodel && fmodel === $KW.getRootNode(this)
                && _shouldDeduceModalContainer.onZindexChange.call(this, this.zIndex, old)) {
                    modal = $KW.deduceModalContainer(fmodel);
                    $KW.updateModalContainer(fmodel, modal);
                }
            }
        },

        ContainerWidget: {
            appName: false,

            _voltmxControllerName: true,

            addWidgets: true,

            init: true,

            layoutType: function ContainerWidget$_view_layoutType(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom;

                $KD.setAttr(el.node, 'kcl', $KW.layout(this));
            },

            gutterX: true,

            gutterY: true,

            onBreakpointChange: true,

            onBreakpointHandler: false,

            onDestroy: true,

            onHide: true,

            onInit: true,

            onResize: true,

            postShow: true,

            preShow: true,

            responsiveConfig: false,

            retainFlowHorizontalAlignment: false,

            reverseLayoutDirection: function ContainerWidget$_view_reverseLayoutDirection(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    $KD = $K.dom, layout = $KW.layout(this);

                if(['hflex', 'rflex', 'vflex'].indexOf(layout) >= 0) {
                    if(this.reverseLayoutDirection) {
                        if(['hflex', 'rflex'].indexOf(layout) >= 0) {
                            $KD.style(el.node, 'flexDirection', 'row-reverse');
                        } else if(layout === 'vflex') {
                            $KD.style(el.node, 'flexDirection', 'column-reverse');
                        }
                    } else {
                        $KD.style(el.node, 'flex-direction', null);
                    }
                }
            }
        },

        GroupWidget: {
            onSelection: true
        },

        UserWidget: {
            addWidgets: false,

            anchorPoint: true,

            appName: false,

            backgroundColor: true,

            backgroundColorMultiStepGradient: true,

            backgroundColorTwoStepGradient: true,

            backgroundImage: true,

            borderColor: true,

            borderWidth: true,

            bottom: true,

            centerX: true,

            centerY: true,

            contentAlignment: false,

            cornerRadius: true,

            doLayout: true,

            focusSkin: true,

            focusStateSkinProperties: true,

            frame: false,

            height: true,

            hoverStateSkinProperties: true,

            id: false,

            info: true,

            init: false,

            isVisible: true,

            left: true,

            maxHeight: true,

            maxWidth: true,

            minHeight: true,

            minWidth: true,

            onTouchEnd: true,

            onTouchMove: true,

            onTouchStart: true,

            opacity: true,

            padding: false, //with flex this is not applicable

            paddingInPixel: false, //with flex this is not applicable

            parent: false, //non-constructor & readonly property

            right: true,

            skin: true,

            top: true,

            transform: true,

            width: true,

            zIndex: true
        }
    };


    $K.defVoltmxProp($KW, [
        {keey:'auditPerformance', value:function UI$_$KW_auditPerformance() {
            //fflex_centerX
            //fflex_centerY
            //hflex_centerX
            //hflex_centerY
            //vflex_centerX
            //vflex_centerY
            //fflex_AGH
            //image_AGHW
        }},
        {keey:'model', value:function UI$_$KW_model(view) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KW = $K.widget, $KD = $K.dom;


            if($KU.is(view, 'widget')) {
                return view;
            } else if($KU.is(view, 'dom')) {
                return _map[$KD.getAttr(view, 'id')] || null;
            } else if($KU.is(view, 'string') && view) {
                return _map[view] || $KW.getModelByPath(view) || null;
            } else if($KU.is(view, 'array') && view.length) {
                return $KW.getModelByPath(view) || null;
            }
            return null;
        }},
        {keey:'rootOfForm', value:function UI$_$KW_rootOfForm(hash) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, model = null;

            if($KU.is(hash, 'string')) {
                if($K.behavior.isCompositeApp && (hash.indexOf('/') > 0)) {
                    hash = hash.split('/');
                    model = _root[hash[0]][hash[1]] || null;
                } else {
                    model = _root[hash] || null;
                }
            }

            return model;
        }},
        {keey:'root', value:function UI$_$KW_root(view, arg1, arg2) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = null,
                $KU = $K.utils, model = $KW.model(view);

            if(model) {
                _ = model._kwebfw_;

                if(arguments.length === 1) {
                    return _root[model.id] || null;
                } else if(arguments.length > 1 && $KW.isContainer(model)
                && ['tab', 'template'].indexOf(arg1) >= 0
                && !_.rid && !_.pid && Object.prototype.hasOwnProperty.call(_.is, arg1)
                && !$KU.is(model, 'widget', 'FlexScrollContainer')) {
                    //NOTE:: Below 3 lines also there, in "_postInitialization.BasicWidget" function of this file.
                    _.rid = _.uid;
                    _.wap = model.id;

                    if(arg1 === 'tab') {
                        _.wap = (arg2+'_'+_.wap);
                    }

                    //NOTE:: Similar loop can be found in "_addWidgets" function of this file.
                    $KU.each($KW.children(model), function(widget) {
                        _createWidgetHierarchy.call(this, widget);
                    }, model);
                }
            } else if($KU.is(view, 'string') && view) {
                return _root[view] || null;
            } else {
                return null;
            }
        }}
    ]);


    /***************************************************************************
    *                                                                          *
    *                                                                          *
    *                           voltmx.ui.BasicWidget                            *
    *                                                                          *
    *                                                                          *
    ****************************************************************************/
    Object.defineProperty(voltmx.ui, 'BasicWidget', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.BasicWidget constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var BasicWidget = function BasicWidget(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, self = null,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(this === voltmx.ui) {
                throw new Error('This is a class and must be instantiated.');
            } else {
                _populateUnderscore.BasicWidget.call(this);

                if(['voltmx.ui.BasicWidget', 'voltmx.ui.ContainerWidget', 'voltmx.ui.GroupWidget'].indexOf(this._kwebfw_.ns) >= 0) {
                    delete this._;
                    throw new Error('This class cannot be instantiated.');
                } else {
                    self = this;

                    if(!bconfig.isPreValidated) {
                        prop = {
                            accessibilityConfig: null,
                            activeStateSkin: '',
                            anchorPoint: {x: 0.5, y: 0.5},
                            autogrowMode: voltmx.flex.AUTOGROW_NONE,
                            backgroundColor: '',
                            backgroundColorMultiStepGradient: null,
                            backgroundColorTwoStepGradient: null,
                            backgroundImage: '',
                            blur: {enabled: false, value: 0},
                            borderColor: '',
                            borderWidth: '',
                            blockedUISkin: '',
                            bottom: '',
                            centerX: '',
                            centerY: '',
                            contentAlignment: constants.CONTENT_ALIGN_CENTER,
                            cornerRadius: '',
                            cursorType: '',
                            doLayout: null,
                            enable: true,
                            focusSkin: null,
                            focusStateSkinProperties: null,
                            fontColor: '',
                            fontFamily: '',
                            fontSize: null,
                            fontStyle: null,
                            fontWeight: null,
                            frame: {x: null, y: null, width: -1, height: -1, doLayout: false},
                            height: '',
                            hoverSkin: '',
                            hoverStateSkinProperties: null,
                            id: '',
                            info: {},
                            isVisible: true,
                            left: '',
                            maxHeight: '',
                            maxWidth: '',
                            minHeight: '',
                            minWidth: '',
                            onBlur: null,
                            onClick: null,
                            onFocus: null,
                            onHover: null,
                            onRightClick: null,
                            onScrollWidgetPosition: null,
                            onTouchEnd: null,
                            onTouchMove: null,
                            onTouchStart: null,
                            opacity: 1,
                            padding: null,
                            paddingInPixel: false,
                            parent: null,
                            retainContentAlignment: false,
                            retainFlexPositionProperties: false,
                            right: '',
                            shadowColor: '',
                            shadowOffset: null,
                            shadowRadius: 0,
                            textShadowColor: '',
                            textShadowOffset: null,
                            textShadowRadius: 0,
                            skin: null,
                            top: '',
                            transform: null,
                            width: '',
                            zIndex: 1
                        };

                        if($KU.is(_dependentPropertiesValidationMessage.BasicWidget, 'function')) {
                            dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.BasicWidget.call(this, prop, bconfig, lconfig, pspconfig);
                        }
                    }

                    if(dependentPropertiesValidationMessage) {
                        throw new Error(dependentPropertiesValidationMessage);
                    } else {
                        if(!bconfig.isPreValidated) {
                        //Copying lconfig properties to bconfig
                            $KU.each(lconfig, function(value, key) {
                                if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                                    bconfig[key] = value;
                                } else {
                                //Throw Error
                                }
                            });

                            //Copying pspconfig properties to bconfig
                            $KU.each(pspconfig, function(value, key) {
                                if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                                    bconfig[key] = value;
                                } else {
                                //Throw Error
                                }
                            });

                            if(!$KW.isFlexPropertyDefined(bconfig, 'left')
                        && !$KW.isFlexPropertyDefined(bconfig, 'right')
                        && !$KW.isFlexPropertyDefined(bconfig, 'centerX')) {
                                bconfig.left = '0%';
                            }

                            if(!$KW.isFlexPropertyDefined(bconfig, 'top')
                        && !$KW.isFlexPropertyDefined(bconfig, 'bottom')
                        && !$KW.isFlexPropertyDefined(bconfig, 'centerY')) {
                                bconfig.top = '0%';
                            }
                        }

                        if(bconfig.isMaster === true) {
                            this._kwebfw_.is.component = {};
                        }

                        if(bconfig.isPreValidated === true) {
                            this._kwebfw_.isPreValidated = true;
                        }

                        if(!bconfig.isPreValidated) {
                            //Defaulting to platfom values specific to BasicWidget
                            $KU.each(prop, function(value, key) {
                                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                                    $KW = $K.widget, valid = false, message = '';

                                if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                                    bconfig[key] = value;
                                } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                                    throw new Error('<'+key+'> is a non-constructor property of <'+self._kwebfw_.ns+'> class.');
                                } else if(!$KU.is(_valid.BasicWidget[key], 'function')) {
                                    throw new Error('<'+key+'> is available in default widget properties of <voltmx.ui.BasicWidget>, but not in <_valid.BasicWidget> namespace.');
                                } else {
                                    valid = _valid.BasicWidget[key].call(self, bconfig[key]);
                                    if($KU.is(valid, 'array')) {
                                        bconfig[key] = valid[0]; valid = valid[1];
                                    }

                                    if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                        message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                        if($KU.is(valid, 'string')) {
                                            message += ('\n' + valid);
                                        }

                                        throw new Error(message);
                                    }
                                }
                            });
                        }

                        //Defining Getters/Setters specific to BasicWidget
                        $KU.each(_view.BasicWidget, function(value, key) {
                            var $K = voltmx.$kwebfw$, $KU = $K.utils;

                            $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                            $KU.defineGetter(self, key, function BasicWidget$_getter() {
                                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                                if($KU.is(_getter.BasicWidget[key], 'function')) {
                                    return _getter.BasicWidget[key].call(this, this._kwebfw_.prop[key]);
                                }
                                return this._kwebfw_.prop[key];
                            }, true);

                            $KU.defineSetter(self, key, function BasicWidget$_setter(val) {
                                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, rmodel = null,
                                    valid = false, message = '', final = null, el = null, old = null;

                                if(value === false) {
                                    throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                                } else if(this._kwebfw_.prop[key] !== val) {
                                    rmodel = $KW.rmodel(this);

                                    if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                        throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                                    } else {
                                        valid = _valid.BasicWidget[key].call(this, val);
                                        if($KU.is(valid, 'array')) {
                                            val = valid[0]; valid = valid[1];
                                        }

                                        if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                            message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                            if($KU.is(valid, 'string')) {
                                                message += ('\n' + valid);
                                            }

                                            throw new Error(message);
                                        } else {
                                            old = this._kwebfw_.prop[key];
                                            this._kwebfw_.prop[key] = val;

                                            if($KU.is(_setter.BasicWidget[key], 'function')) {
                                                _setter.BasicWidget[key].call(this, old);
                                            }

                                            if(_relayoutActiveTriggerer.BasicWidget().indexOf(key) >= 0) {
                                                $KW.markRelayout(this);
                                            }

                                            if(_relayoutPassiveTriggerer.BasicWidget().indexOf(key) >= 0) {
                                                final = this._kwebfw_.flex.final;

                                                if(!(final.height && final.width)) {
                                                    $KW.markRelayout(this);
                                                }
                                            }

                                            $KW.onPropertyChange(this, key, old);

                                            if($KU.is(value, 'function')) {
                                                el = $KW.el(this);
                                                if(key === 'isVisible' || el.node) {
                                                    value.call(this, el, old);
                                                }
                                            }
                                        }
                                    }
                                }
                            }, false);
                        });

                        if(bconfig.isPreValidated) {
                            p = this._kwebfw_.prop;

                            p.frame = {x:null, y:null, width:-1, height:-1, doLayout:false};
                            p.parent = null;
                            if(p.padding === undefined) p.padding = null;
                            if(p.focusSkin === undefined) p.focusSkin = null;
                            if(p.skin === undefined) p.skin = null;
                        }

                        if($KU.is(_postInitialization.BasicWidget, 'function')) {
                            _postInitialization.BasicWidget.call(this, bconfig, lconfig, pspconfig);
                        }
                    }
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        /**
         * Takes care of flushing out the widget reference to clean memory.
         *
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     void
         */
        var basic__flush = function BasicWidget$_flush(config) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_,
                prop = _.prop, voltmxControllerName = prop._voltmxControllerName,
                uid = _.uid, hint = document.getElementById(uid+'_hint');

            if(!config) {
                config = {};
            }

            hint && $KD.remove(hint);

            if(_.view) {
                $KD.off(_.view); //Remove all event listeners to avoid memory leaks
                _.view = null; //Cleaning cached view (DOM) of this widget instance
            }

            _cleanMeasuresAndMutates(uid);
            delete _map[uid];

            if(voltmxControllerName && !config.fromDestoryCallstack) {
                _voltmx.mvc.destroyController(voltmxControllerName);
            }
        };


        /**
         * Builds the view layer for voltmx.ui.BasicWidget.
         *
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  BasicWidget view.
         */
        var basic__render = function BasicWidget$_render(tag, children) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, $KW = $K.widget, el = null,
                $KF = voltmx.flex, omodel = null, parent = $KW.pmodel(this), _ = this._kwebfw_,
                playout = $KW.layout($KF.FLOW_VERTICAL), is = _.is, prop = _.prop, view = _.view;

            if(is.tab !== true && $KU.is(prop.onInit, 'function')) {
                throw new Error(('<'+_.name+'> does not support the event <onInit>.'));
            } else if(this.isVisible || $KU.is(this, 'widget', 'Form2') || $K.F.RIVW) {
                if(!view) {
                    tag = tag || 'DIV';
                    view = $KD.create(tag);
                    $KU.defineProperty(_, 'view', view);

                    $KD.setAttr(view, 'id', _.uid);
                    $KD.setAttr(view, 'kw', _.name);
                    $KD.setAttr(view, 'kwp', _.wap);

                    if(['td', 'th'].indexOf(tag.toLowerCase()) >= 0) {
                        $KD.setAttr(view, 'align', 'left');
                        $KD.setAttr(view, 'valign', 'top');
                    }

                    if(_.oid) {
                        $KD.setAttr(view, 'kwo', _.oid);
                    }

                    if($KU.is(_.ii, 'string') && _.ii) {
                        $KD.setAttr(view, 'kwi', _.ii);
                    }

                    $KU.each(children, function(child) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget;

                        $KW.addToView(this, child);
                    }, view);

                    el = $KW.el(view);

                    _view.BasicWidget.anchorPoint.call(this, el, this.anchorPoint);
                    _view.BasicWidget.backgroundColor.call(this, el, this.backgroundColor);
                    _view.BasicWidget.backgroundColorMultiStepGradient.call(this, el, this.backgroundColorMultiStepGradient);
                    _view.BasicWidget.backgroundColorTwoStepGradient.call(this, el, this.backgroundColorTwoStepGradient);
                    _view.BasicWidget.backgroundImage.call(this, el, this.backgroundImage);
                    _view.BasicWidget.borderWidth.call(this, el, this.borderWidth);
                    _view.BasicWidget.blur.call(this, el, this.blur);
                    _view.BasicWidget.contentAlignment.call(this, el, this.contentAlignment);
                    _view.BasicWidget.cursorType.call(this, el, this.cursorType);
                    _view.BasicWidget.cornerRadius.call(this, el, this.cornerRadius);
                    _view.BasicWidget.fontColor.call(this, el, this.fontColor);
                    _view.BasicWidget.fontSize.call(this, el, this.fontSize);
                    _view.BasicWidget.fontStyle.call(this, el, this.fontStyle);
                    _view.BasicWidget.fontWeight.call(this, el, this.fontWeight);
                    _view.BasicWidget.fontFamily.call(this, el, this.fontFamily);
                    _view.BasicWidget.opacity.call(this, el, this.opacity);
                    _view.BasicWidget.shadowColor.call(this, el, this.shadowColor);
                    _view.BasicWidget.shadowRadius.call(this, el, this.shadowRadius);
                    _view.BasicWidget.shadowOffset.call(this, el, this.shadowOffset);
                    _view.BasicWidget.textShadowColor.call(this, el, this.textShadowColor);
                    _view.BasicWidget.textShadowOffset.call(this, el, this.textShadowOffset);
                    _view.BasicWidget.textShadowRadius.call(this, el, this.textShadowRadius);
                    _view.BasicWidget.transform.call(this, el, this.transform);
                    if($K.F.RIVW && !this.isVisible) {
                        _view.BasicWidget.isVisible.call(this, el, this.isVisible);
                    }
                    _view.BasicWidget.padding.call(this, el, this.padding);
                    _view.BasicWidget.skin.call(this, el, this.skin);
                    if(parent) {
                        if($KW.isFlexContainer(parent)) {
                            playout = $KW.layout(parent);
                        }
                    } else {
                        omodel = $KW.omodel(this);
                        if(omodel && $KU.is(omodel, 'widget', 'CollectionView')
                           && omodel.layout === voltmx.collectionview.LAYOUT_CUSTOM) {
                            playout = $KF.FREE_FORM;
                        }
                    }

                    _applyFlexRule.call(this, playout, 'horizontal', view, false, false);
                    _applyFlexRule.call(this, playout, 'vertical', view, false, false);
                }
            }

            return view;
        };


        //TODO:: addGestureRecognizer
        var basic_addGestureRecognizer = function BasicWidget$addGestureRecognizer(type, options, callback) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, gesture = null, identifier = '';

            if(!$KU.is(this._kwebfw_.gesture, 'object')) this._kwebfw_.gesture = {};
            gesture = this._kwebfw_.gesture[type];
            if(!$KU.is(gesture, 'array')) gesture = [];

            gesture.push({cb:callback, id:identifier, opt:options});

            return identifier;
        };


        var basic_animate = function BasicWidget$animate(animInstance, animConfig, animCallback) {
            var $K = voltmx.$kwebfw$;

            if(animInstance instanceof $K.Animator) {
                animInstance.animate(this, animConfig, animCallback);
            }
        };


        var basic_clone = function BasicWidget$clone(prefix) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                clone = $KU.clone(this, prefix);

            return clone;
        };


        var basic_convertPointFromWidget = function BasicWidget$convertPointFromWidget(point, widget) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            if($KU.is(widget, 'widget') && $KU.is(point, 'object')
            && $KU.is(point.x, 'string') && $KU.is(point.y, 'string')) {
                return _distanceBetweenFromWidgetToWidget(point, this, widget);
            }
            throw new Error('Invalid argument passed.');
        };


        var basic_convertPointToWidget = function BasicWidget$convertPointToWidget(point, widget) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            if($KU.is(widget, 'widget') && $KU.is(point, 'object')
            && $KU.is(point.x, 'string') && $KU.is(point.y, 'string')) {
                return _distanceBetweenFromWidgetToWidget(point, widget, this);
            }
            throw new Error('Invalid argument passed.');
        };


        var basic_removeFromParent = function BasicWidget$removeFromParent() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget,
                _ = this._kwebfw_, pmodel = $KW.pmodel(this);

            pmodel && _removeWidget.call(pmodel, (_.uwi || this));
        };


        //TODO:: removeGestureRecognizer
        var basic_removeGestureRecognizer = function BasicWidget$removeGestureRecognizer(identifier) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, position = -1, gtype = '',
                on = this._kwebfw_.on, gesture = this._kwebfw_.gesture, removed = false;

            //Remove from gesture registered via setGestureRecognizer
            if($KU.is(on, 'object')) {
                $KU.each(on, function(value, type) {
                    if(value.id === identifier) {
                        delete on[type];
                        removed = true;
                        return true;
                    }
                });
            }

            //Remove from gesture registered via addGestureRecognizer
            if(!removed && $KU.is(gesture, 'object')) {
                $KU.each(gesture, function(value, type) {
                    if(removed) return true;

                    gtype = type;

                    $KU.each(value, function(data, index) {
                        if(data.id === identifier) {
                            position = index;
                            removed = true;
                            return true;
                        }
                    });
                });

                if(position !== -1) {
                    gesture[gtype].splice(position, 1);

                    if(!gesture[gtype].length) {
                        delete gesture.gtype;
                    }
                }
            }
        };

        var basic_setActive = function BasicWidget$setActive() {
            var $K = kony.$kwebfw$, $KW = $K.widget,
                $KD = $K.dom, dom = null;
            
            if ($KW.interactable(this)) {
                dom = $KW.focusableElement(this);
                dom && $KD.focus(dom);
            }
        };

        var basic_setEnabled = function BasicWidget$setEnabled(enable) {
            this.enable = enable;
        };


        var basic_setFocus = function BasicWidget$setFocus(value) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget;

            if(value === true) {
                $KW.setFocus(this);
            }
        };


        //TODO:: setGestureRecognizer
        var basic_setGestureRecognizer = function BasicWidget$setGestureRecognizer(type, options, callback) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, identifier = '';

            if(!$KU.is(this._kwebfw_.on, 'object')) this._kwebfw_.on = {};

            this._kwebfw_.on[type] = {cb:callback, id:identifier, opt:options};

            return identifier;
        };


        var basic_setVisibility = function BasicWidget$setVisibility(flag) {
            this.isVisible = flag;
        };

        var basic_getPreferredSize = function(frame) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                el = $KW.el(this),
                preferredSize = {
                    width: 0,
                    height: 0
                };

            if(el.node && frame) {
                preferredSize.width = _getPrefferedWidth.call(this, el, frame.width);
                preferredSize.height = _getPrefferedHeight.call(this, el, frame.height);

                $KD.style(el.node, 'max-width', null);
                $KD.style(el.node, 'max-height', null);
            }

            return preferredSize;
        };

        var _getPrefferedWidth = function(el, maxWidth) {
            var wrapper = el.node;
            var element = wrapper;

            var initialWidth = wrapper.style.width;

            var defaultWidth = _getDefaultWidth.call(this);
            wrapper.style.width = defaultWidth ? defaultWidth : 'auto';


            if(maxWidth !== Number.MAX_VALUE)
                wrapper.style.maxWidth = maxWidth + 'px';

            if(!defaultWidth) { //content driven widgets
                var initialWrap = element.style.whiteSpace;
                element.style.whiteSpace = 'nowrap';
                element.style.whiteSpace = (wrapper.offsetWidth >= Math.floor(maxWidth)) ? 'pre-wrap' : 'nowrap';
            }

            var finalWidth = wrapper.offsetWidth;
            wrapper.style.width = initialWidth;
            if(!defaultWidth)
                element.style.whiteSpace = initialWrap;

            return finalWidth;
        };

        var _getPrefferedHeight = function(el, maxHeight) {
            var wrapper = el.node;
            var initialHeight = wrapper.style.height;
            var defaultHeight = _getDefaultHeight.call(this);
            wrapper.style.height = defaultHeight ? defaultHeight : 'auto';

            if(maxHeight !== Number.MAX_VALUE)
                wrapper.style.maxHeight = maxHeight + 'px';

            var finalHeight = wrapper.offsetHeight;
            wrapper.style.height = initialHeight;
            return finalHeight;
        };
        var _getDefaultHeight = function() {
            return '';
        };
        var _getDefaultWidth = function() {
            return '';
        };

        $K.defVoltmxProp(BasicWidget.prototype, [
            {keey:'_flush', value:basic__flush},
            {keey:'_render', value:basic__render},
            {keey:'addGestureRecognizer', value:basic_addGestureRecognizer},
            {keey:'animate', value:basic_animate},
            {keey:'clone', value:basic_clone},
            {keey:'convertPointFromWidget', value:basic_convertPointFromWidget},
            {keey:'convertPointToWidget', value:basic_convertPointToWidget},
            {keey:'removeFromParent', value:basic_removeFromParent},
            {keey:'removeGestureRecognizer', value:basic_removeGestureRecognizer},
            {keey:'setActive', value:basic_setActive},
            {keey:'setEnabled', value:basic_setEnabled},
            {keey:'setFocus', value:basic_setFocus},
            {keey:'setGestureRecognizer', value:basic_setGestureRecognizer},
            {keey:'setVisibility', value:basic_setVisibility}
        ]);

        return BasicWidget;
    }())});


    /***************************************************************************
    *                                                                          *
    *                                                                          *
    *                         voltmx.ui.ContainerWidget                          *
    *                                                                          *
    *                                                                          *
    ****************************************************************************/
    Object.defineProperty(voltmx.ui, 'ContainerWidget', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.ContainerWidget constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var ContainerWidget = function ContainerWidget(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!bconfig.isPreValidated) {
                prop = { //Do not add event properties here
                    _voltmxControllerName: '',
                    addWidgets: null,
                    appName: $K.app.id,
                    gutterX: '',
                    gutterY: '',
                    init: null,
                    layoutType: voltmx.flex.FREE_FORM,
                    onBreakpointChange: null,
                    onBreakpointHandler: null,
                    onDestroy: null,
                    onHide: null,
                    onInit: null,
                    onResize: null,
                    postShow: null,
                    preShow: null,
                    responsiveConfig: null,
                    retainFlowHorizontalAlignment: false,
                    reverseLayoutDirection: false
                };
            }

            _populateUnderscore.ContainerWidget.call(this);

            if(!bconfig.appName) bconfig.appName = prop.appName;

            ContainerWidget.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.ContainerWidget, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.ContainerWidget.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                //Defaulting to platfom values specific to ContainerWidget
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<'+key+'> is a non-constructor property of <'+self._kwebfw_.ns+'> class.');
                        } else if(!$KU.is(_valid.ContainerWidget[key], 'function')) {
                            throw new Error('<'+key+'> is available in default widget properties of <voltmx.ui.ContainerWidget>, but not in <_valid.ContainerWidget> namespace.');
                        } else {
                            valid = _valid.ContainerWidget[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to ContainerWidget
                $KU.each(_view.ContainerWidget, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function ContainerWidget$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.ContainerWidget[key], 'function')) {
                            return _getter.ContainerWidget[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function ContainerWidget$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, rmodel = null, final = null,
                            valid = false, message = '', el = null, old = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.ContainerWidget[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.ContainerWidget[key], 'function')) {
                                        _setter.ContainerWidget[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.ContainerWidget().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.ContainerWidget().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.ContainerWidget, 'function')) {
                    _postInitialization.ContainerWidget.call(this, bconfig, lconfig, pspconfig);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(ContainerWidget, voltmx.ui.BasicWidget);


        /**
         * Takes care of flushing out the widget reference to clean memory.
         *
         * @override
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.ContainerWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} config - An object with config properties.
         * @returns     void
         */
        var container__flush = function ContainerWidget$_flush(config) {
            var $super = voltmx.ui.ContainerWidget.base.prototype, _ = this._kwebfw_,
                $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, id = _.prop.id;

            if(!config) {
                config = {};
                config.iterate = false;
            }

            if(config.iterate) {
                $KU.each($KW.children(this), function(widget) {
                    widget._flush(config);
                });
            }

            $super._flush.call(this, config);

            if($KU.is(this, 'widget', 'Form2')) {
                delete _root[id];
            } else if(_.uwi instanceof voltmx.ui.UserWidget) {
                _cleanMeasuresAndMutates(_.uwi._kwebfw_.uid);
                delete _map[_.uwi._kwebfw_.uid];
            }
        };


        var container__render = function ContainerWidget$_render(tag, children) {
            var $super = voltmx.ui.ContainerWidget.base.prototype,
                el = null, view = this._kwebfw_.view, $K = voltmx.$kwebfw$,
                $KU = $K.utils, $KW = $K.widget, $KD = $K.dom;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    if($KW.isFlexContainer(this) && !$KU.is(this, 'widget', 'Form2')) {
                        if(!$KU.is(children, 'array')) children = [];

                        if($K.F.RFB) {
                            children.push($KD.create('DIV', {class:'kvp', kr:'kfb'}));
                        }
                    }

                    view = $super._render.call(this, tag, children);
                    el = $KW.el(view);

                    _view.ContainerWidget.layoutType.call(this, el, this.layoutType);
                    _view.ContainerWidget.reverseLayoutDirection.call(this, el, this.reverseLayoutDirection);
                }
            }

            return view;
        };


        var container_add = function ContainerWidget$add() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget;

            _addWidgets.call(this, [].slice.call(arguments), $KW.children(this).length);
        };


        var container_addAt = function ContainerWidget$addAt(widget, index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, children = null;

            if($KU.is(index, 'number')) {
                if(index < 0) index = 0;

                children = $KW.children(this);

                if(index > children.length) {
                    index = children.length;
                }

                _addWidgets.call(this, [widget], index);
            } else {
                //Log index must be of number datatype
            }
        };


        var container_destroy = function ContainerWidget$destroy(arg0) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null, context = null,
                $KW = $K.widget, $KA = $K.app, self = null, valid = false, config = {fromDestoryCallstack : true};

            context = ($KU.is(arg0, 'object')) ? arg0 : {};

            if($KU.is(this, 'widget', 'Form2')) {
                if(this._voltmxControllerName && context.forced !== true) {
                    throw new Error('Cannot call <destroy> method on a MVC form.');
                } else if($KW.model($KA.currentFormUID) === this) {
                    throw new Error('Cannot call <destroy> method on current form.');
                } else {
                    valid = true;
                }
            } else if($KU.is(this, 'widget', 'component')) {
                valid = true;
            }

            if(valid) {
                _ = this._kwebfw_;
                $KW.invokeLifeCycleEvent(this, 'onDestroy', true);

                //Remove all widgets from root hierarchy and _map
                $KW.iterate(this, function(widget) {
                    _cleanUnderscore.call(widget);
                    delete this[widget.id];
                    widget._flush(config);
                }, {scope:this, tabs:false});

                delete _.children;

                if(this._voltmxControllerName) {
                    if($KU.is(this, 'widget', 'Form2')) {
                        _cleanMeasuresAndMutates(_.uid);
                        _cleanUnderscore.call(this);
                        delete _map[_.uid];
                        delete _root[_.prop.id];
                    }
                } else if($KU.is(this, 'widget', 'Form2')) {
                    self = this;

                    _cleanUnderscore.call(this, {rid:false});

                    $KU.defineGetter(window, this.id, function() {
                        _invokeAddWidgets.call(self, true);
                        return self;
                    });
                }
            }
        };


        var container_executeOnParent = function Container$executeOnParent(callback) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, pmodel = null, args = [];

            if(this._voltmxControllerName) {
                pmodel = $KW.closest($KW.model(this._kwebfw_.owner), function(widget) {
                    return (widget._voltmxControllerName) ? true : null;
                }, {owner:false, tabs:false});

                if(pmodel) {
                    if(arguments.length >= 2) {
                        args = [].slice.call(arguments);
                        args = args.slice(1, args.length);
                    }
                    _voltmx.mvc.executeInJsContext(pmodel, callback, args);
                }
            }
        };


        //One suppose to call this method on a fixed size container.
        var container_forceLayout = function ContainerWidget$forceLayout(arg0) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                fmodel = null, isForm = true, forced = false;

            if(!$KW.isFlexContainer(this)) {
                //Throw Error
            } else {
                fmodel = $KW.fmodel(this) || this;

                if($KW.isRendered(fmodel)) {
                    if($KU.loadedFromOtherFramework()) {
                        isForm = true;
                        fmodel = $KW.getRootNode(fmodel);
                    } else if($KU.is(arg0, 'boolean')) {
                        forced = arg0;
                    } else if(!$KU.is(this, 'widget', 'Form2')
                    && this._kwebfw_.forceLayout === true) {
                        //e.g. forceLayout of voltmx.ui.Map callout template
                        forced = true;
                        isForm = false;
                        delete this._kwebfw_.forceLayout;
                    } else if(!$KU.is(fmodel, 'widget', 'Form2')) {
                        forced = false;
                        delete fmodel._kwebfw_.relayout;
                        delete fmodel._kwebfw_.forceLayout;
                    }

                    if(forced || fmodel._kwebfw_.relayout) {
                        if(!forced) {
                            _dirty.cascade = fmodel._kwebfw_.relayout;
                            delete fmodel._kwebfw_.relayout;

                            $KU.each(_dirty.cascade, function(widget) {
                                _cascadeRelayout.call(fmodel, widget);
                            });
                        }

                        $KW.iterate(fmodel, function(widget) {
                            var $K = voltmx.$kwebfw$;

                            if(widget.isVisible || $K.F.RIVW) {
                                _relayout.call(this, widget, forced);
                            } else {
                                delete widget._kwebfw_.relayout;
                                return true;
                            }
                        }, {scope:fmodel, tabs:true});

                        _dirty = {cascade:{}, widgets:{}, templates:{}};

                        _resolveMeasures();
                        _resolveMutates();

                        if(isForm) {
                            //NOTE:: It is considered that doLayout should not be fired
                            //       for widgets of voltmx.ui.Map callout template
                            //       This consideration can be changed, but it needs time.
                            //       As we don't have time proceeding with this consideration.
                            //Current challenge is, calling doLayout might make,
                            //that callout template dirty and will run into...
                            //... infitine forceLayout call stack (as, for !isForm, forced is set to true)
                            //If noone wants to make any widget of callout template dirty,
                            //then he/she should not need any widget's frame too.
                            $KU.each(_doLayoutWidgtsList, function(widget) {
                                _doLayout.call(widget);
                            });
                        }

                        _doLayoutWidgtsList = [];

                        isForm && fmodel.forceLayout();
                        $KW.evaluateScrollPosition(fmodel);
                    }
                }
            }
        };


        var container_remove = function ContainerWidget$remove(widget) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            if($KU.is(widget, 'widget') && widget.parent) {
                _removeWidget.call(widget.parent, widget);
            }
        };


        var container_removeAll = function ContainerWidget$removeAll() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

            $KU.each($KW.children(this), function(widget) {
                _removeWidget.call(this, widget);
            }, this);
        };


        var container_removeAt = function ContainerWidget$removeAt(index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, widget = null;

            if($KU.is(index, 'number')) {
                widget = $KW.children(this)[index];

                if($KU.is(widget, 'widget')) {
                    _removeWidget.call(this, widget);
                }
            } else {
                //Log invalid datatype for index
            }

            return widget;
        };


        var container_scrollToBeginning = function Container$scrollToBeginning() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KW = $K.widget, el = null;

            if(this instanceof voltmx.ui.Form2
            || this instanceof voltmx.ui.FlexScrollContainer) {
                el = $KW.el(this);

                if(el.viewport) {
                    $KW.populateScrollDetails(this);

                    if($KU.scrollType() === 'native') {
                        el.viewport.scrollLeft = 0;
                        el.viewport.scrollTop = 0;
                    }
                }
            } else {
                throw new Error('Cannot call <scrollToBeginning> method on <'+ this._kwebfw_.ns+'>');
            }
        };


        var container_scrollToEnd = function Container$scrollToEnd() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KW = $K.widget, scroll = null, el = null;

            if(this instanceof voltmx.ui.Form2
            || this instanceof voltmx.ui.FlexScrollContainer) {
                el = $KW.el(this);

                if(el.viewport) {
                    $KW.populateScrollDetails(this);
                    scroll = this._kwebfw_.ui.scroll;

                    if($KU.scrollType() === 'native') {
                        el.viewport.scrollLeft = scroll.maxX;
                        el.viewport.scrollTop = scroll.maxY;
                    }
                }
            } else {
                throw new Error('Cannot call <scrollToEnd> method on <'+ this._kwebfw_.ns+'>');
            }
        };


        var container_scrollToWidget = function Container$scrollToWidget(widget/*, animate*/) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

            if($KU.is(widget, 'widget')) {
                $KW.setFocus(widget);
            }
        };


        var container_setContentOffset = function Container$setContentOffset(offset, animate) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget;

            $KW.setContentOffset(this, offset, animate);
        };


        var container_setDefaultUnit = function ContainerWidget$setDefaultUnit(unit) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KF = voltmx.flex;

            if($KW.isFlexContainer(this) && this._kwebfw_.defaultUnit !== unit
            && [$KF.PERCENTAGE, $KF.DP, $KF.PX, ''].indexOf(unit) >= 0) {
                if(unit) {
                    this._kwebfw_.defaultUnit = unit;
                } else {
                    delete this._kwebfw_.defaultUnit;
                }

                $KW.iterate(this, function(widget) {
                    var _ = widget._kwebfw_;

                    if(this !== widget && _.defaultUnit) {
                        return true;
                    }
                    if(unit) {
                        _.layoutUnit = unit;
                    } else {
                        delete _.layoutUnit;
                    }
                }, {scope:this, tabs:false});
            }
        };


        var container_widgets = function ContainerWidget$widgets() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_;

            return ($KU.is(_.children, 'array')) ? _.children.slice(0) : [];
        };


        $K.defVoltmxProp(ContainerWidget.prototype, [
            {keey:'_flush', value:container__flush},
            {keey:'_render', value:container__render},
            {keey:'add', value:container_add},
            {keey:'addAt', value:container_addAt},
            {keey:'destroy', value:container_destroy},
            {keey:'executeOnParent', value:container_executeOnParent},
            {keey:'forceLayout', value:container_forceLayout},
            {keey:'remove', value:container_remove},
            {keey:'removeAt', value:container_removeAt},
            {keey:'removeAll', value:container_removeAll},
            {keey:'scrollToBeginning', value:container_scrollToBeginning},
            {keey:'scrollToEnd', value:container_scrollToEnd},
            {keey:'scrollToWidget', value:container_scrollToWidget},
            {keey:'scrollToWidget', value:container_scrollToWidget},
            {keey:'setContentOffset', value:container_setContentOffset},
            {keey:'setDefaultUnit', value:container_setDefaultUnit},
            {keey:'widgets', value:container_widgets}
        ]);


        return ContainerWidget;
    }())});


    /***************************************************************************
    *                                                                          *
    *                                                                          *
    *                           voltmx.ui.GroupWidget                            *
    *                                                                          *
    *                                                                          *
    ****************************************************************************/
    Object.defineProperty(voltmx.ui, 'GroupWidget', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.GroupWidget constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var GroupWidget = function GroupWidget(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!bconfig.isPreValidated) {
                prop = { //Do not add event properties here
                    onSelection: null
                };
            }

            _populateUnderscore.GroupWidget.call(this);

            GroupWidget.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.GroupWidget, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.GroupWidget.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to GroupWidget
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.GroupWidget[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.GroupWidget>, but not in <_valid.GroupWidget> namespace.');
                        } else {
                            valid = _valid.GroupWidget[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to GroupWidget
                $KU.each(_view.GroupWidget, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function GroupWidget$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.GroupWidget[key], 'function')) {
                            return _getter.GroupWidget[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function GroupWidget$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, rmodel = null, valid = false,
                            $KW = $K.widget, old = null, final = null, el = null, message = '';

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.GroupWidget[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.GroupWidget[key], 'function')) {
                                        _setter.GroupWidget[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.GroupWidget().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.GroupWidget().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.GroupWidget, 'function')) {
                    _postInitialization.GroupWidget.call(this, bconfig, lconfig, pspconfig);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(GroupWidget, voltmx.ui.BasicWidget);


        /**
         * Takes care of flushing out the widget reference to clean memory.
         *
         * @override
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.GroupWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     void
         */
        var group__flush = function GroupWidget$_flush() {
            var $super = voltmx.ui.GroupWidget.base.prototype,
                $K = voltmx.$kwebfw$, $KW = $K.widget;

            $KW.clearGroupA11y(this, this.masterData, this.masterDataMap);
            $super._flush.call(this);
        };


        /**
         * Builds the view layer for voltmx.ui.GroupWidget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.GroupWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  GroupWidget view.
         */
        var group__render = function GroupWidget$_render(tag, children) {
            var $super = voltmx.ui.GroupWidget.base.prototype,
                view = this._kwebfw_.view, $K = voltmx.$kwebfw$;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, tag, children);
                }
            }

            return view;
        };


        $K.defVoltmxProp(GroupWidget.prototype, [
            {keey:'_flush', value:group__flush},
            {keey:'_render', value:group__render}
        ]);


        return GroupWidget;
    }())});


    /***************************************************************************
    *                                                                          *
    *                                                                          *
    *                            voltmx.ui.UserWidget                            *
    *                                                                          *
    *                                                                          *
    ****************************************************************************/
    Object.defineProperty(voltmx.ui, 'UserWidget', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.UserWidget constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var UserWidget = function UserWidget(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, self = null,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            _populateUnderscore.UserWidget.call(this);

            self = this;

            if(!bconfig.isPreValidated) {
                prop = {
                    addWidgets: undefined,
                    anchorPoint: undefined,
                    appName: $K.app.id,
                    backgroundColor: undefined,
                    backgroundColorMultiStepGradient: undefined,
                    backgroundColorTwoStepGradient: undefined,
                    backgroundImage: undefined,
                    borderColor: undefined,
                    borderWidth: undefined,
                    bottom: undefined,
                    centerX: undefined,
                    centerY: undefined,
                    contentAlignment: undefined,
                    cornerRadius: undefined,
                    doLayout: undefined,
                    focusSkin: undefined, //non-constructor property
                    focusStateSkinProperties: undefined,
                    frame: undefined, //{x:undefined, y:undefined, width:-1, height:-1, doLayout:false}, //non-constructor & readonly property
                    height: undefined,
                    hoverStateSkinProperties: undefined,
                    id: undefined, //constructor only
                    info: undefined,
                    init: undefined, //constructor only
                    isVisible: true,
                    left: undefined,
                    maxHeight: undefined,
                    maxWidth: undefined,
                    minHeight: undefined,
                    minWidth: undefined,
                    onTouchEnd: undefined,
                    onTouchMove: undefined,
                    onTouchStart: undefined,
                    opacity: undefined,
                    padding: undefined, //constructor only - with flex this is not applicable
                    paddingInPixel: undefined, //constructor only - with flex this is not applicable
                    parent: undefined, //non-constructor & readonly property
                    right: undefined,
                    skin: undefined,
                    top: undefined,
                    transform: undefined, //non-constructor property
                    width: undefined,
                    zIndex: undefined
                };
            }

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.UserWidget, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.UserWidget.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Copying lconfig properties to bconfig
                    $KU.each(lconfig, function(value, key) {
                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else {
                            //Throw Error
                        }
                    });

                    //Copying pspconfig properties to bconfig
                    $KU.each(pspconfig, function(value, key) {
                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else {
                            //Throw Error
                        }
                    });

                    if(!$KW.isFlexPropertyDefined(bconfig, 'left')
                        && !$KW.isFlexPropertyDefined(bconfig, 'right')
                        && !$KW.isFlexPropertyDefined(bconfig, 'centerX')) {
                        bconfig.left = '0%';
                    }

                    if(!$KW.isFlexPropertyDefined(bconfig, 'top')
                        && !$KW.isFlexPropertyDefined(bconfig, 'bottom')
                        && !$KW.isFlexPropertyDefined(bconfig, 'centerY')) {
                        bconfig.top = '0%';
                    }
                }

                if(bconfig.isMaster === true) {
                    this._kwebfw_.is.component = {};
                }

                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to UserWidget
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.UserWidget[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.UserWidget>, but not in <_valid.UserWidget> namespace.');
                        } else {
                            valid = _valid.UserWidget[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to UserWidget
                $KU.each(_view.UserWidget, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineGetter(self, key, function UserWidget$_getter() {
                        return (key === 'parent') ? this._kwebfw_.prop[key] : this._kwebfw_.proxy[key];
                    }, true);

                    $KU.defineSetter(self, key, function UserWidget$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                            valid = false, message = '', rmodel = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.UserWidget[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    this._kwebfw_.proxy[key] = val;
                                }
                            }
                        }
                    }, false);
                });

                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    p.frame = null;
                    p.parent = null;
                    if(p.padding === undefined) p.padding = null;
                    if(p.focusSkin === undefined) p.focusSkin = null;
                    if(p.skin === undefined) p.skin = null;
                    if(p.anchorPoint === undefined) p.anchorPoint = null;
                    if(p.backgroundColor === undefined) p.backgroundColor = null;
                    if(p.transform === undefined) p.transform = null;
                }

                if($KU.is(_postInitialization.UserWidget, 'function')) {
                    _postInitialization.UserWidget.call(this, bconfig, lconfig, pspconfig);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        var userwidget_addGestureRecognizer = function UserWidget$addGestureRecognizer(type, options, callback) {
            this._kwebfw_.proxy.addGestureRecognizer(type, options, callback);
        };


        var userwidget_animate = function UserWidget$animate(animInstance, animConfig, animCallback) {
            this._kwebfw_.proxy.animate(animInstance, animConfig, animCallback);
        };


        var userwidget_convertPointFromWidget = function UserWidget$convertPointFromWidget(point, widget) {
            this._kwebfw_.proxy.convertPointFromWidget(point, widget);
        };


        var userwidget_convertPointToWidget = function UserWidget$convertPointToWidget(point, widget) {
            this._kwebfw_.proxy.convertPointToWidget(point, widget);
        };


        var userwidget_removeFromParent = function UserWidget$removeFromParent() {
            this._kwebfw_.proxy.removeFromParent();
        };


        var userwidget_removeGestureRecognizer = function UserWidget$removeGestureRecognizer(identifier) {
            this._kwebfw_.proxy.removeGestureRecognizer(identifier);
        };

        var userwidget_setActive = function UserWidget$setActive() {
            this._kwebfw_.proxy.setActive();
        };

        var userwidget_setEnabled = function UserWidget$setEnabled(enable) {
            this._kwebfw_.proxy.setEnabled(enable);
        };


        var userwidget_setFocus = function UserWidget$setFocus(value) {
            this._kwebfw_.proxy.setFocus(value);
        };


        var userwidget_setGestureRecognizer = function UserWidget$setGestureRecognizer(type, options, callback) {
            this._kwebfw_.proxy.setGestureRecognizer(type, options, callback);
        };


        var userwidget_setVisibility = function UserWidget$setVisibility(flag) {
            this._kwebfw_.proxy.setVisibility(flag);
        };


        $K.defVoltmxProp(UserWidget.prototype, [
            {keey:'addGestureRecognizer', value:userwidget_addGestureRecognizer},
            {keey:'animate', value:userwidget_animate},
            {keey:'convertPointFromWidget', value:userwidget_convertPointFromWidget},
            {keey:'convertPointToWidget', value:userwidget_convertPointToWidget},
            {keey:'removeFromParent', value:userwidget_removeFromParent},
            {keey:'removeGestureRecognizer', value:userwidget_removeGestureRecognizer},
            {keey:'setActive', value:userwidget_setActive},
            {keey:'setEnabled', value:userwidget_setEnabled},
            {keey:'setFocus', value:userwidget_setFocus},
            {keey:'setGestureRecognizer', value:userwidget_setGestureRecognizer},
            {keey:'setVisibility', value:userwidget_setVisibility}
        ]);


        return UserWidget;
    }())});


    /***************************************************************************
    *                                                                          *
    *                              voltmx.ui.Alert                               *
    *                          voltmx.ui.createAnimation                         *
    *                        voltmx.ui.makeAffineTransform                       *
    *                                                                          *
    ****************************************************************************/
    Object.defineProperty(voltmx.ui, 'Alert', {configurable:false, enumerable:false, writable:false, value:(function() {
        var Alert = function Alert(config, arg1, arg2) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, ret = false,
                message = '', callback = null, type = '';

            if($KU.is(config, 'object')) {
                message = config.message;
                type = config.alerttype || config.alertType || constants.ALERT_TYPE_INFO;
                callback = config.alerthandler || config.alertHandler || null;
            } else if($KU.is(config, 'string')) {
                message = config;
                callback = arg1;
                type = arg2 || constants.ALERT_TYPE_INFO;
            }

            callback = $KU.is(callback, 'function') ? callback : null;

            if(type === constants.ALERT_TYPE_INFO
            || type === constants.ALERT_TYPE_ERROR) {
                //eslint-disable-next-line no-alert
                alert(message);
                callback && callback();
            } else if(type === constants.ALERT_TYPE_CONFIRMATION) {
                //eslint-disable-next-line no-alert
                ret = confirm(message);
                callback && callback(ret);
            }
        };


        return Alert;
    }())});


    Object.defineProperty(voltmx.ui, 'createAnimation', {configurable:false, enumerable:false, writable:false, value:(function() {
        var createAnimation = function createAnimation(animDef) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, animator = null;

            $KU.log({api:'voltmx.ui.createAnimation', enter:true});
            animator = new $K.Animator(animDef);
            $KU.log({api:'voltmx.ui.createAnimation', exit:true});

            return animator;
        };


        return createAnimation;
    }())});


    Object.defineProperty(voltmx.ui, 'defineExtendedWidget', {configurable:false, enumerable:false, writable:false, value:function(child, parent, protoFunctionDictionary) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, ns = child, name = '', pkg = window;

        if(!(parent === voltmx.ui.Button || parent === voltmx.ui.Image2
        || parent === voltmx.ui.Label || parent === voltmx.ui.Switch
        || parent === voltmx.ui.TextArea2 || parent === voltmx.ui.TextBox2)) {
            //TODO:: Throw error - ParentClass is not supported to be inherited.
        } else {
            if(!($KU.is(child, 'string') && child)) {
                //TODO:: Throw error - Invalid argument(s) passed.
            } else {
                child = child.split('.');
                name = child.splice((child.length-1), 1)[0];
                $KU.each(child, function(val) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    if(!$KU.is(pkg[val], 'object')) {
                        pkg[val] = {};
                    }

                    pkg = pkg[val];
                });

                if($KU.is(pkg[name], 'function')) {
                    //TODO:: Throw error - Class is already defined.
                } else {
                    pkg[name] = function ExtendedWidget() {
                        this.preInitializeCall.apply(this, [].slice.call(arguments));
                    };

                    child = pkg[name];
                    $KU.inherits(child, parent);

                    $KU.each(protoFunctionDictionary, function(value, keey) {
                        child.prototype[keey] = value;
                    });

                    if($KU.is(parent.prototype.__$kwebfw$name__, 'string')
                    && parent.prototype.__$kwebfw$name__) {
                        name = parent.prototype.__$kwebfw$name__;
                    } else {
                        name = new parent({id:'kwebfw'}, {}, {});
                        name = name._kwebfw_.name;
                    }

                    $KU.defineProperty(child.prototype, '__$kwebfw$ns__', ns, null);
                    $KU.defineProperty(child.prototype, '__$kwebfw$name__', name, null);
                }
            }
        }
    }});


    Object.defineProperty(voltmx.ui, 'makeAffineTransform', {configurable:false, enumerable:false, writable:false, value:(function() {
        var makeAffineTransform = function makeAffineTransform() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, transform = null;

            $KU.log({api:'voltmx.ui.makeAffineTransform', enter:true});
            transform = new $K.Transform();
            $KU.log({api:'voltmx.ui.makeAffineTransform', exit:true});

            return transform;
        };


        return makeAffineTransform;
    }())});

    Object.defineProperty(voltmx.ui, 'renderTo', {configurable:false, enumerable:false, writable:false, value:(function() {
        var renderTo = function renderTo(model, elementRefById) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, supportedWidget = false,
                flag = $KU.loadedFromOtherFramework(), _render = null, ele = null;

            supportedWidget = (model instanceof voltmx.ui.FlexContainer || model instanceof voltmx.ui.UserWidget);

            if(supportedWidget && flag) {
                if($KU.is(model, 'widget', 'UserWidget')) {
                    _render = model._kwebfw_.proxy._render();
                } else {
                    _render = model._render();
                }

                $KW.invokeLifeCycleEvent(model, 'preShow', false);

                $KW.registerEvents(_render);

                if(elementRefById) {
                    ele = document.getElementById(elementRefById);
                    ele.appendChild(_render);
                }

                $KW.invokeLifeCycleEvent(model, 'postShow', true);
            }
        };

        return renderTo;
    }())});
}());


/* FILE PATH :: 'lib/apis/voltmxunsupported.js' */


(function() {
    var $K = voltmx.$kwebfw$, $KU = $K.utils,
        _notSupported = function(api, channel) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;
            $KU.unsupportedAPI(api, channel);
        };

    $K.defVoltmxProp(voltmx, [
        {keey:'accelerometer', value:{}}
    ]);

    $K.defVoltmxProp(voltmx, [
        {keey:'actionExtension', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'backgroundtasks', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'camera', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'contact', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'dragdrop', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'filter', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'forcetouch', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'image', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'iMessageExtensions', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'intentExtension', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'keychain', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'lang', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'localAuthentication', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'localnotifications', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'map', value:{}}
    ]);
    $K.defVoltmxProp(voltmx.net, [
        {keey:'cache', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'notificationContentExtension', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'notificationsettings', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'payment', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'reactNative', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'shareExtensions', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'stream', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'todayExtension', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'types', value:{}}
    ]);
    $K.defVoltmxProp(voltmx, [
        {keey:'web', value:{}}
    ]);
    $K.defVoltmxProp(window, [
        {keey:'com', value:{}, items:[
            {keey:'voltmx', value:{}}
        ]}
    ]);

    $KU.defineProperty(voltmx.application, 'getCurrentSettingsMenu', function() {
        _notSupported('voltmx.application.getCurrentSettingsMenu');
    });

    $KU.defineProperty(voltmx.io.FileSystem, 'copyBundledRawFileTo', function() {
        _notSupported('voltmx.io.FileSystem.copyBundledRawFileTo');
    });
    $KU.defineProperty(voltmx.io.FileSystem, 'getDataDirectoryPath', function() {
        _notSupported('voltmx.io.FileSystem.getDataDirectoryPath');
    }); 

    $KU.defineProperty(voltmx.io.File.prototype, 'copyTo', function() {
        _notSupported('voltmx.io.File.copyTo');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'createDirectory', function() {
        _notSupported('voltmx.io.File.createDirectory');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'createFile', function() {
        _notSupported('voltmx.io.File.createFile');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'exists', function() {
        _notSupported('voltmx.io.File.exists');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'getFilesList', function() {
        _notSupported('voltmx.io.File.getFilesList');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'isDirectory', function() {
        _notSupported('voltmx.io.File.isDirectory');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'isFile', function() {
        _notSupported('voltmx.io.File.isFile');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'moveTo', function() {
        _notSupported('voltmx.io.File.moveTo');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'read', function() {
        _notSupported('voltmx.io.File.read');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'readAsText', function() {
        _notSupported('voltmx.io.File.readAsText');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'remove', function() {
        _notSupported('voltmx.io.File.remove');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'rename', function() {
        _notSupported('voltmx.io.File.rename');
    });
    $KU.defineProperty(voltmx.io.File.prototype, 'write', function() {
        _notSupported('voltmx.io.File.write');
    });

    $KU.defineProperty(voltmx.accelerometer, 'registerAccelerationEvents', function() {
        _notSupported('voltmx.accelerometer.registerAccelerationEvents');
    });
    $KU.defineProperty(voltmx.accelerometer, 'retrieveCurrentAcceleration', function() {
        _notSupported('voltmx.accelerometer.retrieveCurrentAcceleration');
    });
    $KU.defineProperty(voltmx.accelerometer, 'startMonitoringAcceleration', function() {
        _notSupported('voltmx.accelerometer.startMonitoringAcceleration');
    });
    $KU.defineProperty(voltmx.accelerometer, 'stopMonitoringAcceleration', function() {
        _notSupported('voltmx.accelerometer.stopMonitoringAcceleration');
    });
    $KU.defineProperty(voltmx.accelerometer, 'unregisterAccelerationEvents', function() {
        _notSupported('voltmx.accelerometer.unregisterAccelerationEvents');
    });

    $KU.defineProperty(voltmx.actionExtension, 'setExtensionsCallbacks', function() {
        _notSupported('voltmx.actionExtension.setExtensionsCallbacks');
    });

    $KU.defineProperty(voltmx.application, 'addSettingsMenuItemAt', function() {
        _notSupported('voltmx.application.addSettingsMenuItemAt');
    });
    $KU.defineProperty(voltmx.application, 'beginBackgroundTask', function() {
        _notSupported('voltmx.application.beginBackgroundTask');
    });
    $KU.defineProperty(voltmx.application, 'createSettingsMenu', function() {
        _notSupported('voltmx.application.createSettingsMenu');
    });
    $KU.defineProperty(voltmx.application, 'endBackgroundTask', function() {
        _notSupported('voltmx.application.endBackgroundTask');
    });
    $KU.defineProperty(voltmx.application, 'getSettingValue', function() {
        _notSupported('voltmx.application.getSettingValue');
    });
    $KU.defineProperty(voltmx.application, 'getApplicationBadgeValue', function() {
        _notSupported('voltmx.application.getApplicationBadgeValue');
    });
    $KU.defineProperty(voltmx.application, 'getAppMenuBadgeValue', function() {
        _notSupported('voltmx.application.getAppMenuBadgeValue');
    });
    $KU.defineProperty(voltmx.application, 'isInMultiWindowMode', function() {
        _notSupported('voltmx.application.isInMultiWindowMode');
    });
    $KU.defineProperty(voltmx.application, 'openApplicationSettings', function() {
        _notSupported('voltmx.application.openApplicationSettings');
    });
    $KU.defineProperty(voltmx.application, 'registerOnKeyPress', function() {
        _notSupported('voltmx.application.registerOnKeyPress');
    });
    $KU.defineProperty(voltmx.application, 'removeSettingsMenuItemAt', function() {
        _notSupported('voltmx.application.removeSettingsMenuItemAt');
    });
    $KU.defineProperty(voltmx.application, 'removeSecondaryTile', function() {
        _notSupported('voltmx.application.removeSecondaryTile');
    });
    $KU.defineProperty(voltmx.application, 'requestReview', function() {
        _notSupported('voltmx.application.requestReview');
    });
    $KU.defineProperty(voltmx.application, 'setCheckBoxSelectionImageAlignment', function() {
        _notSupported('voltmx.application.setCheckBoxSelectionImageAlignment');
    });
    $KU.defineProperty(voltmx.application, 'setCurrentAppMenuFont', function() {
        _notSupported('voltmx.application.setCurrentAppMenuFont');
    });
    $KU.defineProperty(voltmx.application, 'setDefaultListboxPadding', function() {
        _notSupported('voltmx.application.setDefaultListboxPadding');
    });
    $KU.defineProperty(voltmx.application, 'setDefaultTextboxPadding', function() {
        _notSupported('voltmx.application.setDefaultTextboxPadding');
    });
    $KU.defineProperty(voltmx.application, 'setApplicationBadgeValue', function() {
        _notSupported('voltmx.application.setApplicationBadgeValue');
    });
    $KU.defineProperty(voltmx.application, 'setApplicationProperties', function() {
        _notSupported('voltmx.application.setApplicationProperties');
    });
    $KU.defineProperty(voltmx.application, 'setAppMenuBadgeValue', function() {
        _notSupported('voltmx.application.setAppMenuBadgeValue');
    });
    $KU.defineProperty(voltmx.application, 'setCurrentSettingsMenu', function() {
        _notSupported('voltmx.application.setCurrentSettingsMenu');
    });
    $KU.defineProperty(voltmx.application, 'seAppTitle', function() {
        _notSupported('voltmx.application.seAppTitle');
    });
    $KU.defineProperty(voltmx.application, 'setSecondaryTile', function() {
        _notSupported('voltmx.application.setSecondaryTile');
    });
    $KU.defineProperty(voltmx.application, 'setZoomedOutView', function() {
        _notSupported('voltmx.application.setZoomedOutView');
    });
    $KU.defineProperty(voltmx.application, 'zoomIn', function() {
        _notSupported('voltmx.application.zoomIn');
    });

    $KU.defineProperty(voltmx.backgroundtasks, 'startTask', function() {
        _notSupported('voltmx.backgroundtasks.startTask');
    });
    $KU.defineProperty(voltmx.backgroundtasks, 'stopTask', function() {
        _notSupported('voltmx.backgroundtasks.stopTask');
    });
    $KU.defineProperty(voltmx.backgroundtasks, 'getTaskDetails', function() {
        _notSupported('voltmx.backgroundtasks.getTaskDetails');
    });

    $KU.defineProperty(voltmx.camera, 'releaseRawBytes', function() {
        _notSupported('voltmx.camera.releaseRawBytes');
    });

    $KU.defineProperty(voltmx.contact, 'add', function() {
        _notSupported('voltmx.contact.add');
    });
    $KU.defineProperty(voltmx.contact, 'details', function() {
        _notSupported('voltmx.contact.details');
    });
    $KU.defineProperty(voltmx.contact, 'find', function() {
        _notSupported('voltmx.contact.find');
    });
    $KU.defineProperty(voltmx.contact, 'remove', function() {
        _notSupported('voltmx.contact.remove');
    });

    $KU.defineProperty(voltmx.crypto, 'createHMacHash', function() {
        _notSupported('voltmx.crypto.createHMacHash');
    });

    $KU.defineProperty(voltmx.dragdrop, 'DragInteraction', function() {
        _notSupported('voltmx.dragdrop.DragInteraction');
    });
    $KU.defineProperty(voltmx.dragdrop, 'DropInteraction', function() {
        _notSupported('voltmx.dragdrop.DropInteraction');
    });
    $KU.defineProperty(voltmx.dragdrop, 'removeDragInteraction', function() {
        _notSupported('voltmx.dragdrop.removeDragInteraction');
    });
    $KU.defineProperty(voltmx.dragdrop, 'removeDropInteraction', function() {
        _notSupported('voltmx.dragdrop.removeDropInteraction');
    });

    $KU.defineProperty(voltmx.filter, 'createFilter', function() {
        _notSupported('voltmx.filter.createFilter');
    });

    $KU.defineProperty(voltmx.forcetouch, 'getQuickActionItems', function() {
        _notSupported('voltmx.forcetouch.getQuickActionItems');
    });
    $KU.defineProperty(voltmx.forcetouch, 'getStaticQuickActionItems', function() {
        _notSupported('voltmx.forcetouch.getStaticQuickActionItems');
    });
    $KU.defineProperty(voltmx.forcetouch, 'removeQuickActionItems', function() {
        _notSupported('voltmx.forcetouch.removeQuickActionItems');
    });
    $KU.defineProperty(voltmx.forcetouch, 'setQuickActionItems', function() {
        _notSupported('voltmx.forcetouch.setQuickActionItems');
    });

    $KU.defineProperty(voltmx.image, 'createImage', function() {
        _notSupported('voltmx.image.createImage');
    });
    $KU.defineProperty(voltmx.image, 'createImageFromSnapShot', function() {
        _notSupported('voltmx.image.createImageFromSnapShot');
    });
    $KU.defineProperty(voltmx.image, 'cropImageInTiles', function() {
        _notSupported('voltmx.image.cropImageInTiles');
    });
    $KU.defineProperty(voltmx.image, 'cropImageInTilesForRects', function() {
        _notSupported('voltmx.image.cropImageInTilesForRects');
    });

    $KU.defineProperty(voltmx.iMessageExtensions, 'setExtensionsCallbacks', function() {
        _notSupported('voltmx.iMessageExtensions.setExtensionsCallbacks');
    });

    $KU.defineProperty(voltmx.intentExtension, 'setExtensionsCallbacks', function() {
        _notSupported('voltmx.intentExtension.setExtensionsCallbacks');
    });

    /*$KU.defineProperty(voltmx.io, 'FileList', {});
    $KU.defineProperty(voltmx.io.FileList, 'item', function() {
        _notSupported('voltmx.io.FileList.item');
    });*/

    $KU.defineProperty(voltmx.io.FileSystem, 'getAppGroupDirectoryPath', function() {
        _notSupported('voltmx.io.FileSystem.getAppGroupDirectoryPath');
    });
    $KU.defineProperty(voltmx.io.FileSystem, 'getApplicationDirectoryPath', function() {
        _notSupported('voltmx.io.FileSystem.getApplicationDirectoryPath');
    });
    $KU.defineProperty(voltmx.io.FileSystem, 'getCacheDirectoryPath', function() {
        _notSupported('voltmx.io.FileSystem.getCacheDirectoryPath');
    });
    $KU.defineProperty(voltmx.io.FileSystem, 'getDatabaseDirectoryPath', function() {
        _notSupported('voltmx.io.FileSystem.getDatabaseDirectoryPath');
    });
    $KU.defineProperty(voltmx.io.FileSystem, 'getExternalStorageDirectoryPath', function() {
        _notSupported('voltmx.io.FileSystem.getExternalStorageDirectoryPath');
    });
    $KU.defineProperty(voltmx.io.FileSystem, 'getFile', function() {
        _notSupported('voltmx.io.FileSystem.getFile');
    });
    $KU.defineProperty(voltmx.io.FileSystem, 'getRawDirectoryPath', function() {
        _notSupported('voltmx.io.FileSystem.getRawDirectoryPath');
    });
    $KU.defineProperty(voltmx.io.FileSystem, 'getSupportDirectoryPath', function() {
        _notSupported('voltmx.io.FileSystem.getSupportDirectoryPath');
    });
    $KU.defineProperty(voltmx.io.FileSystem, 'isExternalStorageAvailable', function() {
        _notSupported('voltmx.io.FileSystem.isExternalStorageAvailable');
    });

    $KU.defineProperty(voltmx.keychain, 'remove', function() {
        _notSupported('voltmx.keychain.remove');
    });
    $KU.defineProperty(voltmx.keychain, 'retrieve', function() {
        _notSupported('voltmx.keychain.retrieve');
    });
    $KU.defineProperty(voltmx.keychain, 'save', function() {
        _notSupported('voltmx.keychain.save');
    });

    $KU.defineProperty(voltmx.lang, 'getUncaughtExceptionHandler', function() {
        _notSupported('voltmx.lang.getUncaughtExceptionHandler');
    });
    $KU.defineProperty(voltmx.lang, 'setUncaughtExceptionHandler', function() {
        _notSupported('voltmx.lang.setUncaughtExceptionHandler');
    });

    $KU.defineProperty(voltmx.localAuthentication, 'authenticate', function() {
        _notSupported('voltmx.localAuthentication.authenticate');
    });
    $KU.defineProperty(voltmx.localAuthentication, 'getBiometryType', function() {
        _notSupported('voltmx.localAuthentication.getBiometryType');
    });
    $KU.defineProperty(voltmx.localAuthentication, 'cancelAuthentication', function() {
        _notSupported('voltmx.localAuthentication.cancelAuthentication');
    });
    $KU.defineProperty(voltmx.localAuthentication, 'getStatusForAuthenticationMode', function() {
        _notSupported('voltmx.localAuthentication.getStatusForAuthenticationMode');
    });

    $KU.defineProperty(voltmx.localnotifications, 'cancel', function() {
        _notSupported('voltmx.localnotifications.cancel');
    });
    $KU.defineProperty(voltmx.localnotifications, 'create', function() {
        _notSupported('voltmx.localnotifications.create');
    });
    $KU.defineProperty(voltmx.localnotifications, 'getNotifications', function() {
        _notSupported('voltmx.localnotifications.getNotifications');
    });
    $KU.defineProperty(voltmx.localnotifications, 'setCallbacks', function() {
        _notSupported('voltmx.localnotifications.setCallbacks');
    });

    $KU.defineProperty(voltmx.map, 'containsLocation', function() {
        _notSupported('voltmx.map.containsLocation');
    });
    $KU.defineProperty(voltmx.map, 'distanceBetween', function() {
        _notSupported('voltmx.map.distanceBetween');
    });
    $KU.defineProperty(voltmx.map, 'decode', function() {
        _notSupported('voltmx.map.decode');
    });
    $KU.defineProperty(voltmx.map, 'searchRoutes', function() {
        _notSupported('voltmx.map.searchRoutes');
    });    

    $KU.defineProperty(voltmx.media, 'createFromFile', function() {
        _notSupported('voltmx.media.createFromFile');
    });
    $KU.defineProperty(voltmx.media, 'createFromUri', function() {
        _notSupported('voltmx.media.createFromUri');
    });

    $KU.defineProperty(voltmx.net, 'urlDecode', function() {
        _notSupported('voltmx.net.urlDecode');
    });
    $KU.defineProperty(voltmx.net, 'urlEncode', function() {
        _notSupported('voltmx.net.urlEncode');
    });

    $KU.defineProperty(voltmx.net.cache, 'setMemoryAndDiskCapacity', function() {
        _notSupported('voltmx.net.cache.setMemoryAndDiskCapacity');
    });
    $KU.defineProperty(voltmx.net.cache, 'getMemoryCapacity', function() {
        _notSupported('voltmx.net.cache.getMemoryCapacity');
    });
    $KU.defineProperty(voltmx.net.cache, 'getDiskCapacity', function() {
        _notSupported('voltmx.net.cache.getDiskCapacity');
    });
    $KU.defineProperty(voltmx.net.cache, 'getCurrentDiskUsage', function() {
        _notSupported('voltmx.net.cache.getCurrentDiskUsage');
    });
    $KU.defineProperty(voltmx.net.cache, 'getCurrentMemoryUsage', function() {
        _notSupported('voltmx.net.cache.getCurrentMemoryUsage');
    });
    $KU.defineProperty(voltmx.net.cache, 'setCacheConfig', function() {
        _notSupported('voltmx.net.cache.setCacheConfig');
    });

    $KU.defineProperty(voltmx.notificationContentExtension, 'setExtensionsCallbacks', function() {
        _notSupported('voltmx.notificationContentExtension.setExtensionsCallbacks');
    });

    $KU.defineProperty(voltmx.notificationsettings, 'createAction', function() {
        _notSupported('voltmx.notificationsettings.createAction');
    });
    $KU.defineProperty(voltmx.notificationsettings, 'createCategory', function() {
        _notSupported('voltmx.notificationsettings.createCategory');
    });
    $KU.defineProperty(voltmx.notificationsettings, 'registerCategory', function() {
        _notSupported('voltmx.notificationsettings.registerCategory');
    });
    $KU.defineProperty(voltmx.os, 'getDeviceId', function() {
        _notSupported('voltmx.os.getDeviceId');
    });
    $KU.defineProperty(voltmx.os, 'hasAccelerometerSupport', function() {
        _notSupported('voltmx.os.hasAccelerometerSupport');
    });
    $KU.defineProperty(voltmx.os, 'registerSpeechRecognizer', function() {
        _notSupported('voltmx.os.registerSpeechRecognizer');
    });
    $KU.defineProperty(voltmx.os, 'startSpeechRecognition', function() {
        _notSupported('voltmx.os.startSpeechRecognition');
    });
    $KU.defineProperty(voltmx.os, 'stopSpeechRecognition', function() {
        _notSupported('voltmx.os.stopSpeechRecognition');
    });
    $KU.defineProperty(voltmx.os, 'unregisterSpeechRecognizer', function() {
        _notSupported('voltmx.os.unregisterSpeechRecognizer');
    });
    $KU.defineProperty(voltmx.os, 'getBatteryLevel', function() {
        _notSupported('voltmx.os.getBatteryLevel');
    });
    $KU.defineProperty(voltmx.os, 'registerBatteryChange', function() {
        _notSupported('voltmx.os.registerBatteryChange');
    });
    $KU.defineProperty(voltmx.os, 'unregisterBatteryChange', function() {
        _notSupported('voltmx.os.unregisterBatteryChange');
    });

    $KU.defineProperty(voltmx.payment, 'canWeMakePayment', function() {
        _notSupported('voltmx.payment.canWeMakePayment');
    });
    $KU.defineProperty(voltmx.payment, 'getPaymentData', function() {
        _notSupported('voltmx.payment.getPaymentData');
    });
    $KU.defineProperty(voltmx.payment, 'getSupportedPaymentNetworks', function() {
        _notSupported('voltmx.payment.getSupportedPaymentNetworks');
    });
    $KU.defineProperty(voltmx.payment, 'updateTransactionResponse', function() {
        _notSupported('voltmx.payment.updateTransactionResponse');
    });

    $KU.defineProperty(voltmx.phone, 'addCalendarEvent', function() {
        _notSupported('voltmx.phone.addCalendarEvent');
    });
    $KU.defineProperty(voltmx.phone, 'cancelVibration', function() {
        _notSupported('voltmx.phone.cancelVibration');
    });
    $KU.defineProperty(voltmx.phone, 'findCalendarEvents', function() {
        _notSupported('voltmx.phone.findCalendarEvents');
    });
    $KU.defineProperty(voltmx.phone, 'getRemoveEventOptions', function() {
        _notSupported('voltmx.phone.getRemoveEventOptions');
    });
    $KU.defineProperty(voltmx.phone, 'hasVibratorSupport', function() {
        _notSupported('voltmx.phone.hasVibratorSupport');
    });
    $KU.defineProperty(voltmx.phone, 'openEmail', function() {
        _notSupported('voltmx.phone.openEmail');
    });
    $KU.defineProperty(voltmx.phone, 'performHapticFeedback', function() {
        _notSupported('voltmx.phone.performHapticFeedback');
    });
    $KU.defineProperty(voltmx.phone, 'removeCalendarEvent', function() {
        _notSupported('voltmx.phone.removeCalendarEvent');
    });
    $KU.defineProperty(voltmx.phone, 'sendSMS', function() {
        _notSupported('voltmx.phone.sendSMS');
    });
    $KU.defineProperty(voltmx.phone, 'startVibration', function() {
        _notSupported('voltmx.phone.startVibration');
    });

    $KU.defineProperty(voltmx.reactNative, 'setCallback', function() {
        _notSupported('voltmx.reactNative.setCallback');
    });
    $KU.defineProperty(voltmx.reactNative, 'sendResult', function() {
        _notSupported('voltmx.reactNative.sendResult');
    });

    $KU.defineProperty(voltmx.shareExtensions, 'popConfigurationViewController', function() {
        _notSupported('voltmx.shareExtensions.popConfigurationViewController');
    });
    $KU.defineProperty(voltmx.shareExtensions, 'pushConfigurationViewController', function() {
        _notSupported('voltmx.shareExtensions.pushConfigurationViewController');
    });
    $KU.defineProperty(voltmx.shareExtensions, 'setExtensionsCallbacks', function() {
        _notSupported('voltmx.shareExtensions.setExtensionsCallbacks');
    });

    $KU.defineProperty(voltmx.stream, 'registerDataStream', function() {
        _notSupported('voltmx.stream.registerDataStream');
    });
    $KU.defineProperty(voltmx.stream, 'deregisterDataStream', function() {
        _notSupported('voltmx.stream.deregisterDataStream');
    });
    $KU.defineProperty(voltmx.stream, 'setCallback', function() {
        _notSupported('voltmx.stream.setCallback');
    });

    $KU.defineProperty(voltmx.todayExtension, 'setExtensionsCallbacks', function() {
        _notSupported('voltmx.todayExtension.setExtensionsCallbacks');
    });

    $KU.defineProperty(voltmx.types, 'RawBytes', function() {
        _notSupported('voltmx.types.RawBytes');
    });
    $KU.defineProperty(voltmx.types.RawBytes.prototype, 'readAsText', function() {
        _notSupported('voltmx.types.RawBytes.readAsText');
    });
    $KU.defineProperty(voltmx.web, 'WebAuthenticationSession', function() {
        _notSupported('voltmx.web.WebAuthenticationSession');
    });

    $KU.defineProperty(com.voltmx, 'BeaconRegion', function() {
        _notSupported('com.voltmx.BeaconRegion');
    });
    $KU.defineProperty(com.voltmx, 'PeripheralManager', function() {
        _notSupported('com.voltmx.PeripheralManager');
    });
    $KU.defineProperty(com.voltmx, 'isPassLibraryAvailable', function() {
        _notSupported('com.voltmx.isPassLibraryAvailable');
    });

    $KU.defineProperty(com.voltmx, 'Beacon', function() {
        _notSupported('com.voltmx.Beacon');
    });
    $KU.defineProperty(com.voltmx.Beacon.prototype, 'getrssi', function() {
        _notSupported('com.voltmx.Beacon.getrssi');
    });
    $KU.defineProperty(com.voltmx.Beacon.prototype, 'getMajor', function() {
        _notSupported('com.voltmx.Beacon.getMajor');
    });
    $KU.defineProperty(com.voltmx.Beacon.prototype, 'getMinor', function() {
        _notSupported('com.voltmx.Beacon.getMinor');
    });
    $KU.defineProperty(com.voltmx.Beacon.prototype, 'getAccuracy', function() {
        _notSupported('com.voltmx.Beacon.getAccuracy');
    });
    $KU.defineProperty(com.voltmx.Beacon.prototype, 'getProximity', function() {
        _notSupported('com.voltmx.Beacon.getProximity');
    });
    $KU.defineProperty(com.voltmx.Beacon.prototype, 'getProximityUUIDString', function() {
        _notSupported('com.voltmx.Beacon.getProximityUUIDString');
    });

    $KU.defineProperty(com.voltmx, 'BeaconManager', function() {
        _notSupported('com.voltmx.BeaconManager');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'getRangedRegions', function() {
        _notSupported('com.voltmx.BeaconManager.getRangedRegions');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'authorizationStatus', function() {
        _notSupported('com.voltmx.BeaconManager.authorizationStatus');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'getMonitoredRegions', function() {
        _notSupported('com.voltmx.BeaconManager.getMonitoredRegions');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'requestStateForRegion', function() {
        _notSupported('com.voltmx.BeaconManager.requestStateForRegion');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'stopRangingBeaconsInRegion', function() {
        _notSupported('com.voltmx.BeaconManager.stopRangingBeaconsInRegion');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'startMonitoringBeaconRegion', function() {
        _notSupported('com.voltmx.BeaconManager.startMonitoringBeaconRegion');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'startRangingBeaconsInRegion', function() {
        _notSupported('com.voltmx.BeaconManager.startRangingBeaconsInRegion');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'stopMonitoringBeaconsRegion', function() {
        _notSupported('com.voltmx.BeaconManager.stopMonitoringBeaconsRegion');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'isRangingAvailableForBeaconRegions', function() {
        _notSupported('com.voltmx.BeaconManager.isRangingAvailableForBeaconRegions');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'setAuthorizationStatusChangedCallback', function() {
        _notSupported('com.voltmx.BeaconManager.setAuthorizationStatusChangedCallback');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'setMonitoringStartedForRegionCallback', function() {
        _notSupported('com.voltmx.BeaconManager.setMonitoringStartedForRegionCallback');
    });
    $KU.defineProperty(com.voltmx.BeaconManager.prototype, 'isMonitoringAvailableForBeaconRegions', function() {
        _notSupported('com.voltmx.BeaconManager.isMonitoringAvailableForBeaconRegions');
    });

    $KU.defineProperty(com.voltmx, 'PeripheralManager', function() {
        _notSupported('com.voltmx.PeripheralManager');
    });
    $KU.defineProperty(com.voltmx.PeripheralManager.prototype, 'isAdvertising', function() {
        _notSupported('com.voltmx.PeripheralManager.isAdvertising');
    });
    $KU.defineProperty(com.voltmx.PeripheralManager.prototype, 'stopAdvertising', function() {
        _notSupported('com.voltmx.PeripheralManager.stopAdvertising');
    });
    $KU.defineProperty(com.voltmx.PeripheralManager.prototype, 'authorizationStatus', function() {
        _notSupported('com.voltmx.PeripheralManager.authorizationStatus');
    });
    $KU.defineProperty(com.voltmx.PeripheralManager.prototype, 'startAdvertisingWithMeasuredPower', function() {
        _notSupported('com.voltmx.PeripheralManager.startAdvertisingWithMeasuredPower');
    });

    $KU.defineProperty(com.voltmx, 'PassLibrary', function() {
        _notSupported('com.voltmx.PassLibrary');
    });
    $KU.defineProperty(com.voltmx.PassLibrary.prototype, 'addPassWithCompletionCallback', function() {
        _notSupported('com.voltmx.PassLibrary.addPassWithCompletionCallback');
    });
    $KU.defineProperty(com.voltmx.PassLibrary.prototype, 'addPassesWithCompletionCallback', function() {
        _notSupported('com.voltmx.PassLibrary.addPassesWithCompletionCallback');
    });
    $KU.defineProperty(com.voltmx.PassLibrary.prototype, 'containsPass', function() {
        _notSupported('com.voltmx.PassLibrary.containsPass');
    });
    $KU.defineProperty(com.voltmx.PassLibrary.prototype, 'getPassWithTypeIdentifierAndSerialNumber', function() {
        _notSupported('com.voltmx.PassLibrary.getPassWithTypeIdentifierAndSerialNumber');
    });
    $KU.defineProperty(com.voltmx.PassLibrary.prototype, 'getPasses', function() {
        _notSupported('com.voltmx.PassLibrary.getPasses');
    });
    $KU.defineProperty(com.voltmx.PassLibrary.prototype, 'removePass', function() {
        _notSupported('com.voltmx.PassLibrary.removePass');
    });
    $KU.defineProperty(com.voltmx.PassLibrary.prototype, 'replacePassWithPass', function() {
        _notSupported('com.voltmx.PassLibrary.replacePassWithPass');
    });

    $KU.defineProperty(voltmx, 'runOnMainThread', function() {
        _notSupported('voltmx.runOnMainThread');
    });
    $KU.defineProperty(voltmx, 'runOnWorkerThread', function() {
        _notSupported('voltmx.runOnWorkerThread');
    });

}());

/* FILE PATH :: 'lib/plugins/voltmxdropdown.js' */
/* global Volt MX */
(function() {
    var _default = {
        caseSensitive: false,
        focusOutInstance: false,
        searchCritaria: voltmx.$kwebfw$.constants.STARTS_WITH,
        icon: 'kdropdownicon.png',
        position: voltmx.$kwebfw$.constants.POSITION_AUTO,
        height: '200px',
        selectedOption: '',
        callback: null,
        selectedSkin: '-voltmx-selected',
        hoverSkin: '-voltmx-hovered',
        focusSkin: '-voltmx-focused'
    },

    _map = {}

    var _attachEvents = function() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, instance = _map[this.id];

        $KD.on(instance.container, 'click', 'dropdown', _containerOnClick, {scope:this});
        $KD.on(instance.list, 'click', 'dropdown', _listOnClick, {scope:this});
        $KD.on(instance.list, 'mousemove', 'dropdown', _listOnHover, {scope:this});
        $KD.on(instance.input, 'input', 'dropdown', _input, {scope:this});
        $KD.on(instance.container, 'keydown', 'dropdown', _keydown, {scope:this});
        $KD.on(instance.input, 'keydown', 'dropdown', _keydown, {scope:this});

        if(instance.focusOutInstance) {
            $KD.on(instance.container, 'focusout', 'dropdown', _onFocusout, {scope:this});
        }
    },

    _containerOnClick = function(e) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, instance = _map[this.id];

        if(!$KD.hasCls(instance.container, 'active')){
            this.createOptions();
        }

        if (e.target === instance.input) {
            $KD.toggleCls(instance.container, 'active');
        } else if (e.target === instance.icon) {//todo
            $KD.toggleCls(instance.container, 'active');
            $KD.focus(instance.input);
        }

        if($KD.hasCls(instance.container, 'active')) {
            _setPosition.call(this);
            if(instance.selectedOption) {
                selectedLI = _getSelectedNode.call(this, instance.selectedOption);
                selectedLI && $KD.addCls(selectedLI, instance.selectedSkin);
                selectedLI && $KD.addCls(selectedLI, instance.focusSkin);
                $KD.setAttr(selectedLI, 'isselected', 'true');
                selectedLI.focus();
                instance.input.focus();
                //selectedLI.setAttribute('aria-selected', 'selected');//todo
            }
        }
    },

    _setPosition = function() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, constants = voltmx.$kwebfw$.constants,
            instance = _map[this.id], position, selectedLI;

        if($KD.hasCls(instance.container, 'active')) {
            if(instance.position === constants.POSITION_AUTO) {
                position = _getPosition(instance.container, instance.list.offsetHeight);
                if(position === constants.POSITION_TOP) {
                    $KD.style(instance.list, 'top', null);
                    $KD.style(instance.list, 'bottom', '100%');
                    $KD.setAttr(instance.container, 'kposition', 'top');
                } else {
                    $KD.style(instance.list, 'bottom', null);
                    $KD.style(instance.list, 'top', '100%');
                    $KD.setAttr(instance.container, 'kposition', 'bottom');
                }
            }
        }
    },

    _dettachEvents = function() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, instance = _map[this.id];

        $KD.off(instance.container);
        $KD.off(instance.list);
        $KD.off(instance.input);
    },

    _getPosition = function(el, height) {
        var offset = el.getBoundingClientRect(), position = 'top';
        if(window.innerHeight - offset.y - offset.height - height >= 0) {
            position = 'bottom';
        }
        return position;
    },

    _getSelectedNode = function(txt) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU=$K.utils, instance = _map[this.id], selectedNode = null;

        $KU.each($KD.children(instance.list), function(li) {
            if(li.innerText === txt) {
                selectedNode = li;
            }
        });

        return selectedNode;
    },

    _input = function(e){
        var $K = voltmx.$kwebfw$, $KD = $K.dom, instance = _map[this.id];

        if (!$KD.hasCls(instance.container, 'active')) {
            $KD.addCls(instance.container, 'active');
        }

        this.createOptions(instance.input.value);

        _setPosition.call(this);
    },

    _keydown = function(e){
        var $K = voltmx.$kwebfw$, $KD = $K.dom, instance = _map[this.id],
            kposition = $KD.getAttr(instance.container, 'kposition');

        if(e.keyCode === 40){//down arrow
            if(e.target === instance.input && kposition === 'bottom') {
                $KD.focus(instance.list);
            } else if(e.target === instance.list) {
                if($KD.childAt(instance.list, 0)) {
                    $KD.focus($KD.childAt(instance.list, 0));
                }
            } else {
                $KD.next(e.target) && $KD.focus($KD.next(e.target));
            }
        } else if(e.keyCode === 38){//up arrow
            if(e.target === instance.input && kposition === 'top') {
                $KD.focus(instance.list);
            } else if(e.target === instance.list) {
                $KD.focus(instance.input);
            } else {
                if($KD.prev(e.target)) {
                    $KD.focus($KD.prev(e.target));
                } else {
                    $KD.focus(instance.list);
                }
            }
        } else if((e.keyCode === 13 || e.keyCode === 32) && e.target.tagName === 'LI') {
            _onSelect.call(this, e.target);
        }
    },

    _listOnClick = function(e) {
        _onSelect.call(this, e.target);
    },

   _listOnHover = function(e) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, instance = _map[this.id], target = e.target,
        relatedNode = instance.relatedNode, hoverSkin = instance.hoverSkin;

        if(relatedNode) {
            $KD.removeCls(relatedNode, hoverSkin);
            if($KD.hasAttr(relatedNode, 'isselected')) {
                $KD.addCls(relatedNode, instance.selectedSkin);
            }

            instance.relatedNode = null;
        }

        if(target.tagName === 'LI') {
            $KD.addCls(target, hoverSkin);
            instance.relatedNode = target;
            if($KD.hasAttr(target, 'isselected')) {
                $KD.removeCls(target, instance.selectedSkin);
            }
        }
   };

    _onFocusout = function(e) {
        var instance = _map[this.id], self = this;

        timeout = setTimeout(function() {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = self._kwebfw_;

            if(instance && !(instance.container === $KD.active() || $KD.contains(instance.container, $KD.active())
            || $KD.parent(instance.container) === $KD.active()) && $KD.hasCls(instance.container, 'active')) {
                $KD.removeCls(instance.container, 'active');
            }

            clearTimeout(timeout); self = timeout = null;
        }, 0);
    };

    _onSelect = function(li) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, instance = _map[this.id];

        $KD.setAttr(instance.input, 'value', li.innerText);
        $KD.removeCls(instance.container, 'active');

        instance.selectedOption = li.innerText;
        instance.callback && instance.callback.call(this, instance.selectedOption);
    };

    voltmx.$kwebfw$.plugins.DropDown = function(data, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, prop = null;

        this.id = 'K'+$KU.uid();
        if(_map.hasOwnProperty(this.id)) {
            //Throw Error
            return;
        }

        _map[this.id] = {};
        prop = _map[this.id];

        prop.options = data || [];
        config = config || {};

        $KU.each(_default, function(value, key) {
            prop[key] = (config.hasOwnProperty(key)) ? config[key] : value;
        });

        this.init();
        //this.createOptions();

        if(config.renderTo) this.renderTo(config.renderTo);
    };

    voltmx.$kwebfw$.plugins.DropDown.prototype = {
        _get: function(property) {
            return _map[this.id][property];
        },

        createOptions: function(filter) {//need to change the name
            var $K = voltmx.$kwebfw$, $KD = $K.dom, constants = voltmx.$kwebfw$.constants,
                list = null, filterOptions = null, fragment = null, instance = _map[this.id];

            filter = filter || "";
            list = instance.list;

            if(!instance.caseSensitive) {
                filter = filter.toLowerCase();
            }
            filterOptions = instance.options.filter(
                function(option) {
                    //Todo search criteria
                    option = option.toString();//todo
                    if(!instance.caseSensitive) {
                        option = option.toLowerCase();
                    }
                    if(instance.searchCritaria === constants.STARTS_WITH) {
                        return filter === "" || option.substring(0, filter.length) === filter;
                    } else if(instance.searchCritaria === constants.CONTAINS) {
                        return filter === "" || option.indexOf(filter) != -1;
                    } else {
                        return instance.searchCritaria(option, filter);
                    }
                }
            );

            if (filterOptions.length === 0) {
                $KD.removeCls(list, 'active');
            } else {
                $KD.addCls(list, 'active');
            }

            list.innerHTML = '';
            fragment = $KD.create();
            filterOptions.forEach(function(foption){
                var li = $KD.create('LI', {tabIndex: -1, role: 'row', 'aria-colcount': 1});
                li.innerText = foption;
                $KD.add(fragment, li);
            });
            $KD.add(list, fragment);
            $KD.setAttr(list, 'aria-rowcount', filterOptions.length);
        },

        destroy: function() {
            _dettachEvents.call(this);
            delete  _map[this.id];
        },

        disable: function() {
            //
        },

        enable: function() {
            //
        },

        init: function() {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils,
                constants = voltmx.$kwebfw$.constants, instance = _map[this.id];

            instance.container = $KD.create('div');
            instance.input = $KD.create('input', {type: 'text'});
            instance.icon = $KD.create('img', {src: $KU.getImageURL(instance.icon)});
            instance.list = $KD.create('ul', {tabIndex: 1, role: 'grid', 'aria-colcount': 1});

            $KD.add(instance.container, instance.input);
            $KD.add(instance.container, instance.icon);
            $KD.add(instance.container, instance.list);

            $KD.style(instance.list, 'maxHeight', instance.height);
            $KD.setAttr(instance.container, 'kdropdown', true);
            instance.selectedOption && $KD.setAttr(instance.input, 'value', instance.selectedOption);

            if(instance.position === constants.POSITION_TOP) {
                $KD.style(instance.list, 'bottom', '100%');
                $KD.setAttr(instance.container, 'kposition', 'top');
            } else if(instance.position === constants.POSITION_BOTTOM) {
                $KD.style(instance.list, 'top', '100%');
                $KD.setAttr(instance.container, 'kposition', 'bottom');
            } else {//POSITION_AUTO
                //
            }

            _attachEvents.call(this);
        },

        renderTo: function(holder) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, instance = _map[this.id];

            $KD.add(holder, instance.container);
        }
    };
}());


/* FILE PATH :: 'lib/widgets/voltmxform.js' */
(function() {
    var $K = voltmx.$kwebfw$, _navigated = false;

    Object.defineProperty(voltmx.$kwebfw$.flag, 'navigated', {
        enumerable:false, configurable:true,
        get:function() {
            return _navigated;
        }
    });
    Object.defineProperty(voltmx.$kwebfw$.flag, 'navigated', {
        enumerable:false, configurable:false, set:function(/*val*/) {}
    });


    $K.defVoltmxProp($K.ui, [
        {keey:'Form2', value:{}, items:[
            {keey:'onOrientation', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, device = $K.device;

                device.height = $KD.body().offsetHeight;
                device.width = $KD.body().offsetWidth;

                this.forceLayout(true);
            }},

            {keey:'onResize', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    $KD = $K.dom, device = $K.device, height = -1, width = -1;

                height = $KD.body().offsetHeight;
                width = $KD.body().offsetWidth;
                //* DONOT DELETE:: This block or below block
                device.height = height;
                device.width = width;
                //*/
                /* DONOT DELETE:: This block or above block
                if(height !== device.height && width !== device.width) {
                    //Orientation might have changed
                    //TODO:: We need a better condition
                    device.height = height;
                    device.width = width;
                //} else if(width === device.width && height !== device.height) {
                    //Keyboard might have opened or something else
                    //We can even check if document.activeElement is...
                    //...textbox(not button or submit)/textarea/contentEditable
                }
                //*/

                if($K.behavior.responsive === true) {
                    if(_hasBreakpointChanged.call(this, device.width)) {
                        //Framework should do something for ResponsiveLayout

                        __relayoutResponsiveContainers(this);
                        $KW.invokeLifeCycleEvent(this, 'onBreakpointHandler', true);
                        $KW.invokeLifeCycleEvent(this, 'onBreakpointChange', true);
                    }

                    $KW.fire(this, 'onResize', this);
                }
                this.forceLayout(true);
            }}
        ]}
    ]);


    var _deduceAnimationDetails = function(current, previous) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            anim = {}, effect = null, inTrans = current.inTransitionConfig,
            outTrans = previous.outTransitionConfig, inAnim = -1, outAnim = -1,
            formIn = {
                'topCenter': 'slidetopin',
                'bottomCenter': 'slidebottomin',
                'rightCenter': 'sliderightin',
                'leftCenter': 'slideleftin',
                'fadeAnimation': 'fadein',
                'anim1': 'slidetopin',
                'anim2': 'sliderightin',
                'anim3': 'slideleftin',
                'anim4': 'sliderightin',
                'anim5': 'slideleftin',
                'anim6': 'scalein',
                'anim7': 'slidetoprightin',
                'anim8': 'slidebottomleftin',
                'anim9': 'expandvertically',
                'anim10': 'slidebottomin'
            }, formOut = {
                'rightCenter': 'sliderightout',
                'leftCenter': 'slideleftout',
                'topCenter': 'slidetopout',
                'bottomCenter': 'slidebottomout',
                'fadeAnimation': 'fadeout',
                'anim1': 'slidetopout',
                'anim2': 'sliderightout',
                'anim3': 'slideleftout',
                'anim4': 'sliderightout',
                'anim5': 'slideleftout',
                'anim6': 'scaleout',
                'anim7': 'slidetoprightout',
                'anim8': 'slidebottomleftout',
                'anim9': 'shrinkvertically',
                'anim10': 'slidebottomout'
            };

        if(inTrans && ($KU.is(inTrans.formAnimation, 'number')
        || $KU.is(inTrans.formanimation, 'number'))) {
            inAnim = ($KU.is(inTrans.formAnimation, 'number') ? inTrans.formAnimation : inTrans.formanimation);
            if(inAnim > 0) {
                anim = {in:{effect:formIn[('anim'+inAnim.toString())], duration:'0.5s'}};
            }

            if(outTrans && ($KU.is(outTrans.formAnimation, 'number')
            || $KU.is(outTrans.formanimation, 'number'))) {
                outAnim = ($KU.is(outTrans.formAnimation, 'number') ? outTrans.formAnimation : outTrans.formanimation);
                if(outAnim > 0) {
                    anim.out = {effect:formOut[('anim'+outAnim.toString())], duration:'0.5s'};
                }
            }
        } else {
            if(inTrans) {
                effect = inTrans.formTransition || inTrans.formtransition;

                if(effect && effect !== 'none') {
                    anim.in = {effect:formIn[effect], duration:'0.5s'};
                }
            }
            if(outTrans) {
                effect = outTrans.formTransition || outTrans.formtransition;

                if(effect && effect !== 'none') {
                    anim.out = {effect:formOut[effect], duration:'0.5s'};
                }
            }
        }

        return anim;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //This function will be called in the scope of widget instance
    var _getCurrentBreakpoint = function Form2$_getCurrentBreakpoint(width) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            breakpoints = this._kwebfw_.prop.breakpoints, bp = -1;

        if($K.behavior.responsive === true) {
            if(!($KU.is(breakpoints, 'array') && breakpoints.length > 0)) {
                breakpoints = $K.behavior.breakpoints;

                if(!($KU.is(breakpoints, 'array') && breakpoints.length > 0)) {
                    breakpoints = null;
                }
            }

            if($KU.is(breakpoints, 'array') && breakpoints.length > 0) {
                if(width > breakpoints[(breakpoints.length - 1)]) {
                    bp = constants.BREAKPOINT_MAX_VALUE;
                } else if(width <= breakpoints[0]) {
                    bp = breakpoints[0];
                } else {
                    $KU.each(breakpoints, function(breakpoint) {
                        if(width <= breakpoint) {
                            bp = breakpoint;
                            return true;
                        }
                    });
                }
            }
        }

        return bp;
    };


    var __relayoutResponsiveContainers = function(formModel) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget;

        $KW.iterate(formModel, function(widget) {
            if(widget._kwebfw_.is.component) {
                widget = $KW.proxy(widget);
            }

            if(widget.layoutType === voltmx.flex.RESPONSIVE_GRID
            || (widget.parent && widget.parent.layoutType === voltmx.flex.RESPONSIVE_GRID)) {
                $KW.markRelayout(widget);
            }
        });
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        Form2: {
            breakpoints: function Form2$_getter_breakpoints(value) {
                return value.slice(0);
            },

            contentOffset: function Form2$_getter_contentOffset(value) {
                return {x:value.x, y:value.y};
            },

            contentOffsetMeasured: function Form2$_getter_contentOffsetMeasured(value) {
                var scroll = this._kwebfw_.ui.scroll;

                value.x = scroll.x;
                value.y = scroll.y;

                return {x:value.x, y:value.y};
            },

            contentSize: function Form2$_getter_contentSize(value) {
                return {width:value.width, height:value.height};
            },

            contentSizeMeasured: function Form2$_getter_contentSizeMeasured(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, el = null,
                    $KW = $K.widget, _ = this._kwebfw_, scroll = _.ui.scroll;

                if($KU.scrollType() === 'native') {
                    el = $KW.el(this);

                    scroll.width = el.viewport.scrollWidth;
                    scroll.height = el.viewport.scrollHeight;
                }

                value.width = scroll.width;
                value.height = scroll.height;

                return {width:value.width, height:value.height};
            },

            footers: function Form2$_getter_footers(value) {
                return (value) ? value.slice(0) : value;
            },

            headers: function Form2$_getter_headers(value) {
                return (value) ? value.slice(0) : value;
            },

            title: function Form2$_getter_title(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if(prop.i18n_title) {
                    value = $KU.getI18Nvalue(prop.i18n_title);
                }

                return value;
            }
        }
    };


    var _handleAnimation = function Form2$_handleAnimation(cform, cview, pform, pview) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KG = $K.globals, timeout = null,
            anim = _deduceAnimationDetails(cform, pform), duration = 0;

        if(anim.in) {
            duration = parseFloat(anim.in.duration);
            if(anim.out) {
                duration = Math.max(duration || parseFloat(anim.out.duration));
            }

            _renderCurrentForm.call(cform, $KG.appForms, cview, false);

            if(pview && anim.out) {
                $KD.addCls(pview, '-voltmx-form-trans');
                $KD.style(pview, {
                    animationName: anim.out.effect,
                    animationDuration: anim.out.duration
                });
            }
            $KD.addCls(cview, '-voltmx-form-trans');
            $KD.style(cview, {
                animationName: anim.in.effect,
                animationDuration: anim.in.duration
            });

            timeout = setTimeout(function() {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, $KA = $K.app,
                    cform = $KW.model($KA.currentFormUID), cview = cform._kwebfw_.view,
                    pform = $KW.model($KA.previousFormUID), pview = pform._kwebfw_.view;

                clearTimeout(timeout); timeout = null;

                if(pview && anim.out) {
                    $KD.style(pview, 'animation-name', null);
                    $KD.style(pview, 'animation-duration', null);
                    $KD.style(pview, {position:null, left:null, top:null});
                }

                $KD.style(cview, 'animation-name', null);
                $KD.style(cview, 'animation-duration', null);
                $KD.removeCls(cview, '-voltmx-form-trans');
                $KD.removeCls(pview, '-voltmx-form-trans');

                _removePreviousForm.call(pform);
                $K.apm.send(cform, 'FormEntry');

                $KW.invokeLifeCycleEvent(cform, 'postShow', true);
                if($KW.isFlexContainer(cform)) cform.forceLayout();
            }, (duration*1000));
        } else {
            _renderCurrentForm.call(cform, $KG.appForms, cview, true);
        }
    };


    //This function will be called in the scope of widget instance
    var _handleScrollBar = function Form2$_handleScrollBar() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, prop = this._kwebfw_.prop, el = $KW.el(this);

        if($KU.scrollType() === 'native') {
            if(!prop.enableScrolling || prop.scrollDirection === voltmx.flex.SCROLL_NONE) {
                $KD.style(el.viewport, {overflowX:'hidden', overflowY:'hidden'});
            } else { //Scrolling Enabled
                if(prop.scrollDirection === voltmx.flex.SCROLL_VERTICAL) {
                    $KD.style(el.viewport, {overflowX:'hidden', overflowY:'auto'});
                } else if(prop.scrollDirection === voltmx.flex.SCROLL_HORIZONTAL) {
                    $KD.style(el.viewport, {overflowX:'auto', overflowY:'hidden'});
                } else if(prop.scrollDirection === voltmx.flex.SCROLL_BOTH) {
                    $KD.style(el.viewport, {overflowX:'auto', overflowY:'auto'});
                }
            }
        } else { //Custom Scroll
            if(!prop.enableScrolling || prop.scrollDirection === voltmx.flex.SCROLL_NONE) {
                $KD.style(el.hScroll, 'visibility', 'hidden');
                $KD.style(el.vScroll, 'visibility', 'hidden');
            } else { //Scrolling Enabled
                if(prop.horizontalScrollIndicator) {
                    $KD.style(el.hScroll, 'visibility', null);
                } else {
                    $KD.style(el.hScroll, 'visibility', 'hidden');
                }

                if(prop.verticalScrollIndicator) {
                    $KD.style(el.vScroll, 'visibility', null);
                } else {
                    $KD.style(el.vScroll, 'visibility', 'hidden');
                }

                if(prop.horizontalScrollIndicator
                && prop.scrollDirection === voltmx.flex.SCROLL_VERTICAL) {
                    $KD.style(el.hScroll, 'visibility', 'hidden');
                } else if(prop.verticalScrollIndicator
                && prop.scrollDirection === voltmx.flex.SCROLL_HORIZONTAL) {
                    $KD.style(el.vScroll, 'visibility', 'hidden');
                }
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _hasBreakpointChanged = function Form2$_hasBreakpointChanged(width) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KA = $K.app,
            previous = -1, current = -1, changed = false;

        if($KU.is($KA.currentBreakpoint, 'integer') && $KA.currentBreakpoint >= 0) {
            previous = $KA.currentBreakpoint;
        }

        current = _getCurrentBreakpoint.call(this, width);

        if(previous !== current) {
            changed = true;
            $KA.currentBreakpoint = current;
        }

        return changed;
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        Form2: function Form2$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Form2', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Form2', null);
                }
            }

            if(!_.name) $KU.defineProperty(_, 'modalContainer', null, true);
            if(!_.ui) $KU.defineProperty(_, 'ui', {}, null);
            $KU.defineProperty(_.ui, 'scroll', {x:0, y:0, width:-1, height:-1, minX:-1, maxX:-1, minY:-1, maxY:-1, status:'ended'}, true);
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        Form2: function Form2$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = this._kwebfw_, prop = _.prop;

            if(prop.i18n_title) {
                prop.text = prop.i18n_title;
            }

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'slForm';
            }

            $KU.each(prop.footers, function(tpl) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;
                //This will create hierarchy if not created
                $KW.getTemplate(null, tpl);
            });

            $KU.each(prop.headers, function(tpl) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;
                //This will create hierarchy if not created
                $KW.getTemplate(null, tpl);
            });

        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        Form2: function Form2$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        Form2: function Form2$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //This function must be called in the scope of widget instance
    var _removePreviousForm = function Form2$_removePreviousForm() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, scroll = this._kwebfw_.ui.scroll;

        $KD.remove(this._kwebfw_.view);

        if(!this.retainScrollPosition) {
            scroll.x = scroll.y = 0;
        }
    };


    //This function must be called in the scope of widget instance
    var _renderCurrentForm = function Form2$_renderCurrentForm(holder, view, removePrevForm) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
            $KA = $K.app, _ = this._kwebfw_, el = $KW.el(view), previousForm = null;

        $KD.add(holder, view);
        $KD.style(el.viewport, {
            top:(el.header.offsetHeight+'px'),
            bottom:(el.footer.offsetHeight+'px')
        });

        if($KW.isFlexContainer(this)) {
            _navigated = true;
            this.forceLayout(true);
            _navigated = false;
        }

        _view[_.name].title.call(this, el, _.prop.title);
        $KD.style(view, 'visibility', 'visible');

        $KW.registerForIdleTimeout();
        $KW.onRender(view);

        //NOTE:: If <removePrevForm> is not a boolean, then
        //       Form.show() of current form has happened
        if(removePrevForm === true || removePrevForm !== false) {
            previousForm = $KW.model($KA.previousFormUID);

            if(removePrevForm === true && previousForm) {
                _removePreviousForm.call(previousForm);
            }

            $K.apm.send(this, 'FormEntry');

            //Incase of form animation, "postShow" is fired on "animationEnd" event
            $KW.invokeLifeCycleEvent(this, 'postShow', true);
            if($KW.isFlexContainer(this)) this.forceLayout();
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        Form2: {
            title: function Form2$_setter_title(/*old*/) {
                this._kwebfw_.prop.i18n_title = '';
            }
        }
    };


    //All the functions will be called in the scope of widget instance
    var _updateURLhash = function Form2$_updateURLhash(pf) {
        var flag = (!pf || this.id !== pf.id);

        if($K.behavior.isCompositeApp && (flag || this.appName !== pf.appName)) {
            location.hash = ('#/' + this.appName+'/'+this.id);
        } else if(flag) {
            location.hash = ('#_' + this.id);
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Form2: {
            allowHorizontalBounce: function Form2$_valid_allowHorizontalBounce(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            allowVerticalBounce: function Form2$_valid_allowVerticalBounce(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            bounces: function Form2$_valid_bounces(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            breakpoints: function Form2$_valid_breakpoints(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    i = 0, ilen = 0, flag = false;

                if($KU.is(value, 'array')) {
                    ilen = value.length;

                    for(i=0; i<ilen; i++) {
                        if($KU.is(value[i], 'integer') && value[i] > 0) {
                            if(i === 0) {
                                flag = true;
                            } else if(value[i] > value[i-1]) {
                                flag = true;
                            } else {
                                flag = false;
                                break;
                            }
                        } else {
                            flag = false;
                            break;
                        }
                    }
                }

                return flag;
            },

            contentOffset: function Form2$_valid_contentOffset(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.x, 'size')
                && $KU.is(value.y, 'size')) {
                    flag = true;
                }

                return flag;
            },

            contentOffsetMeasured: function Form2$_valid_contentOffsetMeasured(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.x, 'integer') && value.x >= 0
                && $KU.is(value.y, 'integer') && value.y >= 0) {
                    flag = true;
                }

                return flag;
            },

            contentSize: function Form2$_valid_contentSize(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.width, 'string')
                && $KU.is(value.width, 'size')
                && $KU.is(value.height, 'string')
                && $KU.is(value.height, 'size')) {
                    flag = true;
                }

                return flag;
            },

            contentSizeMeasured: function Form2$_valid_contentSizeMeasured(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.height, 'integer') && value.height >= 0
                && $KU.is(value.width, 'integer') && value.width >= 0) {
                    flag = true;
                }

                return flag;
            },

            displayOrientation: function Form2$_valid_displayOrientation(value) {
                var flag = false, options = [
                    constants.FORM_DISPLAY_ORIENTATION_BOTH,
                    constants.FORM_DISPLAY_ORIENTATION_LANDSCAPE,
                    constants.FORM_DISPLAY_ORIENTATION_PORTRAIT
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            enabledForIdleTimeout: function Form2$_valid_enabledForIdleTimeout(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            enableOnScrollWidgetPositionForSubwidgets: function Form2$_valid_enableOnScrollWidgetPositionForSubwidgets(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            enableScrolling: function Form2$_valid_enableScrolling(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            footers: function Form2$_valid_footers(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    i = 0, ilen = 0, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'array')) {
                    flag = true;
                    ilen = value.length;

                    for(i=0; i<ilen; i++) {
                        if(!$KU.is(value[i], 'widget', 'FlexContainer')) {
                            flag = false;
                            break;
                        }
                    }
                }

                return flag;
            },

            headers: function Form2$_valid_headers(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    i = 0, ilen = 0, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'array')) {
                    flag = true;
                    ilen = value.length;

                    for(i=0; i<ilen; i++) {
                        if(!$KU.is(value[i], 'widget', 'FlexContainer')) {
                            flag = false;
                            break;
                        }
                    }
                }

                return flag;
            },

            horizontalScrollIndicator: function Form2$_valid_horizontalScrollIndicator(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            i18n_title: function Form2$_valid_i18n_title(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            inTransitionConfig: function Form2$_valid_inTransitionConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, options = null, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')) {
                    if(Object.prototype.hasOwnProperty.call(value, 'formTransition')) {
                        if($KU.is(value.formTransition, 'string')) {
                            options = ['none', 'topcenter', 'bottomcenter', 'rightcenter', 'leftcenter'];
                            flag = (options.indexOf(value.formTransition.toLowerCase()) >= 0) ? true : false;
                        }
                    } else if(Object.prototype.hasOwnProperty.call(value, 'formAnimation')) {
                        if($KU.is(value.formAnimation, 'number')) {
                            options = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
                            flag = (options.indexOf(value.formAnimation) >= 0) ? true : false;
                        }
                    }
                }

                return flag;
            },

            needAppMenu: function Form2$_valid_needAppMenu(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            onDeviceBack: function Form2$_valid_onDeviceBack(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },


            onOrientationChange: function Form2$_valid_onOrientationChange(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onResize: function Form2$_valid_onResize(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onScrollEnd: function Form2$_valid_onScrollEnd(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onScrolling: function Form2$_valid_onScrolling(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onScrollStart: function Form2$_valid_onScrollStart(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onScrollTouchReleased: function Form2$_valid_onScrollTouchReleased(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            outTransitionConfig: function Form2$_valid_outTransitionConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, options = null, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')) {
                    if(Object.prototype.hasOwnProperty.call(value, 'formTransition')) {
                        if($KU.is(value.formTransition, 'string')) {
                            options = ['none', 'topcenter', 'bottomcenter', 'rightcenter', 'leftcenter'];
                            flag = (options.indexOf(value.formTransition.toLowerCase()) >= 0) ? true : false;
                        }
                    } else if(Object.prototype.hasOwnProperty.call(value, 'formAnimation')) {
                        if($KU.is(value.formAnimation, 'number')) {
                            options = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
                            flag = (options.indexOf(value.formAnimation) >= 0) ? true : false;
                        }
                    }
                }

                return flag;
            },

            retainScrollPosition: function Form2$_valid_retainScrollPosition(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            scrollDirection: function Form2$_valid_scrollDirection(value) {
                var flag = false, options = [
                    voltmx.flex.SCROLL_BOTH,
                    voltmx.flex.SCROLL_HORIZONTAL,
                    voltmx.flex.SCROLL_NONE,
                    voltmx.flex.SCROLL_VERTICAL
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            title: function Form2$_valid_title(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            verticalScrollIndicator: function Form2$_valid_verticalScrollIndicator(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        Form2: {
            allowHorizontalBounce: true,

            allowVerticalBounce: true,

            bounces: true,

            breakpoints: false,

            contentOffset: function Form2$_view_contentOffset(/*el, old*/) {
                this.setContentOffset(this.contentOffset, true);
            },

            contentOffsetMeasured: false,

            contentSize: function Form2$_view_contentSize(/*el, old*/) {},

            contentSizeMeasured: false,

            displayOrientation: false,

            enabledForIdleTimeout: function Form2$_view_enabledForIdleTimeout(/*el, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app,
                    cf = $KW.model($KA.currentFormUID);

                if(this === cf) $KW.registerForIdleTimeout();
            },

            enableOnScrollWidgetPositionForSubwidgets: true,

            enableScrolling: function Form2$_view_enableScrolling(/*el, old*/) {
                _handleScrollBar.call(this);
            },

            footers: false,

            headers: false,

            horizontalScrollIndicator: function Form2$_view_horizontalScrollIndicator(/*el, old*/) {
                _handleScrollBar.call(this);
            },

            i18n_title: false,

            inTransitionConfig: true,

            needAppMenu: false, //TODO::

            onDeviceBack: true,

            onOrientationChange: true,

            onScrollEnd: true,

            onScrolling: true,

            onScrollStart: true,

            onScrollTouchReleased: true,

            outTransitionConfig: true,

            retainScrollPosition: true,

            scrollDirection: function Form2$_view_scrollDirection(/*el, old*/) {
                _handleScrollBar.call(this);
            },

            title: function Form2$_view_title(/*el, old*/) {
                var $K = voltmx.$kwebfw$, $KA = $K.app,
                    title = this.title || $KA.title || $KA.id;

                if(title !== document.title) {
                    document.title = title;
                }

            },

            verticalScrollIndicator: function Form2$_view_verticalScrollIndicator(/*el, old*/) {
                _handleScrollBar.call(this);
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'Form2', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Form2 constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.ContainerWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */

        var Form2 = function Form2(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    allowHorizontalBounce: true,
                    allowVerticalBounce: true,
                    bounces: true, //Should this property be supported ???
                    breakpoints: [],
                    contentOffset: {x:'0dp', y:'0dp'},
                    contentOffsetMeasured: {x:0, y:0}, //Must be in dp unit
                    contentSize: {width:'100%', height:'100%'},
                    contentSizeMeasured: {height:0, width:0}, //Must be in dp unit
                    displayOrientation: constants.FORM_DISPLAY_ORIENTATION_BOTH, //In doc not available, but in SPA code available
                    dockableAppmenu: false, //TODO:: In doc not available, but in SPA code available
                    dockableFooter: false, //TODO:: In doc not available, but in SPA code available
                    dockableHeader: false, //TODO:: In doc not available, but in SPA code available
                    enabledForIdleTimeout: false,
                    enableOnScrollWidgetPositionForSubwidgets: false,
                    enableScrolling: true,
                    footers: null, //In doc not available, but in SPA code available
                    formType: '', //TODO:: OLD, may be backward compatibility
                    headers: null, //In doc not available, but in SPA code available
                    i18n_title: '',
                    inTransitionConfig: null,
                    masterDataLoad: false, //TODO:: OLD, may be backward compatibility
                    needAppLevelMenu: true, //TODO:: OLD, may be backward compatibility
                    needAppMenu: true,
                    onDeviceBack: null,
                    onOrientationChange: null,
                    onScrollEnd: null,
                    onScrolling: null,
                    onScrollStart: null,
                    onScrollTouchReleased: null,
                    outTransitionConfig: null,
                    preOrientationChange: null, //TODO:: In doc not available, but in SPA code available
                    resetFocusToTop: false, //TODO:: In doc not available, but in SPA code available
                    retainScrollPosition: false,
                    scrollDirection: voltmx.flex.SCROLL_VERTICAL,
                    title: '',
                    transactionalDataLoad: false, //TODO:: OLD, may be backward compatibility
                    type: '', //TODO:: In doc not available, but in SPA code available
                    useTransform: false, //TODO:: In doc not available, but in SPA code available
                    verticalScrollIndicator: true
                };
            }

            _populateUnderscore.Form2.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name+$KU.uid());
            }

            Form2.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Form2, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Form2.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                //Defaulting to platfom values specific to Form2
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<'+key+'> is a non-constructor property of <'+self._kwebfw_.ns+'> class.');
                        } else if(!$KU.is(_valid.Form2[key], 'function')) {
                            throw new Error('<'+key+'> is available in default widget properties of <voltmx.ui.Form2>, but not in <_valid.Form2> namespace.');
                        } else {
                            valid = _valid.Form2[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Form2
                $KU.each(_view.Form2, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Form2$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Form2[key], 'function')) {
                            return _getter.Form2[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Form2$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Form2[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Form2[key], 'function')) {
                                        _setter.Form2[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Form2().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Form2().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    p.contentOffsetMeasured = {x: 0, y: 0};
                    p.contentSizeMeasured= {height: 0, width: 0};
                }

                if($KU.is(_postInitialization.Form2, 'function')) {
                    _postInitialization.Form2.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Form2, voltmx.ui.ContainerWidget);


        /**
         * Builds the view layer for Form2 widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Form2
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  Form2 view.
         */
        var form2__render = function Form2$_render(/*tag*/) {
            var $super = voltmx.ui.Form2.base.prototype, _ = this._kwebfw_,
                view = _.view, $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                $KD = $K.dom, el = $KW.el(view), hScroll = null, vScroll = null,
                viewport = null, scrolee = null, footer = null, header = null;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    header = $KD.create('DIV', {kr:'header'});
                    viewport = $KD.create('DIV', {kr:'viewport'});
                    footer = $KD.create('DIV', {kr:'footer'});

                    if($KU.scrollType() !== 'native') {
                        $KD.style(viewport, {overflowX:'hidden', overflowY:'hidden'});

                        scrolee = $KD.create('DIV', {kr:'scrolee'});
                        hScroll = $KD.create('DIV', {kr:'h-scroll'}, {display:'none'});
                        vScroll = $KD.create('DIV', {kr:'v-scroll'}, {display:'none'});

                        $KD.add(viewport, scrolee);
                        $KD.add(viewport, hScroll);
                        $KD.add(viewport, vScroll);
                    }

                    view = $super._render.call(this, 'FORM', [header, viewport, footer]);

                    $KD.on(view, 'submit', 'nosubmit', function(e) {
                        var $K = voltmx.$kwebfw$, $KD = $K.dom;
                        $KD.preventDefault(e);
                    });

                    $KD.addCls(view, 'kvp');
                    _handleScrollBar.call(this);
                    $KW.registerNativeScrollEvent(this);

                    el = $KW.el(view);
                }

                $KW.accessibility(this);
                $KD.style(view, 'visibility', 'hidden');

                $KU.each($KW.children(this), function(cmodel/*, index*/) {
                    if(cmodel.isVisible || $K.F.RIVW) {
                        $KD.add((el.scrolee || el.viewport), cmodel._render());
                    }
                });
            }

            return view;
        };


        //TODO::
        var form2_replaceAt = function Form2$replaceAt() {
            //
        };


        var form2_setZoomScale = function Form2$setZoomScale() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

            if($KW.isFlexContainer(this)) {
                $KU.unsupportedAPI('voltmx.ui.Form2.setZoomScale');
            } else {
                //Throw Error
            }
        };


        var form2_show = function Form2$show(arg0) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KG = $K.globals, $KA = $K.app,
                $KW = $K.widget, $KD = $K.dom, cv = null, sameFormId = false,
                pv = null, cf = null, pf = null, modal = null, context = null;

            context = ($KU.is(arg0, 'object')) ? arg0 : {};

            if(this._voltmxControllerName && context.forced !== true) {
                throw new Error('Cannot call <show> method on a MVC form.');
            } else {
                if(!$KU.is($KW.model($KA.currentFormUID), 'widget')) {
                    cf = this;
                    $KA.currentFormUID = cf._kwebfw_.uid;
                    $K.apm.send(this, 'AppLoad');
                    $K.apm.send(this, 'AppTransition', {status: 'Foreground'});
                } else {
                    cf = $KW.model($KA.currentFormUID);
                    $K.apm.send(cf, 'FormExit');
                    $KW.dismissPickers(cf);
                    $KW.invokeLifeCycleEvent(cf, 'onHide', true);
                    $KW.removeSensitiveText(cf);
                    if(cf.id !== this.id) {
                        $KA.previousFormUID = cf._kwebfw_.uid;
                    } else {
                        sameFormId = true;
                        $KD.remove(cf._kwebfw_.view);
                    }

                    cf = this;
                    $KA.currentFormUID = cf._kwebfw_.uid;
                }

                pf = $KW.model($KA.previousFormUID);
                pv = (pf) ? pf._kwebfw_.view : null;
                $KA.currentBreakpoint = -1;

                _updateURLhash.call(cf, pf);

                modal = $KW.deduceModalContainer(cf);
                $KW.updateModalContainer(cf, modal);

                if(!cf._kwebfw_.view) {
                    $KW.invokeLifeCycleEvent(cf, 'init', false);
                }

                $KW.invokeLifeCycleEvent(cf, 'preShow', false);
                $K.ui[cf._kwebfw_.name].onResize.call(cf);

                $KD.html($KG.appScrap, '');
                cv = cf._render();

                if(!pf || sameFormId) { //No animation required
                    _renderCurrentForm.call(cf, $KG.appForms, cv, (sameFormId ? null : true));
                } else {
                    if(!cf.inTransitionConfig && !pf.outTransitionConfig) { //No animation required
                        _renderCurrentForm.call(cf, $KG.appForms, cv, true);
                    } else { //Animation required
                        _handleAnimation(cf, cv, pf, pv);
                    }
                }

                cf = pf = cv = pv = null; //For GC
            }
        };


        $K.defVoltmxProp(Form2.prototype, [
            {keey:'_render', value:form2__render},
            {keey:'replaceAt', value:form2_replaceAt},
            {keey:'setZoomScale', value:form2_setZoomScale},
            {keey:'show', value:form2_show}
        ]);


        return Form2;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxflexcontainer.js' */
(function() {
    //This function must be called in the scope of widget instance
    var _deduceTagName = function FlexContainer$_deduceTagName(tag) {
        var a11y = this._kwebfw_.prop.accessibilityConfig;

        tag = (a11y && a11y.tagName) ? a11y.tagName.toLowerCase() : 'div';

        return tag;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        FlexContainer: {
            //
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        FlexContainer: function FlexContainer$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.FlexContainer', true);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'FlexContainer', true);
                }
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {};


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        FlexContainer: function FlexContainer$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        FlexContainer: function FlexContainer$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        FlexContainer: {
            clipBounds: function FlexContainer$_setter_clipBounds(/*old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if($KU.is(this, 'widget', 'FlexScrollContainer')) {
                    prop.enableScrolling = !prop.enableScrolling;
                    this.enableScrolling = !prop.enableScrolling;
                }
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        FlexContainer: {
            clipBounds: function FlexContainer$_valid_clipBounds(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            isMaster: function FlexContainer$_valid_isMaster(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            isModalContainer: function FlexContainer$_valid_isModalContainer(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            masterType: function FlexContainer$_valid_masterType(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if(value === constants.MASTER_TYPE_DEFAULT
                || value === constants.MASTER_TYPE_USERWIDGET
                || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        FlexContainer: {
            clipBounds: function FlexContainer$_view_clipBounds(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom;

                if($KW.name(this) === 'FlexContainer') {
                    if(this.clipBounds) {
                        $KD.style(el.node, {overflowX:'hidden', overflowY:'hidden'});
                    } else {
                        $KD.style(el.node, {overflowX:'visible', overflowY:'visible'});
                    }
                }
            },

            isMaster: false,

            isModalContainer: function FlexContainer$_view_isModalContainer(/*el, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app,
                    fmodel = $KW.fmodel(this), modal = null, deduce = false;

                if(fmodel && fmodel === $KW.model($KA.currentFormUID)) {
                    modal = fmodel._kwebfw_.modalContainer;

                    if(this.isModalContainer) {
                        if(!modal) { //Then, "this" will be the only possible modalContainer
                            $KW.updateModalContainer(fmodel, this);
                        } else if($KW.contains(modal, this, false)) {
                            $KW.updateModalContainer(fmodel, this);
                        } else if($KW.pmodel(this) === $KW.pmodel(modal)
                        && this.zIndex > modal.zIndex) {
                            deduce = true;
                        } else if(!$KW.contains(this, modal, false)) {
                            deduce = true;
                        }
                    } else if(this === modal) {
                        deduce = true;
                    }

                    if(deduce) {
                        modal = $KW.deduceModalContainer(fmodel);
                        $KW.updateModalContainer(fmodel, modal);
                    }
                }
            },

            masterType: false
        }
    };


    Object.defineProperty(voltmx.ui, 'FlexContainer', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.FlexContainer constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.ContainerWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var FlexContainer = function FlexContainer(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    clipBounds: true,
                    isMaster: false,
                    isModalContainer: false,
                    masterType: null
                };
            }

            _populateUnderscore.FlexContainer.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name+$KU.uid());
            }

            FlexContainer.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.FlexContainer, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.FlexContainer.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                //Defaulting to platfom values specific to FlexContainer
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<'+key+'> is a non-constructor property of <'+self._kwebfw_.ns+'> class.');
                        } else if(!$KU.is(_valid.FlexContainer[key], 'function')) {
                            throw new Error('<'+key+'> is available in default widget properties of <voltmx.ui.FlexContainer>, but not in <_valid.FlexContainer> namespace.');
                        } else {
                            valid = _valid.FlexContainer[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to FlexContainer
                $KU.each(_view.FlexContainer, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function FlexContainer$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.FlexContainer[key], 'function')) {
                            return _getter.FlexContainer[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function FlexContainer$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.FlexContainer[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.FlexContainer[key], 'function')) {
                                        _setter.FlexContainer[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.FlexContainer().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.FlexContainer().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.FlexContainer, 'function')) {
                    _postInitialization.FlexContainer.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(FlexContainer, voltmx.ui.ContainerWidget);


        /**
         * Builds the view layer for voltmx.ui.FlexContainer widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.FlexContainer
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  FlexContainer view.
         */
        var flexcontainer__render = function FlexContainer$_render(tag, children) {
            var $super = voltmx.ui.FlexContainer.base.prototype,
                _ = this._kwebfw_, $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KW = $K.widget, view = _.view, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, _deduceTagName.call(this, tag), children);

                    el = $KW.el(view);

                    _view.FlexContainer.clipBounds.call(this, el, this.clipBounds);
                }

                $KW.accessibility(this);

                $KU.each($KW.children(this), function(cmodel/*, index*/) {
                    if(cmodel.isVisible || $K.F.RIVW) {
                        $KW.addToView(view, cmodel._render());
                    }
                });
            }

            return view;
        };


        $K.defVoltmxProp(FlexContainer.prototype, [
            {keey:'_render', value:flexcontainer__render}
        ]);


        return FlexContainer;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxflexscrollcontainer.js' */
(function() {
    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        FlexScrollContainer: {
            contentOffset: function FlexScrollContainer$_getter_contentOffset(value) {
                return {x:value.x, y:value.y};
            },

            contentOffsetMeasured: function FlexScrollContainer$_getter_contentOffsetMeasured(value) {
                var scroll = this._kwebfw_.ui.scroll;

                value.x = scroll.x;
                value.y = scroll.y;

                return {x:value.x, y:value.y};
            },

            contentSize: function FlexScrollContainer$_getter_contentSize(value) {
                return {width:value.width, height:value.height};
            },

            contentSizeMeasured: function FlexScrollContainer$_getter_contentSizeMeasured(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, el = null,
                    $KW = $K.widget, _ = this._kwebfw_, scroll = _.ui.scroll;

                if($KU.scrollType() === 'native') {
                    el = $KW.el(this);

                    scroll.width = el.viewport ? el.viewport.scrollWidth : -1;
                    scroll.height = el.viewport ? el.viewport.scrollHeight : -1;
                }

                value.width = scroll.width;
                value.height = scroll.height;

                return {width:value.width, height:value.height};
            },

            scrollingEvents: function FlexScrollContainer$_getter_scrollingEvents(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    scrollingEvents = value ? {} : null;

                $KU.each(value, function(val, key) {
                    scrollingEvents[key] = val;
                });

                return scrollingEvents;
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _handleScrollBar = function FlexScrollContainer$_handleScrollBar() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, prop = this._kwebfw_.prop, el = $KW.el(this);

        if($KU.scrollType() === 'native') {
            if(!prop.enableScrolling || prop.scrollDirection === voltmx.flex.SCROLL_NONE) {
                $KD.style(el.node, {overflowX:'hidden', overflowY:'hidden'});
            } else { //Scrolling Enabled
                if(prop.scrollDirection === voltmx.flex.SCROLL_VERTICAL) {
                    $KD.style(el.node, {overflowX:'hidden', overflowY:'auto'});
                } else if(prop.scrollDirection === voltmx.flex.SCROLL_HORIZONTAL) {
                    $KD.style(el.node, {overflowX:'auto', overflowY:'hidden'});
                } else if(prop.scrollDirection === voltmx.flex.SCROLL_BOTH) {
                    $KD.style(el.node, {overflowX:'auto', overflowY:'auto'});
                }
            }
        } else { //Custom Scroll
            if(!prop.enableScrolling || prop.scrollDirection === voltmx.flex.SCROLL_NONE) {
                $KD.style(el.hScroll, 'visibility', 'hidden');
                $KD.style(el.vScroll, 'visibility', 'hidden');
            } else { //Scrolling Enabled
                if(prop.horizontalScrollIndicator) {
                    $KD.style(el.hScroll, 'visibility', null);
                } else {
                    $KD.style(el.hScroll, 'visibility', 'hidden');
                }

                if(prop.verticalScrollIndicator) {
                    $KD.style(el.vScroll, 'visibility', null);
                } else {
                    $KD.style(el.vScroll, 'visibility', 'hidden');
                }

                if(prop.horizontalScrollIndicator
                && prop.scrollDirection === voltmx.flex.SCROLL_VERTICAL) {
                    $KD.style(el.hScroll, 'visibility', 'hidden');
                } else if(prop.verticalScrollIndicator
                && prop.scrollDirection === voltmx.flex.SCROLL_HORIZONTAL) {
                    $KD.style(el.vScroll, 'visibility', 'hidden');
                }
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        FlexScrollContainer: function FlexScrollContainer$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.FlexScrollContainer', true);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'FlexScrollContainer', true);
                }
            }

            if(!_.ui) $KU.defineProperty(_, 'ui', {}, null);
            $KU.defineProperty(_.ui, 'scroll', {x:0, y:0, width:-1, height:-1, minX:-1, maxX:-1, minY:-1, maxY:-1, status:'ended'}, true);
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        FlexScrollContainer: function FlexScrollContainer$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

            if(!prop.clipBounds) prop.clipBounds = true;

            if($KU.is(prop.padding, 'null')) {
                prop.padding = [0, 0, 0, 0];
            }

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'slFSbox';
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        FlexScrollContainer: function FlexScrollContainer$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        FlexScrollContainer: function FlexScrollContainer$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        FlexScrollContainer: {
            property: function FlexScrollContainer$_setter_property(/*old*/) {
                //
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        FlexScrollContainer: {
            allowHorizontalBounce: function FlexScrollContainer$_valid_allowHorizontalBounce(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            allowVerticalBounce: function FlexScrollContainer$_valid_allowVerticalBounce(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            animateIcons: function FlexScrollContainer$_valid_animateIcons(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            bounces: function FlexScrollContainer$_valid_bounces(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            contentOffset: function FlexScrollContainer$_valid_contentOffset(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.x, 'size')
                && $KU.is(value.y, 'size')) {
                    flag = true;
                }

                return flag;
            },

            contentOffsetMeasured: function FlexScrollContainer$_valid_contentOffsetMeasured(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.x, 'integer') && value.x >= 0
                && $KU.is(value.y, 'integer') && value.y >= 0) {
                    flag = true;
                }

                return flag;
            },

            contentSize: function FlexScrollContainer$_valid_contentSize(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.width, 'string')
                && $KU.is(value.width, 'size')
                && $KU.is(value.height, 'string')
                && $KU.is(value.height, 'size')) {
                    flag = true;
                }

                return flag;
            },

            contentSizeMeasured: function FlexScrollContainer$_valid_contentSizeMeasured(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.height, 'integer') && value.height >= 0
                && $KU.is(value.width, 'integer') && value.width >= 0) {
                    flag = true;
                }

                return flag;
            },

            enableOnScrollWidgetPositionForSubwidgets: function FlexScrollContainer$_valid_enableOnScrollWidgetPositionForSubwidgets(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            enableScrolling: function FlexScrollContainer$_valid_enableScrolling(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            horizontalScrollIndicator: function FlexScrollContainer$_valid_horizontalScrollIndicator(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            onScrollStart: function FlexScrollContainer$_valid_onScrollStart(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function')
                || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            onScrollTouchReleased: function FlexScrollContainer$_valid_onScrollTouchReleased(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function')
                || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            onScrolling: function FlexScrollContainer$_valid_onScrolling(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function')
                || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            onDecelerationStarted: function FlexScrollContainer$_valid_onDecelerationStarted(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function')
                || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            onScrollEnd: function FlexScrollContainer$_valid_onScrollEnd(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function')
                || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            pullToRefreshI18NKey: function FlexScrollContainer$_valid_pullToRefreshI18NKey(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            pullToRefreshIcon: function FlexScrollContainer$_valid_pullToRefreshIcon(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            pullToRefreshSkin: function FlexScrollContainer$_valid_pullToRefreshSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            pushToRefreshI18NKey: function FlexScrollContainer$_valid_pushToRefreshI18NKey(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            pushToRefreshIcon: function FlexScrollContainer$_valid_pushToRefreshIcon(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            pushToRefreshSkin: function FlexScrollContainer$_valid_pushToRefreshSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            releaseToPullRefreshI18NKey: function FlexScrollContainer$_valid_releaseToPullRefreshI18NKey(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            releaseToPushRefreshI18NKey: function FlexScrollContainer$_valid_releaseToPushRefreshI18NKey(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            retainScrollPosition: function FlexScrollContainer$_valid_retainScrollPosition(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            scrollDirection: function FlexScrollContainer$_valid_scrollDirection(value) {
                var flag = false, options = [
                    voltmx.flex.SCROLL_BOTH,
                    voltmx.flex.SCROLL_HORIZONTAL,
                    voltmx.flex.SCROLL_NONE,
                    voltmx.flex.SCROLL_VERTICAL
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            scrollingEvents: function FlexScrollContainer$_valid_scrollingEvents(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false, subflag = true,
                    names = ['onPush', 'onPull', 'onReachingBegining', 'onReachingEnd'];

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')) {
                    flag = true;

                    $KU.each(names, function(name) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if(Object.prototype.hasOwnProperty.call(value, name)
                        && !$KU.is(value[name], 'function')) {
                            subflag = false;
                            return true;
                        }
                    });
                }

                return (flag && subflag);
            },

            verticalScrollIndicator: function FlexScrollContainer$_valid_verticalScrollIndicator(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        FlexScrollContainer: {
            allowHorizontalBounce: true,

            allowVerticalBounce: true,

            animateIcons: true,

            bounces: true,

            contentOffset: function FlexScrollContainer$_view_contentOffset(/*el, old*/) {
                this.setContentOffset(this.contentOffset, true);
            },

            contentOffsetMeasured: false,

            contentSize: function FlexScrollContainer$_view_contentSize(/*el, old*/) {},

            contentSizeMeasured: false,

            enableOnScrollWidgetPositionForSubwidgets: true,

            enableScrolling: function FlexScrollContainer$_view_enableScrolling(/*el, old*/) {
                _handleScrollBar.call(this);
            },

            horizontalScrollIndicator: function FlexScrollContainer$_view_horizontalScrollIndicator(/*el, old*/) {
                _handleScrollBar.call(this);
            },

            onScrollStart: true,

            onScrollTouchReleased: true,

            onScrolling: true,

            onDecelerationStarted: true,

            onScrollEnd: true,

            pullToRefreshI18NKey: true,

            pullToRefreshIcon: true,

            pullToRefreshSkin: true,

            pushToRefreshI18NKey: true,

            pushToRefreshIcon: true,

            pushToRefreshSkin: true,

            releaseToPullRefreshI18NKey: true,

            releaseToPushRefreshI18NKey: true,

            retainScrollPosition: true,

            scrollDirection: function FlexScrollContainer$_view_scrollDirection(/*el, old*/) {
                _handleScrollBar.call(this);
            },

            scrollingEvents: true,

            verticalScrollIndicator: function FlexScrollContainer$_view_verticalScrollIndicator(/*el, old*/) {
                _handleScrollBar.call(this);
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'FlexScrollContainer', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.FlexScrollContainer constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.FlexContainer
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var FlexScrollContainer = function FlexScrollContainer(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    allowHorizontalBounce: true, //The "bounces" property takes precedence over this property.
                    allowVerticalBounce: true, //The "bounces" property takes precedence over this property.
                    animateIcons: true,
                    bounces: true,
                    contentOffset: {x: '0dp', y: '0dp'},
                    contentSize: {width: '100%', height: '100%'},
                    contentOffsetMeasured: {x: 0, y: 0}, //Must be in dp unit
                    contentSizeMeasured: {height: 0, width: 0}, //Must be in dp unit
                    enableOnScrollWidgetPositionForSubwidgets: false,
                    enableScrolling: true,
                    horizontalScrollIndicator: true,
                    onScrollStart: null,
                    onScrollTouchReleased: null,
                    onScrolling: null,
                    onDecelerationStarted: null,
                    onScrollEnd: null,
                    pullToRefreshI18NKey: '',
                    pullToRefreshIcon: '',
                    pullToRefreshSkin: '',
                    pushToRefreshI18NKey: '',
                    pushToRefreshIcon: '',
                    pushToRefreshSkin: '',
                    releaseToPullRefreshI18NKey: '',
                    releaseToPushRefreshI18NKey: '',
                    retainScrollPosition: false,
                    scrollDirection: voltmx.flex.SCROLL_HORIZONTAL,
                    scrollingEvents: null,
                    verticalScrollIndicator: true
                };
            }

            _populateUnderscore.FlexScrollContainer.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            FlexScrollContainer.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.FlexScrollContainer, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.FlexScrollContainer.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to FlexScrollContainer
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.FlexScrollContainer[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.FlexScrollContainer>, but not in <_valid.FlexScrollContainer> namespace.');
                        } else {
                            valid = _valid.FlexScrollContainer[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to FlexScrollContainer
                $KU.each(_view.FlexScrollContainer, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function FlexScrollContainer$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.FlexScrollContainer[key], 'function')) {
                            return _getter.FlexScrollContainer[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function FlexScrollContainer$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.FlexScrollContainer[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.FlexScrollContainer[key], 'function')) {
                                        _setter.FlexScrollContainer[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.FlexScrollContainer().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.FlexScrollContainer().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    p.contentOffsetMeasured = {x: 0, y: 0};
                    p.contentSizeMeasured= {height: 0, width: 0};
                }

                if($KU.is(_postInitialization.FlexScrollContainer, 'function')) {
                    _postInitialization.FlexScrollContainer.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(FlexScrollContainer, voltmx.ui.FlexContainer);


        /**
         * Takes care of flushing out the widget reference to clean memory.
         *
         * @override
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.FlexScrollContainer
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     void
         */
        var flexscrollcontainer__flush = function FlexScrollContainer$_flush(config) {
            var $super = voltmx.ui.FlexScrollContainer.base.prototype,
                $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, el = $KW.el(this);

            el.viewport && $KD.off(el.viewport); //Remove all event listeners to avoid memory leaks
            $super._flush.call(this, config);
        };


        var flexscrollcontainer__render = function FlexScrollContainer$_render(tag) {
            var $super = voltmx.ui.FlexScrollContainer.base.prototype,
                scrolee = null, _ = this._kwebfw_, view = _.view,
                $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                $KD = $K.dom, hScroll = null, vScroll = null, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    if($KU.scrollType() === 'native') {
                        view = $super._render.call(this, tag);
                    } else {
                        scrolee = $KD.create('DIV', {kr:'scrolee'});
                        hScroll = $KD.create('DIV', {kr:'h-scroll'});
                        vScroll = $KD.create('DIV', {kr:'v-scroll'});
                        view = $super._render.call(this, tag, [scrolee, hScroll, vScroll]);
                    }

                    _handleScrollBar.call(this);
                    $KW.registerNativeScrollEvent(this);

                    el = $KW.el(view);
                }

                $KW.accessibility(this);

                $KU.each($KW.children(this), function(cmodel/*, index*/) {
                    if(cmodel.isVisible || $K.F.RIVW) {
                        $KW.addToView((el.scrolee || view), cmodel._render());
                    }
                });
            }

            return view;
        };


        var flexscrollcontainer_setZoomScale = function FlexScrollContainer$setZoomScale() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('voltmx.ui.FlexScrollContainer.setZoomScale');
        };


        $K.defVoltmxProp(FlexScrollContainer.prototype, [
            {keey:'_flush', value:flexscrollcontainer__flush},
            {keey:'_render', value:flexscrollcontainer__render},
            {keey:'setZoomScale', value:flexscrollcontainer_setZoomScale}
        ]);


        return FlexScrollContainer;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxcanvas.js' */
//check
(function() {
    var $K = voltmx.$kwebfw$,
        DEFAULT_DASHLINECONFIG = [1, 1], DEFAULT_THICKNESS = 1,
        SOLIDLINECONFIG = [], DEFAULT_SHAPECOLOR = '00000000';


    $K.defVoltmxProp($K.ui, [
        {keey:'Canvas', value:{}, items:[
            {keey:'doLayout', value:function(/*frame*/) {
                _drawShapesOnCanvas.call(this);
            }}
        ]}
    ]);


    var _clearRect = function Canvas$_clearRect(ctx) {
        var frame = this._kwebfw_.prop.frame;

        ctx.clearRect(0, 0, frame.width, frame.height);
    };

    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};

    var _drawLine = function Canvas$_drawLine(ctx, shape) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            lineConfig = shape.lineStyleConfig, lineWidth = DEFAULT_THICKNESS,
            points = shape.points, linepts = [], widgetFrame = this._kwebfw_.prop.frame;

        if(points && points.length === 2) {
            linepts.push($KU.getValueUnitByWidgetFrame(points[0][0], 'x', widgetFrame).value);
            linepts.push($KU.getValueUnitByWidgetFrame(points[0][1], 'y', widgetFrame).value);
            linepts.push($KU.getValueUnitByWidgetFrame(points[1][0], 'x', widgetFrame).value);
            linepts.push($KU.getValueUnitByWidgetFrame(points[1][1], 'y', widgetFrame).value);
            ctx.beginPath();
            if(voltmx.canvas.LINE_STYLE_DASHED === shape.lineStyle
            || voltmx.canvas.LINE_STYLE_DOTTED === shape.lineStyle) {
                if(lineConfig) {
                    $KU.each(lineConfig, function(lineConfigData, index) {
                        lineConfig[index] = $KU.getValueUnitByWidgetFrame(lineConfigData).value;
                    }, this);
                } else {
                    lineConfig = DEFAULT_DASHLINECONFIG;
                }
                ctx.setLineDash(lineConfig);
            } else {
                ctx.setLineDash(SOLIDLINECONFIG);
            }

            /*
            *  Next canvas enhancements, we need to support lineCap / Round corner
            *
            if(voltmx.canvas.LINE_STYLE_DASHED === shape.lineStyle) {
               ctx.lineCap   = 'solid'; //think cross platform and do it
            } else if(voltmx.canvas.LINE_STYLE_DOTTED === shape.lineStyle) {
               ctx.lineCap   = 'round';
            }
            */

            if(shape.thickness) {
                lineWidth = $KU.getValueUnitByWidgetFrame(shape.thickness).value;
            }
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = _getStrokeStyle(ctx, shape.strokeColor, linepts, lineWidth);
            ctx.moveTo(linepts[0], linepts[1]);
            ctx.lineTo(linepts[2], linepts[3]);
            ctx.stroke();
        }
    };

    var _drawShapesOnCanvas = function Canvas$_drawShapesOnCanvas() {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
            $KD = $K.dom, shapesdata = this._kwebfw_.prop.shapesData,
            el = $KW.el(this), scale = $K.device.DPI,
            ctx = el.canvas.getContext('2d'), frame = this._kwebfw_.prop.frame;

        $KD.setAttr(el.canvas, 'width', frame.width * scale);
        $KD.setAttr(el.canvas, 'height', frame.height * scale);
        ctx.scale(scale, scale);
        _clearRect.call(this, ctx);
        $KU.each(shapesdata, function(shape/* , index */) {
            if(voltmx.canvas.SHAPE_TYPE_LINE === shape.shapeType) {
                _drawLine.call(this, ctx, shape);
            }
        }, this);
    };

    var _getDataObj = function Canvas$_getDataObj(dataArr) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, returnDataObj = {};

        $KU.each(dataArr, function(data/* , index */) {
            returnDataObj[data.shapeid] = data;
        });

        return returnDataObj;
    };

    var _getIndexFromShapesData = function Canvas$_getIndexFromShapesData(shapeId) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, returnIndex = -1,
            dataArr = this._kwebfw_.prop.shapesData;

        $KU.each(dataArr, function(data, index) {
            if(data.shapeid === shapeId) returnIndex = index;
        });

        return returnIndex;
    };

    var _getStrokeStyle = function Canvas$_getStrokeStyle(ctx, strokeColor, points, lineThickness) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            strokeStyle = $KU.convertHexToRGBA(DEFAULT_SHAPECOLOR);

        if(strokeColor) {
            if(typeof strokeColor === 'string') {
                strokeStyle = $KU.convertHexToRGBA(strokeColor);
            } else if(typeof strokeColor === 'object') {
                switch(strokeColor.color_type) {
                    case 'one':
                        strokeStyle = $KU.convertHexToRGBA(strokeColor.color);
                        break;
                    case 'two':
                        strokeStyle = _getStrokeStyleTwoStepGradient(ctx, strokeColor, points, lineThickness);
                        break;
                    case 'ms_gradient':
                        strokeStyle = _getStrokeStyleMSGradient(ctx, strokeColor, points, lineThickness);
                        break;
                    default:
                        break;
                }
            }
        }

        return strokeStyle;
    };

    var _getStrokeStyleTwoStepGradient = function Canvas$_getStrokeStyleTwoStepGradient(ctx, strokeColor, points, lineThickness) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, bottomcolor = '',
            gradient = null, x1 = 0, x2 = 0, y1 = 0, y2 = 0, topcolor = '',
            thinknessby2 = parseFloat(lineThickness/2);

        topcolor = $KU.convertHexToRGBA(strokeColor.top_color);
        bottomcolor = $KU.convertHexToRGBA(strokeColor.bottom_color);

        if(strokeColor.style === 'hg' || strokeColor.style === 'hs') {
            x1 = points[0];
            y1 = points[1];
            x2 = points[2];
            y2 = points[3];
        } else if(strokeColor.style === 'vg' || strokeColor.style === 'vs') {
            x1 = points[0];
            y1 = (points[1] - thinknessby2);
            x2 = points[0];
            y2 = (points[1] + thinknessby2);
        }

        gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        gradient.addColorStop(0, topcolor);

        if(strokeColor.style === 'vs' || strokeColor.style === 'hs') {
            gradient.addColorStop(0.5, topcolor);
            gradient.addColorStop(0.5, bottomcolor);
        }

        gradient.addColorStop(1, bottomcolor);

        return gradient;
    };

    var _getStrokeStyleMSGradient = function(ctx, strokeColor, points, lineThickness) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, gradient = null,
            i = 0, x1 = 0, x2 = 0, y1 = 0, y2 = 0,
            thinknessby2 = parseFloat(lineThickness/2);

        if('toRight' === strokeColor.gradientType) {
            x1 = points[0];
            y1 = points[1];
            x2 = points[2];
            y2 = points[3];
        } else if('toLeft' === strokeColor.gradientType) {
            x1 = points[2];
            y1 = points[3];
            x2 = points[0];
            y2 = points[1];
        } else if('toBottom' === strokeColor.gradientType) {
            x1 = points[0];
            y1 = (points[1] - thinknessby2);
            x2 = points[0];
            y2 = (points[1] + thinknessby2);
        } else if('toTop' === strokeColor.gradientType) {
            x1 = points[0];
            y1 = (points[1] + thinknessby2);
            x2 = points[0];
            y2 = (points[1] - thinknessby2);
        }

        gradient = ctx.createLinearGradient(x1, y1, x2, y2);

        for(i=0; i<strokeColor.colors.length && i<strokeColor.cs.length; i++) {
            gradient.addColorStop(parseFloat(strokeColor.cs[i])/100, $KU.convertHexToRGBA(strokeColor.colors[i]));
        }

        return gradient;
    };

    var _getter = {
        Canvas: {
        }
    };


    var _populateUnderscore = {
        Canvas: function Canvas$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Canvas', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Canvas', null);
                }
            }
        }
    };

    var _postInitialization = {};

    var _relayoutActiveTriggerer = {
        Canvas: function Canvas$_relayoutActiveTriggerer() {
            return [];
        }
    };

    var _relayoutPassiveTriggerer = {
        Canvas: function Canvas$_relayoutPassiveTriggerer() {
            return [];
        }
    };

    var _setter = {
        Canvas: {
        }
    };

    var _updateShapeData = function Canvas$_updateShapeData(shapeData) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, returnflag = false,
            existingShapeData = {}, updateData = {}, index = -1;

        index = _getIndexFromShapesData.call(this, shapeData.shapeid);

        if(index !== -1) {
            existingShapeData = this._kwebfw_.prop.shapesData[index];
            $KU.each(existingShapeData, function(data, key) {
                updateData[key] = data;
            });
            $KU.each(shapeData, function(data, key) {
                if(key !== 'shapeType') {
                    updateData[key] = data;
                }
            });
            if(voltmx.canvas.SHAPE_TYPE_LINE === updateData.shapeType) {
                _valid.Canvas.validateLineData.call(this, updateData);
            }
            this._kwebfw_.prop.shapesData[index] = updateData;
            returnflag = true;
        }

        return returnflag;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Canvas: {
            shapesData: function Canvas$_valid_shapesData(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array')) {
                    $KU.each(value, function(data/* , index */) {
                        var validDataObj = {};

                        if(!data.shapeid) {
                            throw new $KU.error(6001, 'Invalid shapesData', 'shapesData does not have mandatory value shapeid.');
                        } else if(!data.shapeType) {
                            throw new $KU.error(6001, 'Invalid shapesData', 'shapesData does not have mandatory value shapeType.');
                        } else if(validDataObj[data.shapeid]) {
                            throw new $KU.error(6002, 'Invalid shapesData', 'shapesData has duplicate shape identifier.'+ data.shapeid);
                        } else {
                            if(voltmx.canvas.SHAPE_TYPE_LINE === data.shapeType) {
                                _valid.Canvas.validateLineData.call(this, data);
                            } else {
                                throw new $KU.error(6001, 'Invalid shapesData', 'Not a valid shapeType.');
                            }

                            validDataObj[data.shapeid] = data;
                        }
                    }, this);

                    flag = true;
                } else if($KU.is(value, 'undefined')) {
                    flag = true;
                }

                return flag;
            },

            validateLineData: function Canvas$_valid_validateLineData(shapeLineData) {
                _valid.Canvas.validateLinePoints.call(this, shapeLineData.points);
            },

            validateLinePoints: function Canvas$_valid_validateLinePoints(points, flag) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    innerDataValidDataFlag = ($KU.is(flag, 'boolean')) ? flag : true;

                if(points instanceof Array) {
                    if(points.length !== 2) {
                        throw new $KU.error(6001, 'Invalid shapesData', 'shapesData does not have mandatory value points for shapeType line.');
                    } else if(innerDataValidDataFlag) {
                        _valid.Canvas.validateLinePoints.call(this, points[0], false);
                        _valid.Canvas.validateLinePoints.call(this, points[1], false);
                    }
                } else {
                    throw new $KU.error(6001, 'Invalid shapesData', 'shapesData does not have mandatory value points for shapeType line.');
                }
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to 'false', will not create a setter
    var _view = {
        Canvas: {
            shapesData: function Canvas$_view_shapesData(/* el, old */) {
                _drawShapesOnCanvas.call(this);
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'Canvas', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Canvas constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Shanker Pulugam <shanker.pulugam@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var Canvas = function Canvas(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    shapesData: []
                };
            }

            _populateUnderscore.Canvas.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            Canvas.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Canvas, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Canvas.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to Canvas
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Canvas[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Canvas>, but not in <_valid.Canvas> namespace.');
                        } else {
                            valid = _valid.Canvas[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Canvas
                $KU.each(_view.Canvas, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Canvas$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Canvas[key], 'function')) {
                            return _getter.Canvas[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Canvas$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Canvas[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Canvas[key], 'function')) {
                                        _setter.Canvas[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Canvas().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Canvas().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.Canvas, 'function')) {
                    _postInitialization.Canvas.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Canvas, voltmx.ui.BasicWidget);


        /**
         * Builds the view layer for voltmx.ui.Canvas widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Canvas
         * @author      Shanker Pulugam <shanker.pulugam@voltmx.com>
         *
         * @returns     {HTMLElement}  Canvas view.
         */
        var canvas__render = function Canvas$_render(tag) {
            var $super = voltmx.ui.Canvas.base.prototype,
                $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                _ = this._kwebfw_, view = _.view, canvas = null;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    canvas = $KD.create('CANVAS', {}, {width:'100%', height:'100%'});
                    view = $super._render.call(this, tag, [canvas]);
                }

                $KW.accessibility(this);
            }

            return view;
        };


        /**
         * This method is used to shapes data to existing shapesData.
         *
         * @access      public
         * @method      addShapes
         * @memberof    voltmx.ui.Canvas
         * @author      Shanker Pulugam <shanker.pulugam@voltmx.com>
         *
         * @param       {array} shapesData - array of shapes data to draw on canvas.
         *
         * @throws      {InvalidArgumentException} - One liner description about this exception.
         *
         * @returns     void.
         *
         * @desc        A brief description about the class.
         */
        var canvas_addShapes = function Canvas$addShapes(shapesData) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, final = null, $KU = $K.utils,
                addData = [], existingDataObj = _getDataObj(this._kwebfw_.prop.shapesData);

            _valid.Canvas.shapesData.call(this, shapesData);

            $KU.each(shapesData, function(data/* , index */) {
                if(existingDataObj[data.shapeid]) {
                    throw new $KU.error('CanvasError', 'addShapes:: already shapeid exists');
                } else {
                    addData.push(data);
                }
            });
            this._kwebfw_.prop.shapesData = this._kwebfw_.prop.shapesData.concat(addData);
            _drawShapesOnCanvas.call(this);

            if(_relayoutActiveTriggerer.Canvas().indexOf('addShapes') >= 0) {
                $KW.markRelayout(this);
            }

            if(_relayoutPassiveTriggerer.Canvas().indexOf('addShapes') >= 0) {
                final = this._kwebfw_.flex.final;

                if(!(final.height && final.width)) {
                    $KW.markRelayout(this);
                }
            }
        };


        /**
         * This method is used to shapes data to existing shapesData.
         *
         * @access      public
         * @method      clear
         * @memberof    voltmx.ui.Canvas
         * @author      Shanker Pulugam <shanker.pulugam@voltmx.com>
         *
         * @param       No Arguments to this API.
         *
         * @throws      Not applicable.
         *
         * @returns     void.
         *
         * @desc        A brief description about the class.
         */
        var canvas_clear = function Canvas$clear() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, final = null,
                el = $KW.el(this), ctx = null;

            ctx = el.canvas.getContext('2d');
            this._kwebfw_.prop.shapesData = [];
            _clearRect.call(this, ctx);

            if(_relayoutActiveTriggerer.Canvas().indexOf('clear') >= 0) {
                $KW.markRelayout(this);
            }

            if(_relayoutPassiveTriggerer.Canvas().indexOf('clear') >= 0) {
                final = this._kwebfw_.flex.final;

                if(!(final.height && final.width)) {
                    $KW.markRelayout(this);
                }
            }
        };

        /**
         * This method is used to shapes data to existing shapesData.
         *
         * @access      public
         * @method      removeShapes
         * @memberof    voltmx.ui.Canvas
         * @author      Shanker Pulugam <shanker.pulugam@voltmx.com>
         *
         * @param       {array} shapesData - array of shapes data to draw on canvas.
         *
         * @throws      {InvalidArgumentException} - One liner description about this exception.
         *
         * @returns     void.
         *
         * @desc        A brief description about the class.
         */
        var canvas_removeShapes = function Canvas$removeShapes(shapeIds) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, final = null,
                isremoved = false;


            $KU.each(shapeIds, function(shapeId/* , index */) {
                var existingIndex = _getIndexFromShapesData.call(this, shapeId);

                if(existingIndex !== -1) {
                    this._kwebfw_.prop.shapesData.splice(existingIndex, 1);
                    isremoved = true;
                }
            }, this);

            isremoved && _drawShapesOnCanvas.call(this);

            if(_relayoutActiveTriggerer.Canvas().indexOf('removeShapes') >= 0) {
                $KW.markRelayout(this);
            }

            if(_relayoutPassiveTriggerer.Canvas().indexOf('removeShapes') >= 0) {
                final = this._kwebfw_.flex.final;

                if(!(final.height && final.width)) {
                    $KW.markRelayout(this);
                }
            }
        };

        /**
         * This method is used to shapes data to existing shapesData.
         *
         * @access      public
         * @method      updateShapes
         * @memberof    voltmx.ui.Canvas
         * @author      Shanker Pulugam <shanker.pulugam@voltmx.com>
         *
         * @param       {array} shapesData - array of shapes data to draw on canvas.
         *
         * @throws      {InvalidArgumentException} - One liner description about this exception.
         *
         * @returns     void.
         *
         * @desc        A brief description about the class.
         */
        var canvas_updateShapes = function Canvas$updateShapes(shapesData) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, final = null, isupdated = false,
                $KU = $K.utils;


            $KU.each(shapesData, function(shapeData/* , index */) {
                isupdated = _updateShapeData.call(this, shapeData) || isupdated;
            }, this);

            isupdated && _drawShapesOnCanvas.call(this);

            if(_relayoutActiveTriggerer.Canvas().indexOf('updateShapes') >= 0) {
                $KW.markRelayout(this);
            }

            if(_relayoutPassiveTriggerer.Canvas().indexOf('updateShapes') >= 0) {
                final = this._kwebfw_.flex.final;

                if(!(final.height && final.width)) {
                    $KW.markRelayout(this);
                }
            }
        };

        $K.defVoltmxProp(Canvas.prototype, [
            {keey:'_render', value:canvas__render},
            {keey:'addShapes', value:canvas_addShapes},
            {keey:'clear', value:canvas_clear},
            {keey:'removeShapes', value:canvas_removeShapes},
            {keey:'updateShapes', value:canvas_updateShapes}
        ]);

        return Canvas;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxcamera.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'Camera', value:{}, items:[
            {keey:'onClick', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this);
                if(!el.video.srcObject) {
                    this.openCamera();
                }
                return false;
            }},

            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    $KW = $K.widget, $KD = $K.dom, tabindex = '';

                if(!$KW.interactable(this)) {
                    if($KW.disabled(this)) {
                        $KD.setAttr(dom, 'aria-disabled', true);
                    }

                    $KD.setAttr(dom, 'tabindex', -1);
                    $KD.addCls(this._kwebfw_.view, '-voltmx-blocker');
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(dom, 'aria-disabled');
                    $KD.removeCls(this._kwebfw_.view, '-voltmx-blocker');

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        $KD.removeAttr(dom, 'tabindex');
                    }
                }
            }}
        ]}
    ]);

    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dataAvailableCreateBlob = function Camera$_dataAvailableCreateBlob(callback) {
        var _ = this._kwebfw_;
        _.Recorder.ondataavailable = function(e) {
            _.videoData.push(e.data);
            if(_.Recorder && _.Recorder.state === 'inactive') {
                _.blob = new Blob(_.videoData, {type:'video/mp4'});
                _.videoUrl = URL.createObjectURL(_.blob);
                //eslint-disable-next-line no-console
                console.log(_.videoUrl);
                _.Recorder = null;
                callback && callback(this, _.videoUrl);
            }
        };
    };

    var _dependentPropertiesValidationMessage = {};

    var _getter = {
        Camera: {
            //
        }
    };

    var _populateUnderscore = {
        Camera: function Camera$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Camera', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Camera', null);
                }
            }
        }
    };

    var _postInitialization = {};

    var _relayoutActiveTriggerer = {
        Camera: function Camera$_relayoutActiveTriggerer() {
            return [];
        }
    };

    var _relayoutPassiveTriggerer = {
        Camera: function Camera$_relayoutPassiveTriggerer() {
            return [];
        }
    };

    var _setter = {
        Camera: {
            //
        }
    };

    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Camera: {
            cameraSource: function Camera$_valid_camerSource(value) {
                var flag = false, options = [
                    constants.CAMERA_SOURCE_DEFAULT,
                    constants.CAMERA_SOURCE_FRONT,
                    constants.CAMERA_SOURCE_REAR
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            poster: function Camera$_valid_poster(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            rawBytes: function Camera$_valid_rawBytes(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            base64: function Camera$_valid_base64(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            videoDuration: function Camera$_valid_videoDuration(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number') || ($KU.is(value, 'null'))) {
                    flag = true;
                }

                return flag;
            },

            onCapture: function Camera$_valid_onCapture(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            onCaptureFailed: function Camera$_valid_onCaptureFailed(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            onFailure: function Camera$_valid_onFailure(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            }
        }
    };

    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to 'false', will not create a setter
    var _view = {
        Camera: {
            poster: function Camera$_view_poster(/*el, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    $KW = $K.widget, video = $KW.el(this, 'video');

                if(this.poster && video) {
                    $KD.setAttr(video, 'poster', $KU.getImageURL(this.poster));
                }
            },

            cameraSource: true,

            rawBytes: true,

            base64: true,

            onCapture:true,

            onCaptureFailed:true,

            onFailure:true,

            videoDuration: true
        }
    };

    Object.defineProperty(voltmx.ui, 'Camera', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Camera constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Kasam SaiTeja <saiteja.kasam@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var Camera = function Camera(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    cameraSource: constants.CAMERA_SOURCE_DEFAULT,
                    poster: 'cameraicon.png',
                    onCapture: null,
                    onCaptureFailed: null,
                    onFailure: null,
                    rawBytes: null,
                    base64: null,
                    videoDuration: null
                };
            }

            _populateUnderscore.Camera.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            Camera.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Camera, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Camera.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to Camera
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Camera[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Camera>, but not in <_valid.Camera> namespace.');
                        } else {
                            valid = _valid.Camera[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Camera
                $KU.each(_view.Camera, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Camera$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Camera[key], 'function')) {
                            return _getter.Camera[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Camera$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Camera[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Camera[key], 'function')) {
                                        _setter.Camera[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Camera().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Camera().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    if($KU.is(p.videoDuration, undefined)) p.videoDuration = null;
                    if($KU.is(p.rawBytes, undefined)) p.rawBytes = null;
                }

                if($KU.is(_postInitialization.Camera, 'function')) {
                    _postInitialization.Camera.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Camera, voltmx.ui.BasicWidget);

        /**
         * Builds the view layer for voltmx.ui.Camera widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Camera
         * @author      Kasam SaiTeja <saiteja.kasam@voltmx.com>
         *
         * @returns     {HTMLElement}  Camera view.
         */

        var camera__render = function Camera$_render(tag) {
            var $super = voltmx.ui.Camera.base.prototype, _ = this._kwebfw_,
                $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                el = null, canvas = null, view = _.view, video = null;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    video = $KD.create('VIDEO', {});
                    canvas = $KD.create('CANVAS', {});
                    view = $super._render.call(this, tag, [video, canvas]);

                    el = $KW.el(view);
                    $KD.setAttr(el.node, 'kwh-click', 'onClick');
                    $KD.setAttr(el.video, 'autoplay', '');
                    $KD.setAttr(el.video, 'playsinline', '');
                    $KD.style(el.canvas, 'visibility', 'hidden');
                    $KD.style(el.video, {'height':'100%', 'width':'100%'});

                    _view.Camera.poster.call(this, el.video, this.poster);
                }

                $KW.accessibility(this);
            }
            return view;
        };

        var camera_closeCamera = function Camera$closeCamera() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this),
                tracks = [], i = 0;

            if(el.video.srcObject && $KW.visible(this)) {
                tracks = el.video.srcObject.getTracks();
                for(i = 0; i < tracks.length; i++) {
                    tracks[i].stop();
                }
                el.video.srcObject = null;
            }
        };

        var camera_openCamera = function Camera$openCamera() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                model = this, _ = model._kwebfw_, el = $KW.el(this),
                constraints = null, feedSource = null;

            if(el.video && !el.video.srcObject && $KW.visible(this)) {
                if(_.prop.cameraSource === constants.CAMERA_SOURCE_REAR) {
                    feedSource = 'environment';
                    constraints = {video: {facingMode: {exact: feedSource}}, audio: false};
                } else {
                    feedSource = 'user';
                    if((($KU.browser('name') === "chrome" || $KU.browser('name') === "edge") && voltmx.os.deviceInfo().userAgent.includes('Macintosh')) || $KU.browser('name') === 'firefox') {
                        constraints = {video: {facingMode:  feedSource}, audio: false};
                    } else {
                        constraints = {video: {facingMode: {exact: feedSource}}, audio: false};
                    }
                }
                if($KU.browser('supports', 'usermedia')) {
                    navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
                        el.video.srcObject = stream;
                        el.video.play();
                    }).catch(function(err) {
                        if(err.name === 'NotAllowedError' && $KU.is(_.prop.onFailure, 'function')) {
                            $KW.fire(model, 'onFailure', model, constants.CAMERA_PERMISSION_DENIED);
                        } else {
                            if(_.prop.cameraSource === constants.CAMERA_SOURCE_REAR) {
                                $KW.fire(model, 'onFailure', model, constants.CAMERA_SOURCE_REAR_UNAVAILABLE);
                            } else {
                                $KW.fire(model, 'onFailure', model, constants.CAMERA_SOURCE_FRONT_UNAVAILABLE);
                            }
                        }
                    });
                } else {
                    $KW.fire(model, 'onFailure', model, constants.CAMERA_NOT_SUPPORTED);
                }
            }
        };

        var camera_takePicture = function Camera$takePicture() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                el = $KW.el(this), imgCanvas = null, context = null,
                _ = this._kwebfw_, canvasHeight = null, canvasWidth = null;

            if(el.video.srcObject && $KW.visible(this)) {
                imgCanvas = el.canvas;
                canvasHeight = el.video.offsetHeight ? el.video.videoHeight : 0;
                canvasWidth = el.video.offsetWidth ? el.video.videoWidth : 0;
                $KD.setAttr(imgCanvas, 'height', canvasHeight);
                $KD.setAttr(imgCanvas, 'width', canvasWidth);
                context = imgCanvas.getContext('2d');
                try{
                    context.drawImage(el.video, 0, 0);
                    _.prop.base64 = imgCanvas.toDataURL();
                    _.prop.rawBytes = imgCanvas.toDataURL().split(',')[1];
                    $KW.fire(this, 'onCapture', this);
                } catch(err) {
                    $KW.fire(this, 'onCaptureFailed', this, constants.CAMERA_CAPTURE_FAILED);
                }
            }
        };

        var camera_startVideoCapture = function Camera$startVideoCapture(config) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                model = this, _ = model._kwebfw_, el = $KW.el(this),
                constraints = null, feedSource = null, tracks = null,
                i = null;

            if(el.video && $KW.visible(this)) {
                if(_.prop.cameraSource === constants.CAMERA_SOURCE_REAR) {
                    feedSource = 'environment';
                    constraints = {video: {facingMode: {exact: feedSource}}, audio: true};
                } else {
                    feedSource = 'user';
                    if((($KU.browser('name') === "chrome" || $KU.browser('name') === "edge") && voltmx.os.deviceInfo().userAgent.includes('Macintosh')) || $KU.browser('name') === 'firefox') {
                        constraints = {video: {facingMode:  feedSource}, audio: true};
                    } else {
                        constraints = {video: {facingMode: {exact:  feedSource}}, audio:true};
                    }
                }
                if($KU.browser('supports', 'usermedia') && $KU.browser('supports', 'mediarecorder')) {
                    if(el.video.srcObject) {
                        navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
                            _.videoData = [];
                            _.Recorder = new MediaRecorder(stream);
                            _.Recorder.start();
                            if(_.prop.videoDuration && config && config.callback) {
                                setTimeout(function() {
                                    if(_.Recorder.state === 'recording') {
                                        _.Recorder.stop();
                                        tracks = _.Recorder.stream.getTracks();
                                        for(i = 0; i < tracks.length; i++) {
                                            tracks[i].stop();
                                        }
                                    }
                                    _dataAvailableCreateBlob.call(model, config.callback);
                                }, _.prop.videoDuration*1000);
                            }
                        }).catch(function(/*err*/) {
                            $KW.fire(model, 'onFailure', model, constants.CAMERA_VIDEO_RECORDING_FAILED);
                        });
                    }
                } else {
                    $KW.fire(model, 'onFailure', model, constants.CAMERA_NOT_SUPPORTED);
                }
            }
        };

        var camera_stopVideoCapture = function Camera$stopVideoCapture(config) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_,
                tracks = [], i = null;

            if(config && config.callback && _.Recorder && _.Recorder.state === 'recording' && $KW.visible(this)) {
                _.Recorder.stop();
                tracks = _.Recorder.stream.getTracks();
                for(i = 0; i < tracks.length; i++) {
                    tracks[i].stop();
                }
                _dataAvailableCreateBlob.call(this, config.callback);
            } else {
                $KW.fire(this, 'onFailure', this, constants.CAMERA_VIDEO_RECORDING_FAILED);
            }
        };

        $K.defVoltmxProp(Camera.prototype, [
            {keey:'_render', value:camera__render},
            {keey:'closeCamera', value:camera_closeCamera},
            {keey:'openCamera', value:camera_openCamera},
            {keey:'takePicture', value:camera_takePicture},
            {keey:'startVideoCapture', value:camera_startVideoCapture},
            {keey:'stopVideoCapture', value:camera_stopVideoCapture}
        ]);

        return Camera;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxcomponent.js' */

(function() {
    var _mirrorFlexPosition = function Component$_mirrorFlexPosition(source, bconfig) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            prop = source._kwebfw_.prop, paddingLeft = -1;

        if(!bconfig) bconfig = {};

        if($KW.shouldApplyRTL(source, 'flexPosition')) {
            if(!$KU.is(bconfig.left, 'undefined')) {
                prop.right = bconfig.left;
            }

            if(!$KU.is(bconfig.right, 'undefined')) {
                prop.left = bconfig.right;
            }

            if(!$KU.is(bconfig.padding, 'undefined')) {
                if(!bconfig.padding) {
                    prop.padding = null;
                } else {
                    if(!prop.padding) prop.padding = [];

                    paddingLeft = bconfig.padding[0];
                    prop.padding[1] = bconfig.padding[1];
                    prop.padding[3] = bconfig.padding[3];
                    prop.padding[0] = bconfig.padding[2];
                    prop.padding[2] = paddingLeft;
                }
            }
        } else {
            if(!$KU.is(bconfig.left, 'undefined')) {
                prop.left = bconfig.left;
            }

            if(!$KU.is(bconfig.right, 'undefined')) {
                prop.right = bconfig.right;
            }

            if(!$KU.is(bconfig.padding, 'undefined')) {
                prop.padding = bconfig.padding;
            }
        }
    };


    Object.defineProperty(voltmx.$kwebfw$, 'ComponentWithContract', {configurable:false, enumerable:false, writable:false, value:(function() {
        var ComponentWithContract = function ComponentWithContract(bconfig, lconfig, pspconfig, template) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, proxy = null,
                args = [bconfig, lconfig, pspconfig], component = null;

            proxy = _voltmx.mvc.initializeMasterController(template, bconfig.id, args);
            proxy._kwebfw_.args = [
                ($KU.clone(bconfig, {function:false}) || {}),
                ($KU.clone(lconfig, {function:false}) || {}),
                ($KU.clone(pspconfig, {function:false}) || {})
            ];
            proxy._kwebfw_.prop.id = bconfig.id;
            proxy._kwebfw_.name = 'ComponentWithContract';

            _mirrorFlexPosition(proxy, bconfig);

            $KU.each(bconfig, function(value, name) {
                var prop = proxy._kwebfw_.prop;

                if(['left', 'right', 'padding'].indexOf(name) === -1) {
                    if(name === 'height' && typeof value === 'undefined') {
                        prop[name] = '';
                        prop.autogrowMode = voltmx.flex.AUTOGROW_HEIGHT;
                    } else if(Object.prototype.hasOwnProperty.call(prop, name)) {
                        prop[name] = value;
                    }
                }
            }, proxy);

            $KU.each(lconfig, function(value, name) {
                if(Object.prototype.hasOwnProperty.call(proxy._kwebfw_.prop, name)) {
                    proxy._kwebfw_.prop[name] = value;
                }
            }, proxy);

            $KU.each(pspconfig, function(value, name) {
                if(Object.prototype.hasOwnProperty.call(proxy._kwebfw_.prop, name)) {
                    proxy._kwebfw_.prop[name] = value;
                }
            }, proxy);

            component = new voltmx.ui.UserWidget(bconfig, lconfig, pspconfig);

            proxy._kwebfw_.ns = template;
            $KU.defineProperty(component._kwebfw_, 'proxy', proxy, null);
            $KU.defineProperty(proxy._kwebfw_, 'uwi', component, null);
            component._voltmxControllerName = proxy._voltmxControllerName;
            _voltmx.mvc.setMasterContract(component, bconfig.id, template);
            delete component._voltmxControllerName;

            pspconfig = lconfig = bconfig = null; //For GC

            return component;
        };

        return ComponentWithContract;
    }())});


    Object.defineProperty(voltmx.$kwebfw$, 'ComponentWithoutContract', {configurable:false, enumerable:false, writable:false, value:(function() {
        var ComponentWithoutContract = function ComponentWithoutContract(bconfig, lconfig, pspconfig, template) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, model = null,
                args = [bconfig, lconfig, pspconfig], _ = null;

            model = _voltmx.mvc.initializeMasterController(template, bconfig.id, args);
            _ = model._kwebfw_;
            _.args = [
                ($KU.clone(bconfig, {function:false}) || {}),
                ($KU.clone(lconfig, {function:false}) || {}),
                ($KU.clone(pspconfig, {function:false}) || {})
            ];
            _.prop.id = bconfig.id;
            _.ns = template;
            _.name = 'ComponentWithoutContract';

            _mirrorFlexPosition(model, bconfig);

            $KU.each(bconfig, function(value, name) {
                var prop = model._kwebfw_.prop;

                if(['left', 'right', 'padding'].indexOf(name) === -1) {
                    if(name === 'height' && typeof value === 'undefined') {
                        prop[name] = '';
                        prop.autogrowMode = voltmx.flex.AUTOGROW_HEIGHT;
                    } else {
                        prop[name] = value;
                    }
                }
            }, model);

            $KU.each(lconfig, function(value, name) {
                model._kwebfw_.prop[name] = value;
            }, model);

            $KU.each(pspconfig, function(value, name) {
                model._kwebfw_.prop[name] = value;
            }, model);

            _voltmx.mvc.setMasterContract(model, model.id, template);

            pspconfig = lconfig = bconfig = null; //For GC

            return model;
        };

        return ComponentWithoutContract;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxbrowser.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'Browser', value:{}, items:[
            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, tabindex = '';

                if($KW.disabled(this)) {
                    $KD.setAttr(dom, 'aria-disabled', true);
                    $KD.removeAttr(dom, 'tabindex');
                    $KW.toggleChildren(this);
                } else if(!$KW.interactable(this)) {
                    $KD.removeAttr(dom, 'tabindex');
                    $KW.toggleChildren(this);
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(dom, 'aria-disabled');

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        $KD.removeAttr(dom, 'tabindex');
                    }

                    $KW.toggleChildren(this);
                }
            }}
        ]}
    ]);


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        Browser: {
            requestURLConfig: function Browser$_getter_requestURLConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            }
        }
    };


    //This functions will be called in the scope of widget instance
    var _loadLocalFile = function Browser$_loadLocalFile(view) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KG = $K.globals,
            prop = this._kwebfw_.prop, url = '', iframe = null;

        url += $KG.platform + '/' + 'web/localfiles/' + prop.requestURLConfig.URL;
        iframe = $KD.create('IFRAME', {src:url});
        view.style.overflow = 'hidden';

        $KD.on(iframe, 'load', 'iload', function(/*e*/) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget,
                $KD = $K.dom, script = null, text = '',
                browser = $KW.model($KD.parent(this));

            if(browser) {
                script = $KD.create('SCRIPT', {type:'text/javascript'});
                text = 'if(typeof(voltmx) == \'undefined\' || voltmx){voltmx={}; kony = voltmx};';
                text += 'var context = function(callback){';

                if(browser.enableNativeCommunication) {
                    text += 'var pdoc = parent.document,';
                    text += 'stag = pdoc.createElement(\'script\');';
                    text += 'stag.text=callback;';
                    text += 'pdoc.head.appendChild(stag);';
                } else {
                    text += 'throw (\'<enableNativeCommunciation> property';
                    text += ' of the browser widget is set to false.\\nPlease';
                    text += ' set to true before invoking voltmx.executeInNativeContext !\');';
                }

                script.text = (text + '};voltmx.evaluateJavaScriptInNativeContext=context;');
                this.contentDocument.head.appendChild(script);
            }
        });

        $KD.add(view, iframe);
    };


    //This functions will be called in the scope of widget instance
    var _openUrl = function Browser$_openUrl(url, data, name) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            prop = this._kwebfw_.prop, args = [];

        if(url.indexOf('www.') === 0) {
            url = ('https://'+prop.requestURLConfig.URL);
        }

        $KU.each(data, function(value) {
            args.push((value[0]+'='+value[1]));
        });

        if(args.length) url = (url+'?'+args.join('&'));

        return window.open(url, name);
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        Browser: function Browser$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Browser', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Browser', null);
                }
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {};


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        Browser: function Browser$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        Browser: function Browser$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        Browser: {
            property: function Browser$_setter_property(/*old*/) {
                //
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Browser: {
            enableNativeCommunication: function Browser$_valid_enableNativeCommunication(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            htmlString: function Browser$_valid_htmlString(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            requestURLConfig: function Browser$_valid_requestURLConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')
                && $KU.is(value.URL, 'string') && value.URL
                && (!Object.prototype.hasOwnProperty.call(value, 'requestMethod') || value.requestMethod === constants.BROWSER_REQUEST_METHOD_GET
                || value.requestMethod === constants.BROWSER_REQUEST_METHOD_POST)
                && (!Object.prototype.hasOwnProperty.call(value, 'requestData') || $KU.is(value.requestData, 'array'))) {
                    flag = true;

                    $KU.each(value.requestData, function(data) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if(!($KU.is(data, 'array') && data.length === 2
                        && $KU.is(data[0], 'string') && data[0])) {
                            flag = false;
                            return true;
                        }
                    });
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        Browser: {
            enableNativeCommunication: false,

            htmlString: function Browser$_view_htmlString(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, prop = this._kwebfw_.prop;

                $KD.html(el.node, prop.htmlString);
            },

            requestURLConfig: function Browser$_view_requestURLConfig(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, prop = this._kwebfw_.prop, url='';

                $KD.html(el.node, '');

                if(prop.requestURLConfig && prop.requestURLConfig.URL) {
                    url = prop.requestURLConfig.URL.toLowerCase();

                    if(url.indexOf('http://') === 0
                    || url.indexOf('https://') === 0
                    || url.indexOf('www.') === 0) {
                        _openUrl.call(this, url, prop.requestURLConfig.requestData, this._kwebfw_.uid);
                    } else {
                        _loadLocalFile.call(this, el.node);
                    }
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'Browser', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Browser constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var Browser = function Browser(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    enableNativeCommunication: false,
                    htmlString: '',
                    requestURLConfig: null
                };
            }

            _populateUnderscore.Browser.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            Browser.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Browser, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Browser.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                //Defaulting to platfom values specific to Browser
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Browser[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Browser>, but not in <_valid.Browser> namespace.');
                        } else {
                            valid = _valid.Browser[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Browser
                $KU.each(_view.Browser, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Browser$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Browser[key], 'function')) {
                            return _getter.Browser[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Browser$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Browser[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Browser[key], 'function')) {
                                        _setter.Browser[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Browser().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Browser().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.Browser, 'function')) {
                    _postInitialization.Browser.call(this);
                }
            }


            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Browser, voltmx.ui.BasicWidget);


        /**
         * Builds the view layer for voltmx.ui.Browser widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Browser
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  Browser view.
         */
        var browser__render = function Browser$_render(tag) {
            var $super = voltmx.ui.Browser.base.prototype,
                _ = this._kwebfw_, view = _.view, prop = _.prop,
                $K = voltmx.$kwebfw$, $KW = $K.widget, el = null;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, tag);
                    el = $KW.el(view);

                    if(prop.htmlString) {
                        _view.Browser.htmlString.call(this, el, prop.htmlString);
                    } else if(prop.requestURLConfig) {
                        _view.Browser.requestURLConfig.call(this, el, prop.requestURLConfig);
                    }
                }

                $KW.accessibility(this);
            }

            return view;
        };


        //EvaluateJavaScript
        var browser_evaluateJavaScript = function Browser$evaluateJavaScript(jsScript) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
                $KD = $K.dom, localIframe = $KW.el(this).iframe,
                iframeHead = null, appendHead = null, iframeScript = null;

            if(localIframe) {
                $KU.log('Executing javascript in ' + this.id + ' window handler');
                iframeHead = localIframe.contentDocument.head;
                if(iframeHead === null || iframeHead === undefined) {
                    appendHead = $KD.create('HEAD');
                    localIframe.contentDocument.appendChild(appendHead);
                }
                iframeScript = localIframe.contentDocument.createElement('script');
                iframeScript.text = jsScript;
                iframeHead.appendChild(iframeScript);
            }
        };


        var browser_evaluateJavaScriptAsync = function Browser$evaluateJavaScriptAsync() {
            return null;
        };


        var browser_goBack = function Browser$goBack() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this);

            if(el.iframe) el.iframe.contentWindow.history.back();
        };


        var browser_goForward = function Browser$goForward() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this);

            if(el.iframe) el.iframe.contentWindow.history.forward();
        };


        var browser_reload = function Browser$reload() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this);

            if(el.iframe) el.iframe.contentWindow.location.reload(true);
        };


        $K.defVoltmxProp(Browser.prototype, [
            {keey:'_render', value:browser__render},
            {keey:'evaluateJavaScript', value:browser_evaluateJavaScript},
            {keey:'evaluateJavaScriptAsync', value:browser_evaluateJavaScriptAsync},
            {keey:'goBack', value:browser_goBack},
            {keey:'goForward', value:browser_goForward},
            {keey:'reload', value:browser_reload}
        ]);


        return Browser;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxbutton.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'Button', value:{}, items:[
            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, tabindex = $KW.tabIndex(this, clone);

                if($KW.disabled(this)) {
                    $KD.setAttr(dom, 'disabled', 'true');
                    $KD.setAttr(dom, 'tabindex', -1);
                } else if(!$KW.interactable(this)) {
                    $KD.setAttr(dom, 'tabindex', -1);
                } else {
                    $KD.setAttr(dom, 'disabled', 'false');

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        $KD.removeAttr(dom, 'tabindex');
                    }
                }
            }}
        ]}
    ]);


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        Button: {
            text: function Button$_getter_text() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, text = prop.text;

                if(prop.i18n_text) {
                    text = $KU.getI18Nvalue(prop.i18n_text);
                }

                return text;
            },

            toolTip: function Button$_getter_toolTip() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, toolTip = prop.toolTip;

                if(prop.i18n_toolTip) {
                    toolTip = $KU.getI18Nvalue(prop.i18n_toolTip);
                }

                return toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        Button: function Button$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Button', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Button', null);
                }
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        Button: function Button$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = this._kwebfw_, prop = _.prop;

            if($KU.is(prop.padding, 'null')) {
                prop.padding = [0, 0, 0, 0];
            }

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'defBtnNormal';
            }

            if(prop.i18n_text) {
                prop.text = prop.i18n_text;
            }

            if(prop.i18n_toolTip) {
                prop.toolTip = prop.i18n_toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        Button: function Button$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        Button: function Button$_relayoutPassiveTriggerer() {
            return ['text'];
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        Button: {
            text: function Button$_setter_text(/*old*/) {
                this._kwebfw_.prop.i18n_text = '';
            },

            toolTip: function Button$_setter_toolTip(/*old*/) {
                this._kwebfw_.prop.i18n_toolTip = '';
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Button: {
            i18n_text: function Button$_valid_i18n_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            i18n_toolTip: function Button$_valid_i18n_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            text: function Button$_valid_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    flag = ['', true];
                }

                return flag;
            },

            toolTip: function Button$_valid_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        Button: {
            i18n_text: false,

            i18n_toolTip: false,

            text: function Button$_view_text(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.text(el.node, this.text);
            },

            toolTip: function Button$_view_toolTip(el /*,old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.toolTip) {
                    $KD.setAttr(el.node, 'title', this.toolTip);
                } else {
                    $KD.removeAttr(el.node, 'title');
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'Button', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Button constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var Button = function Button(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    i18n_text: '',
                    i18n_toolTip: '',
                    text: '',
                    toolTip: ''
                };
            }

            _populateUnderscore.Button.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name+$KU.uid());
            }

            Button.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Button, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Button.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to Button
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Button[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Button>, but not in <_valid.Button> namespace.');
                        } else {
                            valid = _valid.Button[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Button
                $KU.each(_view.Button, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Button$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Button[key], 'function')) {
                            return _getter.Button[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Button$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Button[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Button[key], 'function')) {
                                        _setter.Button[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Button().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Button().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.Button, 'function')) {
                    _postInitialization.Button.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Button, voltmx.ui.BasicWidget);


        /**
         * Builds the view layer for voltmx.ui.Button widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Button
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  Button view.
         */
        var button__render = function Button$_render(/*tag*/) {
            var $super = voltmx.ui.Button.base.prototype,
                $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                _ = this._kwebfw_, view = _.view, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, 'BUTTON');

                    $KD.setAttr(view, 'type', 'button');

                    el = $KW.el(view);
                }

                _view.Button.toolTip.call(this, el, this.toolTip);
                _view.Button.text.call(this, el, this.text);

                $KW.accessibility(this);
            }

            return view;
        };


        var button_setFocus = function Button$_setFocus(value) {
            var $super = voltmx.ui.Button.base.prototype, $K = voltmx.$kwebfw$,
                $KU = $K.utils, $KW = $K.widget, $KD = $K.dom, el = $KW.el(this);

            if($KU.is(value, 'boolean') && el.node) {
                if(value === true) {
                    $super.setFocus.call(this, value);
                    $KD.focus(el.node);
                } else {
                    $KD.blur(el.node);
                }
            }
        };


        $K.defVoltmxProp(Button.prototype, [
            {keey:'_render', value:button__render},
            {keey:'setFocus', value:button_setFocus}
        ]);


        return Button;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxcalendar.js' */
(function() {
    var _days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        _months = ['',
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ],
        _weekDays = {sun:0, mon:1, tue:2, wed:3, thu:4, fri:5, sat:6},
        _startDay = 'sun', _weekends = ['sat', 'sun'], _gridCellSkinTypePriorityOrder = [
            'gridCellFocusSkin', 'gridCellInactiveDaysSkin', 'gridCellSelectedSkin',
            'gridCellTodaySkin', 'gridCellWeekendSkin', 'gridCellSpecialSkin', 'gridCellSkin'
        ], $K = voltmx.$kwebfw$, _minYear = 1900, _maxYear = 2099;


    $K.defVoltmxProp($K.ui, [
        {keey:'Calendar', value:{}, items:[
            {keey:'cancelSelection', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_, picker = _.picker,
                    selectedYear = null, cal = null,
                    selectedMonth = null, monthYearPicker = $KD.find(picker, '[kr="monthYearPicker"]')[0],
                    title = $KD.find(monthYearPicker, '[kr="title"]')[0],
                    years = $KD.find(monthYearPicker, '[kr="years"]')[0],
                    months = $KD.find(picker, '[kr="months"]')[0],
                    skinInfo = _getSkinRelatedSkinInfoByGridCell($KD.find(months, '[kr="month"]')[0]);

                cal = $KD.find(picker, '[kr="calendar"]')[0];
                $KD.setAttr(monthYearPicker, 'hidden', true);
                $KD.setAttr(cal, 'hidden', false);
                monthYearPicker = $KD.find(picker, '[kwh-click="onMonthYearClick"]')[0];
                monthYearPicker && $KD.focus(monthYearPicker);

                if(months) {
                    selectedMonth = $KD.find(months, '[class="'+ skinInfo.selectedValue +'"]')[0];
                    if(selectedMonth) {
                        $KD.removeCls(selectedMonth, skinInfo.selectedValue);
                        $KD.addCls(selectedMonth, skinInfo.normalValue);
                        $KD.removeAttr(selectedMonth, 'aria-selected');
                    }
                }
                if(years) {
                    selectedYear = $KD.find(years, '[class="'+ skinInfo.selectedValue +'"]')[0];
                    if(selectedYear) {
                        $KD.removeCls(selectedYear, skinInfo.selectedValue);
                        $KD.addCls(selectedYear, skinInfo.normalValue);
                        $KD.removeAttr(selectedYear, 'aria-selected');
                    }
                }

                $KD.html(title, '');

                return false;
            }},

            {keey:'correctSelection', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_,
                    picker = _.picker, dm = _.displayedMonths[0],
                    selectedMonth, selectedYear,
                    monthYearPicker = $KD.find(picker, '[kr="monthYearPicker"]')[0],
                    years = $KD.find(monthYearPicker, '[kr="years"]')[0],
                    months = $KD.find(picker, '[kr="months"]')[0],
                    title = $KD.find(monthYearPicker, '[kr="title"]')[0];

                if(months) {
                    selectedMonth = _months.indexOf($KD.getAttr(title, 'titlemonth'));
                }
                if(years) {
                    selectedYear = Number($KD.getAttr(title, 'titleyear'));
                }

                _changePicker.call(this, selectedMonth, selectedYear);
                picker = this._kwebfw_.picker;
                monthYearPicker = $KD.find(picker, '[kwh-click="onMonthYearClick"]')[0];
                monthYearPicker && $KD.focus(monthYearPicker);

                return false;
            }},

            {keey:'dateNavigation', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    code = evt.keyCode || evt.which;

                if([33, 34].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 33) { //Page Up
                        evt.shiftKey ? _prevYear.call(this, 1) : _prevMonth.call(this, 1);
                    } else if(code === 34) { //Page Down
                        evt.shiftKey ? _nextYear.call(this, 1) : _nextMonth.call(this, 1);
                    }

                    $KD.focus($KD.find(this._kwebfw_.picker, '[kr="date"]')[0]);
                }

                return false;
            }},

            {keey:'dismissPicker', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    code = evt.keyCode || evt.which;

                if(code === 27) { //Escape
                    $KD.preventDefault(evt);
                    _dismissPicker.call(this, true);
                }

                return false;
            }},

            {keey:'monthNavigation', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    code = evt.keyCode || evt.which;

                if([33, 34, 37, 38, 39, 40].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 37 || code === 38) { //Up Arrow
                        evt.shiftKey ? _prevMonth.call(this, 3) : _prevMonth.call(this, 1);
                    } else if(code === 39 || code === 40) { //Down Arrow
                        evt.shiftKey ? _nextMonth.call(this, 3) : _nextMonth.call(this, 1);
                    } else if(code === 33) { //Page Up
                        _prevYear.call(this, 1);
                    } else if(code === 34) { //Page Down
                        _nextYear.call(this, 1);
                    }

                    $KD.focus($KD.find(this._kwebfw_.picker, '[kr="month"]')[0]);
                }

                return false;
            }},

            {keey:'onApplyClick', value:function(/*evt*/) {
                _applySelectedDates.call(this);

                return false;
            }},

            {keey:'onCloseClick', value:function(/*evt*/) {
                _dismissPicker.call(this, true);

                return false;
            }},

            {keey:'onDateClick', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    date = $KD.closest(evt.target, 'date'), valid = false;

                if(date) {
                    valid = $KD.hasAttr(date, 'aria-disabled') ? false : true;

                    if(valid) {
                        _selectDateFromPicker.call(this, date);
                        $KW.onPropertyChange(this, 'dateComponents');
                    }

                    $K.apm.send(this, 'Touch', {type:(this._kwebfw_.name+'_Selection')});
                    $KW.fire(this, 'onSelection', this, {isValidDateSelected:valid});
                }

                return false;
            }},

            {keey:'onDateFocus', value:function(/*evt*/) {
                /*
                var $K = voltmx.$kwebfw$, $KD = $K.dom, prop = this._kwebfw_.prop,
                    gridConfig = {}, selectedSkin = '', date = null, info = null;

                if(prop.viewConfig && prop.viewConfig.gridConfig) {
                    gridConfig = prop.viewConfig.gridConfig;
                    selectedSkin = (gridConfig.gridCellSelectedSkin || '-voltmx-calendar-cell-selected');
                }

                if(evt.relatedTarget
                && $KD.getAttr(evt.relatedTarget, 'kr') === 'date'
                && !$KD.hasAttr(evt.relatedTarget, 'aria-disabled')) {
                    date = $KD.getAttr(evt.relatedTarget, 'date').split('-');
                    date[0] = parseInt(date[0], 10);
                    date[1] = parseInt(date[1], 10);
                    date[2] = parseInt(date[2], 10);

                    info = _cellRenderInfo.call(this, date[2], date[1], date[0], date[1], date[0]);
                    $KD.removeCls(evt.relatedTarget, selectedSkin);
                    $KD.addCls(evt.relatedTarget, info.skin);
                }

                if($KD.getAttr(evt.target, 'kr') === 'date'
                && !$KD.hasAttr(evt.target, 'aria-disabled')) {
                    date = $KD.getAttr(evt.target, 'date').split('-');
                    date[0] = parseInt(date[0], 10);
                    date[1] = parseInt(date[1], 10);
                    date[2] = parseInt(date[2], 10);

                    info = _cellRenderInfo.call(this, date[2], date[1], date[0], date[1], date[0]);
                    $KD.removeCls(evt.target, info.skin);
                    $KD.addCls(evt.target, selectedSkin);
                }
                //*/
                return false;
            }},

            {keey:'onDateKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    prev = null, next = null, targetDate,
                    code = evt.keyCode || evt.which, currentDate,
                    picker, elementClass;

                if([37, 38, 39, 40].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 37) { //Left Arrow
                        //TODO:: need to add valid date and date boundary checks
                        prev = $KD.prev(evt.target);
                        currentDate = new Date($KD.getAttr(evt.target, 'date'));

                        if(prev) {
                            targetDate = new Date($KD.getAttr(prev, 'date'));
                            if(targetDate.getMonth() !== currentDate.getMonth()) {
                                _prevMonth.call(this, 1);
                                picker = this._kwebfw_.picker;
                                prev = $KD.find(picker, '[date="' + _dateFormatter(targetDate, false) + '"]')[0];
                            }
                            prev.focus();
                        } else {
                            targetDate = currentDate;
                            targetDate.setDate(targetDate.getDate() - 1);
                            _prevMonth.call(this, 1);
                            picker = this._kwebfw_.picker;
                            prev = $KD.find(picker, '[date="' + _dateFormatter(targetDate, false) + '"]')[0];
                            if(prev) {
                                prev.focus();
                            }
                        }
                    } else if(code === 39) { //Right Arrow
                        //TODO:: need to add valid date and date boundary checks
                        next = $KD.next(evt.target);
                        currentDate = new Date($KD.getAttr(evt.target, 'date'));
                        elementClass = $KD.getAttr(next, 'class');

                        if(next && !(elementClass && elementClass === '-voltmx-clear')) {
                            targetDate = new Date($KD.getAttr(next, 'date'));
                            if(targetDate.getMonth() !== currentDate.getMonth()) {
                                _nextMonth.call(this, 1);
                                picker = this._kwebfw_.picker;
                                next = $KD.find(picker, '[date="' + _dateFormatter(targetDate, false) + '"]')[0];
                            }
                            next.focus();
                        } else {
                            targetDate = currentDate;
                            targetDate.setDate(targetDate.getDate() + 1);
                            _nextMonth.call(this, 1);
                            picker = this._kwebfw_.picker;
                            next = $KD.find(picker, '[date="' + _dateFormatter(targetDate, false) + '"]')[0];
                            if(next) {
                                next.focus();
                            }
                        }
                    } else if(code === 38) { //Up Arrow
                        //TODO:: need to add valid date and date boundary checks
                        currentDate = new Date($KD.getAttr(evt.target, 'date'));
                        targetDate = new Date($KD.getAttr(evt.target, 'date'));
                        targetDate.setDate(targetDate.getDate() - 7);
                        if(targetDate.getMonth() !== currentDate.getMonth()) {
                            _prevMonth.call(this, 1);
                        }
                        picker = this._kwebfw_.picker;
                        prev = $KD.find(picker, '[date="' + _dateFormatter(targetDate, false) + '"]')[0];
                        if(prev) {
                            prev.focus();
                        }
                    } else if(code === 40) { //Down Arrow
                        //TODO:: need to add valid date and date boundary checks
                        currentDate = new Date($KD.getAttr(evt.target, 'date'));
                        targetDate = new Date($KD.getAttr(evt.target, 'date'));
                        targetDate.setDate(targetDate.getDate() + 7);
                        if(targetDate.getMonth() !== currentDate.getMonth()) {
                            _nextMonth.call(this, 1);
                        }
                        picker = this._kwebfw_.picker;
                        next = $KD.find(picker, '[date="' + _dateFormatter(targetDate, false) + '"]')[0];
                        if(next) {
                            next.focus();
                        }
                    }
                }

                return false;
            }},

            {keey:'onDateKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    valid = false, code = evt.keyCode || evt.which;

                if([13, 32].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 13 || code === 32) { //Enter or Space
                        valid = $KD.hasAttr(evt.target, 'aria-disabled') ? false : true;

                        if(valid) {
                            _selectDateFromPicker.call(this, evt.target);
                        }

                        $K.apm.send(this, 'Touch', {type:(this._kwebfw_.name+'_Selection')});
                        $KW.fire(this, 'onSelection', this, {isValidDateSelected:valid});
                    }
                }

                return false;
            }},

            {keey:'onFocusOut', value:function(/*evt*/) {
                var timeout = null, self = this;

                timeout = setTimeout(function() {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = self._kwebfw_,
                        picker = _.picker;

                    if(picker && !(picker === $KD.active() || $KD.contains(picker, $KD.active()))) {
                        _dismissPicker.call(self, false);
                    }

                    clearTimeout(timeout); self = timeout = null; //For GC
                }, 0);

                return false;
            }},

            {keey:'onIconClick', value:function(/*evt*/) {
                if(!this._kwebfw_.picker) {
                    _openPicker.call(this);
                }

                return false;
            }},

            {keey:'onIconKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    code = evt.keyCode || evt.which;

                if([13, 32].indexOf(code) >= 0) { //Enter or Space
                    $KD.preventDefault(evt);
                    _openPicker.call(this);
                }

                return false;
            }},

            {keey:'onInputFocusOut', value:function(evt) {
                var _ = this._kwebfw_, prop = _.prop;

                if(evt.target.value !== prop.formattedDate) {
                    _onDateEdited.call(this, evt.target.value);
                }

                return false;
            }},

            {keey:'onInputKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    _ = this._kwebfw_, prop = _.prop,
                    code = evt.keyCode || evt.which;

                if(code === 13 && evt.target.value !== prop.formattedDate) {
                    $KD.preventDefault(evt);
                    _onDateEdited.call(this, evt.target.value);
                }

                return false;
            }},

            {keey:'onMonthYearClick', value:function(/*evt*/) {
                _showMonthYearPicker.call(this);
                return false;
            }},

            {keey:'onNextMonthClick', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, picker = null;

                _nextMonth.call(this, 1);

                picker = this._kwebfw_.picker;
                picker = $KD.find(picker, '[kwh-click="onNextMonthClick"]')[0];
                picker && $KD.focus(picker);

                return false;
            }},

            {keey:'onNextYearClick', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, picker = null;

                _nextYear.call(this, 1);

                picker = this._kwebfw_.picker;
                picker = $KD.find(picker, '[kwh-click="onNextYearClick"]')[0];
                picker && $KD.focus(picker);

                return false;
            }},

            {keey:'onPrevMonthClick', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, picker = null;

                _prevMonth.call(this, 1);

                picker = this._kwebfw_.picker;
                picker = $KD.find(picker, '[kwh-click="onPrevMonthClick"]')[0];
                picker && $KD.focus(picker);

                return false;
            }},

            {keey:'onPrevYearClick', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, picker = null;

                _prevYear.call(this, 1);

                picker = this._kwebfw_.picker;
                picker = $KD.find(picker, '[kwh-click="onPrevYearClick"]')[0];
                picker && $KD.focus(picker);

                return false;
            }},

            {keey:'onPrevYearSetClick', value:function(/*evt*/) {
                // On Click of Previous Year, Picker details are defined
                var $K = voltmx.$kwebfw$, $KD = $K.dom, picker = this._kwebfw_.picker;
                 monthYearPicker = $KD.find(picker, '[kr="monthYearPicker"]')[0],
                    title = $KD.find(monthYearPicker, '[kr="title"]')[0],
                    year = $KD.getAttr(title, 'titleyear'), selectedDiv = null;
                _showPrevYearSet.call(this, 1);

                picker = $KD.find(picker, '[kwh-click="onPrevYearSetClick"]')[0];
                picker && $KD.focus(picker);

                _selectMonthYear(monthYearPicker, '[year="'+year+'"]');

                return false;
            }},

            {keey:'onNextYearSetClick', value:function(/*evt*/) {
                 // On Click of Next Year, Picker details are defined
                var $K = voltmx.$kwebfw$, $KD = $K.dom, picker = this._kwebfw_.picker;
                monthYearPicker = $KD.find(picker, '[kr="monthYearPicker"]')[0],
                    title = $KD.find(monthYearPicker, '[kr="title"]')[0],
                    year = $KD.getAttr(title, 'titleyear'), selectedDiv = null;
                _showNextYearSet.call(this, 1);

                picker = $KD.find(picker, '[kwh-click="onNextYearSetClick"]')[0];
                picker && $KD.focus(picker);

                _selectMonthYear(monthYearPicker, '[year="'+year+'"]');

                return false;
            }},

            {keey:'onYearClick', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_, picker = _.picker,
                    prevCell = null, prevSkinInfo = null, year = '', monthCell = null, title = null,
                    month = '', monthYearPicker = $KD.find(picker, '[kr="monthYearPicker"]')[0],
                    yearCell = $KD.closest(evt.target, 'year'),
                    currentSkinInfo = _getSkinRelatedSkinInfoByGridCell(yearCell),
                    years = $KD.find(monthYearPicker, '[kr="years"]')[0],
                    // On Click of Year getting the title details
                    title = $KD.find(monthYearPicker, '[kr="title"]')[0];
                //Deselect previously selected cell in UI
                if(years) {
                    prevCell = $KD.find(years, '[class="'+ currentSkinInfo.selectedValue +'"]')[0];
                    if(prevCell) {
                        $KD.removeAttr(prevCell, 'aria-selected');
                        prevSkinInfo = _getSkinRelatedSkinInfoByGridCell(prevCell);
                        $KD.removeCls(prevCell, prevSkinInfo.selectedValue);
                        $KD.addCls(prevCell, prevSkinInfo.normalValue);
                    }
                }

                $KD.setAttr(yearCell, 'aria-selected', true);
                $KD.removeCls(yearCell, currentSkinInfo.normalValue);
                $KD.addCls(yearCell, currentSkinInfo.selectedValue);

                year = $KD.getAttr(yearCell, 'year');
                month = $KD.getAttr(title, 'titlemonth');

                // Updating the title details on click of year
                $KD.setAttr(title,'titleyear', year);

                if(monthCell) month = $KD.getAttr(monthCell, 'month');

                title = $KD.find(monthYearPicker, '[kr="title"]')[0];
                _updateMonthYearHeaderLabel.call(this, title, month, year);

                return false;
            }},

            {keey:'onMonthClick', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_, picker = _.picker,
                    prevCell = null, prevSkinInfo = null, yearCell = null, year = '', title = null,
                    month = '', MonthCell = $KD.closest(evt.target, 'month'),
                    monthYearPicker = $KD.find(picker, '[kr="monthYearPicker"]')[0],
                    title = $KD.find(monthYearPicker, '[kr="title"]')[0],
                    currentSkinInfo = _getSkinRelatedSkinInfoByGridCell(MonthCell),
                    months = $KD.find(picker, '[kr="months"]')[0];

                //Deselect previously selected cell in UI
                if(months) {
                    prevCell = $KD.find(months, '[class="'+ currentSkinInfo.selectedValue +'"]')[0];
                    if(prevCell) {
                        $KD.removeAttr(prevCell, 'aria-selected');
                        prevSkinInfo = _getSkinRelatedSkinInfoByGridCell(prevCell);
                        $KD.removeCls(prevCell, prevSkinInfo.selectedValue);
                        $KD.addCls(prevCell, prevSkinInfo.normalValue);
                    }
                }

                $KD.setAttr(MonthCell, 'aria-selected', true);
                $KD.removeCls(MonthCell, currentSkinInfo.normalValue);
                $KD.addCls(MonthCell, currentSkinInfo.selectedValue);

                month = $KD.getAttr(MonthCell, 'month');
                year = $KD.getAttr(title, 'titleyear');
                yearCell = $KD.find($KD.find(monthYearPicker, '[kr="years"]')[0], '[class="-voltmx-calendar-cell-selected"]')[0];
                if(yearCell) year = $KD.getAttr(yearCell, 'year');

                title = $KD.find(monthYearPicker, '[kr="title"]')[0];
                // Updating the titlemonth attribute value in elements 
                $KD.setAttr(title, 'titlemonth', month);
                _updateMonthYearHeaderLabel.call(this, title, month, year);

                return false;
            }},

            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    $KD = $K.dom, el = $KW.el(this), tabindex = '';

                if(!$KW.interactable(this)) {
                    if($KW.disabled(this)) {
                        $KD.setAttr(el.input, 'disabled', 'disabled');
                    } else {
                        $KD.setAttr(el.input, 'readonly', 'readonly');
                    }

                    $KD.setAttr(el.input, 'tabindex', -1);
                    $KD.removeAttr(dom, 'tabindex');
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(el.input, 'disabled');
                    this.dateEditable && $KD.removeAttr(el.input, 'readonly');

                    $KD.setAttr(el.input, 'tabindex', tabindex);
                    $KD.setAttr(dom, 'tabindex', tabindex);
                }
            }},

            {keey:'yearNavigation', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    code = evt.keyCode || evt.which;

                if([33, 34, 37, 38, 39, 40].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 37 || code === 38) { //Up Arrow
                        _prevYear.call(this, 1);
                    } else if(code === 39 || code === 40) { //Down Arrow
                        _nextYear.call(this, 1);
                    } else if(code === 33) { //Page Up
                        evt.shiftKey ? _prevYear.call(this, 50) : _prevYear.call(this, 10);
                    } else if(code === 34) { //Page Down
                        evt.shiftKey ? _nextYear.call(this, 50) : _nextYear.call(this, 10);
                    }

                    $KD.focus($KD.find(this._kwebfw_.picker, '[kr="year"]')[0]);
                }

                return false;
            }}
        ]}
    ]);


    //This functions will be called in the scope of widget instance
    var _anchorPicker = function Calendar$_anchorPicker() {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, $KG = $K.globals,
            _ = this._kwebfw_, anchor = _.anchor, pel = null, top = 0, left = 0,
            size = null, offset = null, view = null, psize = {
                width: (parseInt(_.picker.style.width.replace('px', ''), 10)+2),
                height: (parseInt(_.picker.style.height.replace('px', ''), 10)+2)
            };

        if(!anchor.position) {
            top = (($K.device.height - psize.height) / 2);
            left = (($K.device.width - psize.width) / 2);

            $KD.add($KG.appDialogs, _.picker);
        } else {
            pel = $KW.el($KW.model(anchor.holder));

            view = document.getElementById(anchor.widget);
            offset = _getAnchorOffset(anchor.widget, anchor.holder);
            size = {width:view.offsetWidth, height:view.offsetHeight};

            if(anchor.position === 'top') {
                top = (offset.top - psize.height);
                left = offset.left;
            } else if(anchor.position === 'bottom') {
                top = (offset.top + size.height);
                left = offset.left;
            } else if(anchor.position === 'left') {
                left = (offset.left - psize.width);
                top = offset.top;
            } else if(anchor.position === 'right') {
                left = (offset.left + size.width);
                top = offset.top;
            }

            $KD.style(pel.node, 'zIndex', 2147483647);

            if($KW.isContainer(anchor.holder)) {
                $KW.addToView((pel.scrolee || pel.viewport || pel.node), _.picker);
            } else {
                $KD.add(pel.node, _.picker);
            }
        }

        $KD.style(_.picker, {left:(left+'px'), top:(top+'px')});
    };


    //This functions will be called in the scope of widget instance
    var _applySelectedDates = function Calendar$_applySelectedDates() {
        var _ = this._kwebfw_, prop = _.prop;

        if(_.dateSelectionStarted === true) {
            if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_MULTI_SELECT) {
                prop.selectedDates = _.selectedDates;
                prop.displayedMonth = null;
            } else if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_RANGE_SELECT
            && (_.selectedDates.length === 0 || (_.selectedDates[0] && _.selectedDates[1]))) {
                prop.selectedDates = _.selectedDates;
                prop.displayedMonth = null;
            }
        }

        _.selectedDates = [];
        _.dateSelectionStarted = false;
        _closePicker.call(this, true);
        _updateRelatedDateProperties.call(this);
    };

    var _applySkinSelectedCell = function Calendar$_applySkinSelectedCell(cell) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom,
            currentSkinInfo = _getSkinRelatedSkinInfoByGridCell(cell);

        $KD.setAttr(cell, 'aria-selected', true);
        $KD.removeCls(cell, currentSkinInfo.normalValue);
        $KD.addCls(cell, currentSkinInfo.selectedValue);
    };

    //This functions will be called in the scope of widget instance
    var _cellRenderInfo = function Calendar$_cellRenderInfo(date, month, year, displayedMonth, displayedYear) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = null, skins = [],
            info = {disable:false, skin:'', skinType:'', selectedSkin:'',
                appliedSkin:'', appliedSkinType:'', text:date},
            viewConfig = null, gridConfig = null, sd = null, to = null,
            from = null, appliedSkinIndex = -1, isDate = {
                getActiveSkin: function(dt, skinConfig) {
                    var key = '', skin = '';

                    if(this._kwebfw_.enableDatesInactive === false) {
                        key = _dateFormatter(dt, false);
                        skin = this._kwebfw_.enableDatesSkin[key] || '';
                    } else if(this._kwebfw_.enableDateRangeInactive === false) {
                        skin = this._kwebfw_.enableDateRangeSkin;
                    }

                    if(!skin) {
                        skin = skinConfig.gridCellSkin || '-voltmx-calendar-cell';
                    }

                    return skin;
                },

                getWeekendSkin: function(dt, skinConfig) {
                    var key = '', _ = this._kwebfw_,
                        enableOrDisableDates = this._kwebfw_.prop.enableOrDisableDates,
                        skin = skinConfig.gridCellWeekendSkin || '-voltmx-calendar-cell-weekend';

                    if(enableOrDisableDates && enableOrDisableDates.hasToEnable === true
                        && _inEnableDates.call(this, dt)) {
                        key = _dateFormatter(dt, false);
                        skin = _.enableDatesSkin[key];
                    }

                    return skin;
                },

                getInactiveSkin: function(dt, skinConfig) {
                    var key = '', skin = '', _ = this._kwebfw_,
                        startDateRange = _.enableDateRangeStart,
                        endDateRange = _.enableDateRangeEnd;

                    if(_.enableDatesInactive === true) {
                        key = _dateFormatter(dt, false);
                        skin = _.enableDatesSkin[key] || '';
                    } else if(_.enableDateRangeInactive === true
                    && _inValidRange(startDateRange, endDateRange, [dt.getDate(), dt.getMonth() + 1, dt.getFullYear()])) {
                        skin = _.enableDateRangeSkin;
                    }

                    if(!skin) {
                        skin = skinConfig.gridCellInactiveDaysSkin || '-voltmx-calendar-cell-inactive';
                    }

                    return skin;
                },

                getSpecialSkin: function(dt) {
                    var key = _dateFormatter(dt, false),
                        skin = this._kwebfw_.specialSkins[key] || '';

                    return skin;
                },

                hasSpecialSkin: function(dt) {
                    return isDate.getSpecialSkin.call(this, dt) ? true : false;
                },

                selected: function(dt) {
                    var from = null, to = null, i = 0, ilen = 0,
                        _ = this._kwebfw_, prop = _.prop, flag = false,
                        dc = prop.dateComponents, sd = _getAllSelectedDates.call(this);

                    if(dc && prop.selectionType === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
                        if(dt.getDate() === dc[0]
                        && dt.getMonth() === (dc[1] - 1)
                        && dt.getFullYear() === dc[2]) {
                            flag = true;
                        }
                    } else if(sd && prop.selectionType === constants.CALENDAR_SELECTION_TYPE_MULTI_SELECT) {
                        ilen = sd.length;

                        for(i=0; i<ilen; i++) {
                            if(dt.getDate() === sd[i][0]
                            && dt.getMonth() === (sd[i][1] - 1)
                            && dt.getFullYear() === sd[i][2]) {
                                flag = true;
                                break;
                            }
                        }
                    } else if(sd.length > 0 && prop.selectionType === constants.CALENDAR_SELECTION_TYPE_RANGE_SELECT) {
                        if(sd.length === 1) {
                            if(dt.getDate() === sd[0][0]
                            && dt.getMonth() === (sd[0][1] - 1)
                            && dt.getFullYear() === sd[0][2]) {
                                flag = true;
                            }
                        } else {
                            from = new Date(sd[0][2], (sd[0][1] - 1), sd[0][0], 0, 0, 0);
                            to = new Date(sd[1][2], (sd[1][1] - 1), sd[1][0], 0, 0, 0);

                            if(dt.valueOf() >= from.valueOf() && dt.valueOf() <= to.valueOf()) {
                                flag = true;
                            }
                        }
                    }

                    return flag;
                },

                today: function(dt, viewedMonth, viewedYear) {
                    var today = new Date(), flag = false;

                    if(dt.getMonth() === (viewedMonth-1)
                    && dt.getFullYear() === viewedYear) {
                        if(dt.getDate() === today.getDate()
                        && dt.getMonth() === today.getMonth()
                        && dt.getFullYear() === today.getFullYear()) {
                            flag = true;
                        }
                    }

                    return flag;
                },

                weekend: function(dt) {
                    return ([_weekDays[_weekends[0]], _weekDays[_weekends[1]]].indexOf(dt.getDay()) >= 0);
                }
            };

        prop = this._kwebfw_.prop;
        viewConfig = prop.viewConfig;
        gridConfig = (viewConfig && viewConfig.gridConfig) ? viewConfig.gridConfig : {};

        info.disabled = _isDateInactive.call(this, [date, month, year, 0, 0, 0]);

        if(!info.disabled) {
            if($KU.is(displayedMonth, 'integer')
            && $KU.is(displayedYear, 'integer')
            && !(month === displayedMonth && year === displayedYear)) {
                info.disabled = true;
            }
        }

        date = new Date(year, (month-1), date, 0, 0, 0);
        skins.push('gridCellSkin');
        if(info.disabled) skins.push('gridCellInactiveDaysSkin');
        if(isDate.today.call(this, date, displayedMonth, displayedYear)) {
            info.today = true;
            skins.push('gridCellTodaySkin');
        }
        if(isDate.weekend.call(this, date)) {
            info.weekend = true;
            skins.push('gridCellWeekendSkin');
        }
        if(isDate.selected.call(this, date)) {
            info.selected = true;
            skins.push('gridCellSelectedSkin');
        }
        if(isDate.hasSpecialSkin.call(this, date)) skins.push('gridCellSpecialSkin');

        $KU.each(_gridCellSkinTypePriorityOrder, function(gridCellSkinType) {
            if(skins.indexOf(gridCellSkinType) >= 0) {
                info.appliedSkinType = gridCellSkinType;
                return true; //break the loop
            }
        });

        //Today skin has higher prority over any other skin, except selected skin
        if(info.today && info.appliedSkinType !== 'gridCellSelectedSkin') {
            info.appliedSkinType = 'gridCellTodaySkin';
        }

        if(info.appliedSkinType !== 'gridCellSelectedSkin') {
            info.skinType = info.appliedSkinType;
        } else {
            appliedSkinIndex = _gridCellSkinTypePriorityOrder.indexOf(info.appliedSkinType);

            while(appliedSkinIndex !== -1
            && appliedSkinIndex < _gridCellSkinTypePriorityOrder.length) {
                if(skins.indexOf(_gridCellSkinTypePriorityOrder[++appliedSkinIndex]) >= 0) {
                    info.skinType = _gridCellSkinTypePriorityOrder[appliedSkinIndex];
                    break;
                }
            }
        }

        //START:: Logic to get selected cell skin
        info.selectedSkin = gridConfig.gridCellSelectedSkin || '-voltmx-calendar-cell-selected';
        sd = this._kwebfw_.prop.selectedDates;

        if(sd && this._kwebfw_.prop.selectionType === constants.CALENDAR_SELECTION_TYPE_RANGE_SELECT) {
            if(sd.length === 2) {
                from = new Date(sd[0][2], (sd[0][1] - 1), sd[0][0], 0, 0, 0);
                to = new Date(sd[1][2], (sd[1][1] - 1), sd[1][0], 0, 0, 0);

                if(date.valueOf() === from.valueOf() && gridConfig.gridCellFromDateSkin) {
                    info.selectedSkin = gridConfig.gridCellFromDateSkin || '-voltmx-calendar-cell-from';
                } else if(date.valueOf() === to.valueOf() && gridConfig.gridCellToDateSkin) {
                    info.selectedSkin = gridConfig.gridCellToDateSkin || '-voltmx-calendar-cell-to';
                }
            }
        }
        //END:: Logic to get selected cell skin

        if(info.skinType === 'gridCellSpecialSkin') {
            info.skin = isDate.getSpecialSkin.call(this, date);
        } else if(info.skinType === 'gridCellInactiveDaysSkin') {
            info.skin = isDate.getInactiveSkin.call(this, date, gridConfig);
        } else if(info.skinType === 'gridCellSelectedSkin') {
            info.skin = info.selectedSkin;
        } else if(info.skinType === 'gridCellTodaySkin') {
            info.skin = gridConfig.gridCellTodaySkin || '-voltmx-calendar-cell-today';
        } else if(info.skinType === 'gridCellWeekendSkin') {
            info.skin = isDate.getWeekendSkin.call(this, date, gridConfig);
        } else {
            info.skin = isDate.getActiveSkin.call(this, date, gridConfig);
        }

        if(info.appliedSkinType === 'gridCellSelectedSkin') {
            info.appliedSkin = info.selectedSkin;
        } else {
            info.appliedSkin = info.skin;
        }

        return info;
    };


    //This functions will be called in the scope of widget instance
    var _changePicker = function Calendar$_changePicker(month, year) {
        if(month >= 1 && month <= 12
        && year >= _minYear && year <= _maxYear) {
            _populateDisplayedMonths.call(this, month, year);

            if(this._kwebfw_.picker) {
                _closePicker.call(this, false);
                _openPicker.call(this);
            }
        }
    };


    //This functions will be called in the scope of widget instance
    var _closePicker = function Calendar$_closePicker(focus) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
            _ = this._kwebfw_, parent = null, el = null;

        if($KU.is(_.picker, 'dom')) {
            if(_.anchor.holder) {
                parent = $KW.model(_.anchor.holder);
                $KD.style(parent._kwebfw_.view, 'zIndex', parent.zIndex);
            }

            $KU.each($KD.find(_.picker, 'img'), function(node) {
                $KD.removeAttr(node, 'onmousedown');
            });
            $KD.remove(_.picker);
            delete _.picker;
            el = $KW.el(this);

            //Deleting dropdown instances
            if(_.monthDropdown && _.yearDropdown) {
                _.monthDropdown.destroy();
                _.yearDropdown.destroy();
            }

            $KD.setAttr(el.icon, 'aria-expanded', 'false');

            $KW.dismissPicker(this);

            if(focus !== false) {
                $KD.focus(el.icon);
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _convertFormatedDateToDateComponents = function Calendar$_convertFormatedDateToDateComponents(str) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
            prop = _.prop, dc = null, dates = [], valid = true,
            backupDateComponents = prop.dateComponents,
            backupSelectedDates = prop.selectedDates;

        if($KU.is(str, 'string') && str) {
            if(this.selectionType === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
                dc = _parseToDateComponent(str, prop.dateFormat);

                if(dc) {
                    dates.push(dc);
                    prop.dateComponents = dc;
                } else valid = false;
            } else if(this.selectionType === constants.CALENDAR_SELECTION_TYPE_MULTI_SELECT) {
                prop.selectedDates = [];

                $KU.each(str.split(','), function(date) {
                    date = _parseToDateComponent(date, prop.dateFormat);

                    if(date) {
                        dates.push(date);
                        prop.selectedDates.push(date);
                    } else {
                        valid = false;
                        return true;
                    }
                });
            } else if(this.selectionType === constants.CALENDAR_SELECTION_TYPE_RANGE_SELECT) {
                prop.selectedDates = [];

                $KU.each(str.split(' - '), function(date) {
                    date = _parseToDateComponent(date, prop.dateFormat);

                    if(date) {
                        dates.push(date);
                        prop.selectedDates.push(date);
                    } else {
                        valid = false;
                        return true;
                    }
                });
            }

            if(valid) {
                valid = _isValidDateCombination.call(this, prop);
            }

            if(!valid) dates = null;

            prop.dateComponents = backupDateComponents;
            prop.selectedDates = backupSelectedDates;
        }

        return dates;
    };


    var _dateFormatter = function Calendar$_dateFormatter(date, time, format) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            year = -1, month = -1, day = -1, str = '';

        if(arguments.length === 2) {
            format = 'yyyy-MM-dd';
            if(time) format += ' hh:mm:ss';
        }

        if($KU.is(date, 'array')) {
            day = date[0];
            month = date[1];
            year = date[2];
        } else if($KU.is(date, 'date')) {
            day = date.getDate();
            month = (date.getMonth() + 1);
            year = date.getFullYear();
        }

        if(year !== -1 && month !== -1 && day !== -1) {
            year = year.toString();
            month = (month > 9) ? month.toString() : ('0'+month);
            day = (day > 9) ? day.toString() : ('0'+day);
            str = format;
            str = str.replace('dd', day);

            if(str.indexOf('MMM') !== -1) {
                month = _months[parseInt(month, 10)];
                str = str.replace('MMM', month.substr(0, 3));
            } else if(str.indexOf('MM') !== -1) {
                str = str.replace('MM', month);
            }

            if(str.indexOf('yyyy') !== -1) {
                str = str.replace('yyyy', year);
            } else if(str.indexOf('yy') !== -1) {
                year = year.substr(2, 2);
                str = str.replace('yy', year);
            }

            if(time) {
                //TODO::
            }
        }

        return str;
    };


    //This functions will be called in the scope of widget instance
    var _deduceCellHeightAndWidth = function Calendar$_deduceCellHeightAndWidth() {
        var size = null;

        size = {height:40, width:40};

        return size;
    };


    //This functions will be called in the scope of widget instance
    var _deduceDisplayedMonth = function Calendar$_deduceDisplayedMonth() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, date = new Date(),
            prop = this._kwebfw_.prop, dc = null, sd = null, dm = null;

        if(prop.displayedMonth) {
            dm = [prop.displayedMonth[0], prop.displayedMonth[1]];
        } else {
            if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
                dc = prop.dateComponents;

                if($KU.is(dc, 'array')) {
                    dm = [dc[1], dc[2]];
                } else {
                    dm = [(date.getMonth()+1), date.getFullYear()];
                }
            } else {
                sd = prop.selectedDates;

                if(sd && sd.length > 0) {
                    sd = sd[sd.length-1];
                    dm = [sd[1], sd[2]];
                } else {
                    dm = [(date.getMonth()+1), date.getFullYear()];
                }
            }
        }

        return dm;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {
        Calendar: function Calendar$_dependentPropertiesValidationMessage(defProp, bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                prop = this._kwebfw_.prop, valid = false;

            prop.dateComponents = bconfig.dateComponents || defProp.dateComponents;
            prop.selectedDates = bconfig.selectedDates || defProp.selectedDates;
            prop.selectionType = (pspconfig && pspconfig.selectionType)
                                 || bconfig.selectionType || defProp.selectionType;
            prop.validEndDate = bconfig.validEndDate || defProp.validEndDate;
            prop.validStartDate = bconfig.validStartDate || defProp.validStartDate;
            prop.viewConfig = (pspconfig && pspconfig.viewConfig)
                              || bconfig.viewConfig || defProp.viewConfig;

            valid = _isValidDateComponents(prop.dateComponents);
            if($KU.is(valid, 'array')) {
                prop.dateComponents = valid[0];
                valid = valid[1];
            }

            if(valid) valid = _isValidDateCombination.call(this, prop);

            delete prop.dateComponents;
            delete prop.selectedDates;
            delete prop.selectionType;
            delete prop.validEndDate;
            delete prop.validStartDate;
            delete prop.viewConfig;

            return valid ? '' : 'Invalid date combination passed.';
        }
    };


    //This functions will be called in the scope of widget instance
    var _dismissPicker = function Calendar$_dismissPicker(focus) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, dm = null;

        if(_.picker) {
            if(!$KU.is(focus, 'boolean')) focus = true;

            _.selectedDates = [];
            _.dateSelectionStarted = false;

            dm = _deduceDisplayedMonth.call(this);
            _populateDisplayedMonths.call(this, dm[0], dm[1]);

            _closePicker.call(this, focus);
        }
    };


    //This functions will be called in the scope of widget instance
    var _formatDate = function Calendar$_formatDate() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop, result = '';

        if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
            if(prop.dateComponents) {
                result = _dateFormatter(prop.dateComponents, false, prop.dateFormat);
            }
        } else if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_MULTI_SELECT) {
            if(prop.selectedDates) {
                $KU.each(prop.selectedDates, function(date, index) {
                    result += (((index > 0) ? ',' : '') + _dateFormatter(date, false, prop.dateFormat));
                });
            }
        } else if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_RANGE_SELECT) {
            if(prop.selectedDates && prop.selectedDates.length === 2) {
                result = (_dateFormatter(prop.selectedDates[0], false, prop.dateFormat)
                       + ' - '
                       + _dateFormatter(prop.selectedDates[1], false, prop.dateFormat));
            }
        }

        return result;
    };


    var _getAllSelectedDates = function Calendar$_getAllSelectedDates() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, dates = [];

        if(_.dateSelectionStarted === true) {
            dates = _.selectedDates;
        } else if($KU.is(_.prop.selectedDates, 'array')) {
            dates = _.prop.selectedDates;
        }

        return dates;
    };


    var _getAnchorOffset = function Calendar$_getAnchorOffset(widgetUID, holder) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
            offsetParent = null, view = document.getElementById(widgetUID),
            offset = {left:view.offsetLeft, top:view.offsetTop};

        if(!$KW.isContainer(holder)) {
            offsetParent = view.offsetParent;
            //offset = {left:view.offsetLeft, top:0};

            while(offsetParent && $KD.getAttr(offsetParent, 'kr') !== 'item') {
                offset.left += offsetParent.offsetLeft;
                offset.top += offsetParent.offsetTop;
                offsetParent = offsetParent.offsetParent;
            }

            if($KD.getAttr(offsetParent, 'kr') === 'item') {
                offset.left += offsetParent.offsetLeft;
                offset.top += offsetParent.offsetTop;
            }
        }

        return offset;
    };


    var _getSkinRelatedSkinInfoByGridCell = function Calendar$_getSkinRelatedSkinInfoByGridCell(cell) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, info = {},
            types = _gridCellSkinTypePriorityOrder;

        info.normalType = $KD.getAttr(cell, 'cellskintype');
        info.normalValue = $KD.getAttr(cell, 'cellskinvalue');
        info.normalIndex = types.indexOf(info.normalType);
        info.selectedIndex = types.indexOf('gridCellSelectedSkin');
        info.selectedValue = $KD.getAttr(cell, 'cellselectedskin');

        return info;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        Calendar: {
            dateComponents: function Calendar$_getter_dateComponents(value) {
                return (value) ? value.slice(0) : value;
            },

            displayedMonth: function Calendar$_getter_displayedMonth(value) {
                return (value) ? value.slice(0) : value;
            },

            enableOrDisableDates: function Calendar$_getter_enableOrDisableDates(value) {
                if(value) {
                    return {dates: value.dates, hasToEnable: value.hasToEnable, skin: value.skin};
                }
                return value;
            },

            selectedDates: function Calendar$_getter_selectedDates(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, dates = [];

                if($KU.is(value, 'null')) {
                    dates = value;
                } else if(value.length > 0) {
                    $KU.each(value, function(dc) {
                        dates.push(dc.slice(0));
                    });
                }

                return dates;
            },

            toolTip: function Calendar$_getter_toolTip() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, toolTip = prop.toolTip;

                if(prop.i18n_toolTip) {
                    toolTip = $KU.getI18Nvalue(prop.i18n_toolTip);
                }

                return toolTip;
            },

            validEndDate: function Calendar$_getter_validEndDate(value) {
                return (value) ? value.slice(0) : value;
            },

            validStartDate: function Calendar$_getter_validStartDate(value) {
                return (value) ? value.slice(0) : value;
            },

            widgetDataMapForCell: function Calendar$_getter_widgetDataMapForCell(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            }
        }
    };


    var _getMonthYearHeader = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, _ = this._kwebfw_,
            prop = _.prop, viewConfig = prop.viewConfig ? prop.viewConfig.gridConfig : null,
            header, headerSkin = '-voltmx-calendar-header', row, labelCell,
            cancelSelectionCell, correctSelectionCell, cancelSelectSrc, correctSelectSrc;

        header = $KD.create('DIV', {kr:'header'}, {
            display:'table', width:'100%', height: '15%', 'table-layout':'fixed'
        });
        if(prop.gridTheme === voltmx.calendar.MODERN) {
            headerSkin = (viewConfig && viewConfig.headerSkin)
                ? viewConfig.headerSkin : '-voltmx-calendar-header';
            $KD.addCls(header, headerSkin);
        }

        row = $KD.create('DIV', {}, {display:'table-row', width: '100%', height: '100%'});
        cancelSelectionCell = $KD.create('DIV', {tabindex:0}, {display:'table-cell', width:'15%', 'text-align': 'left', 'vertical-align': 'middle'});
        labelCell = $KD.create('DIV', {kr:'title'}, {display:'table-cell', width: '70%', 'text-align': 'center', 'vertical-align': 'middle'});
        correctSelectionCell = $KD.create('DIV', {tabindex:0}, {display:'table-cell', width:'15%', 'text-align':'right', 'vertical-align': 'middle'});

        cancelSelectSrc = (viewConfig && viewConfig.monthYearCancel)
            ? viewConfig.monthYearCancel :'k-cancel.png';
        correctSelectSrc = (viewConfig && viewConfig.monthYearDone)
            ? viewConfig.monthYearDone : 'k-go.png';

        _updateMonthYearHeaderLabel.call(this, labelCell);

        $KD.html(cancelSelectionCell, ('<img loading="lazy" onmousedown="return false;" src="'+$KU.getImageURL(cancelSelectSrc)+'" style="height:50%; width:50%; position:relative; left:5px;"/>'));
        $KD.html(correctSelectionCell, ('<img loading="lazy" onmousedown="return false;" src="'+$KU.getImageURL(correctSelectSrc)+'" style="height:50%; width:50%; position:relative; right:5px;"/>'));

        $KD.setAttr(cancelSelectionCell, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(correctSelectionCell, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(cancelSelectionCell, 'kwh-click', 'cancelSelection');
        $KD.setAttr(correctSelectionCell, 'kwh-click', 'correctSelection');

        $KD.add(row, cancelSelectionCell);
        $KD.add(row, labelCell);
        $KD.add(row, correctSelectionCell);

        $KD.add(header, row);

        return header;
    };


    var _getMonths = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, size = _months.length,
            monthsArray = _months.slice(1, size), monthsBlock,
            row, cell, html = '', _ = this._kwebfw_, prop = _.prop,
            viewConfig = prop.viewConfig ? prop.viewConfig.gridConfig : null,
            cellSelectedSkin = '-voltmx-calendar-cell-selected';

        if(viewConfig && viewConfig.gridMonthYearSelectedSkin) {
            cellSelectedSkin = viewConfig.gridMonthYearSelectedSkin;
        }
        var _monthChunks = function(array, size) {
            var results = [];
            while(array.length) {
                results.push(array.splice(0, size));
            }
            return results;
        };

        monthsBlock = $KD.create('DIV', {kr:'months'}, {display:'table', 'table-layout':'fixed', width: '100%', height: '30%', border: '1px solid #FAFAFA'});
        monthsArray = _monthChunks(monthsArray, 6);
        $KU.each(monthsArray, function(block) {
            row = $KD.create('DIV', {}, {display:'table-row', width: '100%', height: '50%'});

            $KU.each(block, function(month) {
                cell = $KD.create('DIV', {kr:'month'}, {display:'table-cell', width: '100%', height: '15%', 'text-align': 'center', 'vertical-align': 'middle'});
                html = '<label tabindex="0" aria-live="polite" role="option" aria-label="' + month + '">';
                html += month.substring(0, 3) +'</label>';
                $KD.html(cell, html);

                $KD.setAttr(cell, 'month', month);
                $KD.setAttr(cell, 'cellskinvalue', '-voltmx-calendar-cell');
                $KD.setAttr(cell, 'cellselectedskin', cellSelectedSkin);
                $KD.addCls(cell, '-voltmx-calendar-cell');
                $KD.setAttr(cell, 'kwh-click', 'onMonthClick');
                $KD.setAttr(cell, 'kwh-focusout', 'onFocusOut');
                $KD.add(row, cell);
            });

            $KD.add(monthsBlock, row);
        });

        return monthsBlock;
    };


    var _getCounter = function(selectedYearValue) {
        var temp, iterator, counter = 2001;

        if(selectedYearValue) {
            selectedYearValue = Number(selectedYearValue);
        } else {
            selectedYearValue = null;
        }
        if(selectedYearValue !== null) {
            if(selectedYearValue > counter) {
                iterator = Math.floor((selectedYearValue - 2001) / 16);
                for(temp = 0; temp < iterator; temp++) {
                    counter = counter + 16;
                }
            } else {
                iterator = Math.ceil((2001 - selectedYearValue) / 16);
                for(temp = 0; temp < iterator; temp++) {
                    counter = counter - 16;
                }
            }
        }
        return counter;
    };


    var _getYears = function(firstYear) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom,
            _ = this._kwebfw_, prop = _.prop, i, j, html = '', counter, row,
            dc = prop.dateComponents, cell, yearBlock,
            viewConfig = prop.viewConfig ? prop.viewConfig.gridConfig : null,
            cellSelectedSkin = '-voltmx-calendar-cell-selected';

        if(viewConfig && viewConfig.gridMonthYearSelectedSkin) {
            cellSelectedSkin = viewConfig.gridMonthYearSelectedSkin;
        }

        if(firstYear) {
            counter = firstYear;
        } else {
            dc = _.displayedMonths[0][1];
            counter = _getCounter(dc);
        }

        yearBlock = $KD.create('DIV', {kr:'years'}, {display:'table', tableLayout:'fixed', width: '100%', height: '40%'});

        for(i = 1; i <= 4; i++) { // 4 is number of rows of years We want to display.
            row = $KD.create('DIV', {}, {display:'table-row', width: '100%', height: '25%'});

            for(j = 1; j <= 4; j++) { //  Number of columns of years I want to display in each row.
                // SO here 4 Columns * 4 Rows = 16 years will be displayed.
                cell = $KD.create('DIV', {kr:'year'}, {display:'table-cell', width: '25%', 'visibility': 'visible', 'text-align': 'center', 'vertical-align': 'middle'});
                html = '<label tabindex="0" aria-live="polite" role="option" aria-label="' + counter + '">';
                html += counter +'</label>';

                if((counter > _minYear && counter < _maxYear) || counter === _maxYear || counter === _minYear) {
                    cell.style.visibility = 'visible';
                } else {
                    cell.style.visibility = 'hidden';
                }

                $KD.setAttr(cell, 'year', counter);
                $KD.setAttr(cell, 'cellskinvalue', '-voltmx-calendar-cell');
                $KD.setAttr(cell, 'cellselectedskin', cellSelectedSkin);
                $KD.addCls(cell, '-voltmx-calendar-cell');
                $KD.setAttr(cell, 'kwh-click', 'onYearClick');
                $KD.setAttr(cell, 'kwh-focusout', 'onFocusOut');
                $KD.html(cell, html);
                $KD.add(row, cell);
                counter++;
            }

            $KD.add(yearBlock, row);
        }

        return yearBlock;
    };


    var _getYearNavigation = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, _ = this._kwebfw_,
            prop = _.prop, viewConfig = prop.viewConfig ? prop.viewConfig.gridConfig : null,
            prevYearSrc, yearNavigationBlock, row, leftNavCell, rightNavCell, nextYearSrc, centerDiv;

        yearNavigationBlock = $KD.create('DIV', {}, {display:'table', 'table-layout':'fixed', width: '100%', height: '15%'});
        row = $KD.create('DIV', {}, {display:'table-row', width: '100%', height: '100%'});
        leftNavCell = $KD.create('DIV', {tabindex:0}, {display:'table-cell', width:'20%', 'text-align': 'left', 'vertical-align': 'middle'});
        centerDiv = $KD.create('DIV', {}, {display:'table-cell', width:'60%'});
        rightNavCell = $KD.create('DIV', {tabindex:0}, {display:'table-cell', width:'20%', 'text-align':'right', 'vertical-align': 'middle'});

        prevYearSrc = (viewConfig && viewConfig.leftNavigationImage)
            ? viewConfig.leftNavigationImage : 'kwebfw-prev-month.png';
        nextYearSrc = (viewConfig && viewConfig.rightNavigationImage)
            ? viewConfig.rightNavigationImage : 'kwebfw-next-month.png';

        $KD.setAttr(leftNavCell, 'kwh-click', 'onPrevYearSetClick');
        $KD.setAttr(rightNavCell, 'kwh-click', 'onNextYearSetClick');

        $KD.html(leftNavCell, ('<img loading="lazy" onmousedown="return false;" src="'+ $KU.getImageURL(prevYearSrc) +'" style="height:15px; width:25px; display:inline-block;"/>'));
        $KD.html(rightNavCell, ('<img loading="lazy" onmousedown="return false;" src="'+ $KU.getImageURL(nextYearSrc) +'" style="height:15px; width:25px; display:inline-block;"/>'));

        $KD.setAttr(leftNavCell, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(rightNavCell, 'kwh-focusout', 'onFocusOut');

        $KD.add(row, leftNavCell);
        $KD.add(row, centerDiv);
        $KD.add(row, rightNavCell);
        $KD.add(yearNavigationBlock, row);

        return yearNavigationBlock;
    };


    //This functions will be called in the scope of widget instance
    var _inEnableDateRange = function Calendar$_inEnableDateRange(dt) {
        var startDate = this._kwebfw_.enableDateRangeStart,
            endDate = this._kwebfw_.enableDateRangeEnd,
            flag = _inValidRange(startDate, endDate, dt);

        return flag;
    };


    //This functions will be called in the scope of widget instance
    var _inEnableDates = function Calendar$_inEnableDates(dt) {
        var flag = false, key = _dateFormatter(dt, false);

        if(this._kwebfw_.enableDates
        && this._kwebfw_.enableDates[key] === true) {
            flag = true;
        }

        return flag;
    };


    var _inValidRange = function Calendar$_inValidRange(start, end, target) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

        if(!target) {
            flag = true;
        } else {
            if($KU.is(start, 'array')) {
                start = new Date(start[2], (start[1] - 1), start[0], 0, 0, 0);
            }
            if($KU.is(end, 'array')) {
                end = new Date(end[2], (end[1] - 1), end[0], 0, 0, 0);
            }
            if($KU.is(target, 'array')) {
                target = new Date(target[2], (target[1] - 1), target[0], 0, 0, 0);
            }

            if(start && end && target >= start && target <= end) {
                flag = true;
            } else if(start && !end && target >= start) {
                flag = true;
            } else if(!start && end && target <= end) {
                flag = true;
            } else if(!start && !end) {
                flag = true;
            }
        }

        return flag;
    };


    //This functions will be called in the scope of widget instance
    var _isDateInactive = function Calendar$_isDateInactive(dc) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, dt = null,
            _ = this._kwebfw_, prop = _.prop, flag = null,
            weekends = [_weekDays[_weekends[0]], _weekDays[_weekends[1]]];

        if(!$KU.is(flag, 'boolean') && $KU.is(_.enableDatesInactive, 'boolean')) {
            if(_inEnableDates.call(this, dc)) {
                flag = _.enableDatesInactive;
            }
        }

        if(!$KU.is(flag, 'boolean') && $KU.is(_.enableDateRangeInactive, 'boolean')) {
            if(_inEnableDateRange.call(this, dc)) {
                flag = _.enableDateRangeInactive;
            } else {
                flag = !_.enableDateRangeInactive;
            }
        }

        if(!$KU.is(flag, 'boolean') && !_inValidRange(prop.validStartDate, prop.validEndDate, dc)) {
            flag = true;
        }

        if(flag !== true && prop.viewConfig && prop.viewConfig.gridConfig
        && prop.viewConfig.gridConfig.allowWeekendSelectable === false) {
            dt = new Date(dc[2], (dc[1] - 1), dc[0], 0, 0, 0);
            if(weekends.indexOf(dt.getDay()) >= 0) {
                flag = true;
            }
        }

        return (flag === true) ? true : false;
    };


    //This functions will be called in the scope of widget instance
    var _isValidDateCombination = function Calendar$_isValidDateCombination(prop) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
            validStartDate = prop.validStartDate, from = null, to = null,
            validEndDate = prop.validEndDate, type = prop.selectionType,
            dc = prop.dateComponents, sd = prop.selectedDates, dates = null,
            enableDateRangeStart = null, enableDateRangeEnd = null,
            next = null, flag = true;

        if(flag && validStartDate && validEndDate) {
            validStartDate = new Date(validStartDate[2], (validStartDate[1] - 1), validStartDate[0], 0, 0, 0);
            validEndDate = new Date(validEndDate[2], (validEndDate[1] - 1), validEndDate[0], 0, 0, 0);

            if(validStartDate > validEndDate) flag = false;
        }

        if(flag && _.enableDateRangeStart && _.enableDateRangeEnd) {
            enableDateRangeStart = new Date(_.enableDateRangeStart[2], (_.enableDateRangeStart[1] - 1), _.enableDateRangeStart[0], 0, 0, 0);
            enableDateRangeEnd = new Date(_.enableDateRangeEnd[2], (_.enableDateRangeEnd[1] - 1), _.enableDateRangeEnd[0], 0, 0, 0);

            if(enableDateRangeStart > enableDateRangeEnd) flag = false;
        }

        if(flag && sd && type === constants.CALENDAR_SELECTION_TYPE_RANGE_SELECT) {
            from = new Date(sd[0][2], (sd[0][1] - 1), sd[0][0], 0, 0, 0);
            to = new Date(sd[1][2], (sd[1][1] - 1), sd[1][0], 0, 0, 0);

            if(from > to) flag = false;
        }

        if(flag) {
            if(dc && type === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
                flag = !_isDateInactive.call(this, dc);
            } else if(sd && type === constants.CALENDAR_SELECTION_TYPE_MULTI_SELECT) {
                $KU.each(sd, function(date) {
                    if(_isDateInactive.call(this, date)) {
                        flag = false;
                        return true;
                    }
                }, this);
            } else if(from && to && type === constants.CALENDAR_SELECTION_TYPE_RANGE_SELECT) {
                dates = [];
                next = from;

                while(next <= to) {
                    dates.push(next);
                    next = new Date((next.getTime() + (24*60*60*1000)));
                } next = null;

                $KU.each(dates, function(date) {
                    if(_isDateInactive.call(this, date)) {
                        flag = false;
                        return true;
                    }
                }, this);
            }
        }

        return flag;
    };


    var _isValidDateComponents = function Calendar$_isValidDateComponents(dc) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
            year = 0, month = 0, date = 0, hour = 0, min = 0, sec = 0;

        if($KU.is(dc, 'null')) {
            flag = true;
        } else if($KU.is(dc, 'array')) {
            if(dc.length === 3 || dc.length === 6) {
                if(dc.length === 3) {
                    dc.push(0, 0, 0);
                }

                if($K.F.EIWP) {
                    if($KU.is(dc[0], 'numeric')) {
                        dc[0] = parseInt(dc[0], 10);
                    }
                    if($KU.is(dc[1], 'numeric')) {
                        dc[1] = parseInt(dc[1], 10);
                    }
                    if($KU.is(dc[2], 'numeric')) {
                        dc[2] = parseInt(dc[2], 10);
                    }
                }

                year = $KU.is(dc[2], 'number') ? dc[2] : -1;
                month = $KU.is(dc[1], 'number') ? dc[1] : -1;
                date = $KU.is(dc[0], 'number') ? dc[0] : -1;
                hour = $KU.is(dc[3], 'number') ? dc[3] : -1;
                min = $KU.is(dc[4], 'number') ? dc[4] : -1;
                sec = $KU.is(dc[5], 'number') ? dc[5] : -1;

                if(year >= _minYear && year <= _maxYear
                && month >= 1 && month <= 12
                && date >= 1 && date <= 31
                && hour >= 0 && hour <= 23
                && min >= 0 && min <= 59
                && sec >= 0 && sec <= 59) {
                    if([4, 6, 9, 11].indexOf(month) >= 0 && date <= 30) {
                        flag = true;
                    } else if(month === 2) {
                        if($KU.is(year, 'leapyear') && date <= 29) {
                            flag = true;
                        } else if(date <= 28) {
                            flag = true;
                        }
                    } else {
                        flag = true;
                    }
                }
            }
        }

        if(!flag && $K.F.EIWP) {
            if($KU.is(dc, 'array') && $KU.is(dc[0], 'null')
            && $KU.is(dc[2], 'null') && $KU.is(dc[2], 'null')) {
                flag = [null, true];
            }
        }

        return flag;
    };


    var _maxDate = function Calendar$_maxDate(month, year) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, max = -1;

        if(month === 2) {
            max = $KU.is(year, 'leapyear') ? 29 : 28;
        } else if([4, 6, 9, 11].indexOf(month) >= 0) {
            max = 30;
        } else if([1, 3, 5, 7, 8, 10, 12].indexOf(month) >= 0) {
            max = 31;
        }

        return max;
    };


    //This functions will be called in the scope of widget instance
    var _nextMonth = function Calendar$_nextMonth(count) {
        var _ = this._kwebfw_, dm = _.displayedMonths[0], month = dm[0], year = dm[1];

        if(count >= 1 && count <= 12) {
            if(month >= 12) {
                year += 1;
                month = month - 12;
            }

            month += count;

            _changePicker.call(this, month, year);
        }
    };


    //This functions will be called in the scope of widget instance
    var _nextYear = function Calendar$_nextYear(count) {
        var _ = this._kwebfw_, dm = _.displayedMonths[0], month = dm[0], year = dm[1];

        if((year+count) <= _maxYear) {
            _changePicker.call(this, month, (year+count));
        }
    };


    //This functions will be called in the scope of widget instance
    var _onDateEdited = function Calendar$_onDateEdited(formattedDate) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, dates = null,
            _ = this._kwebfw_, prop = _.prop, valid = true;

        dates = _convertFormatedDateToDateComponents.call(this, formattedDate);

        if(!dates) {
            valid = false;
        } else if(prop.selectionType && !dates.length) {
            this.dateComponents = null;
            this.selectedDates = null;
        } else if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
            this.dateComponents = dates[0];
        } else {
            this.selectedDates = dates;
        }

        $KW.fire(this, 'onDone', this, {isValidDateSelected:valid});
    };


    //This functions will be called in the scope of widget instance
    var _openPicker = function Calendar$_openPicker() {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, picker = null,
            el = $KW.el(this), _ = this._kwebfw_, prop = _.prop,
            dc = prop.dateComponents, dm = _.displayedMonths[0], date = null,
            today = new Date(), selectedDates = _getAllSelectedDates.call(this),
            pickers = {};

        if(selectedDates.length > 0
        && prop.selectionType !== constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
            date = selectedDates[selectedDates.length-1];
            date = new Date(date[2], (date[1]-1), date[0], 0, 0, 0);
        } else if(dc && prop.selectionType === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
            date = new Date(dc[2], (dc[1]-1), dc[0], dc[3], dc[4], dc[5]);
        } else if(today.getMonth() === (dm[0]-1) && today.getFullYear() === dm[1]) {
            date = today;
        } else {
            date = new Date(dm[1], (dm[0]-1), 1, 0, 0, 0);
        }

        pickers = $KW.pickers(this);

        pickers[_.uid] = _.uid;
        picker = _.picker = _renderPicker.call(this, date);

        $KD.setAttr(el.icon, 'aria-expanded', 'true');
        _anchorPicker.call(this);

        date = _dateFormatter(date, false);
        date = $KD.find(picker, '[date="'+date+'"]')[0];

        if(!date) {
            date = new Date(_.displayedMonths[0][1], (_.displayedMonths[0][0]-1), 1, 0, 0, 0);
            date = $KD.find(picker, '[date="'+_dateFormatter(date, false)+'"]')[0];
        }

        $KD.focus(date); //NOTE:: After focus, position the picker
    };


    var _parseToDateComponent = function Calendar$_parseToDateComponent(str, format) {
        var dc = null, date = null, dt = '', mth = '',
            yr = '', hr = '00', min = '00', sec = '00',
            strip = function(value, pattern, lookfor) {
                var index = pattern.indexOf(lookfor);
                return (index !== -1) ? value.substr(index, lookfor.length) : '';
            };

        dt = strip(str, format, 'dd');
        mth = strip(str, format, 'MMM');
        if(!mth) mth = strip(str, format, 'MM');
        yr = strip(str, format, 'yyyy');
        if(!yr) yr = strip(str, format, 'yy');

        hr = strip(str, format, 'hh') || '00';
        min = strip(str, format, 'mm') || '00';
        sec = strip(str, format, 'ss') || '00';

        if(!dt || !mth || !yr) {
            dc = null;
        } else {
            date = new Date((yr+'-'+mth+'-'+dt+' '+hr+':'+min+':'+sec));

            if(isNaN(date.valueOf()) || date.toString() === 'Invalid Date') {
                dc = null;
            } else {
                dt = parseInt(dt, 10);
                mth = parseInt(mth, 10);
                yr = parseInt(yr, 10);
                hr = parseInt(hr, 10);
                min = parseInt(min, 10);
                sec = parseInt(sec, 10);

                date = _dateFormatter([dt, mth, yr, hr, min, sec], false, format);

                dc = (date === str) ? [dt, mth, yr, hr, min, sec] : null;
            }
        }

        return dc;
    };


    //This functions will be called in the scope of widget instance
    var _populateDisplayedMonths = function Calendar$_populateDisplayedMonths(month, year) {
        var _ = this._kwebfw_, prop = _.prop, noOfMonths = prop.noOfMonths, i = 0;

        noOfMonths = 1; //Until this feature is implemented, hard coding its value to 1
        _.displayedMonths.splice(0, _.displayedMonths.length); //Making it empty

        for(i=0; i<noOfMonths; i++) {
            _.displayedMonths.push([month, year]);

            month = (month + 1);

            if(month > 12) {
                month = 1;
                year = (year + 1);
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        Calendar: function Calendar$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Calendar', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Calendar', null);
                }
            }

            if(!_.anchor) $KU.defineProperty(_, 'anchor', {}, null);
            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }
            $KU.defineProperty(_, 'dateSelectionStarted', false, true);
            $KU.defineProperty(_, 'displayedMonths', [], false); //Must not be writable
            $KU.defineProperty(_, 'enableDateRangeEnd', null, true);
            $KU.defineProperty(_, 'enableDateRangeInactive', null, true);
            $KU.defineProperty(_, 'enableDateRangeSkin', '', true);
            $KU.defineProperty(_, 'enableDateRangeStart', null, true);
            $KU.defineProperty(_, 'enableDates', {}, true);
            $KU.defineProperty(_, 'enableDatesInactive', null, true);
            $KU.defineProperty(_, 'enableDatesSkin', {}, true);
            $KU.defineProperty(_, 'selectedDates', [], true);
            $KU.defineProperty(_, 'specialSkins', {}, true);
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        Calendar: function Calendar$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = this._kwebfw_, prop = _.prop;

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'slCalendar';
            }

            if($KU.is(prop.padding, 'null')) {
                prop.padding = [0, 0, 0, 0];
            }

            if(prop.i18n_toolTip) {
                prop.toolTip = prop.i18n_toolTip;
            }

            _updateRelatedDateProperties.call(this);
        }
    };


    //This function will be called in the scope of widget instance
    var _prepareDates = function Calendar$_prepareDates(month, year, startingDay) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, c = 0, prevYear = year,
            nextYear = year, prevMonth = (month-1), nextMonth = (month+1),
            currentMaxDate = -1, date = '', prevMaxDate = -1, dates = [],
            firstDay = -1, firstDiff = 0, nextDate = 1;

        if(month === 1) {
            prevMonth = 12;
            prevYear = (year - 1);
        } else if(month === 12) {
            nextMonth = 1;
            nextYear = (year + 1);
        }

        prevMaxDate = _maxDate(prevMonth, prevYear);
        currentMaxDate = _maxDate(month, year);

        if($KU.is(startingDay, 'string') && startingDay
        && Object.prototype.hasOwnProperty.call(_weekDays, startingDay)) {
            startingDay = _weekDays[startingDay];
        } else {
            startingDay = 0;
        }

        firstDay = new Date(year, (month-1), 1, 0, 0, 0);
        firstDay = firstDay.getDay();

        if(firstDay <= 6 && firstDay >= startingDay) {
            firstDiff = firstDay - startingDay;
        } else {
            firstDiff = 6 - startingDay + 1;
            firstDiff += firstDay;
        }

        for(c=0; c<42; c++) {
            if(c < firstDiff) {
                date = prevMaxDate - firstDiff + c + 1; //Add previous month dates in reverse
                date = [prevYear, prevMonth, date];
            } else if(c >= firstDiff && c <= (currentMaxDate + firstDiff)) {
                date = c - firstDiff + 1; //Add current month dates in forward

                if(date > currentMaxDate) {
                    date = nextDate++;
                    date = [nextYear, nextMonth, date];
                } else {
                    date = [year, month, date];
                }
            } else {
                date = nextDate++; //Add next month dates in forward
                date = [nextYear, nextMonth, date];
            }

            dates.push(date);
        }

        return dates;
    };


    //This function will be called in the scope of widget instance
    var _prepareDays = function Calendar$_prepareDays(startingDay) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, c = 0, days = [];

        if($KU.is(startingDay, 'string') && startingDay
        && Object.prototype.hasOwnProperty.call(_weekDays, startingDay)) {
            startingDay = _weekDays[startingDay];
        } else {
            startingDay = 0;
        }

        for(c=startingDay; c<7; c++) {
            days.push(c);
        }

        for(c=0; c<startingDay; c++) {
            days.days(c);
        }

        return days;
    };


    //This functions will be called in the scope of widget instance
    var _prevMonth = function Calendar$_prevMonth(count) {
        var _ = this._kwebfw_, dm = _.displayedMonths[0], month = dm[0], year = dm[1];

        if(count >= 1 && count <= 12) {
            month -= count;

            if(month <= 0) {
                year -= 1;
                month = 12 - month;
            }

            _changePicker.call(this, month, year);
        }
    };


    //This functions will be called in the scope of widget instance
    var _prevYear = function Calendar$_prevYear(count) {
        var _ = this._kwebfw_, dm = _.displayedMonths[0], month = dm[0], year = dm[1];

        if((year-count) >= _minYear) {
            _changePicker.call(this, month, (year-count));
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        Calendar: function Calendar$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        Calendar: function Calendar$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //This function will be called in the scope of widget instance
    var _renderAction = function Calendar$_renderAction() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom,
            action = $KD.create('DIV', {kr:'actions'});

        //

        return action;
    };


    //This function will be called in the scope of widget instance
    var _renderCalendar = function Calendar$_renderCalendar(month, year, date) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, calendar = null, size = null, calheight = 0,
            _ = this._kwebfw_, prop = _.prop, viewConfig = prop.viewConfig,
            gridConfig = (viewConfig && viewConfig.gridConfig) ? viewConfig.gridConfig : {};

        size = _deduceCellHeightAndWidth.call(this);
        if(prop.gridTheme === voltmx.calendar.LEGACY) {
            calheight = ((size.height * 6) + 41 + 40 + 19) + 'px';
        } else if($K.behavior[constants.API_LEVEL] >= constants.API_LEVEL_9200
        || $K.behavior.calendarMonthYearSelectionDropdownView) {/* grid *//* header *//* weekdays */
            calheight = ((size.height * 6) + 44 + 22) + 'px';
        } else {
            calheight = ((size.height * 6) + 38 + 22) + 'px';
        }

        //Extra height for apply and close buttons in calendar for modern theme
        if(prop.gridTheme === voltmx.calendar.MODERN
        && prop.selectionType !== constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
            calheight = parseInt(calheight) + 20 + 'px';
        }

        calendar = $KD.create('DIV', {kr:'calendar'}, {
            position: 'relative',
            top: '0px', left: '0px',
            height: calheight,
            width: ((size.width * 7) + 'px')
        });

        $KD.addCls(calendar, (gridConfig.gridSkin || '-voltmx-calendar-grid'));
        $KD.add(calendar, _renderHeader.call(this, month, year));
        $KD.add(calendar, _renderDays.call(this, _startDay));
        $KD.add(calendar, _renderDates.call(this, month, year, _startDay, _weekends));
        if(prop.gridTheme === voltmx.calendar.LEGACY
        || prop.selectionType !== constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
            $KD.add(calendar, _renderFooter.call(this, date));
        }

        return calendar;
    };


    //This function will be called in the scope of widget instance
    var _renderDates = function Calendar$_renderDates(month, year, startingDay/*, weekends*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, grid = null,
            row = null, tpl = null, size = _deduceCellHeightAndWidth.call(this),
            dates = _prepareDates.call(this, month, year, startingDay);

        grid = $KD.create('DIV', {role:'grid'});
        row = $KD.create('DIV', {kr:'dates', role:'row'});

        $KU.each(dates, function(date) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, info = null,
                dt = '', cell = $KD.create('DIV', {
                    kr: 'date', role: 'gridcell'
                }, {
                    height:(size.height+'px'),
                    width:(size.width+'px')
                });

            info = _cellRenderInfo.call(this, date[2], date[1], date[0], month, year);

            dt = '<label';
            if(!(date[1] === month && date[0] === year)
            && this.hidePreviousNextMonthDates) {
                dt += ' hidden';
            }
            dt += ' class="-voltmx-ca-';
            dt += this.dayTextAlignmentInCell;
            dt += ('">' + info.text + '</label>');

            tpl = _renderTemplate.call(this, date);

            $KD.setAttr(cell, 'aria-label',
                (new Date(date[0], (date[1]-1), date[2], 0, 0, 0).toDateString())
            );
            if(info.today) $KD.setAttr(cell, 'aria-current', 'date');
            if(info.disabled) $KD.setAttr(cell, 'aria-disabled', true);
            if(info.selected) $KD.setAttr(cell, 'aria-selected', true);

            date = _dateFormatter([date[2], date[1], date[0]], false);
            $KD.setAttr(cell, 'date', date);
            $KD.setAttr(cell, 'cellskintype', info.skinType);
            $KD.setAttr(cell, 'cellskinvalue', info.skin);
            $KD.setAttr(cell, 'cellselectedskin', info.selectedSkin);
            $KD.setAttr(cell, 'tabindex', 0);
            $KD.setAttr(cell, 'kwh-click', 'onDateClick');
            $KD.setAttr(cell, 'kwh-focusin', 'onDateFocus');
            $KD.setAttr(cell, 'kwh-keydown', 'onDateKeyDown,dismissPicker,dateNavigation');
            $KD.setAttr(cell, 'kwh-keyup', 'onDateKeyUp');
            $KD.setAttr(cell, 'kwh-focusout', 'onFocusOut');

            dt && $KD.html(cell, dt);
            tpl && $KD.add(cell, tpl);
            $KD.addCls(cell, info.appliedSkin);
            $KD.add(row, cell);
        }, this);

        $KD.add(row, $KD.create('DIV', {class:'-voltmx-clear'}));
        $KD.add(grid, row);

        return grid;
    };


    //This function will be called in the scope of widget instance
    var _renderDays = function Calendar$_renderDays(startingDay/*, weekends*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            _ = this._kwebfw_, prop = _.prop, days = null,
            wrapper = null, size = null;

        days = _prepareDays.call(this, startingDay);
        size = _deduceCellHeightAndWidth.call(this);
        wrapper = $KD.create('DIV', {kr:'weekdays'});

        $KU.each(days, function(day) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom,
                cell = $KD.create('LABEL', {
                    kr: 'day', day: day
                }, {
                    width: (size.width+'px'),
                    textAlign: 'center'
                });

            //$KD.addCls(cell, 'textAlign', ('-voltmx-ca-'+this.dayTextAlignmentInCell));
            $KD.html(cell, _days[day].toUpperCase());
            $KD.add(wrapper, cell);
        }, this);

        $KD.add(wrapper, $KD.create('DIV', {class:'-voltmx-clear'}));

        if(prop.hideDaysHeader) {
            $KD.style(wrapper, 'visibility', 'hidden');
        }

        return wrapper;
    };


    //This function will be called in the scope of widget instance
    var _renderFooter = function Calendar$_renderFooter(/*date*/) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_,
            config = _.prop.viewConfig ? _.prop.viewConfig.gridConfig : null, footer = null,
            html = '', row = null, left = null, apply = null, close = null;

        footer = $KD.create('DIV', {kr:'footer'}, {
            display:'table', width:'100%', height:'20px', tableLayout:'auto'
        });

        row = $KD.create('DIV', {}, {display:'table-row'});
        left = $KD.create('DIV', {}, {display:'table-cell', verticalAlign:'middle', width:'100%'});
        $KD.add(row, left);

        if(this.selectionType !== constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
            apply = $KD.create('DIV', {}, {display:'table-cell', verticalAlign:'middle'});
            html = '<input type="button" value="Apply"';
            if(config && config.doneButtonSkin) {
                html += (' class="'+config.doneButtonSkin+'"');
            }
            html +=' kr="apply" kwh-click="onApplyClick" kwh-keydown="dismissPicker"/>';
            $KD.html(apply, html); $KD.add(row, apply);
        }

        close = $KD.create('DIV', {}, {display:'table-cell', verticalAlign:'middle'});
        html = '<input type="button" value="Close"';
        if(config && config.cancelButtonSkin) {
            html += (' class="'+config.cancelButtonSkin+'"');
        }
        html += ' kr="close" kwh-click="onCloseClick" kwh-keydown="dismissPicker"/>';
        $KD.html(close, html); $KD.add(row, close);

        $KD.add(footer, row);

        return footer;
    };


    //This function will be called in the scope of widget instance
    var _renderHeader = function Calendar$_renderHeader(month, year) {
        var $K = voltmx.$kwebfw$, header = null;

        if($K.behavior[constants.API_LEVEL] >= constants.API_LEVEL_9200
        || $K.behavior.calendarMonthYearSelectionDropdownView) {
            header = _renderMonthYearDropDownHeader.call(this, month, year);
        } else {
            header = _renderMonthYearPopupHeader.call(this, month, year);
        }

        return header;
    };


    //This function will be called in the scope of widget instance
    var _renderMonthYearDropDownHeader = function Calendar$_renderMonthYearDropDownHeader(month, year) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, header = null, _ = this._kwebfw_,
            prop = _.prop, viewConfig = prop.viewConfig ? prop.viewConfig.gridConfig : null,
            row = null, prevMonthCell = null, nextMonthCell = null, prevMonthSrc = '',
            nextMonthSrc = '', monthHolder = null, yearHolder = null, selectedSkin = '-voltmx-calendar-cell-selected',
            hoverSkin = '-voltmx-calendar-cell-hover', headerSkin = '-voltmx-calendar-header',
            _generateYearsArray = function(start, end, step) {
                var i = null, years = [];

                for(i=start; i<=end; i+= step) {
                    years.push(i.toString());
                }

                return years;
            };

        if(viewConfig) {
            selectedSkin = viewConfig.gridMonthYearSelectedSkin || '-voltmx-calendar-cell-selected';
            hoverSkin = viewConfig.gridMonthYearHoverSkin || '-voltmx-calendar-cell-hover';
        }

        header = $KD.create('DIV', {kr:'header'}, {
            width:'100%'
        });
        if(prop.gridTheme === voltmx.calendar.MODERN) {
            prevMonthSrc = (viewConfig && viewConfig.leftNavigationImage)
                ? viewConfig.leftNavigationImage : 'leftnav.png';
            nextMonthSrc = (viewConfig && viewConfig.rightNavigationImage)
                ? viewConfig.rightNavigationImage : 'rightnav.png';
            headerSkin = (viewConfig && viewConfig.headerSkin)
                ? viewConfig.headerSkin : '-voltmx-calendar-header';
            $KD.addCls(header, headerSkin);
        } else {
            prevMonthSrc = (viewConfig && viewConfig.leftNavigationImage)
                ? viewConfig.leftNavigationImage : 'kwebfw-prev-month.png';
            nextMonthSrc = (viewConfig && viewConfig.rightNavigationImage)
                ? viewConfig.rightNavigationImage : 'kwebfw-next-month.png';
        }

        row = $KD.create('DIV', {}, {display:'flex', width:'100%'});
        prevMonthCell = $KD.create('DIV', {tabindex:0}, {width:'20px', marginRight: 'auto'});
        nextMonthCell = $KD.create('DIV', {tabindex:0}, {width:'20px', marginLeft: 'auto'});
        monthHolder = $KD.create('DIV', {tabindex:0, kr:'month'}, {height:'24px', width:'85px', position:'relative', marginLeft:'0px', marginRight:'5px'});
        yearHolder = $KD.create('DIV', {tabindex:0, kr:'year'}, {height:'24px', width:'55px', position:'relative', marginLeft:'5px', marginRight:'0px'});

        $KD.setAttr(prevMonthCell, 'kwh-click', 'onPrevMonthClick');
        $KD.setAttr(prevMonthCell, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(monthHolder, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(yearHolder, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(prevMonthCell, 'kwh-keydown', 'dismissPicker');
        $KD.setAttr(nextMonthCell, 'kwh-click', 'onNextMonthClick');
        $KD.setAttr(nextMonthCell, 'kwh-focusout', 'onFocusOut');

        _.monthDropdown = new $K.plugins.DropDown(_months.slice(1),
            {
                focusOutInstance: true,
                focusSkin: '',
                hoverSkin: hoverSkin,
                selectedSkin: selectedSkin,
                renderTo: monthHolder,
                position:$K.constants.POSITION_BOTTOM, selectedOption:_months[month], height: '150px',
                callback: function(selectedOption) {
                    _renderSelectedMonthYear.call(this, selectedOption);
                }.bind(this)
            });
        _.yearDropdown = new $K.plugins.DropDown(_generateYearsArray.call(this, _minYear, _maxYear, 1),
            {
                focusOutInstance: true,
                focusSkin: '',
                hoverSkin: hoverSkin,
                selectedSkin: selectedSkin,
                renderTo: yearHolder,
                position:$K.constants.POSITION_BOTTOM, selectedOption:year.toString(), height: '150px',
                callback: function(selectedOption) {
                    _renderSelectedMonthYear.call(this, selectedOption);
                }.bind(this)
            });

        $KD.html(prevMonthCell, (
            '<img loading="lazy" onmousedown="return false;"'
            +' src="'+$KU.getImageURL(prevMonthSrc)+'"'
            +'style="height:16px; position:relative; left:8px; top:3px;"/>'
        ));
        $KD.html(nextMonthCell, (
            '<img loading="lazy" onmousedown="return false;"'
            +' src="'+$KU.getImageURL(nextMonthSrc)+'"'
            +'style="height:16px; position:relative; right:4px; top:3px;"/>'
        ));

        $KD.add(row, prevMonthCell);
        $KD.add(row, monthHolder);
        $KD.add(row, yearHolder);
        $KD.add(row, nextMonthCell);
        if(prop.hideMonthsHeader) {
            $KD.style(monthHolder, 'visibility', 'hidden');
            $KD.style(yearHolder, 'visibility', 'hidden');
        }

        $KD.add(header, row);

        return header;
    };


    //This function will be called in the scope of widget instance
    var _renderMonthYearPopupHeader = function Calendar$_renderMonthYearPopHeader(month, year) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, header = null, _ = this._kwebfw_,
            prop = _.prop, viewConfig = prop.viewConfig ? prop.viewConfig.gridConfig : null,
            html = '', row = null, prevYearCell = null, prevMonthCell = null,
            labelCell = null, nextMonthCell = null, nextYearCell = null,
            prevYearSrc = '', prevMonthSrc = '', nextMonthSrc = '',
            nextYearSrc = '', headerSkin = '-voltmx-calendar-header';

        header = $KD.create('DIV', {kr:'header'}, {
            width:'100%'
        });
        if(prop.gridTheme === voltmx.calendar.MODERN) {
            prevYearSrc = (viewConfig && viewConfig.leftNavigationImage)
                ? viewConfig.leftNavigationImage : 'leftnav.png';
            prevMonthSrc = (viewConfig && viewConfig.leftNavigationImage)
                ? viewConfig.leftNavigationImage : 'leftnav.png';
            nextMonthSrc = (viewConfig && viewConfig.rightNavigationImage)
                ? viewConfig.rightNavigationImage : 'rightnav.png';
            nextYearSrc = (viewConfig && viewConfig.rightNavigationImage)
                ? viewConfig.rightNavigationImage : 'rightnav.png';
            headerSkin = (viewConfig && viewConfig.headerSkin)
                ? viewConfig.headerSkin : '-voltmx-calendar-header';
            $KD.addCls(header, headerSkin);
        } else {
            prevYearSrc = (viewConfig && viewConfig.leftNavigationImage)
                ? viewConfig.leftNavigationImage : 'kwebfw-prev-month.png';
            prevMonthSrc = (viewConfig && viewConfig.leftNavigationImage)
                ? viewConfig.leftNavigationImage : 'kwebfw-prev-month.png';
            nextMonthSrc = (viewConfig && viewConfig.rightNavigationImage)
                ? viewConfig.rightNavigationImage : 'kwebfw-next-month.png';
            nextYearSrc = (viewConfig && viewConfig.rightNavigationImage)
                ? viewConfig.rightNavigationImage : 'kwebfw-next-month.png';
        }

        row = $KD.create('DIV', {}, {display:'flex'});
        prevYearCell = $KD.create('DIV', {tabindex:0}, {display:'flex', width:'30px'});
        prevMonthCell = $KD.create('DIV', {tabindex:0}, {width:'20px'});
        labelCell = $KD.create('DIV', {tabindex:0}, {flex:1});
        nextMonthCell = $KD.create('DIV', {tabindex:0, align:'right'}, {width:'20px'});
        nextYearCell = $KD.create('DIV', {tabindex:0}, {display:'flex', width:'30px'});

        $KD.setAttr(prevYearCell, 'kwh-click', 'onPrevYearClick');
        $KD.setAttr(prevYearCell, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(prevYearCell, 'kwh-keydown', 'dismissPicker');
        $KD.setAttr(prevMonthCell, 'kwh-click', 'onPrevMonthClick');
        $KD.setAttr(prevMonthCell, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(prevMonthCell, 'kwh-keydown', 'dismissPicker');
        $KD.setAttr(nextMonthCell, 'kwh-click', 'onNextMonthClick');
        $KD.setAttr(nextMonthCell, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(nextMonthCell, 'kwh-keydown', 'dismissPicker');
        $KD.setAttr(nextYearCell, 'kwh-click', 'onNextYearClick');
        $KD.setAttr(nextYearCell, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(nextYearCell, 'kwh-keydown', 'dismissPicker');
        $KD.setAttr(labelCell, 'kwh-click', 'onMonthYearClick');
        $KD.setAttr(labelCell, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(labelCell, 'kwh-keydown', 'dismissPicker');

        $KD.html(prevYearCell, (
            '<img loading="lazy" onmousedown="return false;"'
            +' src="'+$KU.getImageURL(prevYearSrc)+'"'
            +' style="height:15px; position:relative; left:8px;"/>'
            +'<img onmousedown="return false;" src="'+$KU.getImageURL(prevYearSrc)+'"'
            +' style="height:15px; position:relative; left:-1px;"/>'
        ));
        $KD.html(prevMonthCell, (
            '<img loading="lazy" onmousedown="return false;"'
            +' src="'+$KU.getImageURL(prevMonthSrc)+'"'
            +' style="height:15px; position:relative; left:5px;"/>'
        ));
        $KD.html(nextMonthCell, (
            '<img loading="lazy" onmousedown="return false;"'
            +' src="'+$KU.getImageURL(nextMonthSrc)+'"'
            +' style="height:15px; position:relative; right:5px;"/>'
        ));
        $KD.html(nextYearCell, (
            '<img loading="lazy" onmousedown="return false;"'
            +' src="'+$KU.getImageURL(nextYearSrc)+'"'
            +' style="height:15px; position:relative; right:-1px;"/>'
            +'<img loading="lazy" onmousedown="return false;" src="'+$KU.getImageURL(nextYearSrc)+'"'
            +' style="height:15px; position:relative; right:8px;"/>'
        ));

        html = '<div style="text-align:center;">';
        html += '<label kr="month" tabindex="0" aria-live="polite"';
        html += ' kwh-keydown="dismissPicker,monthNavigation">';
        html += _months[month]+'</label>';
        html += ', ';
        html += '<label kr="year" tabindex="0" aria-live="polite"';
        html += ' kwh-keydown="dismissPicker,yearNavigation">';
        html += year+'</label>';
        html += '</div>';
        $KD.html(labelCell, html);

        $KD.add(row, prevYearCell);
        $KD.add(row, prevMonthCell);
        $KD.add(row, labelCell);
        $KD.add(row, nextMonthCell);
        $KD.add(row, nextYearCell);
        if(prop.hideMonthsHeader) {
            $KD.style(labelCell, 'visibility', 'hidden');
        }

        $KD.add(header, row);

        return header;
    };

    var _renderSelectedMonthYear = function Calendar$_renderSelectedMonthYear(selectedOption) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_, displayedMonths = _.displayedMonths[0],
            selectedMonth = null, selectedYear = null, picker = null, focusItem = null,
            focusElement = null;

        if(_months.indexOf(selectedOption) > -1) {
            selectedMonth = _months.indexOf(selectedOption);
            selectedYear = displayedMonths[1];
            focusItem = '[kr="month"]';
        } else {
            selectedMonth = displayedMonths[0];
            selectedYear = parseInt(selectedOption);
            focusItem = '[kr="year"]';
        }
        _changePicker.call(this, selectedMonth, selectedYear);
        picker = _.picker;
        focusElement = $KD.find(picker, focusItem)[0];
        focusElement && $KD.focus(focusElement);
    };


    //This function will be called in the scope of widget instance
    var _renderPicker = function Calendar$_renderPicker(date) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            _ = this._kwebfw_, prop = _.prop, uid = _.uid, title = null, holder = null,
            picker = null, size = null, calheight = '';

        size = _deduceCellHeightAndWidth.call(this);

        if(prop.gridTheme === voltmx.calendar.LEGACY) {/*grid*//* header *//* weekdays *//*footer*//*unknown*/
            calheight = ((size.height * 6) + 41 + 16 + 40 - 3) + 'px';
        } else if($K.behavior[constants.API_LEVEL] >= constants.API_LEVEL_9200
        || $K.behavior.calendarMonthYearSelectionDropdownView) {/*grid*//* header *//* weekdays */
            calheight = ((size.height * 6) + 44 + 22) + 'px';
        } else {
            calheight = ((size.height * 6) + 38 + 22) + 'px';
        }

        //Extra height for apply and close buttons in calendar for modern theme
        if(prop.gridTheme === voltmx.calendar.MODERN
        && prop.selectionType !== constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
            calheight = parseInt(calheight) + 20 + 'px';
        }

        //Extra height for title
        if(prop.titleOnPopup) {
            calheight = parseInt(calheight) + 15 + 'px';
        }

        picker = $KD.create('DIV', {
            id:(uid+'_picker'), kwf:uid,
            theme: this.gridTheme, role: 'dialog',
            tabindex: -1
        }, {
            display: 'block',
            zIndex: 2147483647,
            position: 'absolute',
            height: calheight,
            width: ((size.width * 7) + 'px')
        });

        title = $KD.create('DIV', {kr:'title'});
        $KD.text(title, this._kwebfw_.prop.titleOnPopup);
        $KD.setAttr(picker, 'kwh-focusout', 'onFocusOut');

        holder = $KD.create('DIV');

        $KU.each(_.displayedMonths, function(dm) {
            $KD.add(holder, _renderCalendar.call(this, dm[0], dm[1], date));
        }, this);

        if(!($K.behavior[constants.API_LEVEL] >= constants.API_LEVEL_9200
        || $K.behavior.calendarMonthYearSelectionDropdownView)) {
            $KD.add(holder, _renderMonthYear.call(this));
        }

        $KD.add(picker, title);
        $KD.add(picker, holder);
        $KD.add(picker, _renderAction.call(this));

        return picker;
    };


    var _renderMonthYear = function() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_,
            prop = _.prop, viewConfig = prop.viewConfig ? prop.viewConfig.gridConfig : null,
            headerBlock, navigatorBlock, yearsBlock, monthBlock, MonthYearPicker, size, calheight = 0;

        size = _deduceCellHeightAndWidth.call(this);

        if(prop.gridTheme === voltmx.calendar.LEGACY) {// -10px is to balance height with extra height because of header padding
            calheight = ((size.height * 6) + 41 + 40 + 19 - 10) + 'px';
        } else {
            calheight = ((size.height * 6) + 38 + 22 - 10) + 'px';
        }

        MonthYearPicker = $KD.create('DIV', {
            kr : 'monthYearPicker',
            tabindex : 0,
            hidden : true
        }, {
            width: ((size.width * 7) + 'px'),
            height: calheight,
            top: '0px', left: '0px',
            position: 'relative',
            backgroundColor: 'White'
        });

        $KD.setAttr(MonthYearPicker, 'kwh-focusout', 'onFocusOut');
        $KD.addCls(MonthYearPicker, ((viewConfig && viewConfig.gridSkin) ? viewConfig.gridSkin : '-voltmx-calendar-grid'));

        //navigator header containing OK image, cancel image and selected year, month display box
        headerBlock = _getMonthYearHeader.call(this);

        //displayMonths
        monthBlock = _getMonths.call(this);

        //display years navigation arrows
        navigatorBlock = _getYearNavigation.call(this);

        //Years to be displayed
        yearsBlock = _getYears.call(this);

        $KD.add(MonthYearPicker, headerBlock);
        $KD.add(MonthYearPicker, monthBlock);
        $KD.add(MonthYearPicker, navigatorBlock);
        $KD.add(MonthYearPicker, yearsBlock);

        ///year wrapper end + navigator teamplate wrapper end
        return MonthYearPicker;
    };


    //This function will be called in the scope of widget instance
    var _renderTemplate = function Calendar$_renderTemplate(date) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            $KW = $K.widget, cellData = null, view = null, formattedDate = '',
            _ = this._kwebfw_, prop = _.prop, tpl = null, template = null;

        if(prop.data && prop.widgetDataMapForCell) {
            formattedDate = _dateFormatter([date[2], date[1], date[0]], false, 'dd/MM/yyyy');
            cellData = prop.data[formattedDate];

            if(cellData) {
                tpl = cellData.template || prop.cellTemplate;

                if($KU.is(tpl, 'string')) {
                    $K.app.allowSetter_voltmxControllerName = true;
                    tpl = _voltmx.mvc.initializeSubViewController(tpl);
                    delete $K.app.allowSetter_voltmxControllerName;

                    if($KU.is(tpl, 'widget', 'FlexContainer')) {
                        tpl._kwebfw_.is.template = true;
                        $KW.root(tpl, 'template');
                    }
                }

                template = $KW.cloneTemplate(tpl, cellData, prop.widgetDataMapForCell);
                view = template._render();
                $KD.style(view, {position:'absolute', top: '0px', left:'0px'});
            }
        }

        return view;
    };


    //This function will be called in the scope of widget instance
    var _selectDateFromPicker = function Calendar$_selectDateFromPicker(cell) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, prevSkinInfo = null, fdate = null,
            tdate = null, date = $KD.getAttr(cell, 'date').split('-'), pos = -1, prevCell = null,
            _ = this._kwebfw_, currentSkinInfo = _getSkinRelatedSkinInfoByGridCell(cell);

        date = [parseInt(date[2], 10), parseInt(date[1], 10), parseInt(date[0], 10)];

        if(this.selectionType === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
            prevCell = _.prop.dateComponents;
            _.prop.dateComponents = [date[0], date[1], date[2], 0, 0, 0];
            _.prop.displayedMonth = null;

            //Deselect previously selected cell in UI
            if(prevCell) {
                prevCell = _dateFormatter(prevCell, false);
                prevCell = $KD.find(_.picker, '[date="'+prevCell+'"]')[0];
                if(prevCell) {
                    $KD.removeAttr(prevCell, 'aria-selected');
                    prevSkinInfo = _getSkinRelatedSkinInfoByGridCell(prevCell);

                    if(prevSkinInfo.selectedIndex < prevSkinInfo.normalIndex) {
                        $KD.removeCls(prevCell, prevSkinInfo.selectedValue);
                        $KD.addCls(prevCell, prevSkinInfo.normalValue);
                    }
                }
            }

            $KD.setAttr(cell, 'aria-selected', true);

            if(currentSkinInfo.selectedIndex < currentSkinInfo.normalIndex) {
                $KD.removeCls(cell, currentSkinInfo.normalValue);
                $KD.addCls(cell, currentSkinInfo.selectedValue);
            }

            _closePicker.call(this, true);
            _updateRelatedDateProperties.call(this);
        } else if(this.selectionType === constants.CALENDAR_SELECTION_TYPE_MULTI_SELECT) {
            if(_.dateSelectionStarted === false) {
                _.dateSelectionStarted = true;
                _.selectedDates = this.selectedDates || [];
            }

            $KU.each(_.selectedDates, function(dc, index) {
                if(dc[0] === date[0] && dc[1] === date[1] && dc[2] === date[2]) {
                    pos = index;
                    return true;
                }
            });

            if(pos !== -1) {
                _.selectedDates.splice(pos, 1);
                $KD.removeAttr(cell, 'aria-selected');

                if(currentSkinInfo.selectedIndex < currentSkinInfo.normalIndex) {
                    $KD.removeCls(cell, currentSkinInfo.selectedValue);
                    $KD.addCls(cell, currentSkinInfo.normalValue);
                }
            } else {
                _.selectedDates.push([date[0], date[1], date[2], 0, 0, 0]);
                $KD.setAttr(cell, 'aria-selected', true);

                if(currentSkinInfo.selectedIndex < currentSkinInfo.normalIndex) {
                    $KD.removeCls(cell, currentSkinInfo.normalValue);
                    $KD.addCls(cell, currentSkinInfo.selectedValue);
                }
            }
        } else if(this.selectionType === constants.CALENDAR_SELECTION_TYPE_RANGE_SELECT) {
            if(_.dateSelectionStarted === false) {
                _.dateSelectionStarted = true;
                _.selectedDates = this.selectedDates || [];
            }

            if(_.selectedDates[0] && _.selectedDates[1]) {
                //Deselect every cell in UI
                _toggleRangeOfCells(
                    _.picker, _.selectedDates[0],
                    _.selectedDates[1], false
                );

                _.selectedDates = [[date[0], date[1], date[2], 0, 0, 0]];

                //Select only this cell in UI
                $KD.setAttr(cell, 'aria-selected', true);
                if(currentSkinInfo.selectedIndex < currentSkinInfo.normalIndex) {
                    $KD.removeCls(cell, currentSkinInfo.normalValue);
                    $KD.addCls(cell, currentSkinInfo.selectedValue);
                }
            } else if(!_.selectedDates[0] && !_.selectedDates[1]) {
                _.selectedDates = [[date[0], date[1], date[2], 0, 0, 0]];

                //Select only this cell in UI
                $KD.setAttr(cell, 'aria-selected', true);
                if(currentSkinInfo.selectedIndex < currentSkinInfo.normalIndex) {
                    $KD.removeCls(cell, currentSkinInfo.normalValue);
                    $KD.addCls(cell, currentSkinInfo.selectedValue);
                }
            } else if(_.selectedDates[0] && !_.selectedDates[1]) {
                _.selectedDates[1] = [date[0], date[1], date[2], 0, 0, 0];

                fdate = new Date(_.selectedDates[0][2], (_.selectedDates[0][1] - 1), _.selectedDates[0][0], 0, 0, 0);
                tdate = new Date(_.selectedDates[1][2], (_.selectedDates[1][1] - 1), _.selectedDates[1][0], 0, 0, 0);

                if($KU.is(fdate, 'equals', tdate)) {
                    _.selectedDates = [];
                } else if(fdate > tdate) {
                    _.selectedDates = [_.selectedDates[1], _.selectedDates[0]];
                }

                if(_.selectedDates.length === 0) { //Deselect every cell in UI
                    _toggleRangeOfCells(
                        _.picker, [date[0], date[1], date[2], 0, 0, 0],
                        [date[0], date[1], date[2], 0, 0, 0], false
                    );
                } else { //Select every cell in range
                    _toggleRangeOfCells(
                        _.picker, _.selectedDates[0],
                        _.selectedDates[1], true
                    );
                }
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        Calendar: {
            dateComponents: function Calendar$_setter_dateComponents(/*old*/) {
                var _ = this._kwebfw_, prop = _.prop, dc = prop.dateComponents;

                if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
                    prop.displayedMonth = (dc) ? [dc[1], dc[2]] : null;
                }

                _updateRelatedDateProperties.call(this);
            },

            displayedMonth: function Calendar$_setter_displayedMonth(/*old*/) {
                var dm = _deduceDisplayedMonth.call(this);

                _populateDisplayedMonths.call(this, dm[0], dm[1]);
            },

            selectedDates: function Calendar$_setter_selectedDates(/*old*/) {
                var _ = this._kwebfw_, prop = _.prop, sd = prop.selectedDates;

                if(prop.selectionType !== constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
                    if(sd && sd.length) {
                        sd = sd[(sd.length-1)];
                        prop.displayedMonth = [sd[1], sd[2]];
                    } else {
                        prop.displayedMonth = null;
                    }
                }

                _updateRelatedDateProperties.call(this);
            },

            selectionType: function Calendar$_setter_selectionType(old) {
                if(old === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
                    this._kwebfw_.prop.dateComponents = null;
                } else {
                    this._kwebfw_.prop.selectedDates = null;
                }

                _updateRelatedDateProperties.call(this);
            },

            toolTip: function Calendar$_setter_toolTip(/*old*/) {
                this._kwebfw_.prop.i18n_toolTip = '';
            }
        }
    };


    var _showMonthYearPicker = function() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, labelCell,
            monthBlock, _ = this._kwebfw_, picker = _.picker, cal, py, cy,
            dm = _.displayedMonths[0], yearBlock = null,
            monthYearPicker = $KD.find(picker, '[kr="monthYearPicker"]')[0],
            // On Click of Month or Year Picker, getting month, year values and setting the title value
            month = _months[dm[0]], year= dm[1],
            title = $KD.find(monthYearPicker, '[kr="title"]')[0];

        $KD.setAttr(title, 'titleyear', year);
        $KD.setAttr(title, 'titlemonth', month);


        yearBlock = $KD.find(monthYearPicker, '[kr="years"]')[0];
        monthBlock = $KD.find(monthYearPicker, '[kr="months"]')[0];
        labelCell = $KD.find(monthYearPicker, '[kr="title"]')[0];
        py = Number($KD.getAttr(($KD.find(yearBlock, '[kr="year"]')[0]), 'year'));
        cy = _getCounter(dm[1]);

        if(py !== cy) {
            $KD.remove(yearBlock);
            yearBlock = _getYears.call(this, cy);
            $KD.add(monthYearPicker, yearBlock);
        }

        // loop through month and year block and apply selected month and year skin default
        $KU.each($KD.children(yearBlock), function(block) {
            $KU.each($KD.children(block), function(cell) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    year = this._kwebfw_.prop.year + '';

                if($KD.getAttr(cell, 'year') === year) {
                    _applySkinSelectedCell(cell);
                }
            }, this);
        }, this);

        $KU.each($KD.children(monthBlock), function(block) {
            $KU.each($KD.children(block), function(cell) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    month = _months[this._kwebfw_.prop.month];

                if($KD.getAttr(cell, 'month') === month) {
                    _applySkinSelectedCell(cell);
                }
            }, this);
        }, this);

        _updateMonthYearHeaderLabel.call(this, labelCell);

        cal = $KD.find(picker, '[kr="calendar"]')[0];
        $KD.setAttr(monthYearPicker, 'hidden', false);
        $KD.setAttr(cal, 'hidden', true);
        $KD.focus(monthYearPicker);

        _selectMonthYear(monthYearPicker, '[month="'+month+'"]');
        _selectMonthYear(monthYearPicker, '[year="'+year+'"]');
        $KD.html(title, (month || '') + ' ' + (year || ''));
    };

    var _selectMonthYear = function Calendar$_selectMonthYear(picker, selector) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, selectedDiv;

        selectedDiv=$KD.find(picker, selector)[0];

        if(selectedDiv) {
            currentSkinInfo = _getSkinRelatedSkinInfoByGridCell(selectedDiv);
            $KD.setAttr(selectedDiv, 'aria-selected', true);
            $KD.removeCls(selectedDiv, currentSkinInfo.normalValue);
            $KD.addCls(selectedDiv, currentSkinInfo.selectedValue);
            $KD.focus(selectedDiv);
        }
    };

    var _toggleRangeOfCells = function Calendar$_toggleRangeOfCells(picker, from, to, select) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, fstr = '', fdate = null,
            tdate = null, skinInfo = null, ndate = null, nstr = '', ncell = null;

        if($KU.is(from, 'array')) {
            fdate = new Date(from[2], (from[1] - 1), from[0], 0, 0, 0);
        }
        if($KU.is(to, 'array')) {
            tdate = new Date(to[2], (to[1] - 1), to[0], 0, 0, 0);
        }

        fstr = _dateFormatter(fdate, false);
        ndate = fdate; nstr = fstr;

        while(ndate >= fdate && ndate <= tdate) {
            ncell = $KD.find(picker, '[date="'+nstr+'"]')[0];

            if(ncell) {
                if(select) {
                    $KD.setAttr(ncell, 'aria-selected', true);
                } else {
                    $KD.removeAttr(ncell, 'aria-selected');
                }
                skinInfo = _getSkinRelatedSkinInfoByGridCell(ncell);

                if(skinInfo.selectedIndex < skinInfo.normalIndex) {
                    if(select) {
                        $KD.removeCls(ncell, skinInfo.normalValue);
                        $KD.addCls(ncell, skinInfo.selectedValue);
                    } else {
                        $KD.removeCls(ncell, skinInfo.selectedValue);
                        $KD.addCls(ncell, skinInfo.normalValue);
                    }
                }
            }

            ndate = new Date((ndate.getTime() + (24*60*60*1000)));
            nstr = _dateFormatter(ndate, false);
        }
    };


    var _showNextYearSet = function() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom,
            counter, yearsEl, yearBlock, picker;

        yearBlock = $KD.find(this._kwebfw_.picker, '[kr="years"]')[0];
        yearsEl = $KD.find(yearBlock, '[kr="year"]')[0];
        counter = Number($KD.getAttr(yearsEl, 'year'));
        counter = counter + 16;
        if(counter <= _getCounter(_maxYear)) {
            $KD.remove(yearBlock);
            yearBlock = _getYears.call(this, counter);
            picker = $KD.find(this._kwebfw_.picker, '[kr="monthYearPicker"]')[0];
            $KD.add(picker, yearBlock);
        }
    };


    var _showPrevYearSet = function() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom,
            counter, yearsEl, yearBlock, picker;

        yearBlock = $KD.find(this._kwebfw_.picker, '[kr="years"]')[0];
        yearsEl = $KD.find(yearBlock, '[kr="year"]')[0];
        counter = Number($KD.getAttr(yearsEl, 'year'));
        counter = counter - 16;
        if(counter >= _getCounter(_minYear)) {
            $KD.remove(yearBlock);
            yearBlock = _getYears.call(this, counter);
            picker = $KD.find(this._kwebfw_.picker, '[kr="monthYearPicker"]')[0];
            $KD.add(picker, yearBlock);
        }
    };


    //This function will be called in the scope of widget instance
    var _updateRelatedDateProperties = function Calendar$_updateRelatedDateProperties() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, _ = this._kwebfw_, prop = _.prop,
            dm = null, dc = prop.dateComponents, el = $KW.el(this);

        if($KU.is(dc, 'array')) {
            prop.year = dc[2];
            prop.month = dc[1];
            prop.day = dc[0];
            prop.hour = dc[3];
            prop.minutes = dc[4];
            prop.seconds = dc[5];
        } else {
            prop.year = -1;
            prop.month = -1;
            prop.day = -1;
            prop.hour = -1;
            prop.minutes = -1;
            prop.seconds = -1;
        }

        dm = _deduceDisplayedMonth.call(this);
        _populateDisplayedMonths.call(this, dm[0], dm[1]);
        prop.formattedDate = _formatDate.call(this);

        if(el.input) {
            $KD.setAttr(el.input, 'value', prop.formattedDate);
        }

        dm = _.displayedMonths[0];
        _changePicker.call(this, dm[0], dm[1]);
    };

    var _updateMonthYearHeaderLabel = function Calendar$_updateMonthYearHeaderLabel(label, selectedMonth, selectedYear) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, prop = this._kwebfw_.prop,
            month = selectedMonth || _months[prop.month],
            year = selectedYear || prop.year;

        $KD.html(label, ((month || '') + ' ' + (year || '')));
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Calendar: {
            calendarIcon: function Calendar$_valid_calendarIcon(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            calendarIconAlignment: function Calendar$_valid_calendarIconAlignment(value) {
                var flag = false, options = [
                    constants.CALENDAR_ICON_ALIGN_AUTO,
                    constants.CALENDAR_ICON_ALIGN_LEFT,
                    constants.CALENDAR_ICON_ALIGN_RIGHT
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            cellTemplate: function Calendar$_valid_cellTemplate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')
                || $KU.is(value, 'widget')
                || $KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            data: function Calendar$_valid_data(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            dateComponents: function Calendar$_valid_dateComponents(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop,
                    flag = _isValidDateComponents(value), dc = null, date = null;

                if(flag === true || ($KU.is(flag, 'array') && flag[1] === true)) {
                    date = ($KU.is(flag, 'array')) ? flag[0] : value;

                    if(date) {
                        if(Object.prototype.hasOwnProperty.call(prop, 'validStartDate')
                        && Object.prototype.hasOwnProperty.call(prop, 'validEndDate')
                        && Object.prototype.hasOwnProperty.call(prop, 'selectionType')
                        && Object.prototype.hasOwnProperty.call(prop, 'selectedDates')) {
                            dc = prop.dateComponents;
                            prop.dateComponents = value;
                            flag = _isValidDateCombination.call(this, prop);
                            /*if(!flag) */prop.dateComponents = dc;
                        }
                    }
                }

                return flag;
            },

            dateEditable: function Calendar$_valid_dateEditable(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            dateFormat: function Calendar$_valid_dateFormat(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            day: function Calendar$_valid_day(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'integer') && value >= 1 && value <= 31) {
                    flag = true;
                }

                return flag;
            },

            dayTextAlignmentInCell: function Calendar$_valid_dayTextAlignmentInCell(value) {
                var flag = false, options = [
                    constants.CONTENT_ALIGN_BOTTOM_CENTER,
                    constants.CONTENT_ALIGN_BOTTOM_LEFT,
                    constants.CONTENT_ALIGN_BOTTOM_RIGHT,
                    constants.CONTENT_ALIGN_MIDDLE_LEFT,
                    constants.CONTENT_ALIGN_MIDDLE_RIGHT,
                    constants.CONTENT_ALIGN_TOP_CENTER,
                    constants.CONTENT_ALIGN_TOP_LEFT,
                    constants.CONTENT_ALIGN_TOP_RIGHT,
                    constants.CONTENT_ALIGN_CENTER
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            displayedMonth: function Calendar$_valid_displayedMonth(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'array') && value.length === 2
                && $KU.is(value[0], 'integer') && $KU.is(value[1], 'integer')
                && value[0] >= 1 && value[0] <= 12
                && value[1] >= _minYear && value[1] <= _maxYear) {
                    flag = true;
                }

                return flag;
            },

            enableOrDisableDates: function Calendar$_valid_enableOrDisableDates(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }
                return flag;
            },

            formattedDate: function Calendar$_valid_formattedDate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') && value === '') {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    flag = ['', true];
                }

                return flag;
            },

            gridTheme: function Calendar$_valid_gridTheme(value) {
                var flag = false, options = [
                    voltmx.calendar.LEGACY,
                    voltmx.calendar.MODERN
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            hideDaysHeader: function Calendar$_valid_hideDaysHeader(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            hideMonthsHeader: function Calendar$_valid_hideMonthsHeader(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            hidePreviousNextMonthDates: function Calendar$_valid_hidePreviousNextMonthDates(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            hour: function Calendar$_valid_hour(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'integer') && value >= 0 && value <= 23) {
                    flag = true;
                }

                return flag;
            },

            i18n_toolTip: function Calendar$_valid_i18n_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            minutes: function Calendar$_valid_minutes(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'integer') && value >= 0 && value <= 59) {
                    flag = true;
                }

                return flag;
            },

            month: function Calendar$_valid_month(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'integer') && value >= 1 && value <= 12) {
                    flag = true;
                }

                return flag;
            },

            noOfMonths: function Calendar$_valid_noOfMonths(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'integer') && value >= 1 && value <= 12) {
                    flag = true;
                }

                return flag;
            },

            onDone: function Calendar$_valid_onDone(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null') || $KU.is(value, 'function')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onSelection: function Calendar$_valid_onSelection(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null') || $KU.is(value, 'function')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            placeholder: function Calendar$_valid_placeholder(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            seconds: function Calendar$_valid_seconds(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'integer') && value >= 0 && value <= 59) {
                    flag = true;
                }

                return flag;
            },

            selectedDates: function Calendar$_valid_selectedDates(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, flag = false,
                    backupSelectedDates = prop.selectedDates;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'array')) {
                    flag = true;

                    $KU.each(value, function(dc) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            valid = _isValidDateComponents(dc);

                        if(valid === false) {
                            flag = false;
                            return true;
                        } else if($KU.is(valid, 'array')) {
                            if(valid[1] === false) {
                                flag = false;
                                return true;
                            }
                            value = valid[0];
                        }
                    });

                    if(flag) {
                        if(Object.prototype.hasOwnProperty.call(prop, 'validStartDate')
                        && Object.prototype.hasOwnProperty.call(prop, 'validEndDate')
                        && Object.prototype.hasOwnProperty.call(prop, 'selectionType')
                        && Object.prototype.hasOwnProperty.call(prop, 'dateComponents')) {
                            if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_MULTI_SELECT) {
                                prop.selectedDates = value;
                                flag = _isValidDateCombination.call(this, prop);
                            } else if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_RANGE_SELECT) {
                                if(value.length !== 2) {
                                    flag = false;
                                } else {
                                    prop.selectedDates = value;
                                    flag = _isValidDateCombination.call(this, prop);
                                }
                            }

                            /*if(!flag) */prop.selectedDates = backupSelectedDates;
                        }
                    }
                }

                return flag;
            },

            selectionType: function Calendar$_valid_selectionType(value) {
                var flag = false, options = [
                    constants.CALENDAR_SELECTION_TYPE_MULTI_SELECT,
                    constants.CALENDAR_SELECTION_TYPE_RANGE_SELECT,
                    constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            titleOnPopup: function Calendar$_valid_titleOnPopup(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            toolTip: function Calendar$_valid_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            validEndDate: function Calendar$_valid_validEndDate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, endDate = null,
                    flag = _isValidDateComponents(value), prop = this._kwebfw_.prop,
                    backupEndDate = prop.validEndDate;

                if(flag === true || ($KU.is(flag, 'array') && flag[1] === true)) {
                    endDate = ($KU.is(flag, 'array')) ? flag[0] : value;

                    if(endDate) {
                        if(Object.prototype.hasOwnProperty.call(prop, 'validStartDate')
                        && Object.prototype.hasOwnProperty.call(prop, 'selectionType')
                        && Object.prototype.hasOwnProperty.call(prop, 'dateComponents')
                        && Object.prototype.hasOwnProperty.call(prop, 'selectedDates')) {
                            prop.validEndDate = endDate;
                            flag = _isValidDateCombination.call(this, prop);
                            /*if(!flag) */prop.validEndDate = backupEndDate;
                        }
                    }
                }

                return flag;
            },

            validStartDate: function Calendar$_valid_validStartDate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, startDate = null,
                    flag = _isValidDateComponents(value), prop = this._kwebfw_.prop,
                    backupStartDate = prop.validStartDate;

                if(flag === true || ($KU.is(flag, 'array') && flag[1] === true)) {
                    startDate = ($KU.is(flag, 'array')) ? flag[0] : value;

                    if(startDate) {
                        if(Object.prototype.hasOwnProperty.call(prop, 'validEndDate')
                        && Object.prototype.hasOwnProperty.call(prop, 'selectionType')
                        && Object.prototype.hasOwnProperty.call(prop, 'dateComponents')
                        && Object.prototype.hasOwnProperty.call(prop, 'selectedDates')) {
                            prop.validStartDate = startDate;
                            flag = _isValidDateCombination.call(this, prop);
                            /*if(!flag) */prop.validStartDate = backupStartDate;
                        }
                    }
                }

                return flag;
            },

            viewConfig: function Calendar$_valid_viewConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
                    backupViewConfig = null, prop = this._kwebfw_.prop;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')) {
                    if(!Object.prototype.hasOwnProperty.call(value, 'gridConfig')) {
                        flag = true;
                    } else {
                        if($KU.is(value.gridConfig, 'object')) {
                            flag = true;
                        }
                    }
                }

                if(flag) {
                    backupViewConfig = prop.viewConfig;
                    prop.viewConfig = value;
                    flag = _isValidDateCombination.call(this, prop);

                    if(!flag) {
                        prop.viewConfig = backupViewConfig;
                    }
                }

                return flag;
            },

            viewType: function Calendar$_valid_viewType(value) {
                var flag = false, options = [
                    constants.CALENDAR_VIEW_TYPE_DEFAULT,
                    constants.CALENDAR_VIEW_TYPE_GRID_ONSCREEN,
                    constants.CALENDAR_VIEW_TYPE_GRID_POPUP
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            widgetDataMapForCell: function Calendar$_valid_widgetDataMapForCell(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            year: function Calendar$_valid_year(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'integer') && value >= _minYear && value <= _maxYear) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        Calendar: {
            calendarIcon: function Calendar$_view_calendarIcon(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                if(this.calendarIcon) {
                    $KD.setAttr(el.icon, 'src', $KU.getImageURL(this.calendarIcon));
                } else {
                    $KD.removeAttr(el.icon, 'src');
                }
            },

            calendarIconAlignment: function Calendar$_view_calendarIconAlignment(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.calendarIconAlignment === constants.CALENDAR_ICON_ALIGN_LEFT
                || (this.calendarIconAlignment === constants.CALENDAR_ICON_ALIGN_AUTO
                && [constants.CONTENT_ALIGN_BOTTOM_RIGHT,
                    constants.CONTENT_ALIGN_MIDDLE_RIGHT,
                    constants.CONTENT_ALIGN_TOP_RIGHT].indexOf(this.contentAlignment) >= 0)) {
                    $KD.addAt(el.node, el.icon, 0);
                } else {
                    $KD.addAt(el.node, el.input, 0);
                }
            },

            cellTemplate: function Calendar$_view_cellTemplate(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            data: function Calendar$_view_data(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            dateComponents: function Calendar$_view_dateComponents(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, prop = this._kwebfw_.prop,
                    displayedMonth = prop.displayedMonth || [-1, -1];


                $KD.setAttr(el.input, 'value', prop.formattedDate);
                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            dateEditable: function Calendar$_view_dateEditable(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this._kwebfw_.prop.dateEditable) {
                    $KD.removeAttr(el.input, 'readonly');
                } else {
                    $KD.setAttr(el.input, 'readonly', 'readonly');
                }
            },

            dateFormat: function Calendar$_view_dateFormat(/*el, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, el = $KW.el(this),
                    prop = this._kwebfw_.prop, formattedDate = _formatDate.call(this);

                if(!prop.placeholder && prop.dateFormat) {
                    $KD.setAttr(el.input, 'placeholder', prop.dateFormat);
                } else if(this.placeholder) {
                    $KD.setAttr(el.input, 'placeholder', prop.placeholder);
                } else {
                    $KD.removeAttr(el.input, 'placeholder');
                }

                formattedDate && $KD.setAttr(el.input, 'value', formattedDate);
            },

            day: false,

            dayTextAlignmentInCell: function Calendar$_view_dayTextAlignmentInCell(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            displayedMonth: function Calendar$_view_displayedMonth(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            enableOrDisableDates: function Calendar$_view_enableOrDisableDates(/*el, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, dc = _.prop.dateComponents,
                    valid = true, displayedMonth = _.prop.displayedMonth || [-1, -1],
                    config = this.enableOrDisableDates, dates = null, skin = '', enable = true;

                if(config) {
                    dates = config.dates;
                    skin = config.skin;
                    enable = config.hasToEnable;
                }

                if($KU.is(dates, 'array')) {
                    if($KU.is(skin, 'string') && $KU.is(enable, 'boolean')) {
                        $KU.each(dates, function(date) {
                            var $K = voltmx.$kwebfw$, $KU = $K.utils, dt = null;

                            if(dc && $KU.is(date, 'date')) {
                                dt = new Date(date[2], (date[1] - 1), date[0], 0, 0, 0);

                                if(dt.valueOf() === dc.valueOf()) {
                                    valid = false;
                                    return true;
                                }
                            }
                        });

                        if(!valid) {
                            //ERROR:: throw error
                        } else {
                            _.enableDates = {};
                            _.enableDatesSkin = {};
                            _.enableDatesInactive = ($KU.is(dates, 'array') && dates.length > 0) ? !enable : null;

                            $KU.each(dates, function(date) {
                                var key = _dateFormatter(date, false);

                                _.enableDates[key] = true;
                                if(skin) _.enableDatesSkin[key] = skin;
                                else delete _.enableDatesSkin[key];
                            });

                            _changePicker.call(this, displayedMonth[0], [1]);
                        }
                    }
                } else {
                    _.enableDates = {};
                    _.enableDatesSkin = {};
                    _.enableDatesInactive = null;
                    _changePicker.call(this, displayedMonth[0], [1]);
                }
            },

            formattedDate: false,

            gridTheme: function Calendar$_view_gridTheme(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            hideDaysHeader: function Calendar$_view_hideDaysHeader(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            hideMonthsHeader: function Calendar$_view_hideMonthsHeader(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            hidePreviousNextMonthDates: function Calendar$_view_hidePreviousNextMonthDates(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            hour: false,

            i18n_toolTip: false,

            minutes: false,

            month: false,

            noOfMonths: function Calendar$_view_noOfMonths(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            onDone: true,

            onSelection: true,

            placeholder: function Calendar$_view_placeholder(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, prop = this._kwebfw_.prop;

                if(!prop.placeholder && prop.dateFormat) {
                    $KD.setAttr(el.input, 'placeholder', prop.dateFormat);
                } else if(this.placeholder) {
                    $KD.setAttr(el.input, 'placeholder', prop.placeholder);
                } else {
                    $KD.removeAttr(el.input, 'placeholder');
                }
            },

            seconds: false,

            selectedDates: function Calendar$_view_selectedDates(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, prop = this._kwebfw_.prop,
                    displayedMonth = prop.displayedMonth || [-1, -1];


                $KD.setAttr(el.input, 'value', prop.formattedDate);
                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            selectionType: function Calendar$_view_selectionType(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            titleOnPopup: function Calendar$_view_titleOnPopup(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            toolTip: function Calendar$_view_toolTip(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.toolTip) {
                    $KD.setAttr(el.node, 'title', this.toolTip);
                } else {
                    $KD.removeAttr(el.node, 'title');
                }
            },

            validEndDate: function Calendar$_view_validEndDate(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            validStartDate: function Calendar$_view_validStartDate(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            viewConfig: function Calendar$_view_viewConfig(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            viewType: false,

            widgetDataMapForCell: function Calendar$_view_widgetDataMapForCell(/*el, old*/) {
                var displayedMonth = this._kwebfw_.prop.displayedMonth || [-1, -1];

                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            },

            year: false
        }
    };


    Object.defineProperty(voltmx.ui, 'Calendar', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Calendar constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var Calendar = function Calendar(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    calendarIcon: 'calbtn.png', //(Read + Write) This property is applicable only when the viewType is set as CALENDAR_VIEW_TYPE_GRID_POPUP
                    calendarIconAlignment: constants.CALENDAR_ICON_ALIGN_RIGHT,
                    cellTemplate: '', //(Read + Write) This property is available only when viewType is set as CALENDAR_VIEW_TYPE_GRID_POPUP or CALENDAR_VIEW_TYPE_GRID_ONSCREEN
                    data: null, //(Read + Write) This is required if cellTemplate is defined
                    dateComponents: [18, 2, 2020, 12, 59, 59], //(Read + Write)
                    dateEditable: true, //(Read + Write)
                    dateFormat: 'dd/MM/yyyy', //(Read + Write)
                    day: -1, //(Read only)
                    dayTextAlignmentInCell: constants.CONTENT_ALIGN_CENTER, //(Read + Write) This property is available only when viewType is set as CALENDAR_VIEW_TYPE_GRID_POPUP or CALENDAR_VIEW_TYPE_GRID_ONSCREEN.
                    displayedMonth: null, //(Read + Write) This property is applicable only when viewType is set as CALENDAR_VIEW_TYPE_GRID_POPUP or CALENDAR_VIEW_TYPE_GRID_ONSCREEN.
                    enableOrDisableDates: null,
                    formattedDate: '', //(Read only)
                    gridTheme: voltmx.calendar.MODERN, //(Read + Write)
                    hideDaysHeader: false, //(Read + Write) This property is available only when viewType is set as CALENDAR_VIEW_TYPE_GRID_POPUP or CALENDAR_VIEW_TYPE_GRID_ONSCREEN. It indicates if the weekdays are hidden on the header for grid calendar.
                    hideMonthsHeader: false, //(Read + Write) This property is available only when viewType is set as CALENDAR_VIEW_TYPE_GRID_POPUP or CALENDAR_VIEW_TYPE_GRID_ONSCREEN. It indicates if the months header is hidden for grid calendar including the navigation buttons.
                    hidePreviousNextMonthDates: false,
                    hour: -1, //(Read only)
                    i18n_toolTip: '', //(Read only)
                    minutes: -1, //(Read only)
                    month: -1, //(Read only)
                    noOfMonths: 1, //(Read + Write)
                    onDone: null, //(Read + Write)
                    onSelection: null, //(Read + Write)
                    placeholder: '', //(Read + Write)
                    seconds: -1, //(Read only)
                    selectedDates: null,
                    selectionType: constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT, //(Read + Write)
                    titleOnPopup: '', //(Read + Write)
                    toolTip: '', //(Read + Write)
                    validEndDate: null, //(Read + Write)
                    validStartDate: null, //(Read + Write)
                    viewConfig: {}, //(Read +Write)
                    viewType: constants.CALENDAR_VIEW_TYPE_GRID_POPUP, //(Read +Write)
                    widgetDataMapForCell: null, //(Read + Write)
                    year: -1 //(Read only)
                };
            }

            _populateUnderscore.Calendar.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            Calendar.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Calendar, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Calendar.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to Calendar
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Calendar[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Calendar>, but not in <_valid.Calendar> namespace.');
                        } else {
                            valid = _valid.Calendar[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Calendar
                $KU.each(_view.Calendar, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Calendar$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Calendar[key], 'function')) {
                            return _getter.Calendar[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Calendar$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Calendar[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Calendar[key], 'function')) {
                                        _setter.Calendar[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Calendar().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Calendar().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.Calendar, 'function')) {
                    _postInitialization.Calendar.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Calendar, voltmx.ui.BasicWidget);

        var calendar__flush = function Calendar$_flush() {
            var $super = voltmx.ui.Calendar.base.prototype,
                $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, el = $KW.el(this);

            el.icon && $KD.off(el.icon, 'onmousedown');
            $super._flush.call(this);
        };

        /**
         * Builds the view layer for voltmx.ui.Calendar widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Calendar
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  Calendar view.
         */
        var calendar__render = function Calendar$_render(tag) {
            var $super = voltmx.ui.Calendar.base.prototype, icon = null,
                _ = this._kwebfw_, prop = _.prop, input = null, view = _.view,
                $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    input = $KD.create('INPUT', {
                        type: 'text',
                        autocomplete: 'off',
                        value: prop.formattedDate
                    });

                    icon = $KD.create('IMG', {
                        alt:'Calendar Icon', role:'button',
                        loading:'lazy'
                    });
                    $KD.on(icon, 'mousedown', 'image', function(e) {
                        $KD.preventDefault(e);
                    });
                    $KD.setAttr(icon, 'aria-label', 'Calendar Icon');
                    $KD.setAttr(icon, 'aria-haspopup', 'true');
                    $KD.setAttr(icon, 'kwh-click', 'onIconClick');
                    $KD.setAttr(icon, 'kwh-keyup', 'onIconKeyUp');
                    $KD.setAttr(input, 'kwh-focusout', 'onInputFocusOut');
                    $KD.setAttr(input, 'kwh-keydown', 'onInputKeyDown');
                    $KD.setAttr(input, 'aria-label', 'Calendar Input');

                    view = $super._render.call(this, tag, [input, icon]);
                    el = $KW.el(view);

                    _view.Calendar.dateFormat.call(this, el, this.dateFormat);
                    _view.Calendar.dateEditable.call(this, el, this.dateEditable);
                    _view.Calendar.calendarIcon.call(this, el, this.calendarIcon);
                    _view.Calendar.calendarIconAlignment.call(this, el, this.calendarIconAlignment);
                    _view.Calendar.enableOrDisableDates.call(this, el, this.enableOrDisableDates);
                }

                $KD.setAttr(el.icon, 'aria-expanded', 'false');
                _view.Calendar.placeholder.call(this, el, this.placeholder);
                _view.Calendar.toolTip.call(this, el, this.toolTip);

                $KW.accessibility(this);
            }

            return view;
        };


        var calendar_clear = function Calendar$clear() {
            var _ = this._kwebfw_, prop = _.prop;

            if(prop.selectionType === constants.CALENDAR_SELECTION_TYPE_SINGLE_SELECT) {
                this.dateComponents = null;
            } else {
                this.selectedDates = null;
            }
        };


        var calendar_clearData = function Calendar$clearData() {
            this.data = null;
        };


        var calendar_dismiss = function Calendar$dismiss() {
            _dismissPicker.call(this, true);
        };


        var calendar_enableRangeOfDates = function Calendar$enableRangeOfDates(startDate, endDate, skin, enable) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
                backupStartDate = _.enableDateRangeStart,
                backupEndDate = _.enableDateRangeEnd, valid = false,
                displayedMonth = _.prop.displayedMonth || [-1, -1];

            if($KU.is(skin, 'string') && $KU.is(enable, 'boolean')) {
                valid = _isValidDateComponents(startDate);
                if(valid === false) {
                    //ERROR:: throw error
                } else if($KU.is(valid, 'array')) {
                    if(!startDate[1]) {
                        //ERROR:: throw error
                    } else {
                        startDate = valid[0];
                        valid = valid[1];
                    }
                }
                if(valid && startDate) {
                    _.enableDateRangeStart = [startDate[0], startDate[1], startDate[2]];
                    startDate = new Date(startDate[2], (startDate[1] - 1), startDate[0], 0, 0, 0);
                }

                valid = _isValidDateComponents(endDate);
                if(valid === false) {
                    //ERROR:: throw error
                } else if($KU.is(valid, 'array')) {
                    if(!valid[1]) {
                        //ERROR:: throw error
                    } else {
                        endDate = valid[0];
                        valid = valid[1];
                    }
                }
                if(valid && endDate) {
                    _.enableDateRangeEnd = [endDate[0], endDate[1], endDate[2]];
                    endDate = new Date(endDate[2], (endDate[1] - 1), endDate[0], 0, 0, 0);
                }
                if($KU.is(_.enableDateRangeInactive, 'boolean')) {
                    _.enableDateRangeInactive = (!startDate && !endDate) ? null : !enable;
                }

                valid = _isValidDateCombination.call(this, this._kwebfw_.prop);
            }

            if(!valid) {
                _.enableDateRangeStart = backupStartDate;
                _.enableDateRangeEnd = backupEndDate;
                //ERROR:: throw error
            } else {
                _.enableDateRangeStart = (!startDate) ? null : [startDate.getDate(), (startDate.getMonth() + 1), startDate.getFullYear()];
                _.enableDateRangeEnd = (!endDate) ? null : [endDate.getDate(), (endDate.getMonth() + 1), endDate.getFullYear()];
                _.enableDateRangeSkin = skin;
                _.enableDateRangeInactive = (!startDate && !endDate) ? null : !enable;
                _changePicker.call(this, displayedMonth[0], [1]);
            }
        };


        var calendar_navigateToNextMonth = function Calendar$navigateToNextMonth() {
            _nextMonth.call(this, 1);
        };


        var calendar_navigateToPreviousMonth = function Calendar$navigateToPreviousMonth() {
            _prevMonth.call(this, 1);
        };


        var calendar_open = function Calendar$open() {
            !this._kwebfw_.picker && _openPicker.call(this);
        };


        var calendar_removeDataAt = function Calendar$removeDataAt(date) {
            var prop = this._kwebfw_.prop, displayedMonth = null;

            if(prop.data && Object.prototype.hasOwnProperty.call(prop.data, date)) {
                delete prop.data[date];
                displayedMonth = prop.displayedMonth || [-1, -1];
                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            }
        };


        var calendar_setContext = function Calendar$setContext(context) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                _ = this._kwebfw_, anchor = _.anchor, omodel = null,
                anchorWidget = null, anchorTemplate = null;

            if($KU.is(context, 'object')
            && ['top', 'bottom', 'left', 'right'].indexOf(context.anchor) >= 0
            && ($KU.is(context.widget, 'widget')
            || ($KU.is(context.widget, 'string') && context.widget))) {
                omodel = $KW.omodel(this);
                anchorWidget = context.widget;

                if(!omodel && $KU.is(context.widget, 'string')) {
                    delete anchor.position;
                    delete anchor.widget;
                    delete anchor.holder;

                    throw new Error('context.widget cannot be a string.');
                } else {
                    if($KU.is(context.widget, 'string')) {
                        anchorTemplate = $KW.tmodel(this);
                        anchorWidget = $KU.get(context.widget, anchorTemplate);
                    }

                    anchor.position = context.anchor;
                    anchor.widget = anchorWidget;
                    anchor.holder = (omodel) ? omodel : anchorWidget.parent;

                    if(!$KU.is(anchor.widget, 'widget', 'Form2')) {
                        anchor.widget = anchor.widget._kwebfw_.uid;
                    } else {
                        delete anchor.position;
                        delete anchor.widget;
                        delete anchor.holder;
                    }
                }
            } else {
                delete anchor.position;
                delete anchor.widget;
                delete anchor.holder;
            }
        };


        var calendar_setData = function Calendar$setData(data) {
            this.data = data;
        };


        var calendar_setDataAt = function Calendar$setDataAt(date, data) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop,
                displayedMonth = prop.displayedMonth || [-1, -1];

            if($KU.is(data, 'object')) {
                if(!prop.data) prop.data = {};

                prop.data[date] = data;
                _changePicker.call(this, displayedMonth[0], displayedMonth[1]);
            }
        };


        var calendar_setDatesSkin = function Calendar$setDatesSkin(dates, skin) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, valid = true;

            $KU.each(dates, function(date) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    valid = _isValidDateComponents(date);

                if(valid === false || ($KU.is(valid, 'array') && valid[1] === false)) {
                    valid = false;
                    return true;
                }
            });

            if(!valid) {
                //ERROR:: throw error
            } else {
                _.specialSkins = {};

                $KU.each(dates, function(date) {
                    var key = _dateFormatter(date, false);

                    if(skin) _.specialSkins[key] = skin;
                    else delete _.specialSkins[key];
                });
            }
        };


        var calendar_setEnabled = function Calendar$setEnabled(dates, skin, enable) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            if(arguments.length === 1) {
                if($KU.is(dates, 'boolean')) {
                    voltmx.ui.Calendar.base.prototype.setEnabled.call(this, dates);
                }
            } else if(arguments.length === 3) {
                this.enableOrDisableDates = {
                    dates: dates,
                    skin: skin,
                    hasToEnable: enable
                };
            }
        };


        var calendar_setEnableAll = function Calendar$setEnableAll(arg0) {
            var enable = (arg0 === false) ? false : true;

            this.enableRangeOfDates([1, 1, _minYear], [31, 12, _maxYear], '', enable);
        };

        $K.defVoltmxProp(Calendar.prototype, [
            {keey:'_flush', value:calendar__flush},
            {keey:'_render', value:calendar__render},
            {keey:'clear', value:calendar_clear},
            {keey:'clearData', value:calendar_clearData},
            {keey:'dismiss', value:calendar_dismiss},
            {keey:'enableRangeOfDates', value:calendar_enableRangeOfDates},
            {keey:'navigateToNextMonth', value:calendar_navigateToNextMonth},
            {keey:'navigateToPreviousMonth', value:calendar_navigateToPreviousMonth},
            {keey:'open', value:calendar_open},
            {keey:'removeDataAt', value:calendar_removeDataAt},
            {keey:'setContext', value:calendar_setContext},
            {keey:'setData', value:calendar_setData},
            {keey:'setDataAt', value:calendar_setDataAt},
            {keey:'setDatesSkin', value:calendar_setDatesSkin},
            {keey:'setEnabled', value:calendar_setEnabled},
            {keey:'setEnableAll', value:calendar_setEnableAll}
        ]);


        return Calendar;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxcheckboxgroup.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'CheckBoxGroup', value:{}, items:[
            {keey:'onChange', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                    prop = this._kwebfw_.prop, payload = null, index = -1;

                if(evt.target.tagName === 'INPUT'
                && $KD.getAttr(evt.target, 'type', 'checkbox')) {
                    payload = {checked:evt.target.checked, key:evt.target.value};
                    if(!$KU.is(prop.selectedKeys, 'array')) {
                        prop.selectedKeys = [];
                        prop.selectedKeyValues = [];
                    }

                    if(payload.checked) {
                        prop.selectedKeys.push(payload.key);
                        prop.selectedKeyValues.push($KW.getGroupSelectedKeyValueByKey(this, payload.key));
                    } else {
                        index = prop.selectedKeys.indexOf(payload.key);

                        prop.selectedKeys.splice(index, 1);
                        prop.selectedKeyValues.splice(index, 1);
                    }

                    $KW.onPropertyChange(this, 'selectedKeys');
                    $K.apm.send(this, 'Touch', {type:(this._kwebfw_.name+'_Selection')});
                    $KW.fire(this, 'onSelection', this);
                }

                return false;
            }},

            {keey:'onCheckBoxBlur', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget;

                $KD.setAttr(evt.target, 'tabindex', -1);
                $KW.fire(this, 'onBlur', this);
                return false;
            }},

            {keey:'onCheckBoxFocus', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, tabindex = $KW.tabIndex(this);

                if($KU.is(tabindex, 'integer') && tabindex >= 0) {
                    $KD.removeAttr(evt.target, 'tabindex');
                } else {
                    $KD.blur(evt.target);
                }

                $KW.fire(this, 'onFocus', this);
                return false;
            }},

            {keey:'onCheckBoxKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    checkbox = null, code = evt.keyCode || evt.which;

                if([37, 38, 39, 40].indexOf(code) >= 0) {
                    checkbox = $KD.parent(evt.target);

                    if([37, 38].indexOf(code) >= 0) { //Up Arrow
                        checkbox = $KD.prev(checkbox);
                    } else if([39, 40].indexOf(code) >= 0) { //Down Arrow
                        checkbox = $KD.next(checkbox);
                    }

                    if(checkbox) {
                        $KD.preventDefault(evt);

                        checkbox = $KD.first(checkbox);
                        $KD.focus(checkbox);
                    }
                }

                return false;
            }},

            {keey:'onKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, checkbox = null,
                    code = evt.keyCode || evt.which;

                if([39, 40].indexOf(code) >= 0) {
                    checkbox = $KD.first(evt.target);

                    if(checkbox) {
                        $KD.preventDefault(evt);

                        checkbox = $KD.first(checkbox);
                        $KD.removeAttr(checkbox, 'tabindex');
                        $KD.focus(checkbox);
                    }
                }

                return false;
            }},

            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                    tabindex = '', checkboxes = $KD.find(dom, 'input[type="checkbox"]');

                if($KW.disabled(this)) {
                    $KD.setAttr(dom, 'aria-disabled', 'true');
                    $KD.removeAttr(dom, 'tabindex');

                    $KU.each(checkboxes, function(checkbox) {
                        checkbox.disabled = true;
                    });
                } else if(!$KW.interactable(this)) {
                    $KD.removeAttr(dom, 'tabindex');

                    $KU.each(checkboxes, function(checkbox) {
                        var $K = voltmx.$kwebfw$, $KD = $K.dom,
                            parent = $KD.parent(checkbox),
                            modal = $KD.create('DIV');

                        $KD.removeAttr(checkbox, 'tabindex');

                        $KD.style(parent, {
                            position:'relative',
                            top:'0px', left:'0px'
                        });

                        $KD.style(modal, {
                            position:'absolute',
                            top:'0px', left:'0px',
                            height:'100%', width:'100%'
                        });

                        $KD.add(parent, modal);
                    });
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(dom, 'aria-disabled');

                    $KU.each(checkboxes, function(checkbox) {
                        var $K = voltmx.$kwebfw$, $KD = $K.dom,
                            parent = $KD.parent(checkbox),
                            modal = $KD.last(parent);

                        checkbox.disabled = false;

                        $KD.style(parent, {
                            position:null,
                            top:null, left:null
                        });

                        if(modal && modal.tagName === 'DIV') {
                            $KD.remove(modal);
                        }
                    });

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        $KD.removeAttr(dom, 'tabindex');
                    }
                }
            }}
        ]}
    ]);


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {
        CheckBoxGroup: function CheckBoxGroup$_dependentPropertiesValidationMessage(prop, bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, message = '', keys = [],
                masterData = (pspconfig && pspconfig.masterData) || bconfig.masterData,
                masterDataMap = (pspconfig && pspconfig.masterDataMap) || bconfig.masterDataMap,
                selectedKeys = (pspconfig && pspconfig.selectedKeys) || bconfig.selectedKeys;

            masterData = ($KU.is(masterData, 'null') || $KU.is(masterData, 'array')) ? masterData : prop.masterData;
            masterDataMap = ($KU.is(masterDataMap, 'null') || $KU.is(masterDataMap, 'array')) ? masterDataMap : prop.masterDataMap;
            selectedKeys = ($KU.is(selectedKeys, 'null') || $KU.is(selectedKeys, 'array')) ? selectedKeys : prop.selectedKeys;

            if(selectedKeys && (masterData || masterDataMap)) {
                $KU.each((masterData || masterDataMap), function(data) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    keys.push(($KU.is(data, 'array')) ? data[0] : data[masterDataMap[1]]);
                });

                $KU.each(selectedKeys, function(name) {
                    if(keys.indexOf(name) === -1) {
                        message += 'Invalid selectedKey(s) <'+name+'>.';
                        return true;
                    }
                });
            }

            return message;
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        CheckBoxGroup: {
            masterData: function CheckBoxGroup$_getter_masterData(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, data = null;

                if(value) {
                    data = [];

                    $KU.each(value, function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, val = [item[0], item[1]];

                        if($KU.is(item[2], 'object')) {
                            val.push($KW.getAccessibilityConfig(item[2]));
                        }

                        if($KU.is(val[1], 'i18n')) {
                            val[1] = $KU.getI18Nvalue(val[1]);
                        }

                        data.push(val);
                    });
                }

                return data;
            },

            masterDataMap: function CheckBoxGroup$_getter_masterDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    data = null, keyName = '', valName = '';

                if(value) {
                    data = [];
                    keyName = value[1];
                    valName = value[2];

                    $KU.each(value[0], function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, val = {};

                        val[keyName] = item[keyName];
                        val[valName] = item[valName];

                        if($KU.is(item.accessibilityConfig, 'object')) {
                            val.accessibilityConfig = $KW.getAccessibilityConfig(item.accessibilityConfig);
                        }

                        if($KU.is(val[valName], 'string')
                        && val[valName].toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') !== -1) {
                            val[valName] = $KU.getI18Nvalue(val[valName]);
                        }

                        data.push(val);
                    });
                }

                return [data, keyName, valName];
            },

            selectedKeys: function CheckBoxGroup$_getter_selectedKeys(value) {
                return (value) ? value.slice(0) : null;
            },

            selectedKeyValues: function CheckBoxGroup$_getter_selectedKeyValues(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            },

            toolTip: function CheckBoxGroup$_getter_toolTip() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, toolTip = prop.toolTip;

                if(prop.i18n_toolTip) {
                    toolTip = $KU.getI18Nvalue(prop.i18n_toolTip);
                }

                return toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        CheckBoxGroup: function CheckBoxGroup$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.CheckBoxGroup', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'CheckBoxGroup', null);
                }
            }
            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        CheckBoxGroup: function CheckBoxGroup$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                _ = this._kwebfw_, prop = _.prop;

            $KW.normalizeGroupMasterData(this);

            if(prop.i18n_toolTip) {
                prop.toolTip = prop.i18n_toolTip;
            }

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'slCheckBoxGroup';
            }

            _setter[_.name].selectedKeys.call(this, prop.selectedKeys);
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        CheckBoxGroup: function CheckBoxGroup$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        CheckBoxGroup: function CheckBoxGroup$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //This functions will be called in the scope of widget instance
    var _renderCheckBoxGroup = function CheckBoxGroup$_renderCheckBoxGroup(holder) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            $KW = $K.widget, _ = this._kwebfw_, prop = _.prop,
            masterdata = this.masterData;

        if(!masterdata && prop.masterDataMap) {
            masterdata = this.masterDataMap[0];
        }

        $KD.html(holder, '');

        $KU.each(masterdata, function(data) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                $KD = $K.dom, div = $KD.create('DIV', {kr:'option'}), key = '', val = '',
                _ = this._kwebfw_, prop = _.prop, input = null, txt = null, a11y = null;

            key = ($KU.is(data, 'array')) ? data[0] : data[prop.masterDataMap[1]];
            val = ($KU.is(data, 'array')) ? data[1] : data[prop.masterDataMap[2]];
            a11y = ($KU.is(data, 'array')) ? data[2] : data['accessibilityConfig'];

            txt = document.createTextNode(($KU.is(val, 'i18n') ? $KU.getI18Nvalue(val) : val));
            input = $KD.create('INPUT', {type:'checkbox', name:this._kwebfw_.uid, value:key, tabindex:-1});

            $KD.setAttr(input, 'kwh-focusin', 'onCheckBoxFocus');
            $KD.setAttr(input, 'kwh-focusout', 'onCheckBoxBlur');
            $KD.setAttr(input, 'kwh-keydown', 'onCheckBoxKeyDown');

            $KW.applyGroupA11Y(input, a11y, val, (_.uid+'_'+key+'_hint'));

            if(prop.itemOrientation === constants.CHECKBOX_ITEM_ORIENTATION_VERTICAL) {
                $KD.setAttr(holder, 'ko', 'vertical');
            } else if(prop.itemOrientation === constants.CHECKBOX_ITEM_ORIENTATION_HORIZONTAL) {
                $KD.setAttr(holder, 'ko', 'horizontal');
            }

            $KD.add(div, input);
            $KD.add(div, txt);
            $KW.addToView(holder, div);
        }, this);

        $KW.accessibility(this);
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        CheckBoxGroup: {
            masterData: function CheckBoxGroup$_setter_masterData(old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = this._kwebfw_.prop;

                prop.selectedKeys = null;
                prop.selectedKeyValues = null;
                $KW.clearGroupA11y(this, old, prop.masterDataMap);
            },

            masterDataMap: function CheckBoxGroup$_setter_masterDataMap(old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = this._kwebfw_.prop;

                if(!prop.masterData) {
                    prop.selectedKeys = null;
                    prop.selectedKeyValues = null;
                }

                $KW.clearGroupA11y(this, prop.masterData, old);
            },

            selectedKeys: function CheckBoxGroup$_setter_selectedKeys(/* old */) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if(!prop.selectedKeys) {
                    prop.selectedKeyValues = null;
                } else {
                    prop.selectedKeyValues = [];

                    $KU.each(prop.selectedKeys, function(value) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = this._kwebfw_.prop,
                            keyval = $KW.getGroupSelectedKeyValueByKey(this, value);

                        prop.selectedKeyValues.push(keyval);
                    }, this);
                }
            },

            toolTip: function CheckBoxGroup$_setter_toolTip(/* old */) {
                this._kwebfw_.prop.i18n_toolTip = '';
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        CheckBoxGroup: {
            itemOrientation: function CheckBoxGroup$_valid_itemOrientation(value) {
                var options = [
                        constants.CHECKBOX_ITEM_ORIENTATION_HORIZONTAL,
                        constants.CHECKBOX_ITEM_ORIENTATION_VERTICAL
                    ], flag = (options.indexOf(value) >= 0);

                return flag;
            },

            i18n_toolTip: function CheckBoxGroup$_valid_i18n_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            masterData: function CheckBoxGroup$_valid_masterData(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;

                    $KU.each(value, function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if(!$KU.is(item, 'array')) {
                            flag = false;
                            return true;
                        }
                    });
                }

                return flag;
            },

            masterDataMap: function CheckBoxGroup$_valid_masterDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value[0], 'array')
                && $KU.is(value[1], 'string') && value[1]
                && value[2] && $KU.is(value[2], 'string')) {
                    flag = true;

                    $KU.each(value[0], function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if(!$KU.is(item, 'object')) {
                            flag = false;
                            return true;
                        }
                    });
                }

                return flag;
            },

            selectedKeys: function CheckBoxGroup$_valid_selectedKeys(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
                    prop = this._kwebfw_.prop, keys = [];

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && value) {
                    if(prop.masterData || prop.masterDataMap) {
                        $KU.each((prop.masterData || prop.masterDataMap[0]), function(data) {
                            var $K = voltmx.$kwebfw$, $KU = $K.utils;

                            keys.push(($KU.is(data, 'array')) ? data[0] : data[prop.masterDataMap[1]]);
                        });

                        $KU.each(value, function(name) {
                            if(keys.indexOf(name) === -1) {
                                flag = false;
                                return true;
                            }
                        });
                    }
                }

                return flag;
            },

            selectedKeyValues: function CheckBoxGroup$_valid_selectedKeyValues(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            toolTip: function CheckBoxGroup$_valid_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        CheckBoxGroup: {
            itemOrientation: false,

            i18n_toolTip: false,

            masterData: function CheckBoxGroup$_view_masterData(el/* , old */) {
                var $K=voltmx.$kwebfw$, $KW = $K.widget;

                $KW.normalizeGroupMasterData(this);
                _renderCheckBoxGroup.call(this, el.node);
            },

            masterDataMap: function CheckBoxGroup$_view_masterDataMap(el/* , old */) {
                var $K=voltmx.$kwebfw$, $KW = $K.widget;

                $KW.normalizeGroupMasterDataMap(this);
                _renderCheckBoxGroup.call(this, el.node);
            },

            selectedKeys: function CheckBoxGroup$_view_selectedKeys(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                $KU.each($KD.find(el.node, 'input'), function(checkbox) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                    if(!$KU.is(prop.selectedKeys, 'array')) {
                        checkbox.checked = false;
                    } else {
                        checkbox.checked = (prop.selectedKeys.indexOf(checkbox.value) !== -1);
                    }
                }, this);
            },

            selectedKeyValues: false,

            toolTip: function CheckBoxGroup$_view_toolTip(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.toolTip) {
                    $KD.setAttr(el.node, 'title', this.toolTip);
                } else {
                    $KD.removeAttr(el.node, 'title');
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'CheckBoxGroup', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.CheckBoxGroup constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var CheckBoxGroup = function CheckBoxGroup(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    itemOrientation: constants.CHECKBOX_ITEM_ORIENTATION_VERTICAL,
                    i18n_toolTip: '',
                    masterData: null,
                    masterDataMap: null,
                    selectedKeys: null,
                    selectedKeyValues: null,
                    toolTip: ''
                };
            }

            _populateUnderscore.CheckBoxGroup.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            CheckBoxGroup.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.CheckBoxGroup, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.CheckBoxGroup.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to CheckBoxGroup
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.CheckBoxGroup[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.CheckBoxGroup>, but not in <_valid.CheckBoxGroup> namespace.');
                        } else {
                            valid = _valid.CheckBoxGroup[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to CheckBoxGroup
                $KU.each(_view.CheckBoxGroup, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function CheckBoxGroup$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.CheckBoxGroup[key], 'function')) {
                            return _getter.CheckBoxGroup[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function CheckBoxGroup$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.CheckBoxGroup[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.CheckBoxGroup[key], 'function')) {
                                        _setter.CheckBoxGroup[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.CheckBoxGroup().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.CheckBoxGroup().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    p.masterDataMap = null;
                }
                if($KU.is(_postInitialization.CheckBoxGroup, 'function')) {
                    _postInitialization.CheckBoxGroup.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(CheckBoxGroup, voltmx.ui.GroupWidget);


        /**
         * Builds the view layer for voltmx.ui.CheckBoxGroup widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.CheckBoxGroup
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  SampleWidget view.
         */
        var checkboxgroup__render = function CheckBoxGroup$_render(tag) {
            var $super = voltmx.ui.CheckBoxGroup.base.prototype,
                _ = this._kwebfw_, view = _.view, $K = voltmx.$kwebfw$,
                $KW = $K.widget, $KD = $K.dom, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, tag);

                    $KD.setAttr(view, 'kwh-change', 'onChange');
                    $KD.setAttr(view, 'kwh-keydown', 'onKeyDown');
                }

                el = $KW.el(view);

                _renderCheckBoxGroup.call(this, view);
                _view.CheckBoxGroup.selectedKeys.call(this, el, _.prop.selectedKeys);
                _view.CheckBoxGroup.toolTip.call(this, el, this.toolTip);
            }

            return view;
        };


        $K.defVoltmxProp(CheckBoxGroup.prototype, [
            {keey:'_render', value:checkboxgroup__render}
        ]);


        return CheckBoxGroup;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxcollectionview.js' */
//All widget file must have this variable
//All the functions will be called in the scope of widget instance
//These function should always return a boolean value
(function() {
    var $K = voltmx.$kwebfw$, _extraHeightToRender = 200;


    $K.defVoltmxProp($K.ui, [
        {keey:'CollectionView', value:{}, items:[
            {keey:'onKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    model = this._kwebfw_.items[0],
                    code = evt.keyCode || evt.which;

                if(model && model._kwebfw_.view) {
                    if([40].indexOf(code) >= 0) {
                        $KD.preventDefault(evt);

                        if(code === 40) { //Down Arrow
                            $KD.focus($KD.parent(model._kwebfw_.view));
                        }
                    }
                }

                return false;
            }},

            {keey:'doLayout', value:function(/*frame*/) {
                _applyLineSpaceAndItemSpace.call(this);
            }},

            {keey:'onItemSelect', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    index = null, secIndex = -1, itemIndex = -1;

                index = $KD.closest(evt.target, 'kr', 'cvitem');

                if(index) {
                    index = $KD.getAttr(index, 'kii').split(',');
                    secIndex = parseInt(index[0], 10);
                    itemIndex = parseInt(index[1], 10);

                    $K.apm.send(this, 'Touch', {type:(this._kwebfw_.name+'_Item_Click')});
                    $KW.fire(this, 'onItemSelect', this, {secIndex:secIndex, itemIndex:itemIndex});
                }

                return false;
            }},

            {keey:'onItemKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, li = null,
                    code = evt.keyCode || evt.which;
                    //TODO
                if([38, 40].indexOf(code) >= 0) {
                    if(code === 38) { //Up Arrow
                        li = $KD.prev(evt.target);
                    } else if(code === 40) { //Down Arrow
                        li = $KD.next(evt.target);
                    }

                    if(li) {
                        $KD.preventDefault(evt);
                        $KD.focus(li);
                    }
                }

                return false;
            }},

            {keey:'onItemKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    code = evt.keyCode || evt.which, secIndex = -1, itemIndex = -1;
                    //TODO
                if([13, 32].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 13 || code === 32) { //Enter or Space
                        itemIndex = $KD.getAttr(evt.target, 'kii').split(',');
                        secIndex = parseInt(itemIndex[0], 10);
                        itemIndex = parseInt(itemIndex[1], 10);

                        $KW.fire(this, 'onItemSelect', this, {secIndex:secIndex, itemIndex:itemIndex});
                    }
                }

                return false;
            }},

            {keey: 'handleOnItemDisplay', value: function() {
                _animator.CollectionView.handleOnItemDisplay.call(this);
            }},

            {keey: 'isHeaderOrFooter', value: function(template) {
                return _deduceIndex.call(this, template._kwebfw_.ii)[1] < 0;
            }}

        ]}
    ]);


    //All the functions will be called in the scope of widget instance
    //Segment APIs actions - add, update and remove will be called
    var _action = {
        CollectionView: {

            _remove: function CollectionView$_action_remove(secIndex, itemIndex, count) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    el = $KW.el(this), _ = this._kwebfw_, $KU = $K.utils,
                    data = _.prop.data, section = _isSectionDS(data[0]),
                    absIndex = 0, i =0,
                    isItemRendered = _isItemRendered.call(this, secIndex, itemIndex),
                    removeSelectedIndex = -1;

                for(i = 0; i < count; i++) {
                    absIndex = _absoluteItemIndex.call(this, secIndex, itemIndex);

                    if(section) data[secIndex][1].splice(itemIndex, 1);
                    else data.splice(itemIndex, 1);


                    if(_.selectedItems.length > 0) {
                        $KU.each(_.selectedItems, function(item, index) {
                            if(item[0] === secIndex && item[1] > itemIndex) {
                                item[1] = item[1] - 1;
                            } else if(item[0] === secIndex && item[1] === itemIndex) {
                                removeSelectedIndex = index;
                            }
                        });
                        if(removeSelectedIndex !== -1) {
                            _.selectedItems.splice(removeSelectedIndex, 1);
                        }
                        _setSelectedItemsRelatedProperties.call(this);
                    }

                    if(el.node) {
                        if(section) {
                            _flushClones(_.clones[secIndex][1][itemIndex]);
                            _.clones[secIndex][1].splice(itemIndex, 1);
                        } else {
                            _flushClones(_.clones[itemIndex]);
                            _.clones.splice(itemIndex, 1);
                        }

                        if(isItemRendered) {
                            _.items.splice(absIndex, 1);
                            $KD.removeAt(el.scrolee, absIndex);
                        }
                    }
                }
                if(el.node) _updateIndexes.call(this, 0, -1);
            },

            _removeAll: function CollectionView$_action_removeAll() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    el = null, _ = this._kwebfw_;

                _.prop.data = [];
                _.items = [];
                _flushClones(_.clones);
                _.clones = [];
                _clearSelectedIndices.call(this);

                if(_.view) {
                    el = $KW.el(this);
                    $KD.html(el.scrolee, '');
                    $KD.setAttr(el.scrolee, 'aria-itemcount', 0);
                }
            },

            _removeSectionAt: function CollectionView$_action_removeSectionAt(secIndex, itemIndex, updateIndicesFlag, count) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    $KU =$K.utils, _ = this._kwebfw_, data = _.prop.data,
                    clones = null, el = $KW.el(this), removeSelectedSectionIndices = [],
                    absIndex = 0, i = 0;


                if(!$KU.is(updateIndicesFlag, 'boolean')) updateIndicesFlag = true;

                if(updateIndicesFlag && _.selectedItems.length > 0) {
                    $KU.each(_.selectedItems, function(item, index) {
                        if(item[0] > secIndex + count) {
                            item[0] = item[0] - count;
                        } else if(item[0] >= secIndex && item[0] <= secIndex + count) {
                            removeSelectedSectionIndices.push(index);
                        }
                    });
                    $KU.each(removeSelectedSectionIndices, function(index) {
                        _.selectedItems.splice(index, 1);
                    });
                    _setSelectedItemsRelatedProperties.call(this);
                }

                if(el.node) {
                    for(i = 0; i < count; i++) {
                        absIndex = _absoluteItemIndex.call(this, secIndex, itemIndex);
                        clones = _.clones[secIndex];
                        //remove data of the given section index
                        data.splice(secIndex, 1);
                        //header node removal of given section index
                        if(clones[0] && clones[0].isVisible) {
                            $KD.removeAt(el.scrolee, absIndex);
                            _.items.splice(absIndex, 1);
                        }

                        //item nodes removal of given section index
                        $KU.each(clones[1], function(clone) {
                            if(clone && clone.isVisible) {
                                $KD.removeAt(el.scrolee, absIndex);
                                _.items.splice(absIndex, 1);
                            }
                        });

                        if(clones[2] && clones[2].isVisible) {
                            $KD.removeAt(el.scrolee, absIndex);
                            _.items.splice(absIndex, 1);
                        }

                        _flushClones(_.clones[secIndex]);
                        _.clones.splice(secIndex, 1);
                    }
                    if(updateIndicesFlag) _updateIndexes.call(this, 0, -1);
                }
            },


            add: function CollectionView$_action_add(secIndex, itemIndex, widgetdata, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, $KU = $K.utils,
                    clone = null, el = $KW.el(this), _ = this._kwebfw_,
                    data = _.prop.data, section = _isSectionDS(data[0]),
                    absIndex = null, itemNode = null,
                    /*eslint-disable no-unused-vars*/ widgetData = null /*eslint-enable no-unused-vars*/;

                if($KU.is(widgetdata, 'object')) {
                    widgetData = [widgetdata];
                }

                _iterateOverData.call(this, widgetdata, function(widgetdata, counter) {
                    if(section) data[secIndex][1].splice(itemIndex + counter, 0, widgetdata);
                    else data.splice(itemIndex + counter, 0, widgetdata);

                    absIndex = _absoluteItemIndex.call(this, secIndex, itemIndex + counter);

                    if(_.selectedItems.length > 0) {
                        $KU.each(_.selectedItems, function(item) {
                            if(item[1] >= itemIndex + counter) {
                                item[1] = item[1] + 1;
                            }
                        });
                        _setSelectedItemsRelatedProperties.call(this);
                    }

                    if(el.node) {
                        if(section) _.clones[secIndex][1].splice(itemIndex + counter, 0, null);
                        else _.clones.splice(itemIndex + counter, 0, null);

                        clone = _getClonedTemplate.call(this, [secIndex, itemIndex + counter]);

                        if(clone) {
                            itemNode = _renderItems.call(this, [clone]);
                            if(absIndex === _.items.length) {
                                _.items.push(clone);
                                $KD.add(el.scrolee, itemNode);
                            } else {
                                _.items.splice(absIndex, 0, clone);
                                $KD.addAt(el.scrolee, itemNode, absIndex);
                            }

                            if(secIndex === -1) secIndex = 0;

                            if(_animator.CollectionView.canAnimate.call(this, anim)) {
                                _animator.CollectionView.onItemDisplayHandler.call(this, voltmx.segment.ADD, [clone]);
                                _animator.CollectionView.applyItemsAnimationByAPI.call(this, 'adddataat', itemNode, itemIndex + counter, secIndex, anim);
                            }
                        }
                    }
                });

                if(el.node) {
                    _updateIndexes.call(this, 0, -1);
                }
            },

            update: function CollectionView$_action_update(secIndex, itemIndex, widgetdata, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, $KU = $K.utils,
                    clone = null, el = $KW.el(this), _ = this._kwebfw_,
                    data = _.prop.data, section = _isSectionDS(data[0]),
                    absIndex = 0,
                    isItemRendered = _isItemRendered.call(this, secIndex, itemIndex),
                    itemNode = null,
                    /*eslint-disable no-unused-vars*/ widgetData = null /*eslint-enable no-unused-vars*/;

                if($KU.is(widgetdata, 'object')) {
                    widgetData = [widgetdata];
                }

                _iterateOverData.call(this, widgetdata, function(widgetdata, counter) {
                    if(section) data[secIndex][1][itemIndex + counter] = widgetdata;
                    else data[itemIndex + counter] = widgetdata;

                    if(_.selectedItems.length > 0) {
                        $KU.each(_.selectedItems, function(item, index) {
                            if(item[0] === secIndex && item[1] === itemIndex + counter) {
                                _.selectedItems.splice(index, 1);
                                return true;
                            }
                        });
                        _setSelectedItemsRelatedProperties.call(this);
                    }

                    if(el.node) {
                        absIndex = _absoluteItemIndex.call(this, secIndex, itemIndex + counter);
                        if(section) {
                            _flushClones(_.clones[secIndex][1][itemIndex + counter]);
                            _.clones[secIndex][1][itemIndex + counter] = null;
                        } else {
                            _flushClones(_.clones[itemIndex + counter]);
                            _.clones[itemIndex + counter] = null;
                        }

                        clone = _getClonedTemplate.call(this, [secIndex, itemIndex + counter]);

                        if(clone) {
                            itemNode = _renderItems.call(this, [clone]);
                            if(isItemRendered) {
                                _.items[absIndex] = clone;
                                $KD.replace(itemNode, $KD.childAt(el.scrolee, absIndex));
                            } else {
                                if(absIndex === _.items.length) {
                                    _.items.push(clone);
                                    $KD.add(el.scrolee, itemNode);
                                } else {
                                    _.items.splice(absIndex, 0, clone);
                                    $KD.addAt(el.scrolee, itemNode, absIndex);
                                }
                            }

                            if(secIndex === -1) secIndex = 0;

                            if(_animator.CollectionView.canAnimate.call(this, anim)) {
                                _animator.CollectionView.onItemDisplayHandler.call(this, voltmx.segment.UPDATE, [clone]);
                                _animator.CollectionView.applyItemsAnimationByAPI.call(this, 'setdataat', itemNode, itemIndex, secIndex, anim);
                            }
                        }
                    }
                });
            },

            remove: function CollectionView$_action_remove(secIndex, itemIndex, count, anim) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    _ = this._kwebfw_, absIndex = null, itemNode = null;
                if(_animator.CollectionView.canAnimate.call(this, anim)) {
                    absIndex = _absoluteItemIndex.call(this, secIndex, itemIndex);
                    itemNode = $KD.parent(_.items[absIndex]._kwebfw_.view);
                    _animator.CollectionView.onItemDisplayHandler.call(this, voltmx.segment.REMOVE, [_.items[absIndex]]);
                    _animator.CollectionView.applyItemsAnimationByAPI.call(this, 'removeat', itemNode, itemIndex, secIndex, anim);
                } else {
                    _action.CollectionView._remove.call(this, secIndex, itemIndex, count);
                }
            },

            addall: function CollectionView$_action_addall(secIndex, itemIndex, newdata, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    clones = null, el = $KW.el(this), _ = this._kwebfw_,
                    data = _.prop.data, items = null, prevLength;

                data.push.apply(data, newdata);

                if(el.node) {
                    clones = _getRenderableClones.call(this, [secIndex, itemIndex]);
                    if(clones.length > 0) {
                        prevLength = $KD.children(el.scrolee).length;
                        $KD.add(el.scrolee, _renderItems.call(this, clones));
                        _.items.push.apply(_.items, clones);

                        if(_animator.CollectionView.canAnimate.call(this, anim)) {
                            items = [].slice.call($KD.children(el.scrolee), prevLength);
                            _animator.CollectionView.onItemDisplayHandler.call(this, voltmx.segment.ADD, clones);
                            _animator.CollectionView.applyItemsAnimationByAPI.call(this, 'addall', items, -1, -1, anim);
                        }
                    }
                    //_updateIndexes.call(this, 0, -1);
                }
            },

            addsectionat: function CollectionView$_action_addsectionat(secIndex, itemIndex, newdata, updateIndicesFlag, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, $KU = $K.utils,
                    clones = null, el = $KW.el(this), _ = this._kwebfw_, data = _.prop.data,
                    absIndex = 0, prevLength, items = [], item = null;

                if(!$KU.is(updateIndicesFlag, 'boolean')) updateIndicesFlag = true;


                if(updateIndicesFlag && _.selectedItems.length > 0) {
                    $KU.each(_.selectedItems, function(item) {
                        if(item[0] >= secIndex) {
                            item[0] = item[0] + newdata.length;
                        }
                    });
                    _setSelectedItemsRelatedProperties.call(this);
                }

                if(el.node) {
                    $KU.each(newdata, function(newdata, counter) {
                        data.splice(secIndex + counter, 0, newdata);
                        _.clones.splice(secIndex + counter, 0, null);
                        clones = _getRenderableClones.call(this, [secIndex + counter, itemIndex], [secIndex + counter, newdata.length]);//TODO
                        absIndex = _absoluteItemIndex.call(this, secIndex + counter, itemIndex);
                        if(absIndex === _.items.length) {
                            if(clones.length > 0) {
                                prevLength = $KD.children(el.scrolee).length;
                                $KD.add(el.scrolee, _renderItems.call(this, clones));
                                _.items.splice.apply(_.items, [absIndex, 0].concat(clones));
                                if(_animator.CollectionView.canAnimate.call(this, anim)) {
                                    items = [].slice.call($KD.children(el.scrolee), prevLength);
                                    _animator.CollectionView.onItemDisplayHandler.call(this, updateIndicesFlag ? voltmx.segment.ADD: voltmx.segment.UPDATE, clones);
                                    _animator.CollectionView.applyItemsAnimationByAPI.call(this, 'addsectionat', items, -1, -1, anim);
                                }
                            }
                        } else {
                            _.items.splice.apply(_.items, [absIndex, 0].concat(clones));
                            $KU.each(clones, function(clone/*, ii*/) {
                                item = _renderItems.call(this, [clone]);
                                items.push(item);
                                $KD.addAt(el.scrolee, item, absIndex++);
                            }, this);
                            if(_animator.CollectionView.canAnimate.call(this, anim)) {
                                _animator.CollectionView.onItemDisplayHandler.call(this, updateIndicesFlag ? voltmx.segment.ADD: voltmx.segment.UPDATE, clones);
                                _animator.CollectionView.applyItemsAnimationByAPI.call(this, 'addsectionat', items, -1, -1, anim);
                            }
                        }
                    }, this);
                    if(updateIndicesFlag) _updateIndexes.call(this, 0, -1);
                } else {
                    $KU.each(newdata, function(newdata, counter) {
                        data.splice(secIndex + counter, 0, newdata);
                    }, this);
                }
            },

            setsectionat: function CollectionView$_action_setsectionat(secIndex, itemIndex, newdata, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this),
                    _ = this._kwebfw_;

                _action.CollectionView.removesectionat.call(this, secIndex, itemIndex, false, newdata.length);
                _action.CollectionView.addsectionat.call(this, secIndex, itemIndex, newdata, false, anim);
                if(_.selectedItems.length > 0) {
                    _.selectedItems.splice(0, _.selectedItems.length);
                    _setSelectedItemsRelatedProperties.call(this);
                }
                if(el.node) _updateIndexes.call(this, 0, -1);
            },

            removesectionat: function CollectionView$_action_removesectionat(secIndex, itemIndex, updateIndicesFlag, count, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    $KU =$K.utils, _ = this._kwebfw_, clones = null, counter = 0,
                    el = $KW.el(this), absIndex = null, items = [], cloneModels = [];

                if(_animator.CollectionView.canAnimate.call(this, anim)) {
                    absIndex = _absoluteItemIndex.call(this, secIndex, itemIndex);
                    if(el.node) {
                        clones = _.clones[secIndex];
                        //header node removal of given section index
                        if(clones[0] && clones[0].isVisible) {
                            items.push($KD.childAt(el.scrolee, absIndex));
                            counter ++;
                        }

                        //item nodes removal of given section index
                        $KU.each(clones[1], function(clone) {
                            if(clone && clone.isVisible) {
                                items.push($KD.childAt(el.scrolee, absIndex + counter));
                                cloneModels.push(clone);
                                counter ++;
                            }
                        });
                    }
                    _animator.CollectionView.onItemDisplayHandler.call(this, voltmx.segment.REMOVE, cloneModels);
                    _animator.CollectionView.applyItemsAnimationByAPI.call(this, 'removesectionat', items, itemIndex, secIndex, anim);
                } else {
                    _action.CollectionView._removeSectionAt.call(this, secIndex, itemIndex, updateIndicesFlag, count);
                }
            }

        }
    };


    //All the functions will be called in the scope of widget instance
    var _animator = {
        CollectionView: {
            applyItemsAnimationByAPI: function CollectionView$_animator_applyItemsAnimationByAPI(action, listItems, itemIndex, secIndex, animObj) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    animDef = null, segmodel = this, item = null,
                    items = [],
                    _wrapRemoveAtCallback = function(callback) {
                        var wrapper = function() {
                            _action.CollectionView._remove.call(segmodel, secIndex, itemIndex);
                            callback && callback.apply(this, arguments);
                        };
                        return wrapper;
                    },
                    _wrapRemoveAllCallback = function(callback) {
                        var wrapper = function() {
                            _action.CollectionView._removeAll.call(segmodel);
                            callback && callback.apply(this, arguments);
                        };
                        return wrapper;
                    },
                    _wrapRemoveSectionAtCallback = function(callback) {
                        var wrapper = function() {
                            _action.CollectionView._removeSectionAt.call(segmodel, secIndex, itemIndex, true);
                            callback && callback.apply(this, arguments);
                        };
                        return wrapper;
                    };

                animDef = animObj.definition;

                if(action === 'removeat') {
                    if(!animObj.callbacks) animObj.callbacks = {};
                    animObj.callbacks.animationEnd = _wrapRemoveAtCallback(animObj.callbacks.animationEnd);
                }

                if(action === 'removeall') {
                    if(!animObj.callbacks) animObj.callbacks = {};
                    animObj.callbacks.animationEnd = _wrapRemoveAllCallback(animObj.callbacks.animationEnd);
                }

                if(action === 'removesectionat') {
                    if(!animObj.callbacks) animObj.callbacks = {};
                    animObj.callbacks.animationEnd = _wrapRemoveSectionAtCallback(animObj.callbacks.animationEnd);
                }

                switch(action) {
                    case 'adddataat':
                    case 'setdataat':
                    case 'removeat':
                        item = listItems.firstChild;
                        animDef.applyItemAnimation([item], animObj.config, animObj.callbacks);
                        break;

                    case 'addall':
                    case 'addsectionat':
                    case 'removesectionat':
                        $KU.each(listItems, function(item) {
                            items.push(item.firstChild);
                        });
                        animDef.applyItemAnimation(items, animObj.config, animObj.callbacks);
                        break;

                    case 'setdata':
                    case 'removeall':
                        $KU.each(listItems, function(item) {
                            items.push(item._kwebfw_.view);
                        });
                        animDef.applyItemAnimation(items, animObj.config, animObj.callbacks);
                        break;
                    default:
                        break;
                }
            },

            animateItems: function CollectionView$_animator_animateItems(animContext) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, animInfo = {},
                    el = $KW.el(this), items = [], widgetId, widgets = [], elsToAnimate = [];

                if($KU.is(el.node, 'null')) {
                    return;
                }

                if(animContext) {
                    items = animContext.context || animContext.items;
                    animInfo = animContext.animation;
                    if(!items || !$KU.is(items, 'array') || !animInfo || !animInfo.definition) {
                        return;
                    }

                    widgetId = animContext.widgetID;
                    widgets = animContext.widgets || [];

                    if(widgetId) widgets.push(widgetId);

                    $KU.each(items, function(itemContext/*, key*/) {
                        var absIndex = 0, model = null, templateModel = null,
                            el = null;

                        absIndex = _absoluteItemIndex.call(this, itemContext.sectionIndex, itemContext.itemIndex);
                        templateModel = this._kwebfw_.items[absIndex];
                        if(templateModel._kwebfw_.view) {//template visible false case
                            if(widgets.length) {
                                $KU.each(widgets, function(widgetId/*, key*/) {
                                    model = templateModel[widgetId];
                                    el = model._kwebfw_.view;
                                    elsToAnimate.push(el);
                                });
                            } else {
                                model = templateModel;
                                el = model._kwebfw_.view;
                                elsToAnimate.push(el);
                            }
                        }
                    }, this);
                }
                animInfo.definition.applyItemAnimation(elsToAnimate, animInfo.config, animInfo.callbacks);
            },

            caf: function CollectionView$_animator_caf(callback) {
                cancelAnimationFrame(callback);
            },

            canAnimate: function CollectionView$_animator_canAnimate(animObj) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, result = true;


                if(!animObj || !animObj.definition || !animObj.definition.applyItemAnimation) {
                    result = false;
                }

                if(!$KW.visible(this)) {
                    result = false;
                }

                return result;
            },

            getItemVisibleState: function CollectionView$_animator_getItemVisibleState(li) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, el = null, offsetTop,
                    offsetHeight, scrollTop, segHeight, state;

                el = $KW.el(this);

                offsetTop = li.offsetTop;
                offsetHeight = li.offsetHeight;

                scrollTop = el.viewport.scrollTop;
                segHeight = el.viewport.offsetHeight;

                if(offsetTop + offsetHeight <= scrollTop) {
                    state = 'past';
                } else if(offsetTop >= scrollTop + segHeight) {
                    state = 'future';
                } else {
                    state = 'present';
                }

                return state;
            },

            handleStateAnimations: function CollectionView$_animator_handleStateAnimations() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils, $KD = $K.dom,
                    visibleFirstItem = null, visibleLastItem = null, _ = this._kwebfw_;

                if(_.prop.onItemDisplay) {
                    visibleFirstItem = _getVisibleItem.call(this, {firstItem: true, lastItem: false});
                    visibleLastItem = _getVisibleItem.call(this, {firstItem: false, lastItem: true});
                }

                $KU.each(_.items, function(clone/*, index*/) {
                    var li = null, state = null, animObj = null, visibleState = null, currentItemContext = null;

                    if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                        li = $KD.closest(clone._kwebfw_.view, 'kr', 'cvitem');
                    }

                    if(li) {
                        state = _animator.CollectionView.getItemVisibleState.call(this, li);
                        if(clone._kwebfw_.animState !== state) {
                            if(state === 'present') {
                                animObj = _.visibleAnim;
                                visibleState = voltmx.segment.VISIBLE;
                            } else {
                                animObj = _.invisibleAnim;
                                visibleState = voltmx.segment.INVISIBLE;
                            }

                            currentItemContext = _getItemContext(clone);
                            if(this._kwebfw_.prop.onItemDisplay && currentItemContext.itemIndex !== -1) {
                                $KW.fire(this, 'onItemDisplay', this,
                                    {
                                        model: this,
                                        state : visibleState,
                                        currentItemContext: currentItemContext,
                                        startItemContext: visibleFirstItem,
                                        endItemContext: visibleLastItem
                                    }
                                );
                            }

                            if(animObj) {
                                animObj.definition.applyItemAnimation([clone], animObj.config, animObj.callbacks);
                            }
                            clone._kwebfw_.animState = state;
                        }
                    }
                }, this);

                this._kwebfw_.rafValue = _animator.CollectionView.raf(_animator.CollectionView.handleStateAnimations.bind(this));
            },

            handleOnItemDisplay: function() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
                    visibleItems, allItems = this._kwebfw_.items, config, itemContext;
                if(this._kwebfw_.view && this.onItemDisplay) {
                    visibleItems = _getVisibleItems.call(this, {indices: false});
                    $KU.each(visibleItems, function(item) {
                        if(!item._kwebfw_.onItemDisplayExecuted) {
                            item._kwebfw_.onItemDisplayExecuted = true;
                            itemContext = _getItemContext(item);
                            config = {
                                sectionIndex: itemContext.sectionIndex,
                                itemIndex: itemContext.itemIndex,
                                itemModel: item
                            };
                            $KW.fire(this, 'onItemDisplay', this, config);
                        }
                    }, this);
                    $KU.each(allItems, function(item) {
                        if(visibleItems.indexOf(item) === -1) {
                            item._kwebfw_.onItemDisplayExecuted = false;
                        }
                    }, this);
                }
            },

            onItemDisplayHandler: function CollectionView$_animator_onItemDisplayHandler(action, items) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils, _ = this._kwebfw_,
                    visibleFirstItem = null, visibleLastItem = null,
                    config = {}, currentItemContext = null;

                if(_.prop.onItemDisplay) {
                    visibleFirstItem = _getVisibleItem.call(this, {firstItem: true, lastItem: false});
                    visibleLastItem = _getVisibleItem.call(this, {firstItem: false, lastItem: true});

                    $KU.each(items, function(clone/*, index*/) {
                        currentItemContext = _getItemContext(clone);
                        config = {
                            model: this,
                            state : action,
                            currentItemContext: currentItemContext,
                            startItemContext: visibleFirstItem,
                            endItemContext: visibleLastItem
                        };
                        if(currentItemContext.itemIndex !== -1) {
                            $KW.fire(this, 'onItemDisplay', this, config);
                        }
                    }, this);
                }
            },

            raf: function CollectionView$_animator_raf(callback) {
                return requestAnimationFrame(callback);
            },

            scrolled: false,

            scrollEnd: function CollectionView$_animator_scrollEnd() {
                this._kwebfw_.rafValue && _animator.CollectionView.caf(this._kwebfw_.rafValue);
            },

            scrollStart: function CollectionView$_animator_scrollStart() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    segNode = null, model = null;

                segNode = $KD.closest(this, 'kw');
                if(segNode) {
                    model = $KW.model(segNode);

                    if(!_animator.CollectionView.scrolled) {
                        if(model._kwebfw_.visibleAnim
                               || model._kwebfw_.invisibleAnim
                               || model._kwebfw_.prop.onItemDisplay) {
                            _animator.CollectionView.setAnimationStates.call(model);
                            model._kwebfw_.rafValue = _animator.CollectionView.raf(_animator.CollectionView.handleStateAnimations.bind(model));
                        }
                        _animator.CollectionView.scrolled = true;
                    }

                    if(_animator.CollectionView.scrollTimer) {
                        clearTimeout(_animator.CollectionView.scrollTimer);
                    }

                    _animator.CollectionView.scrollTimer = setTimeout(function() {
                        _animator.CollectionView.scrollEnd.call(model);
                        clearTimeout(_animator.CollectionView.scrollTimer);
                        _animator.CollectionView.scrollTimer = null;
                        _animator.CollectionView.scrolled = false;
                    }, 250);
                }
            },

            scrollTimer: null,

            setAnimations: function CollectionView$_animator_setAnimations(animInfo) {
                var animObj = null, _ = this._kwebfw_;

                _.visibleAnim = null;
                _.invisibleAnim = null;

                if(animInfo) {
                    if(animInfo.visible) {
                        animObj = animInfo.visible;
                        if(animObj && animObj.definition && animObj.definition.applyItemAnimation) {
                            _.visibleAnim = animObj;
                        }
                    }

                    if(animInfo.invisible) {
                        animObj = animInfo.invisible;
                        if(animObj && animObj.definition && animObj.definition.applyItemAnimation) {
                            _.invisibleAnim = animObj;
                        }
                    }
                }
            },

            setAnimationStates: function CollectionView$_animator_setAnimationStates() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                $KU.each(this._kwebfw_.items, function(clone/*, index*/) {
                    var li = null, state = null;

                    if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                        li = $KD.closest(clone._kwebfw_.view, 'kr', 'cvitem');
                    }

                    if(li) {
                        state = _animator.CollectionView.getItemVisibleState.call(this, li);
                        clone._kwebfw_.animState = state;
                    }
                }, this);
            }
        }
    };


    //This function will be called in the scope of widget instance
    //This function is not yet tested, specially when section index value is there
    var _absoluteIndex = function CollectionView$_absoluteIndex(index) {
        var data = this._kwebfw_.prop.data, absIndex = -1, secIndex = -1, itemIndex = -1;

        index = _deduceIndex.call(this, index);
        secIndex = index[0]; itemIndex = index[1];

        if(!(secIndex === -1 && itemIndex === -1)) {
            if(_isSectionDS(data[0])) {
                if(secIndex >= 0) {
                    if(secIndex < data.length) {
                        for(index=0; index<=secIndex; index++) {
                            absIndex += 1;

                            if(index < secIndex) {
                                absIndex += data[index][1].length;
                            } else if(itemIndex > -1 && itemIndex < data[index][1].length) {
                                absIndex += (itemIndex + 1);
                            }
                        }
                    } else {
                        //SectionIndex exceeds its max boundary for a sectionable segment.
                    }
                } else {
                    //Negative SectionIndex found for a sectionable segment.
                }
            } else { //Non sectionable segment
                if(itemIndex >= 0) {
                    if(itemIndex < data.length) {
                        absIndex = itemIndex;
                    } else {
                        //ItemIndex exceeds its max boundary for a non-sectionable segment.
                    }
                } else {
                    //Negative ItemIndex found for a non-sectionable segment.
                }
            }
        }


        return absIndex;
    };


    //This function will be called in the scope of widget instance
    //This function is not yet tested, specially when section index value is there
    var _absoluteItemIndex = function CollectionView$_absoluteItemIndex(secIndex, itemIndex) {
        var absIndex = 0, _ = this._kwebfw_, data = _.prop.data, clones = _.clones;

        var increment = function(clone, index) {
            if(clone && clone.isVisible) index++;

            return index;
        };

        if(clones.length <= 0) {
            return absIndex;
        }


        if(_isSectionDS(data[0])) {
            if(itemIndex === -1) {
                secIndex--;
                if(secIndex >= 0) {
                    itemIndex = data[secIndex][1].length - 1;
                    if(data[secIndex][2]) itemIndex++;
                }
            } else {
                itemIndex = itemIndex - 1;
            }
            while(secIndex < data.length && secIndex >= 0) {
                if(itemIndex === -1) {
                    absIndex = increment(clones[secIndex][0], absIndex);
                    secIndex--;
                    if(secIndex >= 0) {
                        itemIndex = data[secIndex][1].length - 1;
                        if(data[secIndex][2]) itemIndex++;
                    }
                } else {
                    if(itemIndex <= data[secIndex][1].length && itemIndex > -1) {
                        if(itemIndex === data[secIndex][1].length) {
                            absIndex = increment(clones[secIndex][2], absIndex);
                        } else {
                            absIndex = increment(clones[secIndex][1][itemIndex], absIndex);
                        }
                        itemIndex--;
                    }
                }
            }
        } else {
            itemIndex = itemIndex - 1;
            while(itemIndex < data.length && itemIndex >= 0) {
                absIndex = increment(clones[itemIndex], absIndex);
                itemIndex--;
            }
        }


        return absIndex;
    };

    //This function will be called in the scope of widget instance
    var _applyNodeStyles = function CollectionView$_applyNodeStyles() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.each(this._kwebfw_.items, function(clone, index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                div = null;

            if(!$KU.is(clone, 'null')) {
                div = clone._kwebfw_.view;
            }

            if(div) {
                _applyItemAndHeaderSkin.call(this, div, clone, index);
            }
        }, this);
    };

    var _applyLineSpaceAndItemSpace = function CollectionView$__applyLineSpaceAndItemSpace() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget;
        var _applyMarginForLastItem = function(model, width, height) {//TODO
                var parentNode = $KW.el(model).node;
                if(model.layout === voltmx.collectionview.LAYOUT_HORIZONTAL) {
                    var hBorder = parseInt($KD.style(parentNode, 'border-left-width'), 10) + parseInt($KD.style(parentNode, 'border-right-width'), 10);
                    var cvWidth = model._kwebfw_.prop.frame.width - hBorder;
                    let gapWidth = getGapCollectionViewGrid(cvWidth, collectionViewItemWidth, itemNodes.length - countHeaderFooter, itemSpace);//Issue fix for collection view remove extra margin-right to the div
                    if(gapWidth == 0) {
                        $KD.style(prevWidget.flexNode, 'margin-right','0px');
                    } else {
                        $KD.style(prevWidget.flexNode, 'margin-right', cvWidth - width - gapWidth+ 'px');
                    }
                    if (isFirstItem && totalBoxes == 1) {
                        $KD.style(prevWidget.flexNode, 'margin-left', (cvWidth - collectionViewItemWidth) / 2 + 'px');
                        $KD.style(prevWidget.flexNode, 'margin-right', (cvWidth - collectionViewItemWidth) / 2 + 'px');
                    }
                } else if(model.layout === voltmx.collectionview.LAYOUT_VERTICAL) {
                    var vBorder = parseInt($KD.style(parentNode, 'border-top-width'), 10) + parseInt($KD.style(parentNode, 'border-bottom-width'), 10);
                    var cvHeight = model._kwebfw_.prop.frame.height - vBorder;
                    let gapHeight = getGapCollectionViewGrid(cvHeight, collectionViewItemHeight, itemNodes.length - countHeaderFooter, itemSpace);//Issue fix for collection view remove extra margin-bottom to the div
                    if(gapHeight == 0) {
                        $KD.style(prevWidget.flexNode, 'margin-bottom','0px');
                    } else {
                        $KD.style(prevWidget.flexNode, 'margin-bottom', cvHeight - height - gapHeight + 'px');
                    }
                    if (isFirstItem && totalBoxes == 1) {
                        $KD.style(prevWidget.flexNode, 'margin-top', (cvHeight - collectionViewItemHeight) / 2 + 'px');
                        $KD.style(prevWidget.flexNode, 'margin-bottom', (cvHeight - collectionViewItemHeight) / 2 + 'px');
                    }
                }
            },
            //Issue fix for collection view remove extra margin-right to the div
            getGapCollectionViewGrid = function(parentWidth, childWidth, totalData, itemSpace) {
                let noOfBoxLeft = getNumberOfDivLeft(parentWidth, childWidth, totalData, itemSpace);
                  if(itemSpace == 0) {
                    totalBoxes = parseInt(parentWidth / childWidth);
                  }
                  let totalGapWidth = parentWidth - (totalBoxes * childWidth);
                  let gapBetweenEachBox = totalGapWidth / (totalBoxes - 1);
                  if(noOfBoxLeft == 0) {
                    return 0;
                  } else if(itemSpace > 0){
                    let x = gapBetweenEachBox*(box - 1);
                    let y = ((box > 1) ? (box - 1)*itemSpace : box*itemSpace);
                    console.log("X=>",x);
                    console.log("Y=>",y);
                    return (Math.abs(x - y));                    
                  }
                  return (gapBetweenEachBox*(noOfBoxLeft -1));
            },
            getNumberOfDivLeft = function(parentWidth, childWidth, totalData, itemSpace) {
              let noOfBoxLeft = 0;
              if(itemSpace == 0) {
                totalBoxes = parseInt(parentWidth / childWidth);
                let totalGapWidth = parentWidth - (totalBoxes * childWidth);
                noOfBoxLeft = totalData % totalBoxes;
              } else {
                totalBoxes = 0;
                let widthSum = 0;
                while(widthSum <= parentWidth) {                   
                  widthSum = widthSum + childWidth;                   
                  if(widthSum < parentWidth){
                   widthSum = widthSum + itemSpace; 
                   totalBoxes++;                   
                  }
                  if(widthSum == parentWidth || widthSum > parentWidth){
                   break; 
                  }                  
                }
                box = totalData % totalBoxes;
                noOfBoxLeft = (box == 0) ? 0 : (totalBoxes - box);
              }
              return noOfBoxLeft;
            },
            _isItOfNewRow = function(width, currentSum, parentWidth) {
                return width + currentSum > parentWidth;
            },
            _isItOfNewColumn = function(height, currentSum, parentHieght) {
                return height + currentSum > parentHieght;
            },
            _getNodeAndModel = function(itemNode) {//TODO
                var flexModel = null, index;

                if(itemNode) {
                    index = itemNode.getAttribute('kii').split(',');
                    flexModel = _getClonedTemplate.call(this, parseInt(index[0]), parseInt(index[1]));

                    return {
                        flexNode: itemNode,
                        flexModel: flexModel
                    };
                }
            },
            _resetMargin = function(wNode) {
                $KD.style(wNode, 'margin', null);
            },
            canApplyTop = false, //in Horizontal layout need to apply top(to achieve line space).This will set to true once second row is reached.
            canApplyLeft = false, //in Vertical layout need to apply left(to achieve line space).This will set to true once second column is reached.
            currSectionIndex = -1,
            currWidget = null,
            cvWidth = this._kwebfw_.prop.frame.width,
            cvHeight = this._kwebfw_.prop.frame.height,
            data = this.data,
            el = $KW.el(this),
            height = 0,
            heightSum = 0, //Sume of the widgtes height while iterating.User for setting flag canApplyLeft
            i = 0,
            itemNode = null,
            itemNodes = [],
            isFirstItem = true,
            itemSpace = parseInt(_convertFlexPropertyToCssUnit(this.minItemSpace, 'px'), 10),
            lineSpace = parseInt(_convertFlexPropertyToCssUnit(this.minLineSpace, 'px'), 10),
            prevSecIndex = -1,
            prevHeight = 0,
            prevWidget = null,
            width = 0,
            WidthSum = 0; //sum of the widgets width while iterating.User for setting flag canApplyTop
            countHeaderFooter = 0; // this is used for is header and footer both are present 
            collectionViewItemWidth = 0;
            collectionViewItemHeight = 0;
            totalBoxes = 0;
            box = 0;

        if(data && data.length > 0) {
            //checking for negative input
            itemSpace = (itemSpace < 0) ? 0 : itemSpace;
            lineSpace = (lineSpace < 0) ? 0 : lineSpace;

            itemNodes = el.scrolee.children;
            for(i = 0; i < itemNodes.length; i++) {
                itemNode = itemNodes[i];
                if(itemNode) {
                    if(_isSectionDS(data[0])) {
                        currSectionIndex = parseInt($KD.getAttr(itemNode, 'kii').split(',')[0]);
                        if(prevSecIndex !== currSectionIndex) {
                            prevWidget && _applyMarginForLastItem(this, WidthSum, heightSum);
                            prevWidget = undefined;
                            canApplyTop = canApplyLeft = 0;
                            heightSum = WidthSum = 0;
                            isFirstItem = true;
                            prevSecIndex = currSectionIndex;
                        }
                    }
                    /*eslint-disable no-continue*/
                    if(parseInt($KD.getAttr(itemNode, 'kii').split(',')[1]) < 0) {//header or footer case
                        countHeaderFooter++;
                        continue;
                    }
                    /*eslint-enable no-continue*/
                    currWidget = _getNodeAndModel.call(this, itemNode);//TODO
                    _resetMargin(currWidget.flexNode);
                    if(this.layout === voltmx.collectionview.LAYOUT_HORIZONTAL) {
                        width = itemNode.offsetWidth;//TODO
                        collectionViewItemWidth = itemNode.offsetWidth;
                        if(prevWidget && _isItOfNewRow(width, WidthSum + itemSpace, cvWidth)) {
                            WidthSum = 0;
                            canApplyTop = true;
                            if(isFirstItem) {
                                var prevWidth = prevWidget.flexNode.offsetWidth;//TODO
                                $KD.style(prevWidget.flexNode, 'margin-left', (cvWidth - prevWidth) / 2 + 'px');//TODO
                                $KD.style(prevWidget.flexNode, 'margin-right', (cvWidth - prevWidth) / 2 + 'px');//TODO
                            }
                            isFirstItem = true;
                        } else if(prevWidget) {
                            $KD.style(prevWidget.flexNode, 'margin-right', itemSpace + 'px');//TODO
                            WidthSum += itemSpace;
                            isFirstItem = false;
                        }
                        WidthSum += width;
                        if(canApplyTop) {
                            $KD.style(currWidget.flexNode, 'margin-top', lineSpace + 'px');//TODO
                        }
                    } else if(this.layout === voltmx.collectionview.LAYOUT_VERTICAL) {
                        height = itemNode.offsetHeight;
                        collectionViewItemHeight = itemNode.offsetHeight;
                        if(prevWidget && _isItOfNewColumn(height, heightSum + itemSpace, cvHeight)) {
                            heightSum = 0;
                            canApplyLeft = true;
                            if(isFirstItem) {
                                prevHeight = prevWidget.flexNode.offsetHeight;//TODO
                                $KD.style(prevWidget.flexNode, 'margin-top', (cvHeight - prevHeight) / 2 + 'px');//TODO
                                $KD.style(prevWidget.flexNode, 'margin-bottom', (cvHeight - prevHeight) / 2 + 'px');//TODO
                            }
                            isFirstItem = true;
                        } else if(prevWidget) {
                            $KD.style(prevWidget.flexNode, 'margin-bottom', itemSpace + 'px');//TODO
                            heightSum += itemSpace;
                            isFirstItem = false;
                        }
                        heightSum += height;
                        if(canApplyLeft) {
                            $KD.style(currWidget.flexNode, 'margin-left', lineSpace + 'px');//TODO
                        }
                    }
                    prevWidget = currWidget;
                }
            }
            prevWidget && _applyMarginForLastItem(this, WidthSum, heightSum);
        }
    };


    //This function will be called in the scope of widget instance
    var _applyItemAndHeaderSkin = function CollectionView$_applyItemAndHeaderSkin(div, clone/*, index*/) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, ii = clone._kwebfw_.ii,
            prop = this._kwebfw_.prop, itemSkin = prop.itemSkin;

        if(ii.indexOf(',-1') !== -1) {
            $KD.setAttr(div, 'class', prop.sectionHeaderSkin);
        } else if(ii.indexOf(',-2') !== -1) {
            $KD.setAttr(div, 'class', prop.sectionFooterSkin);
        } else {
            $KD.setAttr(div, 'class', itemSkin);
        }
    };


    //This function will be called in the scope of widget instance
    var _canRenderItem = function CollectionView$_canRenderItem(index, clone, item, tpl) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
            secIndex = -1, itemIndex = -1, flag = false;

        if($K.F.RIVW) {
            flag = true;
        } else {
            index = _deduceIndex.call(this, index);
            secIndex = index[0]; itemIndex = index[1];

            if(arguments.length === 1 && !(secIndex === -1 && itemIndex === -1)) {
                if(secIndex === -1) {
                    clone = _.clones[itemIndex];
                    item = _.prop.data[itemIndex];
                    tpl = this.itemTemplate;
                } else {
                    if(itemIndex === -1) {
                        clone = _.clones[secIndex][0];
                        item = _.prop.data[secIndex][0];
                        tpl = this.sectionHeaderTemplate;
                    } else if(itemIndex === -2) {
                        clone = _.clones[secIndex][2];
                        item = _.prop.data[secIndex][2];
                        tpl = this.sectionFooterTemplate;
                    } else if(!_isSectionCollapsed.call(this, secIndex)) {
                        clone = _.clones[secIndex][1][itemIndex];
                        item = _.prop.data[secIndex][1][itemIndex];
                        tpl = this.itemTemplate;
                    }
                }
            }

            if(secIndex !== -1 && itemIndex !== -1
                && _isSectionCollapsed.call(this, secIndex)) {
                flag = false;
            } else if($KU.is(clone, 'widget')) {
                flag = clone.isVisible;
            } else if($KU.is(item, 'object')
                && $KU.is(tpl, 'widget')
                && !$KU.is(item[_.prop.widgetDataMap[tpl.id]], 'undefined')
                && Object.prototype.hasOwnProperty.call(item[_.prop.widgetDataMap[tpl.id]], 'isVisible')
                && $KU.is(item[_.prop.widgetDataMap[tpl.id]].isVisible, 'boolean')) {
                flag = item[_.prop.widgetDataMap[tpl.id]].isVisible;
            } else if($KU.is(tpl, 'widget')) {
                flag = tpl.isVisible;
            }
        }

        return flag;
    };

    //This function will be called in the scope of widget instance
    var _clearSelectedIndices = function CollectionView$_clearSelectedIndices() {
        var _ = this._kwebfw_, items = _.selectedItems;

        items.splice(0, items.length);
        _setSelectedItemsRelatedProperties.call(this);
    };

    var _cleanupLayoutProps = function CollectionView$_cleanupLayoutProps(model, layouttype/*, isHeaderOrFooter*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;
        var props = ['left', 'right', 'centerX', 'centerY', 'top', 'bottom'];
        if(layouttype === voltmx.collectionview.LAYOUT_CUSTOM)
            return;
        $KU.each(props, function(prop) {
            model[prop] = '';
        });
    };

    var _convertFlexPropertyToCssUnit = function CollectionView$_convertFlexPropertyToCssUnit(value, layoutUnit) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KF = voltmx.flex, unit = '', len = 0;

        if($KU.is(value, 'number')) {
            unit = layoutUnit || $KF.DEFAULT_UNIT;

            if(unit === $KF.PX) {
                value = (value / $K.device.DPI);
                value = Math.round(value);
            } else if(unit === $KF.DP) {
                unit = $KF.PX;
            }
        } else if($KU.is(value, 'string')) {
            len = value.length;

            if(value.substr((len-1), 1) === $KF.PERCENTAGE) {
                unit = $KF.PERCENTAGE;
                value = parseFloat(value.replace($KF.PERCENTAGE, ''), 10);
            } else if(value.substr((len-2), 2) === $KF.PX) {
                unit = $KF.PX;
                value = (parseFloat(value.replace($KF.PX, ''), 10) / $K.device.DPI);
                value = Math.round(value);
            } else if(value.substr((len-2), 2) === $KF.DP) {
                unit = $KF.PX;
                value = parseFloat(value.replace($KF.DP, ''), 10);
            }
        }

        return (value + unit);
    };


    //This function will be called in the scope of widget instance
    var _deduceIndex = function CollectionView$_deduceIndex(index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, secIndex = -1,
            data = this._kwebfw_.prop.data, itemIndex = -1;

        if(data && data.length > 0) {
            if($KU.is(index, 'widget')) {
                index = index._kwebfw_.ii;
            }

            if($KU.is(index, 'string') && index) {
                index = index.split(',');
                if(index.length === 2) {
                    secIndex = parseInt(index[0], 10);
                    itemIndex = parseInt(index[1], 10);

                    if(!$KU.is(secIndex, 'number')) {
                        secIndex = -1;
                    }
                    if(!$KU.is(itemIndex, 'number')) {
                        itemIndex = -1;
                    }
                }
            } else if($KU.is(index, 'number')) {
                secIndex = -1;
                itemIndex = index;
            } else if($KU.is(index, 'array')
                && $KU.is(index[0], 'number')
                && $KU.is(index[1], 'number')) {
                secIndex = index[0];
                itemIndex = index[1];
            }

            if(secIndex < -1) secIndex = -1;
            if(itemIndex < -2) itemIndex = -2;
        }

        return [secIndex, itemIndex];
    };

    /*eslint-disable no-unused-vars*/
    //This function will be called in the scope of widget instance
    //This <index> should be the this._kwebfw_.items[0]
    var _deduceTop = function CollectionView$_deduceTop(index) {
        var data = this._kwebfw_.prop.data, top = 0, secIndex = -1, itemIndex = -1;

        index = _deduceIndex.call(this, index);
        secIndex = index[0]; itemIndex = index[1];

        if(secIndex === -1 && itemIndex === -1) return top;

        if(secIndex === -1) {
            itemIndex--;

            while(itemIndex >= 0) {
                top += _getItemHeight.call(this, [secIndex, itemIndex]);
                itemIndex--;
            }
        } else {
            if(itemIndex === -1) {
                secIndex--;
                itemIndex = (data[secIndex][1].length - 1);
            } else {
                itemIndex--;
            }

            while(secIndex >= 0) {
                top += _getItemHeight.call(this, [secIndex, itemIndex]);

                if(itemIndex === -1) {
                    secIndex--;
                    itemIndex = (data[secIndex][1].length - 1);
                } else {
                    itemIndex--;
                }
            }
        }

        return top;
    };
    /*eslint-enable no-unused-vars*/

    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {
        CollectionView: function CollectionView$_dependentPropertiesValidationMessage(prop, bconfig/*, lconfig, pspconfig*/) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false, message = '',
                sectionable = false, data = bconfig.data || prop.data,
                index = bconfig.selectedItemIndex || prop.selectedItemIndex;

            if($KU.is(index, 'null')) {
                flag = true;
            } else if(data && data.length && $KU.is(index, 'array') && index.length === 2
                && $KU.is(index[0], 'number') && $KU.is(index[1], 'number')) {
                sectionable = _isSectionDS(data[0]);

                if(!sectionable) {
                    if(index[0] === 0 && index[1] >= 0 && index[1] < data.length) {
                        flag = true;
                    }
                } else if(index[0] >= 0 && index[0] < data.length) {
                    if(index[1] >= -1 && index[1] < data[index[0]][1].length) {
                        flag = true;
                    }
                }
            }

            if(!flag) {
                message += 'Segment <selectedItemIndex> value is invalid';
            }

            return message;
        }
    };


    //This function will be called in the scope of widget instance
    var _executeOnItem = function CollectionView$_executeOnItem(index, callback, args) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, tpl = null,
            data = this._kwebfw_.prop.data, item = null, secIndex = -1, itemIndex = -1;

        index = _deduceIndex.call(this, index);
        secIndex = index[0]; itemIndex = index[1];

        if(secIndex === -1 && itemIndex === -1) return;

        if(_isSectionDS(data[0])) {
            if(secIndex >= 0 && secIndex < data.length) {
                if(itemIndex < 0) {
                    if($KU.is(callback, 'function')) {
                        if(!$KU.is(args, 'array')) args = [];
                        if(itemIndex === -1) {
                            item = data[secIndex][0];
                            if(item) {
                                if($KU.is(item, 'string')) {
                                    tpl = _getFrameworkHeaderTemplate();
                                } else {
                                    tpl = item.template || this.sectionHeaderTemplate;
                                }
                                tpl = $KW.getTemplate(this, tpl);
                            }

                            if(!$KU.is(this._kwebfw_.clones[secIndex], 'array')) {
                                this._kwebfw_.clones[secIndex] = [null, [], null];
                            }

                            if(!$KU.is(this._kwebfw_.heights[secIndex], 'array')) {
                                this._kwebfw_.heights[secIndex] = [-1, [], null];
                            }

                            args.splice(0, 0, [secIndex, itemIndex]);
                            args.splice(1, 0, item);
                            args.splice(2, 0, tpl);
                            args.splice(3, 0, this._kwebfw_.clones[secIndex][0]);
                            args.splice(4, 0, this._kwebfw_.heights[secIndex][0]);
                        } else {
                            item = data[secIndex][2];
                            if(item) {
                                if($KU.is(item, 'string')) {
                                    tpl = _getFrameworkHeaderTemplate();
                                } else {
                                    tpl = item.template || this.sectionFooterTemplate;
                                }
                                tpl = $KW.getTemplate(this, tpl);
                            }

                            args.splice(0, 0, [secIndex, itemIndex]);
                            args.splice(1, 0, item);
                            args.splice(2, 0, tpl);
                            args.splice(3, 0, this._kwebfw_.clones[secIndex][2]);
                            args.splice(4, 0, this._kwebfw_.heights[secIndex][2]);
                        }

                        callback.apply(this, args);
                    }
                } else if(itemIndex >= 0 && itemIndex < data[secIndex][1].length) {
                    if($KU.is(callback, 'function')) {
                        if(!$KU.is(args, 'array')) args = [];
                        item = data[secIndex][1][itemIndex];
                        tpl = item.template || this.itemTemplate;
                        tpl = $KW.getTemplate(this, tpl);

                        if(!$KU.is(this._kwebfw_.clones[secIndex], 'array')) {
                            this._kwebfw_.clones[secIndex] = [null, []];
                        }
                        if($KU.is(this._kwebfw_.clones[secIndex][1][itemIndex], 'undefined')) {
                            this._kwebfw_.clones[secIndex][1][itemIndex] = null;
                        }

                        if(!$KU.is(this._kwebfw_.heights[secIndex], 'array')) {
                            this._kwebfw_.heights[secIndex] = [-1, []];
                        }
                        if($KU.is(this._kwebfw_.heights[secIndex][1][itemIndex], 'undefined')) {
                            this._kwebfw_.heights[secIndex][1][itemIndex] = -1;
                        }

                        args.splice(0, 0, [secIndex, itemIndex]);
                        args.splice(1, 0, item);
                        args.splice(2, 0, tpl);
                        args.splice(3, 0, this._kwebfw_.clones[secIndex][1][itemIndex]);
                        args.splice(4, 0, this._kwebfw_.heights[secIndex][1][itemIndex]);

                        callback.apply(this, args);
                    }
                }
            }
        } else if(secIndex < 0) {
            if(itemIndex >= 0 && itemIndex < data.length) {
                if($KU.is(callback, 'function')) {
                    if(!$KU.is(args, 'array')) args = [];
                    item = data[itemIndex];
                    tpl = item.template || this.itemTemplate;
                    tpl = $KW.getTemplate(this, tpl);

                    if(!$KU.is(this._kwebfw_.clones[itemIndex], 'undefined')) {
                        this._kwebfw_.clones[itemIndex] = null;
                    }

                    if(!$KU.is(this._kwebfw_.heights[itemIndex], 'undefined')) {
                        this._kwebfw_.heights[itemIndex] = -1;
                    }

                    args.splice(0, 0, [secIndex, itemIndex]);
                    args.splice(1, 0, item);
                    args.splice(2, 0, tpl);
                    args.splice(3, 0, this._kwebfw_.clones[itemIndex]);
                    args.splice(4, 0, this._kwebfw_.heights[itemIndex]);

                    callback.apply(this, args);
                }
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _firstRenderableItem = function CollectionView$_firstRenderableItem() {
        var data = this._kwebfw_.prop.data, item = null, secIndex = -1, itemIndex = -1;

        if(data) {
            if(!_isSectionDS(data[0])) {
                itemIndex = 0;

                while(itemIndex < data.length) {
                    if(_canRenderItem.call(this, [-1, itemIndex])) {
                        item = _getClonedTemplate.call(this, [-1, itemIndex], true);
                        break;
                    } else {
                        itemIndex++;
                    }
                }
            } else {
                secIndex = 0;

                while(secIndex < data.length) {
                    if(_canRenderItem.call(this, [secIndex, itemIndex])) {
                        item = _getClonedTemplate.call(this, [secIndex, itemIndex], true);
                        break;
                    } else {
                        if(itemIndex === (data[secIndex][1].length - 1)) {
                            secIndex++;
                            itemIndex = -1;
                        } else {
                            itemIndex++;
                        }
                    }
                }
            }
        }

        return item;
    };


    //This function will be called in the scope of widget instance
    var _flushClones = function CollectionView$_flushClones(clones, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(config) {
            config.iterate = true;
        } else {
            config = {iterate : true};
        }

        if($KU.is(clones, 'widget')) clones = [clones];

        if($KU.is(clones, 'array')) {
            $KU.each(clones, function(section) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                if($KU.is(section, 'array')) {
                    if($KU.is(section[0], 'widget')) {
                        section[0]._flush(config);
                    }

                    $KU.each(section[1], function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(item, 'widget')) {
                            item._flush(config);
                        }
                    });

                    if($KU.is(section[2], 'widget')) {
                        section[2]._flush(config);
                    }
                } else if($KU.is(section, 'widget')) {
                    section._flush(config);
                }
            }, this);
        }
    };


    var _getFrameworkHeaderTemplate = function CollectionView$_getFrameworkHeaderTemplate() {
        var flx = null, lbl = null,
            bconfig = {
                'id': 'flxkwebfwHeader',
                'layoutType': voltmx.flex.FREE_FORM,
                'height': voltmx.flex.USE_PREFERRED_SIZE,
                'autogitemMode': voltmx.flex.AUTOGROW_HEIGHT
            };

        flx = new voltmx.ui.FlexContainer(bconfig);
        lbl = new voltmx.ui.Label({'id': 'labelkwebfwHeader'});

        flx.add(lbl);

        return flx;
    };


    var _getIndex = function CollectionView$_getIndex(find, list) {
        var position = -1, i = 0, ilen = list.length;

        for(i=0; i<ilen; i++) {
            if(list[i][0] === find[0] && list[i][1] === find[1]) {
                position = i;
                break;
            }
        }

        return position;
    };

    //This function will be called in the scope of widget instance
    var _getIndexedInfo = function CollectionView$_getIndexedInfo(index, data) {
        var item = null, _ = this._kwebfw_, prop =_.prop, secIndex = -1,
            itemIndex = -1;

        index = _deduceIndex.call(this, index);
        secIndex = index[0]; itemIndex = index[1];

        if(secIndex === -1 && itemIndex === -1) return null;

        if(_isSectionDS(prop.data[0])) {
            if(secIndex >= 0 && secIndex < prop.data.length) {
                if(itemIndex === -1) {
                    item = data[secIndex][0];
                } else if(itemIndex === -2) {
                    item = data[secIndex][2];
                } else if(itemIndex >= 0 && itemIndex < prop.data[secIndex][1].length) {
                    item = data[secIndex][1][itemIndex];
                }
            }
        } else if(secIndex < 0) {
            if(itemIndex >= 0 && itemIndex < prop.data.length) {
                item = data[itemIndex];
            }
        }

        return item;
    };

    //This function will be called in the scope of widget instance
    var _getClonedTemplate = function CollectionView$_getClonedTemplate(index, forced) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, template = null;

        _executeOnItem.call(this, index, function(index, item, tpl, clone/*, height*/) {
            var secIndex = index[0], itemIndex = index[1],
                prop = this._kwebfw_.prop, self = this;

            if($KU.is(clone, 'widget')) {
                template = clone;
            } else {
                if(forced) {
                    template = $KW.cloneTemplate(tpl, item, prop.widgetDataMap, function(model/*, pmodel, windex*/) {
                        model._kwebfw_.ii = index.join(',');
                        _updateSpecialProperties.call(self, model);
                    });
                } else if(_canRenderItem.call(this, index, clone, item, tpl)) {
                    template = $KW.cloneTemplate(tpl, item, prop.widgetDataMap, function(model/*, pmodel, windex*/) {
                        model._kwebfw_.ii = index.join(',');
                        _updateSpecialProperties.call(self, model);
                    });
                }

                if(secIndex === -1) {
                    this._kwebfw_.clones[itemIndex] = template;
                } else {
                    if(itemIndex === -1) {
                        this._kwebfw_.clones[secIndex][0] = template;
                    } else if(itemIndex === -2) {
                        this._kwebfw_.clones[secIndex][2] = template;
                    } else {
                        this._kwebfw_.clones[secIndex][1][itemIndex] = template;
                    }
                }
            }
        });

        return template;
    };


    var _getInvertedDataMap = function CollectionView$_getInvertedDataMap(map) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, invertedMap = {};

        if($KU.is(map, 'object')) {
            $KU.each(map, function(value, key) {
                invertedMap[value] = key;
            });
        }

        return invertedMap;
    };


    //This function will be called in the scope of widget instance
    var _getRenderableClones = function CollectionView$_getRenderableClones(startIndex, endIndex) {
        var data = this._kwebfw_.prop.data, items = [], startSecIndex = startIndex[0],
            startItemIndex = startIndex[1], endSecIndex = -1, endItemIndex = -1,
            datalen = 0;

        var cloneItem = function(model, index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                tpl = _getClonedTemplate.call(model, index);

            if($KU.is(tpl, 'widget') && _canRenderItem.call(model, tpl)) {
                items.push(tpl);
            }
        };

        if(startSecIndex <= -1 && startItemIndex <= -2) return items;

        if(data) {
            datalen = data.length - 1;

            if(!endIndex) {
                if(_isSectionDS(data[0])) endSecIndex = datalen;
                else endItemIndex = datalen;
            } else {
                endSecIndex = endIndex[0];
                endItemIndex = endIndex[1];
                if(_isSectionDS(data[0])) {
                    if(endSecIndex > datalen) endSecIndex = datalen;
                } else {
                    if(endItemIndex > datalen) endItemIndex = datalen;
                }
            }
            if(_isSectionDS(data[0])) {
                while(startSecIndex <= endSecIndex) {
                    if(startItemIndex >= data[startSecIndex][1].length) {
                        startSecIndex++;
                        startItemIndex = -1;
                    } else {
                        cloneItem(this, [startSecIndex, startItemIndex]);
                        if(startItemIndex === -2) {
                            startSecIndex++;
                            startItemIndex = -1;
                        } else {
                            startItemIndex++;
                            if(startItemIndex === data[startSecIndex][1].length) {
                                startItemIndex = -2;
                            }
                        }
                    }
                }
            } else {
                while(startItemIndex <= endItemIndex && startItemIndex >= 0) {
                    cloneItem(this, [startSecIndex, startItemIndex]);
                    startItemIndex++;
                }
            }
        }

        return items;
    };

    //This function will be called in the scope of widget instance
    var _getItemContext = function CollectionView$_getItemContext(clone) {
        var cindex = clone._kwebfw_.ii.split(','),
            secIndex = parseInt(cindex[0], 10),
            itemIndex = parseInt(cindex[1], 10);
        return {
            sectionIndex: (secIndex === -1 ? 0 :secIndex),
            itemIndex: itemIndex
        };
    };

    //This function will be called in the scope of widget instance
    var _getItemCount = function CollectionView$_getItemCount() {
        var prop = this._kwebfw_.prop, itemcount = 0,
            secIndex = -1, itemIndex = -1;

        if(prop.data && prop.data.length) {
            if(_isSectionDS(prop.data[0])) {
                secIndex = (prop.data.length - 1);
                itemIndex = (prop.data[secIndex][1].length - 1);
            } else {
                itemIndex = (prop.data.length - 1);
            }
            itemcount = (_absoluteIndex.call(this, [secIndex, itemIndex]) + 1);
        }

        return itemcount;
    };


    //This function will be called in the scope of widget instance
    var _getItemHeight = function CollectionView$_getItemHeight(index) {
        var size = 0;

        _executeOnItem.call(this, index, function(index, item, tpl, clone, height) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            var updateHeightAndClone = function(index, height, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    secIndex = index[0], itemIndex = index[1];

                if(secIndex === -1) {
                    if(height !== -1) {
                        this._kwebfw_.heights[itemIndex] = height;
                    }
                    if($KU.is(clone, 'widget')) {
                        this._kwebfw_.clones[itemIndex] = clone;
                    }
                } else {
                    if(itemIndex === -1) {
                        if(height !== -1) {
                            this._kwebfw_.heights[secIndex][0] = height;
                        }
                        if($KU.is(clone, 'widget')) {
                            this._kwebfw_.clones[secIndex][0] = clone;
                        }
                    } else if(itemIndex === -2) {
                        if(height !== -1) {
                            this._kwebfw_.heights[secIndex][2] = height;
                        }
                        if($KU.is(clone, 'widget')) {
                            this._kwebfw_.clones[secIndex][2] = clone;
                        }
                    } else {
                        if(height !== -1) {
                            this._kwebfw_.heights[secIndex][1][itemIndex] = height;
                        }
                        if($KU.is(clone, 'widget')) {
                            this._kwebfw_.clones[secIndex][1][itemIndex] = clone;
                        }
                    }
                }
            };

            if(height !== -1) {
                size = height;
            } else {
                if($KU.is(clone, 'widget')) {
                    /* TODO:: Calculate "size" from clone
                        if(clone.height is autogitem) {
                            clone._render() and append to el.scrolee with css properties visibility:hidden;
                            then run clone.forceLayout() and size = clone.frame.height
                            then remove the DOM from view and update this._kwebfw_.minScroleeHeight += size
                            then set el.scrolee.style.height = this._kwebfw_.minScroleeHeight + 'px'
                        } else { //clone.height can not be in percent
                            //
                        }

                        updateHeightAndClone.call(this, index, size);
                        //*/
                } else {
                    if(!Object.prototype.hasOwnProperty.call(item, 'height')) {
                        /* TODO:: Calculate "size" from tpl
                            if(tpl.height is autogitem) {
                                create a clone, then clone._render()
                                and append to el.scrolee with css properties visibility:hidden;
                                then run clone.forceLayout() and size = clone.frame.height
                                then remove the DOM from view and update this._kwebfw_.minScroleeHeight += size
                                then set el.scrolee.style.height = this._kwebfw_.minScroleeHeight + 'px'
                            } else { //tpl.height can not be in percent
                                //
                            }
                            //*/
                    } else {
                        /* TODO:: Calculate "size" from item
                            if(item.height is autogitem) {
                                create a clone, then clone._render()
                                and append to el.scrolee with css properties visibility:hidden;
                                then run clone.forceLayout() and size = clone.frame.height
                                then remove the DOM from view and update this._kwebfw_.minScroleeHeight += size
                                then set el.scrolee.style.height = this._kwebfw_.minScroleeHeight + 'px'
                            } else { //item.height can not be in percent
                                //
                            }
                            //*/
                    }

                    updateHeightAndClone.call(this, index, size, clone);
                }
            }
        });

        return size;
    };


    var _getVisibleItem = function CollectionView$_getVisibleItem(config) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
            $KD = $K.dom, el = $KW.el(this), visibleItem = null,
            scrollTop = 0, scrollBottom = 0, index = null, visibleIndex = null,
            prop = this._kwebfw_.prop;

        if(el.node && prop.data) {
            scrollTop = el.viewport.scrollTop;
            scrollBottom = scrollTop + el.scrolee.offsetHeight;

            $KU.each($KD.children(el.scrolee), function(li) {
                var itemTop = li.offsetTop, itemBottom = itemTop + li.offsetHeight;

                if(config.firstItem && scrollTop < itemBottom) {
                    visibleItem = li;
                    return true;
                }

                if(config.lastItem
                    && (scrollBottom < itemTop || scrollBottom <= itemBottom + 1)) {
                    visibleItem = li;
                    return true;
                }
            });

            index = $KD.getAttr(visibleItem, 'kii');
            index = _deduceIndex.call(this, index);

            if(_isSectionDS(prop.data[0])) {
                visibleIndex = {sectionIndex: index[0]};
                if(index[1] !== -1) visibleIndex['itemIndex'] = index[1];
            } else {
                visibleIndex = {itemIndex: index[1]};
            }
        }

        return visibleIndex;
    };

    var _getVisibleItems = function CollectionView$_getVisibleItems(config) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
            $KD = $K.dom, el = $KW.el(this), visibleItems = [], visibleIndices = [],
            scrollRight = 0, scrollLeft = 0, scrollBottom = 0, scrollTop = 0,
            index = null, visibleItem = null, prop = this._kwebfw_.prop;

        if(el.node && prop.data) {
            scrollTop = el.viewport.scrollTop;
            scrollLeft = el.viewport.scrollLeft;
            scrollBottom = scrollTop + el.scrolee.offsetHeight;
            scrollRight = scrollLeft + el.scrolee.offsetWidth;

            $KU.each($KD.children(el.scrolee), function(div) {
                var itemLeft = div.offsetLeft, itemTop = div.offsetTop, itemBottom = itemTop + div.offsetHeight,
                    itemRight = itemLeft + div.offsetWidth;

                if((scrollTop < itemBottom && itemTop < scrollBottom)
                        && (scrollLeft < itemRight && itemLeft < scrollRight)) {
                    visibleItem = div;
                    index = $KD.getAttr(visibleItem, 'kii');
                    index = _deduceIndex.call(this, index);
                    if(config.indices) {
                        if(_isSectionDS(prop.data[0])) {
                            if(index[1] > -1) {
                                visibleIndices.push({sectionIndex: index[0], itemIndex: index[1]});
                            }
                        } else {
                            visibleIndices.push({itemIndex: index[1]});
                        }
                    } else if(index[1] > -1) {
                        visibleItems.push($KW.model(visibleItem));
                    }
                }
            }, this);
        }

        return config.indices ? visibleIndices : visibleItems;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        CollectionView: {
            contentOffset: function FlexScrollContainer$_getter_contentOffset(value) {
                return {x:value.x, y:value.y};
            },

            contentOffsetMeasured: function FlexScrollContainer$_getter_contentOffsetMeasured(value) {
                var scroll = this._kwebfw_.ui.scroll;

                value.x = scroll.x;
                value.y = scroll.y;

                return {x:value.x, y:value.y};
            },

            data: function CollectionView$_getter_data(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, data = [];

                if(!value) {
                    return value;
                }
                if(!_isSectionDS(value)) {
                    data = value.slice(0);
                } else {
                    $KU.each(value, function(section) {
                        data.push([section[0], section[1].slice(0), section[2]]);
                    });
                }

                return data;
            },

            selectedItemIndex: function CollectionView$_getter_selectedItemIndex(value) {
                var prop = this._kwebfw_.prop, index = null;

                if(prop.selectedItemIndex) {
                    if(value[0] === -1) {
                        index = [0, value[1]];
                    } else {
                        index = value.slice(0);
                    }
                }

                return index;
            },

            selectedItemIndices: function CollectionView$_getter_selectedItemIndices(/*value*/) {
                var prop = this._kwebfw_.prop, indices = null, s = 0,
                    slen = 0, sindex = 0, rindexes = null;

                if(prop.selectedItemIndices) {
                    indices = [];
                    slen = prop.selectedItemIndices.length;

                    for(s=0; s<slen; s++) {
                        sindex = prop.selectedItemIndices[s][0];
                        rindexes = prop.selectedItemIndices[s][1];

                        if(sindex === -1) sindex = 0;
                        indices.push([sindex, rindexes.slice(0)]);
                    }
                }

                return indices;
            },

            widgetDataMap: function CollectionView$_getter_widgetDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            }
        }
    };

    //This function will be called in the scope of widget instance
    var _handleScrollDirection = function CollectionView$_handleScrollDirection(el) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;
        if(this.layout === voltmx.collectionview.LAYOUT_CUSTOM) {
            switch(this.scrollDirection) {
                case voltmx.collectionview.SCROLL_DIRECTION_BOTH:
                    $KD.style(el, 'overflow', 'auto');
                    break;
                case voltmx.collectionview.SCROLL_DIRECTION_VERTICAL:
                    $KD.style(el, {overflowY: 'auto', overflowX: 'hidden'});
                    break;
                case voltmx.collectionview.SCROLL_DIRECTION_HORIZONTAL:
                    $KD.style(el, {overflowY: 'hidden', overflowX: 'auto'});
                    break;
                default:
                    break;
            }
        } else {
            $KD.style(el, {overflowX:'auto', overflowY:'auto'});
        }
    };


    //This function will be called in the scope of widget instance
    var _iterateOverData = function CollectionView$_iterateOverData(data, callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            s = 0, r = 0, slen = 0, rlen = 0;

        if(!$KU.is(callback, 'function')) return;

        if($KU.is(data, 'array')) {
            if(_isSectionDS(data[0])) {
                slen = data.length;

                for(s=0; s<slen; s++) {
                    rlen = data[s][1].length;

                    if(data[s][0] && callback.call(this, data[s][0], -1, s) === true) {
                        break;
                    }

                    for(r=0; r<rlen; r++) {
                        if(callback.call(this, data[s][1][r], r, s) === true) {
                            break;
                        }
                    }

                    if(data[s][2] && callback.call(this, data[s][2], -2, s) === true) {
                        break;
                    }
                }
            } else {
                rlen = data.length;

                for(r=0; r<rlen; r++) {
                    if(callback.call(this, data[r], r, -1) === true) {
                        break;
                    }
                }
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _isSectionCollapsed = function CollectionView$_isSectionCollapsed(index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = null,
            _ = this._kwebfw_, prop = _.prop, collapsed = false;

        if(prop.data) {
            if($KU.is(index, 'number') && index >= 0
                && index < prop.data.length) {
                data = prop.data[index][0];

                if(data && $KU.is(data.metaInfo, 'object')
                    && data.metaInfo.collapsed === true) {
                    collapsed = true;
                }
            }
        }

        return collapsed;
    };


    var _isSectionDS = function CollectionView$_isSectionDS(data) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

        if($KU.is(data, 'array')
            && ($KU.is(data[0], 'object') || $KU.is(data[0], 'string') || $KU.is(data[0], 'null'))
            && $KU.is(data[1], 'array')) {
            flag = true;
        }

        return flag;
    };


    //This function will be called in the scope of widget instance
    var _isItemRendered = function CollectionView$_isItemRendered(secIndex, itemIndex) {
        var flag = false, clone = null, r = 0, _ = this._kwebfw_,
            clones = _.clones, items = _.items, rlen = items.length;

        if(clones.length > 0) {
            if(_isSectionDS(_.prop.data[0])) {
                if(itemIndex <= -1) clone = clones[secIndex];
                else clone = clones[secIndex][1][itemIndex];
            } else {
                clone = clones[itemIndex];
            }

            if(clone) {
                for(r=0; r<rlen; r++) {
                    if(items[r] === clone) {
                        flag = true;
                        break;
                    }
                }
            }
        }

        return flag;
    };

    /*eslint-disable no-unused-vars*/
    //This function will be called in the scope of widget instance
    var _isScrollReachingBottom = function CollectionView$_isScrollReachingBottom(scrollTop, offset) {
        var scroleeHeight = -1, viewportHeight = -1, result = -1, flag = false;

        scroleeHeight = this._kwebfw_.minScroleeHeight;
        viewportHeight = this.frame.height;
        result = scrollTop - scroleeHeight - viewportHeight - offset;

        flag = (result >= 0) ? true : false;

        return flag;
    };


    //This function will be called in the scope of widget instance
    var _isScrollReachingTop = function CollectionView$_isScrollReachingTop(scrollTop, offset) {
        var flag = false, result = scrollTop - offset;

        flag = (result <= 0) ? true : false;

        return flag;
    };
    /*eslint-enable no-unused-vars*/


    //This function will be called in the scope of widget instance
    var _lastRenderableItem = function CollectionView$_lastRenderableItem() {
        var data = this._kwebfw_.prop.data, item = null, secIndex = -1, itemIndex = -1;

        if(data) {
            if(!_isSectionDS(data[0])) {
                itemIndex = data.length - 1;

                while(itemIndex >= 0) {
                    if(_canRenderItem.call(this, [-1, itemIndex])) {
                        item = _getClonedTemplate.call(this, [-1, itemIndex], true);
                        break;
                    } else {
                        itemIndex--;
                    }
                }
            } else {
                secIndex = data.length - 1;
                itemIndex = data[secIndex][1].length - 1;

                while(secIndex >= 0) {
                    if(_canRenderItem.call(this, [secIndex, itemIndex])) {
                        item = _getClonedTemplate.call(this, [secIndex, itemIndex], true);
                        break;
                    } else {
                        if(itemIndex === -1) {
                            secIndex--;
                            itemIndex = data[secIndex][1].length - 1;
                        } else {
                            itemIndex--;
                        }
                    }
                }
            }
        }

        return item;
    };


    //This function will be called in the scope of widget instance
    var _nextRenderableItems = function CollectionView$_nextRenderableItems(index, count) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = this._kwebfw_.prop.data,
            items = [], tpl = null, startSecIndex = -1, startItemIndex = -1,
            itemIndex = -1, lastItemIndex = -1, lastSecIndex = -1, secIndex = -1;

        index = _deduceIndex.call(this, index);
        startSecIndex = index[0];
        startItemIndex = index[1];

        if(startSecIndex === -1 && startItemIndex === -1) return items;

        if(startSecIndex === -1) {
            itemIndex = startItemIndex + 1;
            lastItemIndex = (data.length - 1);

            while(count > 0 && itemIndex <= lastItemIndex) {
                tpl = _getClonedTemplate.call(this, [-1, itemIndex]);

                if($KU.is(tpl, 'widget') && _canRenderItem.call(this, tpl)) {
                    items.push(tpl);
                    count--;
                }

                itemIndex++;
            }
        } else {
            if(startItemIndex === (data[startSecIndex][1].length - 1)) {
                secIndex = startSecIndex + 1;
                itemIndex = -1;
            } else {
                secIndex = startSecIndex;
                itemIndex = startItemIndex + 1;
            }

            lastSecIndex = (data.length - 1);

            while(count > 0 && secIndex <= lastSecIndex) {
                if(itemIndex === -1) {
                    tpl = _getClonedTemplate.call(this, [secIndex, -1]);

                    if($KU.is(tpl, 'widget') && _canRenderItem.call(this, tpl)) {
                        items.push(tpl);
                        count--;
                    }

                    itemIndex++;
                } else {
                    if(itemIndex === data[secIndex][1].length) {
                        secIndex++;
                        itemIndex = -1;
                    } else {
                        tpl = _getClonedTemplate.call(this, [secIndex, itemIndex]);

                        if($KU.is(tpl, 'widget') && _canRenderItem.call(this, tpl)) {
                            items.push(tpl);
                            count--;
                        }

                        itemIndex++;
                    }
                }
            }
        }

        return items;
    };

    /*eslint-disable*/
    //This function will be called in the scope of widget instance
    var _nextTemplate = function CollectionView$_nextTemplate(index) {
        var data = this._kwebfw_.prop.data, secIndex = -1, itemIndex = -1, next = null;

        index = _deduceIndex.call(this, index);

        if(!(secIndex === -1 && itemIndex === -1)) {
            if(secIndex >= 0) {
                if(secIndex < data.length) {
                    if(itemIndex >= 0) {
                        if(itemIndex < data[secIndex][1].length) {
                            if(itemIndex === (data[secIndex][1].length - 1)) {
                                next = _getClonedTemplate.call(this, [(secIndex + 1), -1], true);
                            } else {
                                next = _getClonedTemplate.call(this, [secIndex, (itemIndex + 1)], true);
                            }
                        }
                    } else {
                        if(data[secIndex][1].length > 0) {
                            next = _getClonedTemplate.call(this, [secIndex, 0], true);
                        }
                    }
                }
            } else if(itemIndex >= 0) {
                if(itemIndex < data.length) {
                    if(itemIndex !== (data.length - 1)) {
                        next = _getClonedTemplate.call(this, [-1, (itemIndex + 1)], true);
                    }
                }
            }
        }

        return next;
    };
    /*eslint-enable*/


    //This function will be called in the scope of widget instance
    var _onDataSet = function CollectionView$_onDataSet() {
        var self = this;

        _resetBookKeepers.call(this, function(index) {
            var secIndex = index[0], itemIndex = index[1];

            /*eslint-disable no-constant-condition*/
            if('TODO:: height of the collectionview can be calculated') {
            /*eslint-enable no-constant-condition*/
                if(secIndex === -1) {
                    if(this._kwebfw_.heights[itemIndex] >= 0) {
                        self._kwebfw_.minScroleeHeight += this._kwebfw_.heights[itemIndex];
                    }
                } else {
                    if(itemIndex === -1) {
                        if(this._kwebfw_.heights[secIndex][0] >= 0) {
                            self._kwebfw_.minScroleeHeight += this._kwebfw_.heights[secIndex][0];
                        }
                    } else {
                        if(this._kwebfw_.heights[secIndex][1][itemIndex] >= 0) {
                            self._kwebfw_.minScroleeHeight += this._kwebfw_.heights[secIndex][1][itemIndex];
                        }
                    }
                }
            }
        });
    };


    //This function will be called in the scope of widget instance
    var _onItemChange = function CollectionView$_onItemChange(secIndex, itemIndex, action, data, count, anim) {
        //<action> can be one of "add" / "remove" / "update"/ addsectionat, setsectionat, removesectionat, addall
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, el = $KW.el(this);

        if(secIndex === -1 && itemIndex === -1) return;

        if(['add', 'update', 'remove'].indexOf(action) !== -1
            && !_isSectionDS(this._kwebfw_.prop.data[0])) secIndex = -1;

        if(action === 'addsectionat') {
            _action.CollectionView[action].call(this, secIndex, itemIndex, data, true, anim);
        } else {
            _action.CollectionView[action].call(this, secIndex, itemIndex, data, count, anim);
        }

        $KD.setAttr(el.scrolee, 'aria-itemcount', _getItemCount.call(this));

        _applyNodeStyles.call(this);
        //Update this._kwebfw_.clones
        //Update this._kwebfw_.heights
        //Update this._kwebfw_.items
        //Update this._kwebfw_.top
        //Update this._kwebfw_.scrollTop
        //Update this._kwebfw_.minScroleeHeight
    };

    /*eslint-disable no-unused-vars*/
    //This function will be called in the scope of widget instance
    var _onScroll = function CollectionView$_onScroll(scrollTop) { //scrollTop can never be less than zero
        var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this), delta = 0;

        if(this._kwebfw_.scrollTop === scrollTop) return;

        delta = Math.abs(this._kwebfw_.scrollTop - scrollTop);

        if(delta <= (_extraHeightToRender - 100)) return;

        if(delta > Math.floor(this._kwebfw_.prop.frame.height/3)) {
            _scrollToRenderNewItems.call(this, scrollTop, el);
        } else {
            if(scrollTop > this._kwebfw_.scrollTop) {
                _scrollDownWithDeltaItems.call(this, delta, el);
            } else {
                _scrollUpWithDeltaItems.call(this, delta, el);
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _onSectionChange = function CollectionView$_onSectionChange(index/*, action*/) {
        //<action> can be one of "add" / "remove" / "update"
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = this._kwebfw_.prop.data;

        if(!data || !($KU.is(index, 'number') && index >= 0 && index < data.length)) return;

        //Update this._kwebfw_.clones
        //Update this._kwebfw_.heights
        //Update this._kwebfw_.items
        //Update this._kwebfw_.top
        //Update this._kwebfw_.scrollTop
        //Update this._kwebfw_.minScroleeHeight
    };
    /*eslint-enable no-unused-vars*/


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        CollectionView: function CollectionView$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.CollectionView', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'CollectionView', null);
                }
            }

            if(!_.selectedItems) $KU.defineProperty(_, 'selectedItems', [], null);
            if(!_.ui) $KU.defineProperty(_, 'ui', {}, null);
            $KU.defineProperty(_.ui, 'scroll', {x:0, y:0, width:-1, height:-1, minX:-1, maxX:-1, minY:-1, maxY:-1, status:'ended'}, true);
            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }

            //This holds the templateControllers used in this Segment Items
            if(!_.templates) $KU.defineProperty(_, 'templates', {}, null);

            /* ====================== Book keeping properties starts here ====================== */

            //This holds the cloned templates, those will be rendered, and it is a flat list
            if(!_.items) $KU.defineProperty(_, 'items', [], true);

            //This holds the cloned templates, in the same DS as that of this.data
            if(!_.clones) $KU.defineProperty(_, 'clones', [], true);

            //This holds the height of cloned templates, in the same DS as that of this.data
            if(!_.heights) $KU.defineProperty(_, 'heights', [], true);

            //This holds the amount of top padding required for scroll behavior
            if(typeof _.top !== 'number') $KU.defineProperty(_, 'top', 0, true);

            //This holds the last scrolled position
            if(typeof _.scrollTop !== 'number') {
                $KU.defineProperty(_, 'scrollTop', 0, true);
            }

            //This needed for lazy loading, to determine the best size of scrollbar
            if(typeof _.minScroleeHeight !== 'number') {
                $KU.defineProperty(_, 'minScroleeHeight', 0, true);
            }

            if(typeof _.topCutOffAbsoluteIndex !== 'number') {
                $KU.defineProperty(_, 'topCutOffAbsoluteIndex', 0, true);
            }
            if(typeof _.bottomCutOffAbsoluteIndex !== 'number') {
                $KU.defineProperty(_, 'bottomCutOffAbsoluteIndex', 0, true);
            }

            /* ======================= Book keeping properties ends here ======================= */
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        CollectionView: function CollectionView$_postInitialization() {
            this._kwebfw_.invertedDataMap = _getInvertedDataMap(this._kwebfw_.prop.widgetDataMap);
            _onDataSet.call(this);
        }
    };


    //This function will be called in the scope of widget instance
    var _prevRenderableItems = function CollectionView$_prevRenderableItems(index, count) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = this._kwebfw_.prop.data,
            items = [], tpl = null, startSecIndex = -1, startItemIndex = -1,
            itemIndex = -1, lastItemIndex = -1, lastSecIndex = -1, secIndex = -1;

        index = _deduceIndex.call(this, index);
        startSecIndex = index[0];
        startItemIndex = index[1];

        if(startSecIndex === -1 && startItemIndex === -1) return items;

        if(startSecIndex === -1) {
            itemIndex = startItemIndex - 1;
            lastItemIndex = 0;

            while(count > 0 && itemIndex >= lastItemIndex) {
                tpl = _getClonedTemplate.call(this, [-1, itemIndex]);

                if($KU.is(tpl, 'widget') && _canRenderItem.call(this, tpl)) {
                    items.splice(0, 0, tpl);
                    count--;
                }

                itemIndex--;
            }
        } else {
            if(startItemIndex === -1) {
                secIndex = startSecIndex - 1;
                itemIndex = (data[secIndex][1].length - 1);
            } else {
                secIndex = startSecIndex;
                itemIndex = startItemIndex - 1;
            }

            lastSecIndex = 0;
            lastItemIndex = 0;

            while(count > 0 && secIndex >= lastSecIndex) {
                if(itemIndex === -1) {
                    tpl = _getClonedTemplate.call(this, [secIndex, -1]);

                    if($KU.is(tpl, 'widget') && _canRenderItem.call(this, tpl)) {
                        items.splice(0, 0, tpl);
                        count--;
                    }

                    secIndex--;
                    itemIndex = this._kwebfw_.clones[secIndex][1].length - 1;
                } else {
                    tpl = _getClonedTemplate.call(this, [secIndex, itemIndex]);

                    if($KU.is(tpl, 'widget') && _canRenderItem.call(this, tpl)) {
                        items.splice(0, 0, tpl);
                        count--;
                    }

                    itemIndex--;
                }
            }
        }

        return items;
    };


    //This function will be called in the scope of widget instance
    /*eslint-disable no-unused-vars*/
    var _prevTemplate = function CollectionView$_prevTemplate(index) {
        var data = this._kwebfw_.prop.data, secIndex = -1, itemIndex = -1, prev = null;

        index = _deduceIndex.call(this, index);

        if(secIndex >= 0
        && !(secIndex === -1 && itemIndex === -1)) {
            if(secIndex < data.length) {
                if(itemIndex >= 0) {
                    if(itemIndex < data[secIndex][1].length) {
                        if(itemIndex === 0) {
                            prev = _getClonedTemplate.call(this, [secIndex, -1], true);
                        } else {
                            prev = _getClonedTemplate.call(this, [secIndex, (itemIndex - 1)], true);
                        }
                    }
                } else {
                    if(secIndex > 0 && data[(secIndex - 1)][1].length > 0) {
                        prev = _getClonedTemplate.call(this, [(secIndex - 1), 0], true);
                    }
                }
            }
        } else if(itemIndex >= 0
        && !(secIndex === -1 && itemIndex === -1)) {
            if(itemIndex < data.length) {
                if(itemIndex > 0) {
                    prev = _getClonedTemplate.call(this, [-1, (itemIndex - 1)], true);
                }
            }
        }


        return prev;
    };
    /*eslint-enable no-unused-vars*/
    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        CollectionView: function CollectionView$_relayoutActiveTriggerer() {
            return ['data', 'layout'];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        CollectionView: function CollectionView$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //This function will be called in the scope of widget instance
    var _renderItems = function CollectionView$_renderItems(clones) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom,
            c = 0, clen = clones.length, fragment = null,
            createItem = function(clone) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    item = null, index = _deduceIndex.call(this, clone),
                    absIndex = (_absoluteIndex.call(this, index) + 1);

                item = clone._render();
                $KD.setAttr(item, 'kr', 'cvitem'); //NOTE:: This attr/val has high importance
                $KD.setAttr(item, 'kii', index.join(','));
                //$KD.setAttr(item, 'kwh-click', 'onItemSelect'); //TODO:
                //$KD.setAttr(item, 'kwh-keydown', 'onItemKeyDown');
                //$KD.setAttr(item, 'kwh-keyup', 'onItemKeyUp');
                $KD.setAttr(item, 'role', 'row');
                $KD.setAttr(item, 'tabindex', -1);
                $KD.setAttr(item, 'aria-colcount', 1);
                $KD.setAttr(item, 'aria-itemindex', absIndex);


                $KD.setAttr(item, 'role', 'gridcell');

                $KW.iterate(clone, function(widget) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                        view = widget._kwebfw_.view;

                    if(view) {
                        $KD.setAttr(view, 'aria-colindex', 1);
                        $KD.setAttr(view, 'aria-colcount', 1);
                        $KD.setAttr(view, 'aria-itemindex', absIndex);
                    }
                }, {tabs:false});


                return item;
            };

        if(clen === 1) {
            fragment = createItem.call(this, clones[0]);
        } else if(clen > 1) {
            fragment = $KD.create();

            for(c=0; c<clen; c++) {
                fragment.appendChild(createItem.call(this, clones[c]));
            }
        }

        return fragment;
    };


    //This function will be called in the scope of widget instance
    var _resetBookKeepers = function CollectionView$_resetBookKeepers(callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = this._kwebfw_.prop.data;

        this._kwebfw_.top = 0; this._kwebfw_.scrollTop = 0; this._kwebfw_.minScroleeHeight = 0;
        this._kwebfw_.topCutOffAbsoluteIndex = 0; this._kwebfw_.bottomCutOffAbsoluteIndex = 0;
        _flushClones(this._kwebfw_.clones);
        this._kwebfw_.items = []; this._kwebfw_.clones = []; this._kwebfw_.heights = [];

        if(data && data.length > 0 && _shouldLazyLoad.call(this)) {
            if(_isSectionDS(data[0])) {
                $KU.each(data, function(secItem, secIndex) {
                    this._kwebfw_.clones.push([null, []]);
                    this._kwebfw_.heights.push([-1, []]);
                    this._kwebfw_.heights[secIndex][0] = _getItemHeight.call(this, [secIndex, -1]);

                    if($KU.is(callback, 'function')) {
                        callback.call(this, [secIndex, -1]);
                    }

                    $KU.each(secItem[1], function(item, itemIndex) {
                        this._kwebfw_.clones[secIndex][1].push(null);
                        this._kwebfw_.heights[secIndex][1].push(-1);
                        this._kwebfw_.heights[secIndex][1][itemIndex] = _getItemHeight.call(this, [secIndex, itemIndex]);

                        if($KU.is(callback, 'function')) {
                            callback.call(this, [secIndex, itemIndex]);
                        }
                    }, this);
                }, this);
            } else if($KU.is(data[0], 'object')) {
                $KU.each(data, function(item, index) {
                    this._kwebfw_.clones.push(null);
                    this._kwebfw_.heights.push(-1);
                    this._kwebfw_.heights[index] = _getItemHeight.call(this, [-1, index]);

                    if($KU.is(callback, 'function')) {
                        callback.call(this, [-1, index]);
                    }
                }, this);
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _scrollDownWithDeltaItems = function CollectionView$_scrollDownWithDeltaItems(delta, el) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, cloneToAdd = null,
            cloneToRemove = null, deltaForAdd = 0, deltaForRemove = 0, count = 0,
            itemsToBeRemovedFromTop = [], itemsToBeAddedToBottom = [], removeIndex = -1;

        cloneToAdd = _nextRenderableItems.call(this, this._kwebfw_.items[(this._kwebfw_.items.length - 1)], 1)[0];
        cloneToRemove = this._kwebfw_.items[0];

        while((cloneToAdd || cloneToRemove) && (delta > deltaForAdd || delta > deltaForRemove)) {
            if(cloneToAdd && delta > deltaForAdd) {
                deltaForAdd += _getItemHeight.call(this, cloneToAdd);
                itemsToBeAddedToBottom.push(cloneToAdd);
            }

            if(cloneToRemove && delta > deltaForRemove) {
                deltaForRemove += _getItemHeight.call(this, cloneToRemove);
                itemsToBeRemovedFromTop.push(cloneToRemove);
            }

            count++;

            cloneToAdd = _nextRenderableItems.call(this, this._kwebfw_.items[(this._kwebfw_.items.length - 1 - count)], 1)[0];
            cloneToRemove = this._kwebfw_.items[count];
        }

        this._kwebfw_.scrollTop += delta;

        if(_absoluteIndex.call(this, itemsToBeRemovedFromTop[0]) <= this._kwebfw_.topCutOffAbsoluteIndex) {
            removeIndex = itemsToBeRemovedFromTop.length - 1;
            deltaForRemove = _getItemHeight.call(this, itemsToBeRemovedFromTop[removeIndex]);

            while(deltaForRemove <= _extraHeightToRender) {
                removeIndex--;
                deltaForRemove += _getItemHeight.call(this, itemsToBeRemovedFromTop[removeIndex]);
            }

            itemsToBeRemovedFromTop.splice((removeIndex + 1 /* 1 or 0 ??? */), (itemsToBeRemovedFromTop.length - removeIndex + 1 /* 1 or 0 ??? */));
        }

        $KU.each(itemsToBeRemovedFromTop, function(clone) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom;
            $KD.removeAt(el.scrolee, 0);
            this._kwebfw_.top += _getItemHeight.call(this, clone);
            this._kwebfw_.items.pop();
        }, this);

        $KU.each(itemsToBeAddedToBottom, function(clone) {
            this._kwebfw_.items.push(clone);
        }, this);

        $KD.add(el.scrolee, _renderItems.call(this, itemsToBeAddedToBottom));

        el.scrolee.style.paddingTop = this._kwebfw_.top + 'px';
    };

    /*eslint-disable no-unused-vars*/
    //This function will be called in the scope of widget instance
    var _scrollReachedBottom = function CollectionView$_scrollReachedBottom() {
        //TODO::
    };


    //This function will be called in the scope of widget instance
    var _scrollReachedTop = function CollectionView$_scrollReachedTop() {
        //TODO::
    };
    /*eslint-enable no-unused-vars*/


    //This function will be called in the scope of widget instance
    var _scrollUpWithDeltaItems = function CollectionView$_scrollUpWithDeltaItems(delta, el) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, cloneToAdd = null,
            cloneToRemove = null, deltaForAdd = 0, deltaForRemove = 0, count = 0,
            itemsToBeAddedToTop = [], itemsToBeRemovedFromBottom = [], removeIndex = -1;

        cloneToAdd = _prevRenderableItems.call(this, this._kwebfw_.items[0], 1)[0];
        cloneToRemove = this._kwebfw_.items[(this._kwebfw_.items.length - 1)];

        while((cloneToAdd || cloneToRemove) && (delta > deltaForAdd || delta > deltaForRemove)) {
            if(cloneToAdd && delta > deltaForAdd) {
                deltaForAdd += _getItemHeight.call(this, cloneToAdd);
                itemsToBeAddedToTop.push(cloneToAdd);
            }

            if(cloneToRemove && delta > deltaForRemove) {
                deltaForRemove += _getItemHeight.call(this, cloneToRemove);
                itemsToBeRemovedFromBottom.push(cloneToRemove);
            }

            count++;

            cloneToAdd = _prevRenderableItems.call(this, this._kwebfw_.items[count], 1)[0];
            cloneToRemove = this._kwebfw_.items[(this._kwebfw_.items.length - 1 - count)];
        }

        this._kwebfw_.scrollTop -= delta;

        $KU.each(itemsToBeAddedToTop, function(clone) {
            this._kwebfw_.items.splice(0, 0, clone);
            this._kwebfw_.top -= _getItemHeight.call(this, clone);
        }, this);

        if(_absoluteIndex.call(this, itemsToBeRemovedFromBottom[0]) >= this._kwebfw_.topCutOffAbsoluteIndex) {
            removeIndex = 0;
            deltaForRemove = _getItemHeight.call(this, itemsToBeRemovedFromBottom[removeIndex]);

            while(deltaForRemove <= _extraHeightToRender) {
                removeIndex++;
                deltaForRemove += _getItemHeight.call(this, itemsToBeRemovedFromBottom[removeIndex]);
            }

            itemsToBeRemovedFromBottom.splice((removeIndex + 1 /* 1 or 0 ??? */), (itemsToBeRemovedFromBottom.length - removeIndex + 1 /* 1 or 0 ??? */));
        }

        count = itemsToBeRemovedFromBottom.length;
        while(count > 0) {
            $KD.remove($KD.last(el.scrolee));
            this._kwebfw_.items.splice((this._kwebfw_.items.length-1), 1);
            count--;
        }

        $KD.addAt(el.scrolee, _renderItems.call(this, itemsToBeAddedToTop), 0);

        el.scrolee.style.paddingTop = this._kwebfw_.top + 'px';
    };


    //This function will be called in the scope of widget instance
    var _scrollToRenderNewItems = function CollectionView$_scrollToRenderNewItems(scrollTop, el) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, height = 0, clone = null;

        clone = _firstRenderableItem.call(this);
        this._kwebfw_.top = 0;
        this._kwebfw_.items = [];
        this._kwebfw_.scrollTop = scrollTop;

        //Populate this._kwebfw_.top
        scrollTop -= _extraHeightToRender;
        while(clone && this._kwebfw_.top <= scrollTop) {
            height = _getItemHeight(clone);
            this._kwebfw_.top += height;
            clone = _nextRenderableItems.call(this, clone, 1);
        }

        //Populate this._kwebfw_.items
        scrollTop = this.frame.height + _extraHeightToRender;
        height = 0;
        while(clone && height <= scrollTop) {
            height += _getItemHeight(clone);
            this._kwebfw_.items.push(clone);
            clone = _nextRenderableItems.call(this, clone, 1);
        }

        $KD.html(el.scrolee, '');
        $KD.add(el.scrolee, _renderItems.call(this, this._kwebfw_.items));
        el.scrolee.style.paddingTop = this._kwebfw_.top + 'px';
    };


    //All the functions will be called in the scope of widget instance
    var _setHorizontalLayout = function CollectionView$_setHorizontalLayout(el) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;

        $KD.setAttr(el.scrolee, 'kv', voltmx.collectionview.LAYOUT_HORIZONTAL);
        $KD.style(el.scrolee, {'transition': null, 'transform': null, 'width': null});
    };

    var _setVerticalLayout = function CollectionView$_setVerticalLayout(el) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;

        $KD.setAttr(el.scrolee, 'kv', voltmx.collectionview.LAYOUT_VERTICAL);
        $KD.style(el.scrolee, {'transition': null, 'transform': null, 'width': null});
    };

    var _setCustomLayout = function CollectionView$_setCustomLayout(el) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;

        $KD.setAttr(el.scrolee, 'kv', voltmx.collectionview.LAYOUT_CUSTOM);
        $KD.style(el.scrolee, {'transition': null, 'transform': null, 'width': null});
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        CollectionView: {
            data: function CollectionView$_setter_data(/*old*/) {
                _onDataSet.call(this);
            },

            /*eslint-disable no-unused-vars */
            selectedItemIndex: function CollectionView$_setter_selectedItemIndex(/*old*/) {
                var _ = this._kwebfw_, prop = _.prop, index = -1, deSelectedItem = [];

                if(!_isSectionDS(prop.data[0])) {
                    prop.selectedItemIndex[0] = -1;
                }

                if(!prop.selectedItemIndex) {
                    //TODO
                    deSelectedItem = _.selectedItems.splice(0, _.selectedItems.length);
                } else {
                    if(prop.selectionBehavior === voltmx.collectionview.SINGLE_SELECT) {
                        deSelectedItem = _.selectedItems.splice(0, _.selectedItems.length, prop.selectedItemIndex.slice(0));
                    } else if(prop.selectionBehavior === voltmx.collectionview.MULTI_SELECT) {
                        index = _getIndex(prop.selectedItemIndex, _.selectedItems);

                        if(index !== -1) {
                            deSelectedItem = _.selectedItems.splice(index, 1);
                        } else {
                            _.selectedItems.push(prop.selectedItemIndex.slice(0));
                        }
                    }
                }

                _setSelectedItemsRelatedProperties.call(this);

                if(deSelectedItem.length>0) {
                    _resetItemSelectedSkin.call(this, deSelectedItem);
                }

                _setItemSelectedSkin.call(this);
            },
            /*eslint-enable no-unused-vars */

            selectedItemIndices: function CollectionView$_setter_selectedItemIndices(/*old*/) {
                var prop = this._kwebfw_.prop, items = this._kwebfw_.selectedItems,
                    itemIndexes = null, s = 0, slen = 0, r = 0, rlen = 0,
                    deSelectedItems = items.splice(0, items.length),
                    itemIndices = prop.selectedItemIndices;

                if(itemIndices) {
                    slen = itemIndices.length;

                    for(s=0; s<slen; s++) {
                        itemIndexes = itemIndices[s][1];
                        rlen = itemIndexes.length;

                        for(r=0; r<rlen; r++) {
                            items.push([itemIndices[s][0], itemIndexes[r]]);
                        }
                    }
                }
                _setSelectedItemsRelatedProperties.call(this);

                if(deSelectedItems.length>0) {
                    _resetItemSelectedSkin.call(this, deSelectedItems);
                }

                _setItemSelectedSkin.call(this);
            },

            widgetDataMap: function CollectionView$_setter_widgetDataMap(old) {
                this._kwebfw_.invertedDataMap = _getInvertedDataMap(old);
            }
        }
    };

    var _resetItemSelectedSkin = function CollectionView$_resetItemSelectedSkin(deSelectedItems) {
        var $K = voltmx.$kwebfw$, _ = this._kwebfw_, $KD = $K.dom, prop = _.prop,
            selectedItem = null, selectedSkin = prop.itemSelectedSkin, i = 0;

        if(prop.selectionBehavior === voltmx.collectionview.SINGLE_SELECT) {
            selectedItem = _getIndexedInfo.call(this, deSelectedItems[0], _.clones);
            selectedItem && $KD.removeCls(selectedItem._kwebfw_.view, selectedSkin);
        } else if(prop.selectionBehavior === voltmx.collectionview.MULTI_SELECT) {
            for(i=0; i<deSelectedItems.length; i++) {
                selectedItem = _getIndexedInfo.call(this, deSelectedItems[i], _.clones);
                selectedItem && $KD.removeCls(selectedItem._kwebfw_.view, selectedSkin);
            }
        }
    };

    var _setItemSelectedSkin = function CollectionView$_setItemSelectedSkin() {
        var $K = voltmx.$kwebfw$, _ = this._kwebfw_, $KD = $K.dom, prop = _.prop,
            selectedItem = null, selectedSkin = prop.itemSelectedSkin, i = 0;

        if(prop.selectionBehavior === voltmx.collectionview.SINGLE_SELECT) {
            selectedItem = _getIndexedInfo.call(this, _.selectedItems[0], _.clones);
            selectedItem && $KD.addCls(selectedItem._kwebfw_.view, selectedSkin);
        } else if(prop.selectionBehavior === voltmx.collectionview.MULTI_SELECT) {
            for(i=0; i<_.selectedItems.length; i++) {
                selectedItem = _getIndexedInfo.call(this, _.selectedItems[i], _.clones);
                selectedItem && $KD.addCls(selectedItem._kwebfw_.view, selectedSkin);
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _setSelectedItemsRelatedProperties = function CollectionView$_setSelectedItemsRelatedProperties() {
        var prop = this._kwebfw_.prop, items = this._kwebfw_.selectedItems,
            section = false, indices = {}, r = 0,
            rlen = items.length, sindex = -1, rindex = -1, key = '';

        prop.selectedItemItems = [];

        if(prop.data && prop.data.length > 0) {
            section = _isSectionDS(prop.data[0]);
            prop.selectedItemIndex = (!rlen) ? null : items[(rlen-1)].slice(0);
            prop.selectedItemIndices = (!rlen) ? null : [];

            for(r=0; r<rlen; r++) {
                sindex = items[r][0];
                rindex = items[r][1];

                if(!section) {
                    if(sindex === 0) sindex = -1;
                    prop.selectedItemItems.push(prop.data[rindex]);
                } else {
                    prop.selectedItemItems.push(prop.data[sindex][1][rindex]);
                }

                key = sindex.toString();
                if(!Object.prototype.hasOwnProperty.call(indices, key)) {
                    indices[key] = [];
                }
                indices[key].push(rindex);
            }

            for(key in indices) {
                prop.selectedItemIndices.push([parseInt(key, 10), indices[key]]);
            }
        } else {
            prop.selectedItemIndex = null;
            prop.selectedItemIndices = null;
            items.splice(0, rlen);
        }
    };


    //This function will be called in the scope of widget instance
    var _shouldLazyLoad = function CollectionView$_shouldLazyLoad() {
        /*eslint-disable no-unused-vars */
        var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;

        if($KW.isFixedHeight(this)
            && this._kwebfw_.prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
            flag = true;
        }
        /*eslint-enable no-unused-vars */

        return false; //TODO:: return flag;
    };


    //This function will be called in the scope of widget instance
    var _validateInputIndices = function CollectionView$_validateInputIndices(secIndex, itemIndex, action) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, index = -1,
            data = this._kwebfw_.prop.data, itemIndexBoundary = 0,
            errorMessage = '', secIndexBoundary = 0;

        if(!$KU.is(itemIndex, 'number')) {
            errorMessage = 'Invalid item Index.';
        }

        if(!$KU.is(secIndex, 'undefined') && !$KU.is(secIndex, 'number')) {
            errorMessage = 'Invalid section Index.';
        }

        if(data && data.length > 0) {
            if(_isSectionDS(data[0])) {//TODO header can be null
                index = _deduceIndex.call(this, secIndex+','+itemIndex);
                secIndexBoundary = data.length;

                if(action === 'addsectionat') secIndexBoundary = secIndexBoundary + 1;

                if(index[0] === -1 || index[0] >= secIndexBoundary) {
                    errorMessage = 'Invalid section index.';
                } else if(['add', 'update', 'remove'].indexOf(action) !== -1) {
                    itemIndexBoundary = data[secIndex][1].length;
                    if(action === 'add') itemIndexBoundary = itemIndexBoundary + 1;
                }
            } else {
                if(!$KU.is(secIndex, 'undefined') && secIndex !== 0) {
                    errorMessage = 'Invalid section index.';
                }

                index = _deduceIndex.call(this, '-1,'+itemIndex);
                itemIndexBoundary = data.length;
                if(action === 'add') itemIndexBoundary = itemIndexBoundary + 1;
            }

            if(action !== 'addsectionat' && errorMessage === ''
                && (index[1] === -2 || index[1] >= itemIndexBoundary)) {
                errorMessage = 'Invalid item index.';
            }
        } else {
            if(action !== 'add' && action !== 'addsectionat') {
                errorMessage = 'No data exists.';
            } else if(action === 'addsectionat' && secIndex !== 0) {
                // addsectionat action secIndex rather than ZERO not allowed
                errorMessage = 'Invalid section index.';
            } else if(action === 'add') {
                if(itemIndex !== 0) {
                    // add action itemIndex rather than ZERO not allowed
                    errorMessage = 'Invalid item index.';
                } else if(!$KU.is(secIndex, 'undefined') && secIndex !== 0) {
                    // add action secIndex should be either -1 or undefined
                    errorMessage = 'Invalid section index.';
                }
            }
        }

        return errorMessage;
    };


    //All the functions will be called in the scope of widget instance
    var _updateSelectionBehavior = function CollectionView$_updateSelectionBehavior() {
        _clearSelectedIndices.call(this);
    };


    //This function will be called in the scope of widget instance
    var _updateBottomCutOffAbsoluteIndex = function CollectionView$_updateBottomCutOffAbsoluteIndex() {
        var height = 0, clone = null;

        clone = _lastRenderableItem.call(this);

        while(clone && height < _extraHeightToRender) {
            height += _getItemHeight.call(this, clone);

            if(height < _extraHeightToRender) {
                clone = _prevRenderableItems.call(this, clone, 1)[0];
            }
        }

        this._kwebfw_.bottomCutOffAbsoluteIndex = _absoluteIndex.call(this, clone);
    };


    //This function will be called in the scope of widget instance
    var _updateIndexes = function CollectionView$_updateIndexes(fromIndex, ofSectionIndex) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
            prop = this._kwebfw_.prop, data = prop.data, r = 0, rlen = 0,
            clones = this._kwebfw_.clones, s = 0, slen = 0, el = null;

        var updateIndex = function(collectionviewmodel, clone, index) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
                $KD = $K.dom, absIndex = null, li = null;

            if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                li = $KD.closest(clone._kwebfw_.view, 'kr', 'cvitem');

                if(li) {
                    absIndex = (_absoluteIndex.call(collectionviewmodel, index) + 1);
                    $KD.setAttr(li, 'kii', index);
                    $KD.setAttr(li, 'aria-itemindex', absIndex);
                }
            }

            $KW.iterate(clone, function(model) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    $KD = $K.dom, _ = model._kwebfw_;

                _.ii = index;

                if(_.view) {
                    $KD.setAttr(_.view, 'kwi', index);
                    $KW.replaceWAPIndex(model, index);
                    $KD.setAttr(_.view, 'kwp', _.wap);
                }
            }, {tabs:false});
        };

        if(data) {
            if(_isSectionDS(data[0])) {//TODO header can be null
                slen = clones.length;
                if(ofSectionIndex === -1) { //Section has changed
                    //Change index of items[s][0] and items[s][1][r]
                    for(s=fromIndex; s<slen; s++) {
                        updateIndex(this, clones[s][0], (s + ',-1'));

                        rlen = clones[s][1].length;
                        for(r=0; r<rlen; r++) {
                            updateIndex(this, clones[s][1][r], (s + ',' + r));
                        }
                        updateIndex(this, clones[s][2], (s + ',-2'));
                    }
                } else { //Item of a particular section has changed
                    //Change index of items[r]
                    clones = clones[ofSectionIndex][1];

                    rlen = clones.length;
                    for(r=fromIndex; r<rlen; r++) {
                        updateIndex(this, clones[r], (ofSectionIndex + ',' + r));
                    }
                }
            } else { //Item of a non-sectionable segment has changed
                //Change index of items[r]
                rlen = clones.length;
                for(r=fromIndex; r<rlen; r++) {
                    updateIndex(this, clones[r], ('-1,' + r));
                }
            }

            el = $KW.el(this);
            $KD.setAttr(el.scrolee, 'aria-itemcount', _getItemCount.call(this));
        }
    };

    //This function will be called in the scope of widget instance
    var _updateSectionFooterSkin = function CollectionView$_updateSectionFooterSkin() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, headerItems = [];

        $KU.each(this._kwebfw_.clones, function(record/*, index*/) {
            headerItems.push(record[2]);
        });

        $KU.each(headerItems, function(clone, index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                div = null;

            if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                div = $KD.closest(clone._kwebfw_.view, 'kr', 'cvitem');
            }

            if(div) {
                _applyItemAndHeaderSkin.call(this, div, clone, index);
            }
        }, this);
    };

    //This function will be called in the scope of widget instance
    var _updateSectionHeaderSkin = function CollectionView$_updateSectionHeaderSkin() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, headerItems = [];

        $KU.each(this._kwebfw_.clones, function(record/*, index*/) {
            headerItems.push(record[0]);
        });

        $KU.each(headerItems, function(clone, index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                div = null;

            if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                div = $KD.closest(clone._kwebfw_.view, 'kr', 'cvitem');
            }

            if(div) {
                _applyItemAndHeaderSkin.call(this, div, clone, index);
            }
        }, this);
    };


    //This function will be called in the scope of widget instance
    var _updateItemSkin = function CollectionView$_updateItemSkin() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;
        $KU.each(this._kwebfw_.items, function(clone, index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                div = null;

            if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                div = $KD.closest(clone._kwebfw_.view, 'kr', 'cvitem');
            }

            if(div) {
                _applyItemAndHeaderSkin.call(this, div, clone, index);
            }
        }, this);
    };


    var _updateScrollDirection = function CollectionView$__updateScrollDirection() {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this);
        _handleScrollDirection.call(this, el.scrolee);
    };


    //This function will be called in the scope of widget instance
    var _updateSpecialProperties = function CollectionView$_updateSpecialProperties(widget) {
        widget._kwebfw_.oid = this._kwebfw_.uid;
        widget._kwebfw_.wap = this._kwebfw_.wap + ('[' + widget._kwebfw_.ii + ']_') + widget._kwebfw_.wap;
    };


    //This function will be called in the scope of widget instance
    var _updateTopCutOffAbsoluteIndex = function CollectionView$_updateTopCutOffAbsoluteIndex() {
        var height = 0, clone = null;

        clone = _firstRenderableItem.call(this);

        while(clone && height < _extraHeightToRender) {
            height += _getItemHeight.call(this, clone);

            if(height < _extraHeightToRender) {
                clone = _nextRenderableItems.call(this, clone, 1)[0];
            }
        }

        this._kwebfw_.topCutOffAbsoluteIndex = _absoluteIndex.call(this, clone);
    };
    var _valid = {
        CollectionView: {
            bounces: function CollectionView$_valid_bounces(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            contentOffset: function CollectionView$_valid_contentOffset(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.x, 'size')
                && $KU.is(value.y, 'size')) {
                    flag = true;
                }

                return flag;
            },

            data: function CollectionView$_valid_data(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            dockSectionHeaders: function CollectionView$_valid_dockSectionHeaders(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            itemFocusSkin: function CollectionView$_valid_itemFocusSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            itemSelectedSkin: function CollectionView$_valid_itemSelectedSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },


            itemSkin: function CollectionView$_valid_itemSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            itemTemplate: function CollectionView$_valid_itemTemplate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'widget', 'FlexContainer') || $KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            layout: function CollectionView$_valid_layout(value) {
                var flag = false, options = [
                    voltmx.collectionview.LAYOUT_VERTICAL,
                    voltmx.collectionview.LAYOUT_HORIZONTAL,
                    voltmx.collectionview.LAYOUT_CUSTOM
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            minItemSpace: function CollectionView$_valid_minItemSpace(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    value = value.toLowerCase();

                    if($K.F.EIWP && $KU.is(value, 'numeric')) {
                        value = parseFloat(value, 10);
                    }
                }

                flag = $KU.is(value, 'size', true);

                return (flag ? [value, flag] : flag);
            },

            minLineSpace: function CollectionView$_valid_minLineSpace(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    value = value.toLowerCase();

                    if($K.F.EIWP && $KU.is(value, 'numeric')) {
                        value = parseFloat(value, 10);
                    }
                }

                flag = $KU.is(value, 'size', 'positive');

                return (flag ? [value, flag] : true);
            },

            onItemSelect: function CollectionView$_valid_onItemSelect(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onItemDisplay: function CollectionView$_valid_onItemDisplay(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            onScrollStart: function CollectionView$_valid_onScrollStart(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onScrolling: function CollectionView$_valid_onScrolling(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onScrollEnd: function CollectionView$_valid_onScrollEnd(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            pullToRefreshView: function CollectionView$_valid_pullToRefreshView(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'widget') || $KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            pushToRefreshView: function CollectionView$_valid_pushToRefreshView(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'widget') || $KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            reachingBeginningOffset: function CollectionView$_valid_reachingBeginningOffset(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.x, 'string')
                && $KU.is(value.x, 'size')
                && $KU.is(value.y, 'string')
                && $KU.is(value.y, 'size')) {
                    flag = true;
                }

                if($KU.is(value, 'null')) {
                    //TODO:
                    flag = true;
                }

                return flag;
            },

            reachingEndOffset: function CollectionView$_valid_reachingEndOffset(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.x, 'string')
                && $KU.is(value.x, 'size')
                && $KU.is(value.y, 'string')
                && $KU.is(value.y, 'size')) {
                    flag = true;
                }

                if($KU.is(value, 'null')) {
                    //TODO:
                    flag = true;
                }

                return flag;
            },

            releaseToPullRefreshView: function CollectionView$_valid_releaseToPullRefreshView(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'widget') || $KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            releaseToPushRefreshView: function CollectionView$_valid_releaseToPushRefreshView(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'widget') || $KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            retainSelection: function CollectionView$_valid_retainSelection(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            scrollDirection: function CollectionView$_valid_scrollDirection(value) {
                var flag = false, options = [
                    voltmx.collectionview.SCROLL_DIRECTION_BOTH,
                    voltmx.collectionview.SCROLL_DIRECTION_HORIZONTAL,
                    voltmx.collectionview.SCROLL_DIRECTION_VERTICAL
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            scrollingEvents: function SegmentUI2$_valid_scrollingEvents(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')) {
                    flag = true;
                }

                return flag;
            },

            sectionFooterSkin: function CollectionView$_valid_sectionFooterSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            sectionFooterTemplate: function CollectionView$_valid_sectionFooterTemplate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'widget', 'FlexContainer') || $KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            sectionHeaderSkin: function CollectionView$_valid_sectionHeaderSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            sectionHeaderTemplate: function CollectionView$_valid_sectionHeaderTemplate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'widget', 'FlexContainer') || $KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            selectedItemIndex: function CollectionView$_valid_selectedItemIndex(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
                    prop = this._kwebfw_.prop;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if($KU.is(value, 'array') && Object.prototype.hasOwnProperty.call(prop, 'data')
                && Object.prototype.hasOwnProperty.call(prop, 'selectedItemIndex')) {
                    flag = _validIndex.call(this, value.slice(0), true);
                }

                return flag;
            },

            /*eslint-disable no-unused-vars */
            selectedItemIndices: function CollectionView$_valid_selectedItemIndices(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = true,
                    s = 0, slen = 0, r = 0, rlen = 0, _ = this._kwebfw_,
                    prop = _.prop, secIndex = -1, itemIndexes = [], count = 0;

                if($KU.is(value, 'array')) {
                    slen = value.length;
                    for(s=0; s<slen; s++) {
                        if(flag === false) {
                            break;
                        } else {
                            secIndex = value[s][0];
                            itemIndexes = value[s][1];

                            rlen = itemIndexes.length;
                            for(r=0; r<rlen; r++) {
                                flag = _validIndex.call(this, [secIndex, itemIndexes[r]]);
                                if(flag === false) break;
                                else count++;
                                //TODO
                                /*if(!(prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW
                                && prop.selectionBehavior === constants.SEGUI_MULTI_SELECT_BEHAVIOR)) {
                                    if(count > 1) flag = false;
                                }*/
                            }
                        }
                    }
                    if(flag && value[0][0] === 0 && !_isSectionDS(prop.data[0])) {
                        value[0][0] = -1;
                        flag = [value, true];
                    }
                } else if(!$KU.is(value, 'null')) {
                    flag = false;
                }

                return flag;
            },
            /*eslint-enable no-unused-vars */

            selectedItemItems: function CollectionView$_valid_selectedItemItems(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array')) {
                    flag = true;
                }

                return flag;
            },

            selectionBehavior: function CollectionView$_valid_selectionBehavior(value) {
                var flag = false, options = [
                    voltmx.collectionview.SINGLE_SELECT,
                    voltmx.collectionview.MULTI_SELECT
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            showScrollbars: function CollectionView$_valid_showScrollbars(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },


            widgetDataMap: function CollectionView$_valid_widgetDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _validIndex = function CollectionView$_validIndex(index, mutate) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
            data = this._kwebfw_.prop.data, sectionable = false;

        if(data && data.length && $KU.is(index, 'array') && index.length === 2
        && $KU.is(index[0], 'number') && $KU.is(index[1], 'number')) {
            sectionable = _isSectionDS(data[0]);//TODO header can be null

            if(index[0] === 0 && !sectionable) {
                index[0] = -1;
            }

            if(index[0] < -1) index[0] = -1;
            if(index[1] < -1) index[1] = -1;

            if(!sectionable) {
                if(index[0] === -1 && index[1] >= 0 && index[1] < data.length) {
                    flag = true;
                }
            } else if(index[0] >= 0 && index[0] < data.length) {
                if(index[1] >= -1 && index[1] < data[index[0]][1].length) {
                    flag = true;
                }
            }
        }

        return (mutate === true && flag) ? [index, true] : flag;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        CollectionView: {
            alternateItemSkin: function CollectionView$_view_alternateItemSkin(/*el, old*/) {
                _updateItemSkin.call(this);
            },

            bounces: true,

            contentOffset: function CollectionView$_view_contentOffset(/*el, old*/) {
                this.setContentOffset(this.contentOffset, true);
            },

            contentOffsetMeasured: false,

            data: function CollectionView$_view_data(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    prop = this._kwebfw_.prop, clone = null,
                    height = 0;

                $KD.setAttr(el.scrolee, 'aria-itemcount', _getItemCount.call(this));
                $KD.html(el.scrolee, '');
                this._kwebfw_.items = [];

                if(prop.data && prop.data.length) {
                    if(_shouldLazyLoad.call(this)) {
                        clone = _firstRenderableItem.call(this);
                        _updateTopCutOffAbsoluteIndex.call(this);
                        _updateBottomCutOffAbsoluteIndex.call(this);

                        if($KU.is(clone, 'widget')) {
                            this._kwebfw_.items.push(clone);
                            height += _getItemHeight.call(this, clone);

                            while($KU.is(clone, 'widget') && height < (prop.frame.height + _extraHeightToRender)) {
                                clone = _nextRenderableItems.call(this, clone._kwebfw_.ii, 1)[0];

                                if($KU.is(clone, 'widget')) {
                                    this._kwebfw_.items.push(clone);
                                    height += _getItemHeight.call(this, clone);
                                }
                            }
                        }


                        if(this._kwebfw_.items.length) {
                            $KD.add(el.scrolee, _renderItems.call(this, this._kwebfw_.items));
                        }

                        //TODO:: this._kwebfw_.top and this._kwebfw_.minScroleeHeight
                        $KD.style(el.scrolee, {paddingTop:(this._kwebfw_.top + 'px'), height:(this._kwebfw_.minScroleeHeight + 'px')});
                    } else {
                        _iterateOverData.call(this, prop.data, function(data, itemIndex, secIndex) {
                            clone = _getClonedTemplate.call(this, [secIndex, itemIndex]);
                            clone && _cleanupLayoutProps(clone, this.layout, itemIndex < 0);
                            clone && this._kwebfw_.items.push(clone);
                        });

                        if(this._kwebfw_.items.length) {
                            $KD.add(el.scrolee, _renderItems.call(this, this._kwebfw_.items));
                        }
                        _applyNodeStyles.call(this);
                    }
                }
            },

            dockSectionHeaders: true,

            itemFocusSkin: true,

            itemSelectedSkin: true,

            itemSkin: function CollectionView$_view_itemSkin(/*el, old*/) {
                _updateItemSkin.call(this);
            },

            scrollDirection: function CollectionView$_view_scrollDirection(/*el, old*/) {
                _updateScrollDirection.call(this);
            },

            itemTemplate: true,

            layout: function CollectionView$_view_layout(el/*, old*/) {
                if(this._kwebfw_.prop.layout === voltmx.collectionview.LAYOUT_HORIZONTAL) {
                    _setHorizontalLayout.call(this, el);
                } else if(this._kwebfw_.prop.layout === voltmx.collectionview.LAYOUT_VERTICAL) {
                    _setVerticalLayout.call(this, el);
                } else {
                    _setCustomLayout.call(this, el);
                }
            },

            minItemSpace: function CollectionView$_view_minItemSpace(/*el, old*/) {
                _applyLineSpaceAndItemSpace.call(this);
            },

            minLineSpace: function CollectionView$_view_minLineSpace(/*el, old*/) {
                _applyLineSpaceAndItemSpace.call(this);
            },

            onItemSelect: true,

            onItemDisplay: true,

            pullToRefreshView: true,

            pushToRefreshView: true,

            reachingBeginningOffset: true,

            reachingEndOffset: true,

            releaseToPullRefreshView: true,

            releaseToPushRefreshView: true,

            retainSelection: true,

            scrollingEvents: true,

            sectionFooterSkin: function CollectionView$_view_sectionHeaderSkin(/*el, old*/) {
                var prop = this._kwebfw_.prop;

                if(prop.data && prop.data.length > 0 && _isSectionDS(prop.data[0])) {
                    _updateSectionFooterSkin.call(this);
                }
            },

            sectionFooterTemplate: true,

            sectionHeaderSkin: function CollectionView$_view_sectionHeaderSkin(/*el, old*/) {
                var prop = this._kwebfw_.prop;

                if(prop.data && prop.data.length > 0 && _isSectionDS(prop.data[0])) {
                    _updateSectionHeaderSkin.call(this);
                }
            },

            sectionHeaderTemplate: true,

            selectedItemIndex: function CollectionView$_view_selectedItemIndex(/*el, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_,
                    prop = _.prop, selectedItem = null;

                if($KW.visible(this) && prop.selectedItemIndex) {
                    //_.setFocus is set in voltmxevent.js _setOwnerSelectedIndex.CollectionView function
                    if(_.setFocus !== false) { //IMP:: Must compare with boolean false
                        selectedItem = _getIndexedInfo.call(this, prop.selectedItemIndex, _.clones);
                        selectedItem.setFocus(true); // selectedItem might be null ??

                        if($KW.isFixedHeight(this)) {
                            $KW.scrollElementToParentScroller(selectedItem);
                        }
                    }
                }
            },

            selectedItemIndices: true,

            selectedItemItems: false,

            selectionBehavior: function CollectionView$_view_selectionBehavior(/*el, old*/) {
                _updateSelectionBehavior.call(this);
            },

            showScrollbars: true,

            widgetDataMap: true
        }
    };


    Object.defineProperty(voltmx.ui, 'CollectionView', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.CollectionView constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var CollectionView = function CollectionView(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    alternateItemSkin: '',
                    bounces: true, //Only for TABLE_VIEW //In doc available, but in SPA code not available
                    containerHeight: '', //In doc not available, but in SPA code available
                    containerHeightReference: '', //In doc not available, but in SPA code available
                    contentOffset: null, //In doc not available, but in SPA code available
                    contentOffsetMeasured: {x: 0, y: 0},
                    data: null,
                    dockSectionHeaders: false,
                    enableScrollBounce: true, //In doc not available, but in SPA code available
                    layout: voltmx.collectionview.LAYOUT_VERTICAL,
                    needPageIndicator: true,
                    onItemSelect: null,
                    onItemDisplay: null,
                    onScrollStart: null,
                    onScrolling: null,
                    onScrollEnd: null,
                    retainSelection: false,
                    itemFocusSkin: '',
                    itemSelectedSkin: '',
                    itemSkin: '',
                    itemTemplate: null,
                    scrollingEvents: {},
                    sectionFooterSkin: '',
                    sectionFooterTemplate: null,
                    sectionHeaderSkin: '',
                    sectionHeaderTemplate: null,
                    selectedItemIndex: null,
                    selectedItemIndices: null,
                    selectedItemItems: [],
                    selectionBehavior: voltmx.collectionview.SINGLE_SELECT,
                    showScrollbars: true,
                    widgetDataMap: {}
                };
            }

            _populateUnderscore.CollectionView.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            CollectionView.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.CollectionView, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.CollectionView.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to CollectionView
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.CollectionView[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.CollectionView>, but not in <_valid.CollectionView> namespace.');
                        } else {
                            valid = _valid.CollectionView[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to CollectionView
                $KU.each(_view.CollectionView, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function CollectionView$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.CollectionView[key], 'function')) {
                            return _getter.CollectionView[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function CollectionView$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.CollectionView[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.CollectionView[key], 'function')) {
                                        _setter.CollectionView[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.CollectionView().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.CollectionView().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    if($KU.is(p.contentOffset, undefined)) p.contentOffset = null;
                    if($KU.is(p.contentOffsetMeasured, undefined)) p.contentOffsetMeasured = {x: 0, y: 0};
                    if($KU.is(p.selectedItemIndex, undefined)) p.selectedItemIndex = null;
                }

                if($KU.is(_postInitialization.CollectionView, 'function')) {
                    _postInitialization.CollectionView.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(CollectionView, voltmx.ui.BasicWidget);


        /**
         * Takes care of flushing out the widget reference to clean memory.
         *
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.CollectionView
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     void
         */
        var collectionview_flush = function CollectionView$_flush(config) {
            var $super = voltmx.ui.CollectionView.base.prototype;

            _flushClones.call(this, this._kwebfw_.clones, config);
            $super._flush.call(this);
        };


        /**
         * Builds the view layer for CollectionView widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.CollectionView
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  CollectionView view.
         */
        var collectionview_render = function CollectionView$_render(tag, context) {
            var $super = voltmx.ui.CollectionView.base.prototype, _ = this._kwebfw_,
                $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                $KD = $K.dom, docker = null, view = _.view, blocker = null,
                scrolee = null, hScroll = null, vScroll = null, el = null;

            if(!$KU.is(context, 'object')) context = {};

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    scrolee = $KD.create('DIV', {role:'grid', 'kv': this.layout});//todo
                    docker = $KD.create('DIV', {kr:'docker'}, {position:'absolute', top:'0px', left:'left', width:'100%'});
                    blocker = $KD.create('DIV', {kr:'blocker'}, {position:'absolute', top:'0px', left:'left', width:'100%', height:'100%'});

                    $KD.add(docker, blocker);

                    if($KU.scrollType() !== 'native') {
                        $KD.setAttr(scrolee, 'kr', 'scrolee');
                        hScroll = $KD.create('DIV', {kr:'h-scroll'});
                        vScroll = $KD.create('DIV', {kr:'v-scroll'});
                    }

                    //pageNav = $KD.create('DIV', {align:'center'}, {display:'none', position:'absolute', bottom:'0px', width:'100%'});

                    view = $super._render.call(this, tag, [scrolee, docker, hScroll, vScroll]);

                    $KD.setAttr(view, 'kwh-keydown', 'onKeyDown');
                    $KD.setAttr(scrolee, 'aria-colcount', 1);

                    el = $KW.el(view);

                    $KW.registerNativeScrollEvent(this);
                    //$KD.on(el.viewport, 'scroll', 'segment', _animator.CollectionView.scrollStart, {scope: this});
                }

                el = $KW.el(view);

                if($KU.scrollType() !== 'native') {
                    $KD.style(el.node, {overflowX:'hidden', overflowY:'hidden'});
                } else {
                    _handleScrollDirection.call(this, el.scrolee);
                    $KD.style(el.viewport, {overflowX:'auto', overflowY:'auto'});
                    $KD.style(el.node, {overflowX:'hidden'});
                }

                _view.CollectionView.data.call(this, el, _.prop.data);
                //TODO: accessibility
                //$KW.accessibility(this);
            }

            return view;
        };


        var collectionview_addAll = function CollectionView$addAll(data, anim) {
            var prop = this._kwebfw_.prop, secIndex = -1, itemIndex = -1;

            if(!_valid.CollectionView.data.call(this, data)) {
                throw new Error('Invalid data.');
            }
            if(!prop.data) prop.data = [];

            if(prop.data.length === 0
            || (_isSectionDS(prop.data[0]) && _isSectionDS(data[0]))
            || (!_isSectionDS(prop.data[0]) && !_isSectionDS(data[0]))) {
                if(_isSectionDS(data[0])) secIndex = prop.data.length;
                else itemIndex = prop.data.length;

                _onItemChange.call(this, secIndex, itemIndex, 'addall', data, anim);
            } else {
                //throw Error:: Existing data structure of Segment do not match with that of passed data
                throw new Error('Invalid data.');
            }
        };


        var collectionview_addDataAt = function CollectionView$addDataAt(data, itemIndex, secIndex, anim) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, errorMessage = null;

            if($KU.is(data, 'object') || $KU.is(data, 'array')) {
                errorMessage = _validateInputIndices.call(this, secIndex, itemIndex, 'add');

                if(errorMessage === '') {
                    if(!$KU.is(secIndex, 'number')) secIndex = -1;
                    if(!this._kwebfw_.prop.data) this._kwebfw_.prop.data = [];
                    _onItemChange.call(this, secIndex, itemIndex, 'add', data, anim);
                } else {
                    throw new Error(errorMessage);
                }
            } else {
                throw new Error('Invalid data.');
            }
        };


        var collectionview_addSectionAt = function CollectionView$addSectionAt(data, index, anim) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                prop = this._kwebfw_.prop, errorMessage = '';

            if(!$KU.is(data, 'array')) {
                throw new Error('Invalid data.');
            }

            errorMessage = _validateInputIndices.call(this, index, 0, 'addsectionat');

            if(errorMessage === '') {
                if(!prop.data) prop.data = [];

                if(prop.data.length === 0 || _isSectionDS(prop.data[0])) {
                    _onItemChange.call(this, index, -1, 'addsectionat', data, anim);
                } else {
                    throw new Error('Invalid data.');
                }
            } else {
                throw new Error(errorMessage);
            }
        };

        /*eslint-disable no-unused-vars*/
        var collectionview_animateItems = function CollectionView$animateItems(animContext) {
            _animator.CollectionView.animateItems.call(this, animContext);
        };
        /*eslint-enable no-unused-vars*/


        var collectionview_appendLayoutDataAt = function CollectionView$appendLayoutDataAt(data, itemIndex, sectionIndex) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, itemModel = null,
                _ = this._kwebfw_, prop = _.prop, flexProps = $KW.getFlexProperties(),
                widgetDataMap = prop.widgetDataMap;

            if($KU.is(data, 'object')) data = [data];

            if($KU.is(sectionIndex, 'undefined')) sectionIndex = -1;
            $KU.each(data, function(data, counter) {
                itemModel = _getIndexedInfo.call(this, [sectionIndex, itemIndex + counter], _.clones);

                $KW.iterate(itemModel, function(model/*, pmodel, index*/) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils,
                        dataId = '', prop = null;

                    dataId = widgetDataMap[model.id];//TODO component

                    if($KU.is(dataId, 'string') && dataId
                        && Object.prototype.hasOwnProperty.call(data, dataId)) {
                        prop = data[dataId];
                    }

                    if($KU.is(prop, 'object')) {
                        $KU.each(prop, function(value, keey) {
                            if(flexProps.indexOf(keey) > -1) {
                                model[keey] = value;
                            }
                        });
                    }
                }, {tabs:false});

                if(itemModel) {
                    var rootContainer = $KW.getRootNode(this);
                    //itemModel._kwebfw_.forceLayout = true
                    rootContainer.forceLayout();
                }
            }, this);
        };


        var collectionview_getIndicesForVisibleItems = function CollectionView$getIndicesForVisibleItems() {
            return _getVisibleItems.call(this, {indices: true});
        };

        var collectionview_getVisibleItems = function CollectionView$getVisibleItems() {
            return _getVisibleItems.call(this, {indices: false});
        };


        var collectionview_removeAll = function CollectionView$removeAll(anim) {
            if(_animator.CollectionView.canAnimate.call(this, anim)) {
                _animator.CollectionView.onItemDisplayHandler.call(this, voltmx.segment.REMOVE, this._kwebfw_.items);
                _animator.CollectionView.applyItemsAnimationByAPI.call(this, 'removeall', this._kwebfw_.items, -1, -1, anim);
            } else {
                _action.CollectionView._removeAll.call(this);
            }
        };


        var collectionview_removeAt = function CollectionView$removeAt(itemIndex, secIndex, count, anim) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, errorMessage = null;

            errorMessage = _validateInputIndices.call(this, secIndex, itemIndex, 'remove');
            if(errorMessage === '') {
                if(!$KU.is(secIndex, 'number')) secIndex = -1;
                _onItemChange.call(this, secIndex, itemIndex, 'remove', count || 1, anim);
            } else {
                throw new Error(errorMessage);
            }
        };


        var collectionview_removeSectionAt = function CollectionView$removeSectionAt(index, count, anim) {
            var prop = this._kwebfw_.prop;

            if(prop.data && prop.data.length > 0 && _isSectionDS(prop.data[0])) {
                if(index >= 0 && index < prop.data.length) {
                    _onItemChange.call(this, index, -1, 'removesectionat', prop.data, count || 1, anim);
                } else {
                    throw new Error('Invalid index passed.');
                }
            } else {
                throw new Error('Invalid input or no data exists.');
            }
        };

        var collectionview_scrollToItemAtIndex = function CollectionView$scrollToItemAtIndex(context) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, _ = this._kwebfw_,
                item = null, sectionIndex = context.sectionIndex, itemIndex = context.itemIndex;

            if($KU.is(sectionIndex, 'undefined')) sectionIndex = -1;
            item = _getIndexedInfo.call(this, [sectionIndex, itemIndex], _.clones);
            item.setFocus(true); // item might be null ??

            $KW.scrollElementToParentScroller(item);
        };

        /*eslint-disable no-unused-vars*/
        var collectionview_setAnimations = function CollectionView$setAnimations(animInfo) {
            _animator.CollectionView.setAnimations.call(this, animInfo);
        };
        /*eslint-enable no-unused-vars*/

        var collectionview_setActive = function CollectionView$setActive(itemIndex, secIndex) {
            var $K = kony.$kwebfw$, $KD = $K.dom, $KU = $K.utils, $KW = $K.widget,
                $super = kony.ui.CollectionView.base.prototype, flag = false,
                index = '', li = null, view = this._kwebfw_.view;

            if (!$KU.is(itemIndex, 'number')) itemIndex = -1;
            if (!$KU.is(secIndex, 'number')) secIndex = -1;

            if (itemIndex < 0 && secIndex < 0) {
                $super.setActive.call(this);
            } else {
                flag = _validIndex.call(this, [secIndex, itemIndex]);

                if (flag && $KW.isRendered(this)) {
                    index = secIndex + ',' + itemIndex;
                    li = $KD.find(view, '[kii="' + index + '"]')[0];
                    li && $KD.focus(li);
                } else {
                    if (!flag) {
                        throw new Error('Invalid index passed');
                    } else {
                        throw new Error('Cannot focus the widget befor rendering it');
                    }
                }
            }
        };

        var collectionview_setContentOffset = function segmentedUI2$setAnimations(offset, animate) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget;

            $KW.setContentOffset(this, offset, animate);
        };

        var collectionview_setData = function CollectionView$setData(data, anim) {
            _clearSelectedIndices.call(this);
            this.data = data;
            if(_animator.CollectionView.canAnimate.call(this, anim)) {
                _animator.CollectionView.onItemDisplayHandler.call(this, voltmx.segment.UPDATE, this._kwebfw_.items);
                _animator.CollectionView.applyItemsAnimationByAPI.call(this, 'setdata', this._kwebfw_.items, -1, -1, anim);
            }
        };


        var collectionview_setDataAt = function CollectionView$setDataAt(data, itemIndex, secIndex, anim, arg4) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, widget = null, key = '',
                _ = this._kwebfw_, prop = _.prop, errorMessage = null,
                _constructObject = function(widget, data, key) {
                    var defaultProp = null, value = null;

                    if($KU.is(data, 'string')) {
                        defaultProp = $KW.getDefaultProperty(widget);
                        value = data;
                        data = {};
                        data[defaultProp] = value;
                    } else {
                        data = {};
                    }

                    data[key] = widget[key];
                    return data;
                };

            if(arguments.length === 5 && $KU.is(data, 'widget')) {
                //Will get into this, when setter of cloned model is called
                widget = data;
                key = itemIndex;
                itemIndex = anim;
                secIndex = arg4;

                if(secIndex === -1 && itemIndex !== -1) {
                    if($KU.is(prop.data[itemIndex][widget.id], 'object')) {
                        prop.data[itemIndex][widget.id][key] = widget[key];
                    } else {
                        prop.data[itemIndex][widget.id] = _constructObject(widget, prop.data[itemIndex][widget.id], key);
                    }
                } else if(secIndex !== -1 && itemIndex === -1) {
                    if($KU.is(prop.data[secIndex][0][widget.id], 'object')) {
                        prop.data[secIndex][0][widget.id][key] = widget[key];
                    } else {
                        prop.data[secIndex][0][widget.id] = _constructObject(widget, prop.data[secIndex][0][widget.id], key);
                    }
                } else if(secIndex !== -1 && itemIndex === -2) {
                    if($KU.is(prop.data[secIndex][2][widget.id], 'object')) {
                        prop.data[secIndex][2][widget.id][key] = widget[key];
                    } else {
                        prop.data[secIndex][2][widget.id] = _constructObject(widget, prop.data[secIndex][0][widget.id], key);
                    }
                } else if(secIndex !== -1 && itemIndex !== -1) {
                    if($KU.is(prop.data[secIndex][1][itemIndex][widget.id], 'object')) {
                        prop.data[secIndex][1][itemIndex][widget.id][key] = widget[key];
                    } else {
                        prop.data[secIndex][1][itemIndex][widget.id] = _constructObject(widget, prop.data[secIndex][1][itemIndex][widget.id], key);
                    }
                }
            } else { //This is actual implementation of setDataAt
                if($KU.is(data, 'array')) {
                    errorMessage = _validateInputIndices.call(this, secIndex, itemIndex, 'update');

                    if(errorMessage === '') {
                        if(!$KU.is(secIndex, 'number')) secIndex = -1;
                        _onItemChange.call(this, secIndex, itemIndex, 'update', data, anim);
                    } else {
                        throw new Error(errorMessage);
                    }
                } else {
                    throw new Error('Invalid data.');
                }
            }
        };


        var collectionview_setSectionAt = function CollectionView$setSectionAt(data, index, anim) {
            var prop = this._kwebfw_.prop;

            if(prop.data && prop.data.length > 0 && _isSectionDS(prop.data[0])) {
                if(index >= 0 && index < prop.data.length) {
                    _onItemChange.call(this, index, -1, 'setsectionat', data, anim);
                } else {
                    throw new Error('Invalid index passed.');
                }
            } else {
                throw new Error('Invalid input or no data exists.');
            }
        };


        $K.defVoltmxProp(CollectionView.prototype, [
            {keey:'_flush', value:collectionview_flush},
            {keey:'_render', value:collectionview_render},
            {keey:'addAll', value:collectionview_addAll},
            {keey:'addDataAt', value:collectionview_addDataAt},
            {keey:'addSectionAt', value:collectionview_addSectionAt},
            {keey:'appendLayoutDataAt', value:collectionview_appendLayoutDataAt},
            {keey:'getIndicesForVisibleItems', value:collectionview_getIndicesForVisibleItems},
            {keey:'getVisibleItems', value:collectionview_getVisibleItems},
            {keey:'removeAll', value:collectionview_removeAll},
            {keey:'removeDataAt', value:collectionview_removeAt},
            {keey:'removeSectionAt', value:collectionview_removeSectionAt},
            {keey:'scrollToItemAtIndex', value:collectionview_scrollToItemAtIndex},
            {keey:'setActive', value:collectionview_setActive},
            {keey:'setContentOffset', value:collectionview_setContentOffset},
            {keey:'setData', value:collectionview_setData},
            {keey:'setDataAt', value:collectionview_setDataAt},
            {keey:'setSectionAt', value:collectionview_setSectionAt}
        ]);


        return CollectionView;
    }())});
}());

/* FILE PATH :: 'lib/widgets/voltmxcustomwidget.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'CustomWidget', value:{}, items:[
            {keey:'onRender', value:function() {
                var view = this._kwebfw_.view,
                    ns = _namespace.call(this),
                    config = {};

                config['uniqueId'] = this._kwebfw_.wap.replace(/_/g, '');
                ns && ns.initializeWidget(view, this, config);
            }}
        ]}
    ]);

    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        CustomWidget: {
            //
        }
    };


    //This functions will be called in the scope of widget instance
    var _namespace = function CustomWidget$_namespace() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;
        return $KU.get(this.widgetName, window);
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        CustomWidget: function CustomWidget$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.CustomWidget', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'CustomWidget', null);
                }
            }

            if(!_.tpwp) $KU.defineProperty(_, 'tpwp', {}, null);
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {};


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        CustomWidget: function CustomWidget$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        CustomWidget: function CustomWidget$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        CustomWidget: {
            //
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        CustomWidget: {
            clipBounds: function CustomWidget$_valid_clipBounds(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        CustomWidget: {
            clipBounds: function CustomWidget$_view_clipBounds(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.clipBounds) {
                    $KD.style(el.node, {overflowX:'hidden', overflowY:'hidden'});
                } else {
                    $KD.style(el.node, {overflowX:'visible', overflowY:'visible'});
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'CustomWidget', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.CustomWidget constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var CustomWidget = function CustomWidget(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!($KU.is(pspconfig.widgetName, 'string') && pspconfig.widgetName)) {
                throw new Error('Invalid value of property "widgetName" passed for <CustomWidget> with id="'+bconfig.id+'"');
            } else {
                if(!bconfig.isPreValidated) {
                    prop = {
                        clipBounds: true
                    };
                }

                _populateUnderscore.CustomWidget.call(this);

                CustomWidget.base.call(this, bconfig, lconfig, {});

                if(!bconfig.isPreValidated) {
                    if($KU.is(_dependentPropertiesValidationMessage.CustomWidget, 'function')) {
                        dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.CustomWidget.call(this, prop, bconfig, lconfig, pspconfig);
                    }
                }

                if(dependentPropertiesValidationMessage) {
                    throw new Error(dependentPropertiesValidationMessage);
                } else {
                    if(!bconfig.isPreValidated) {
                        //Defaulting to platfom values specific to CustomWidget
                        $KU.each(prop, function(value, key) {
                            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                                $KW = $K.widget, valid = false, message = '';

                            if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                                bconfig[key] = value;
                            } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                                throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                            } else if(!$KU.is(_valid.CustomWidget[key], 'function')) {
                                throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.CustomWidget>, but not in <_valid.CustomWidget> namespace.');
                            } else {
                                valid = _valid.CustomWidget[key].call(self, bconfig[key]);
                                if($KU.is(valid, 'array')) {
                                    bconfig[key] = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                }
                            }
                        });
                    }

                    //Defining Getters/Setters specific to CustomWidget
                    $KU.each(_view.CustomWidget, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                        $KU.defineGetter(self, key, function CustomWidget$_getter() {
                            var $K = voltmx.$kwebfw$, $KU = $K.utils;

                            if($KU.is(_getter.CustomWidget[key], 'function')) {
                                return _getter.CustomWidget[key].call(this, this._kwebfw_.prop[key]);
                            }
                            return this._kwebfw_.prop[key];
                        }, true);

                        $KU.defineSetter(self, key, function CustomWidget$_setter(val) {
                            var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null, valid = false,
                                $KW = $K.widget, rmodel = null, final = null, message = '';

                            if(value === false) {
                                throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                            } else if(this._kwebfw_.prop[key] !== val) {
                                rmodel = $KW.rmodel(this);

                                if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                    throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                                } else {
                                    valid = _valid.CustomWidget[key].call(this, val);
                                    if($KU.is(valid, 'array')) {
                                        val = valid[0]; valid = valid[1];
                                    }

                                    if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                        message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                        if($KU.is(valid, 'string')) {
                                            message += ('\n' + valid);
                                        }

                                        throw new Error(message);
                                    } else {
                                        old = this._kwebfw_.prop[key];
                                        this._kwebfw_.prop[key] = val;

                                        if($KU.is(_setter.CustomWidget[key], 'function')) {
                                            _setter.CustomWidget[key].call(this, old);
                                        }

                                        if(_relayoutActiveTriggerer.CustomWidget().indexOf(key) >= 0) {
                                            $KW.markRelayout(this);
                                        }

                                        if(_relayoutPassiveTriggerer.CustomWidget().indexOf(key) >= 0) {
                                            final = this._kwebfw_.flex.final;

                                            if(!(final.height && final.width)) {
                                                $KW.markRelayout(this);
                                            }
                                        }

                                        $KW.onPropertyChange(this, key, old);

                                        if($KU.is(value, 'function')) {
                                            value.call(this, old);
                                        }
                                    }
                                }
                            }
                        }, false);
                    });

                    if($KU.is(_postInitialization.CustomWidget, 'function')) {
                        _postInitialization.CustomWidget.call(this);
                    }
                }

                //Defining Getters/Setters specific to CustomWidget
                $KU.each(pspconfig, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.tpwp, key, value, {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function CustomWidget$_getter() {
                        return this._kwebfw_.tpwp[key];
                    }, true);

                    $KU.defineSetter(self, key, function CustomWidget$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget,
                            rmodel = $KW.rmodel(this), ns = null;

                        if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                            throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                        } else {
                            this._kwebfw_.tpwp[key] = val;

                            ns = _namespace.call(this);
                            ns && ns.modelChange(this, key, val);
                        }
                    }, false);
                });
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(CustomWidget, voltmx.ui.BasicWidget);


        /**
         * Builds the view layer for voltmx.ui.CustomWidget widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.CustomWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  CustomWidget view.
         */
        var custom__render = function CustomWidget$_render(tag) {
            var $super = voltmx.ui.CustomWidget.base.prototype, _ = this._kwebfw_,
                $K = voltmx.$kwebfw$, $KW = $K.widget, view = _.view, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, tag);

                    el = $KW.el(view);

                    _view.CustomWidget.clipBounds.call(this, el, this.clipBounds);
                }

                $KW.accessibility(this);
            }

            return view;
        };


        $K.defVoltmxProp(CustomWidget.prototype, [
            {keey:'_render', value:custom__render}
        ]);


        return CustomWidget;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxdatagrid.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'DataGrid', value:{}, items:[
            {keey:'onCellKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, tr = null,
                    td = null, code = evt.keyCode || evt.which, el = $KW.el(this),
                    index = -1, nextFocusRow = function(tr, code) {
                        var rowIndex = $KD.index(tr);

                        if(code === 38) {
                            if(el.dockedheader && rowIndex === 1) {
                                tr = el.dockedheader;
                            } else {
                                tr = $KD.prev(tr);
                            }
                        } else if(code === 40) {
                            if(el.dockedheader && rowIndex === 0) {
                                tr = $KD.childAt(el.table, 1);
                            } else {
                                tr = $KD.next(tr);
                            }
                        }
                        return tr;
                    };

                if([37, 38, 39, 40].indexOf(code) >= 0) {
                    if(code === 37) { //Left Arrow
                        td = $KD.prev(evt.target);
                    } else if(code === 38) { //Up Arrow
                        index = $KD.index(evt.target);
                        tr = nextFocusRow.call(this, $KD.parent(evt.target), code);
                        td = (tr) ? $KD.childAt(tr, index) : null;
                    } else if(code === 39) { //Right Arrow
                        td = $KD.next(evt.target);
                    } else if(code === 40) { //Down Arrow
                        index = $KD.index(evt.target);
                        tr = nextFocusRow.call(this, $KD.parent(evt.target), code);
                        td = (tr) ? $KD.childAt(tr, index) : null;
                    }

                    if(td) {
                        $KD.preventDefault(evt);
                        $KD.focus(td);
                    }
                }

                return false;
            }},

            {keey:'onCellKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                    $KU = $K.utils, cell = $KD.closest(evt.target, 'kr', 'item'),
                    cellIndex = null, code = evt.keyCode || evt.which, parent = null;
                if([13, 32].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);
                    if(cell) {
                        cellIndex = $KD.index(cell);
                        parent = $KD.parent(cell);
                        if($KD.getAttr(parent, 'kr') === 'header') {
                            if($KU.is(cellIndex, 'integer')
                            && $KU.is(this.columnHeadersConfig[cellIndex].columnOnClick, 'function')) {
                                $KW.fire(this, 'columnOnClick', this, {cellIndex:cellIndex});
                            }
                        } else if($KD.getAttr(parent, 'kr') === 'row') {
                            $KW.fire(this, 'onRowSelected', this);
                        }
                    }
                }
                return false;
            }},

            {keey:'onColumnClick', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                    $KU = $K.utils, cell = $KD.closest(evt.target, 'kr', 'item'),
                    cellIndex = null, parent = null;

                if(cell) {
                    cellIndex = $KD.index(cell);
                    parent = $KD.parent(cell);
                    if($KD.getAttr(parent, 'kr') === 'header' && $KU.is(cellIndex, 'integer')
                    && $KU.is(this.columnHeadersConfig[cellIndex].columnOnClick, 'function')) {
                        $KW.fire(this, 'columnOnClick', this, {cellIndex:cellIndex});
                    }
                }

                return false;
            }},

            {keey:'onKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                    prop = this._kwebfw_.prop, el = $KW.el(this), code = evt.keyCode || evt.which,
                    focusElement = null;

                if(prop.showColumnHeaders) {
                    if(prop.dockingHeader) {
                        focusElement = $KD.childAt(el.dockedheader, 0);
                    } else {
                        focusElement = $KD.childAt(el.header, 0);
                    }
                } else {
                    focusElement = $KD.childAt($KD.next(el.header), 0);
                }

                if([40].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 40 && focusElement) { //Down Arrow
                        $KD.focus(focusElement);
                    }
                }

                return false;
            }},

            {keey:'onRowSelect', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                    target = $KD.closest(evt.target, 'kr', 'row');

                if(target) {
                    $KW.fire(this, 'onRowSelected', this);
                }

                return false;
            }},

            {keey:'performSelection', value:function(target) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_,
                    cellIndex = null, prop = _.prop, rowIndex = null, parent = null;

                target = $KD.closest(target, 'tag', 'DIV');
                parent = target ? $KD.closest(target, 'kr', 'row') : null;

                if(target && parent) {
                    cellIndex = $KD.index(target);
                    rowIndex = $KD.index(parent);
                    rowIndex = _deduceRowIndexGivenDomIndex.call(this, rowIndex);
                    _.selectedCellPos = [rowIndex, cellIndex];
                    if(prop.isMultiSelect) {
                        if(_.selectedIndices.indexOf(rowIndex) >= 0) {
                            _.selectedItems.splice(_.selectedIndices.indexOf(rowIndex), 1);
                            _.selectedIndices.splice(_.selectedIndices.indexOf(rowIndex), 1);
                        } else {
                            _.selectedIndices.push(rowIndex);
                            _.selectedItems.push(prop.data[rowIndex]);
                        }
                    } else {
                        _.selectedIndices = [rowIndex];
                        _.selectedItems = [prop.data[rowIndex]];
                    }

                    _setSelectedRowRelatedProperties.call(this);
                    _applyRowsSkin.call(this);
                }
                return false;
            }}
        ]}
    ]);


    //All the functions will be called in the scope of widget instance
    //DataGrid APIs actions - add, update and remove will be called
    var _action = {
        DataGrid : {
            _removeAll: function DataGrid$_action_removeAll() {
                var _ = this._kwebfw_, prop = _.prop;

                prop.data = [];
                prop.rowCount = 0;
                _flushClones(_.clones[1]);
                _.clones[1] = [];
                _.rows = [];
                _.selectedIndices = [];
                _.selectedItems = [];
                _removeAllRows.call(this);
                _setSelectedRowRelatedProperties.call(this);
            },

            addAll: function DataGrid$_action_addAll(rowindex, data) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils, $KW = $K.widget,
                    _ = this._kwebfw_, prop = _.prop, el = $KW.el(this);


                _generateClones.call(this, data);
                $KU.each(data, function(row) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                    if($KU.is(row, 'object')) {
                        prop.data.push(row);
                        el.table && $KD.add(el.table, _createRow.call(this, row, prop.rowCount, null, _.clones[1][prop.rowCount]));
                        _.rows.push(_.clones[1][prop.rowCount]);
                        prop.rowCount += 1;
                    } else {
                        throw new Error('Invalid row data');
                    }
                }, this);
                $KD.setAttr(el.table, 'aria-rowcount', prop.rowCount);
            },

            addDataAt: function DataGrid$_action_addDataAt(index, data) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                    _ = this._kwebfw_, prop = _.prop, el = $KW.el(this),
                    pos = 0, row = null;

                if(index === prop.data.length) {
                    prop.data.push(data);
                    row = _generateClones.call(this, [data], index);
                    el.table && $KD.add(el.table, _createRow.call(this, data, prop.rowCount, null, row[0]));
                    _.rows.push(_.clones[1][prop.rowCount]);
                } else {
                    prop.data.splice(index, 0, data);
                    _.clones[1].splice(index, 0, []);
                    row = _generateClones.call(this, [data], index);
                    for(pos = 0;pos< _.selectedIndices.length;pos++) {
                        if(_.selectedIndices[pos] >= index) {
                            _.selectedIndices[pos] = _.selectedIndices[pos] + 1;
                        }
                    }
                    if(_.selectedCellPos[0] >= index) {
                        _.selectedCellPos[0] += 1;
                    }
                    _.rows.splice(index, 0, _.clones[1][index]);
                    _setSelectedRowRelatedProperties.call(this);
                    el.table && $KD.addAt(el.table, _createRow.call(this, data, index, null, row[0]), _deduceRowIndexGivenModelIndex.call(this, index));
                    _updateDomIndex.call(this);
                }
                prop.rowCount += 1;
                $KD.setAttr(el.table, 'aria-rowcount', prop.rowCount);
            },

            removeAt: function DataGrid$_action_removeAt(index) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    el = $KW.el(this), _ = this._kwebfw_, pos = 0, prop = _.prop,
                    updatedIndex = null;

                prop.data.splice(index, 1);
                prop.rowCount -= 1;
                _flushClones(_.clones[1][index]);
                _.clones[1].splice(index, 1);
                _.rows.splice(index, 1);

                if(_.selectedIndices.indexOf(index) >= 0) {
                    updatedIndex = prop.selectedIndices.indexOf(index);
                    _.selectedIndices.splice(updatedIndex, 1);
                    _.selectedItems.splice(updatedIndex, 1);
                }
                for(pos= 0; pos<_.selectedIndices.length; pos++) {
                    if(_.selectedIndices[pos] >= index) {
                        _.selectedIndices[pos] = _.selectedIndices[pos] - 1;
                    }
                }
                if(_.selectedCellPos[0] > index) {
                    _.selectedCellPos[0] -= 1;
                } else if(_.selectedCellPos[0] === index) {
                    _.selectedCellPos = [];
                }
                el.table && $KD.removeAt(el.table, _deduceRowIndexGivenModelIndex.call(this, index));
                _setSelectedRowRelatedProperties.call(this);
                _updateDomIndex.call(this);
                $KD.setAttr(el.table, 'aria-rowcount', prop.rowCount);
            },

            update: function DataGrid$_action_update(index, data) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, row = null,
                    _ = this._kwebfw_, el = $KW.el(this), prop = _.prop, tr = null;

                prop.data[index] = data;
                if(_.selectedIndices.indexOf(index) >= 0) {
                    _.selectedItems.splice(prop.selectedIndices.indexOf(index), 1);
                    _.selectedIndices.splice(prop.selectedIndices.indexOf(index), 1);
                    if(_.selectedCellPos[0] === index) {
                        _.selectedCellPos = [];
                    }
                }

                _flushClones(_.clones[1][index]);
                _.clones[1][index] = [];
                row = _generateClones.call(this, [data], index);
                if(el.table) {
                    tr = $KD.childAt(el.table, _deduceRowIndexGivenModelIndex.call(this, index));
                    tr && $KD.html(tr, '');
                    _createRow.call(this, data, index, tr, row[0]);
                    _.rows.splice(index, 1, _.clones[1][index]);
                }
                _setSelectedRowRelatedProperties.call(this);
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _applyHeaderSkin = function DataGrid$_applyHeaderSkin() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
            _ = this._kwebfw_, prop = _.prop, el = $KW.el(this),
            _applySkinToHeaderRows = function(el) {
                $KU.each($KD.children(el), function(item, index) {
                    $KD.setAttr(item, 'class', prop.headerSkin);
                    _setContentAlignment.call(this, item, prop.columnHeadersConfig[index]);
                }, this);
            };

        if(el.header) {
            _applySkinToHeaderRows.call(this, el.header);
            if(prop.dockingHeader && el.dockedheader) {
                _applySkinToHeaderRows.call(this, el.dockedheader);
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _applyHeightinPercent = function DataGrid$_applyHeightinPercent(config, cell, tr, isColumn, docker) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, tplheight = '', template = null, rowheight = null;

        if((config.columnType !== 'template' && !isColumn)
        || (config.columnHeaderType !== 'template' && isColumn)) {
            return;
        }

        template = $KD.first(cell);
        tplheight = template.style.height;
        rowheight = tr.style.height;
        if(tplheight && tplheight.substring(tplheight.length - 1) === '%') {
            if(rowheight) {
                if(parseFloat(rowheight) < parseFloat(tplheight)) {
                    if(isColumn && docker) {
                        $KD.style(docker, 'height', tplheight);
                        $KD.style(tr, 'height', '100%');
                    } else {
                        $KD.style(tr, 'height', tplheight);
                    }
                }
            } else {
                if(isColumn && docker) {
                    $KD.style(docker, 'height', tplheight);
                    $KD.style(tr, 'height', '100%');
                } else {
                    $KD.style(tr, 'height', tplheight);
                }
            }
            $KD.style(cell, 'height', '100%');
            $KD.style(template, 'height', '100%');
        }
    };


    //This function will be called in the scope of widget instance
    var _applyRowsSkin = function DataGrid$_applyRowsSkin() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
            _ = this._kwebfw_, prop = _.prop, el = $KW.el(this);

        if(el.table) {
            $KU.each($KD.children(el.table), function(tr, index) {
                if(index > 0) {
                    if((index % 2) !== 0) {
                        tr.className = prop.rowNormalSkin;
                    } else {
                        tr.className = prop.rowAlternateSkin;
                    }

                    if(prop.rowFocusSkin && prop.selectedIndices
                    && prop.selectedIndices.indexOf(_deduceRowIndexGivenDomIndex.call(this, index)) >= 0) {
                        tr.className = prop.rowFocusSkin;
                    }
                }
            }, this);
        }
    };


    //This function will be called in the scope of widget instance
    var _clearSelectedIndices = function DataGrid$_clearSelectedIndices() {
        var _ = this._kwebfw_;

        _.selectedIndices = [];
        _.selectedItems = [];
        _.selectedCellItems = [];
        _.selectedCellPos = [];
        _setSelectedRowRelatedProperties.call(this);
    };


    //This function will be called in the scope of widget instance
    var _removeAllRows = function DataGrid$_removeAllRows() {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
            $KU = $K.utils, prop = this._kwebfw_.prop, el = $KW.el(this), index = null;

        if(el.table) {
            $KU.each($KD.find(el.table, 'LI'), function(item) {
                index = $KD.index(item);
                if(index > 0) {
                    $KD.remove(item);
                }
            });
            $KD.setAttr(el.table, 'aria-rowcount', prop.rowCount + 1);
        }
    };


    //This function will be called in the scope of widget instance
    var _createColumnHeaderCell = function DataGrid$_createColumnHeaderCell(config, index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, $KW = $K.widget,
            ariaindex = index + 1, tpl = null, th = $KD.create('DIV',
                {kr:'item', tabindex:-1}, {width:(config.columnWidthInPercentage + '%')});

        // Creation of empty div for column UI resizable feature
        var div = $KD.create('DIV', {}, {
            top: '0px',
            right: '0px',
            width: '1px',
            position: 'absolute',
            cursor: 'col-resize',
            userSelect: 'none',
            height: '100%'
        });

        $KD.setAttr(th, 'kwh-click', 'onColumnClick');
        $KD.setAttr(th, 'kwh-keydown', 'onCellKeyDown');
        $KD.setAttr(th, 'kwh-keyup', 'onCellKeyUp');
        $KD.setAttr(th, 'aria-colindex', ariaindex);
        index = [-1, index];
        $KD.setAttr(th, 'kii', index.join(','));

        if($KU.is(config.columnHeaderTemplate, 'string')
        || $KU.is(config.columnHeaderTemplate, 'object')) {
            tpl = _getClonedTemplateCell.call(this, config, config.columnHeaderTemplate.data, index, true);
            tpl = tpl._render();
            $KW.iterate(tpl, function(widget) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    view = widget._kwebfw_.view;

                if(view) {
                    $KD.setAttr(view, 'aria-colindex', ariaindex);
                }
            }, {tabs:false});
            $KD.style(tpl, {position: 'relative'});
            $KD.add(th, tpl);
            $KD.add(th, div);
        } else if($KU.is(config.columnHeaderText, 'string')) {
            if(config.columnHeaderText.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') !== -1) {
                $KD.text(th, $KU.getI18Nvalue(config.columnHeaderText));
            } else {
                $KD.text(th, config.columnHeaderText);
            }
            $KD.add(th, div);
        }
        _setContentAlignment.call(this, th, config);
        return th;
    };


    //This function will be called in the scope of widget instance
    var _createRow = function DataGrid$_createRow(data, rowIndex, tr, row) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            _ = this._kwebfw_, prop = _.prop, td = null;

        tr = tr || $KD.create('LI', {kr:'row', tabindex:-1});

        //Don't delete this line. $KD.setAttr(tr, 'kwh-keydown', 'onRowKeyDown');
        $KD.setAttr(tr, 'aria-rowindex', rowIndex + 1);
        $KD.setAttr(tr, 'aria-colcount', _getColumnCount.call(this));

        $KU.each(prop.columnHeadersConfig, function(config, index) {
            td = _createRowCell.call(this, config, data, [rowIndex, index], row[index]);
            _applyHeightinPercent.call(this, config, td, tr);
            $KD.add(tr, td);
        }, this);

        return tr;
    };


    //This function will be called in the scope of widget instance
    var _createRowCell = function DataGrid$_createRowCell(config, data, index, clone) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, $KW = $K.widget,
            image = null, tpl = null,
            td = $KD.create('DIV', {
                kr:'item', tabindex:-1
            }, {
                width:(config.columnWidthInPercentage+'%')
            });

        $KD.setAttr(td, 'kwh-keydown', 'onCellKeyDown');
        $KD.setAttr(td, 'kwh-keyup', 'onCellKeyUp');
        $KD.setAttr(td, 'kwh-click', 'onRowSelect');
        $KD.setAttr(td, 'aria-colindex', index[1] + 1);
        $KD.setAttr(td, 'aria-rowindex', index[0] + 1);
        $KD.setAttr(td, 'kii', index.join(','));
        if(config.columnType === constants.DATAGRID_COLUMN_TYPE_TEXT) {
            if($KU.is(data[config.columnID], 'string')
            || $KU.is(data[config.columnID], 'number')
            || $KU.is(data[config.columnID], 'boolean')) {
                if($KU.is(data[config.columnID], 'string')
                && data[config.columnID].toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') !== -1) {
                    $KD.text(td, $KU.getI18Nvalue(data[config.columnID]));
                } else {
                    $KD.text(td, data[config.columnID]);
                }
            }
        } else if(config.columnType === constants.DATAGRID_COLUMN_TYPE_IMAGE) {
            if($KU.is(data[config.columnID], 'string') && data[config.columnID]) {
                image = $KD.create('IMG', {
                    tabindex:-1, loading:'lazy',
                    src:$KU.getImageURL(data[config.columnID])
                });
                $KD.on(image, 'mousedown', 'image', function(e) {
                    $KD.preventDefault(e);
                });
                $KD.add(td, image);
            }
        } else if(config.columnType === constants.DATAGRID_COLUMN_TYPE_TEMPLATE
        && $KU.is(clone, 'widget', 'FlexContainer')) {
            tpl = clone._render();
            $KW.iterate(tpl, function(widget) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    view = widget._kwebfw_.view;

                if(view) {
                    $KD.setAttr(view, 'aria-colindex', index[1] + 1);
                    $KD.setAttr(view, 'aria-rowindex', index[0] + 1);
                }
            }, {tabs:false});
            $KD.style(tpl, {position: 'relative'});
            $KD.add(td, tpl);
        }
        _setContentAlignment.call(this, td, config);
        return td;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All the functions will be called in the scope of widget instance
    var _deduceRowIndexGivenDomIndex = function DataGrid$_deduceActualRowIndex(index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(index, 'number') && index >= 0) {
            index = index - 1;
        }
        return index;
    };


    //All the functions will be called in the scope of widget instance
    var _deduceRowIndexGivenModelIndex = function DataGrid$_deduceRowIndexGivenModelIndex(index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(index, 'number') && index >= 0) {
            index = index + 1;
        }
        return index;
    };


    //All the functions will be called in the scope of widget instance
    var _dockColumnHeader = function DataGrid$_dockColumnHeader(docker) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
            $KU = $K.utils, prop = this._kwebfw_.prop, dockheader = null;

        if(prop.dockingHeader && docker) {
            dockheader = $KD.first(docker);
            $KU.each(prop.columnHeadersConfig, function(config, columnIndex) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, dockth = null;

                dockth = _createColumnHeaderCell.call(this, config, columnIndex);
                _applyHeightinPercent.call(this, config, dockth, dockheader, true, docker);
                $KD.add(dockheader, dockth);
            }, this);
            $KD.removeAttr(docker, 'hidden');
            $KW.registerNativeScrollEvent(this);
        }
    };


    //This function will be called in the scope of widget instance
    var _enableScrollBar = function DataGrid$_enableScrollBar(el) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            hScroll = null, vScroll = null;

        if(this.enableScrollBar === constants.DATAGRID_SCROLLBAR_VERTICAL) {
            if($KU.scrollType() === 'native') {
                $KD.style(el.node, {overflowX:'hidden', overflowY:'auto'});
            } else {
                $KD.setAttr(el.node, 'kr', 'scrolee');
                hScroll = $KD.create('DIV', {kr:'h-scroll'});
                vScroll = $KD.create('DIV', {kr:'v-scroll'});
                $KD.add(el.node, hScroll); $KD.add(el.node, vScroll);
            }
        } else if($KU.scrollType() === 'native') {
            $KD.style(el.node, {overflowX:'hidden', overflowY:'hidden'});
        }
    };


    //All the functions will be called in the scope of widget instance
    var _executeOnRow = function DataGrid$_executeOnRow(index, config, data, isColumn, callback, args) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, tpl = null,
            columnIndex = index[1], widgetDataMap = {}, rowIndex = index[0];

        if(columnIndex === -1 && rowIndex === -1) return;

        if($KU.is(callback, 'function')) {
            if(!$KU.is(args, 'array')) args = [];

            if(isColumn) {
                tpl = config.columnHeaderTemplate.template;
                if(!$KU.is(this._kwebfw_.clones[0][columnIndex], 'undefined')) {
                    this._kwebfw_.clones[0][columnIndex] = null;
                }
            } else {
                tpl = config.columnDataTemplate;

                if($KU.is(this._kwebfw_.clones[1][rowIndex], 'undefined')) {
                    this._kwebfw_.clones[1][rowIndex] = [];
                }

                if($KU.is(this._kwebfw_.clones[1][rowIndex], 'array')
                && !$KU.is(this._kwebfw_.clones[1][rowIndex][columnIndex], 'undefined')) {
                    this._kwebfw_.clones[1][rowIndex][columnIndex] = null;
                }
            }

            tpl = $KW.getTemplate(this, tpl);
            $KU.each(tpl, function(value, keey) {
                if($KU.is(value, 'widget')) {
                    widgetDataMap[keey] = keey;
                }
            });

            args.splice(0, 0, index);
            args.splice(2, 0, tpl);
            if(isColumn) {
                args.splice(1, 0, data);
                args.splice(3, 0, this._kwebfw_.clones[0][columnIndex]);
            } else {
                if(data[config.columnID] === undefined) {
                    data[config.columnID] = {};
                }
                args.splice(1, 0, data[config.columnID]);
                args.splice(3, 0, this._kwebfw_.clones[1][rowIndex][columnIndex]);
            }
            args.splice(4, 0, widgetDataMap);

            callback.apply(this, args);
        }
    };


    //All the functions will be called in the scope of widget instance
    var _flushClones = function DataGrid$_flushClones(clones, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(config) {
            config.iterate = true;
        } else {
            config = {iterate : true};
        }

        if($KU.is(clones, 'widget')) clones = [clones];

        if($KU.is(clones, 'array')) {
            $KU.each(clones, function(rows) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                if($KU.is(rows, 'array')) {
                    $KU.each(rows, function(cell) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;
                        if($KU.is(cell, 'widget')) {
                            cell._flush(config);
                        }
                    });
                } else if($KU.is(rows, 'widget')) {
                    rows._flush(config);
                }
            }, this);
        }
    };


    //All the functions will be called in the scope of widget instance
    var _getColumnCount = function DataGrid$_getColumnCount() {
        var _ = this._kwebfw_, prop = _.prop;

        if(prop.columnHeadersConfig && prop.columnHeadersConfig.length >= 0) {
            return prop.columnHeadersConfig.length;
        }
    };


    //This function will be called in the scope of widget instance
    var _getColumnIndexById = function DataGrid$_getColumnIndexById(id) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, index = -1,
            _ = this._kwebfw_, prop = _.prop;

        $KU.each(prop.columnHeadersConfig, function(config, count) {
            if(config.columnID === id) {
                index = count;
                return true;
            }
        }, this);

        return index;
    };


    //This function will be called in the scope of widget instance
    var _getColumnIdByIndex = function DataGrid$_getcolumnIdByIndex(index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, colId = null,
            _ = this._kwebfw_, prop = _.prop;

        $KU.each(prop.columnHeadersConfig, function(config, count) {
            if(count === index) {
                colId = config.columnID;
                return true;
            }
        }, this);

        return colId;
    };


    //All the functions will be called in the scope of widget instance
    var _getClonedTemplate = function DataGrid$_getClonedTemplate(config, data, index, isColumn) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, template = null;

        _executeOnRow.call(this, index, config, data, isColumn, function(index, data, tpl, clone, widgetDataMap) {
            var self = this, columnIndex = index[1], rowIndex = index[0];

            if($KU.is(clone, 'widget')) {
                template = clone;
            } else {
                template = $KW.cloneTemplate(tpl, data, widgetDataMap, function(model) {
                    model._kwebfw_.ii = index.join(',');
                    _updateSpecialProperties(self, model, index);
                });
            }

            if(rowIndex === -1) { // only columns
                this._kwebfw_.clones[0][columnIndex] = template;
            } else {
                this._kwebfw_.clones[1][rowIndex][columnIndex] = template;
            }
        });

        return template;
    };


    //All the functions will be called in the scope of widget instance
    var _generateClones = function DataGrid$_generateClones(data, startIndex/*, endIndex*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
            prop = _.prop, rowIndex = prop.data.length, clones = [];

        if(startIndex >= 0) {
            rowIndex = startIndex; //if wanted to generate clones for specific set rows
        }

        $KU.each(data, function(/*data*/) {
            $KU.each(prop.columnHeadersConfig, function(config, colIndex) {
                if(config.columnType !== constants.DATAGRID_COLUMN_TYPE_TEMPLATE) {
                    if($KU.is(_.clones[1][rowIndex], 'undefined')) {
                        _.clones[1][rowIndex] = [];
                    }
                    _.clones[1][rowIndex][colIndex] = null;
                }
            }, this);
            clones.push(_.clones[1][rowIndex]);
            rowIndex +=1;
        }, this);

        return clones;
    };


    //All the functions will be called in the scope of widget instance
    var _onRowChange = function DataGrid$_onRowChange(rowIndex, action, data) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this);

        _action.DataGrid[action].call(this, rowIndex, data);
        _applyRowsSkin.call(this);
        _view.DataGrid.gridlineColor.call(this, el);
    };


    //All the functions will be called in the scope of widget instance
    var _getClonedTemplateCell = function DataGrid$_getClonedTemplateCell(config, data, index, isColumn) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, clone = null;

        if(isColumn) {
            if(config.columnHeaderTemplate.data
            && $KU.is(config.columnHeaderTemplate.data, 'object')
            && config.columnHeaderTemplate.template
            && ($KU.is(config.columnHeaderTemplate.template, 'widget', 'FlexContainer')
            || $KU.is(config.columnHeaderTemplate.template, 'string'))) {
                clone = _getClonedTemplate.call(this, config, data, index, isColumn);
            }
        } else {
            if(data && $KU.is(data, 'object')
            && config.columnDataTemplate
            && ($KU.is(config.columnDataTemplate, 'widget', 'FlexContainer')
            || $KU.is(config.columnDataTemplate, 'string'))) {
                clone = _getClonedTemplate.call(this, config, data, index);
            }
        }
        return clone;
    };


    var _getter = {
        DataGrid: {
            columnHeadersConfig:  function DataGrid$_getter_columnHeadersConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, config = [];

                $KU.each(value, function(v) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils, item = {};

                    if($KU.is(v.columnHeaderText, 'string')
                    && v.columnHeaderText.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') !== -1) {
                        item = $KU.getI18Nvalue(v);
                    } else {
                        item = v;
                    }

                    config.push(item);
                });

                return config;
            },

            data: function DataGrid$_getter_data(/*value*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    _ = this._kwebfw_, prop = _.prop, data = [];

                if(!prop.data) {
                    data = prop.data;
                } else {
                    $KU.each(prop.data, function(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, item = {};

                        $KU.each(val, function(v, k) {
                            var $K = voltmx.$kwebfw$, $KU = $K.utils;

                            if($KU.is(v, 'string')
                            && v.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') !== -1) {
                                item[k] = $KU.getI18Nvalue(v);
                            } else {
                                item[k] = v;
                            }
                        });
                        data.push(item);
                    });
                }

                return data;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        DataGrid: function DataGrid$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.DataGrid', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'DataGrid', null);
                }
            }

            if(!_.ui) $KU.defineProperty(_, 'ui', {}, null);
            if(!_.templates) $KU.defineProperty(_, 'templates', {}, null);
            //This holds the cloned templates, those will be rendered, and it is a flat list
            if(!_.rows) $KU.defineProperty(_, 'rows', [], true);
            //This holds the cloned templates, in the same DS as that of this.data
            if(!_.clones) $KU.defineProperty(_, 'clones', [[], []], true);
            if(!_.selectedIndices) $KU.defineProperty(_, 'selectedIndices', []);
            if(!_.selectedItems) $KU.defineProperty(_, 'selectedItems', []);
            if(!_.selectedCellIndex) $KU.defineProperty(_, 'selectedCellPos', []);
            $KU.defineProperty(_.ui, 'scroll', {x:0, y:0, width:-1, height:-1, minX:-1, maxX:-1, minY:-1, maxY:-1, status:'ended'}, true);
            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {};


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        DataGrid: function DataGrid$_relayoutActiveTriggerer() {
            return ['data'];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        DataGrid: function DataGrid$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //This function will be called in the scope of widget instance
    var _setContentAlignment = function DataGrid$_setContentAlignment(el, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

        if($KU.is(config.columnContentAlignment, 'string')) {
            $KD.addCls(el, '-voltmx-ca-' + config.columnContentAlignment);
        }
    };


    //This function will be called in the scope of widget instance
    var _setSelectedRowRelatedProperties = function DataGrid$_setSelectedRowRelatedProperties() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
            prop = _.prop, selectedIndices = _.selectedIndices, updatedIndex = null,
            cellId = null, indicesLength = selectedIndices.length;

        if(prop.data && prop.data.length > 0) {
            if(indicesLength > 0) {
                prop.selectedIndex = selectedIndices[indicesLength - 1];
                prop.selectedItem = _.selectedItems[indicesLength - 1];
                if(prop.isMultiSelect) {
                    prop.selectedIndices = selectedIndices;
                    prop.selectedItems = _.selectedItems;
                    if(prop.selectedIndex === selectedIndices[indicesLength -1]) {
                        updatedIndex = prop.selectedIndices[indicesLength - 1];
                        prop.selectedIndex = (updatedIndex >= 0) ? updatedIndex : null;
                        prop.selectedItem = prop.data[updatedIndex] ? prop.data[updatedIndex] : null;
                    }
                } else {
                    prop.selectedIndices = [selectedIndices[indicesLength -1]];
                    prop.selectedItems = [_.selectedItems[indicesLength - 1]];
                }
            } else {
                prop.selectedIndex = null;
                prop.selectedItem = null;
                prop.selectedIndices = [];
                prop.selectedItems = [];
            }
            if($KU.is(_.selectedCellPos[1], 'integer'))
                cellId = prop.columnHeadersConfig[_.selectedCellPos[1]].columnID;
            if(!$KU.is(cellId, 'null')) {
                prop.selectedCellIndex = [_.selectedCellPos[1], cellId];
                prop.selectedCellItem = prop.data[_.selectedCellPos[0]][cellId];
            } else {
                prop.selectedCellIndex = null;
                prop.selectedCellItem = null;
            }
        } else {
            prop.selectedIndex = null;
            prop.selectedItem = null;
            prop.selectedIndices = [];
            prop.selectedItems = [];
            prop.selectedCellIndex = null;
            prop.selectedCellItem = null;
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        DataGrid: {
            data: function DataGrid$_setter_data(/*old*/) {
                var prop = this._kwebfw_.prop;

                prop.rowCount = (prop.data) ? prop.data.length : 0;
            }
        }
    };


    //All the functions will be called in the scope of widget instance
    var _shouldLazyLoad = function DataGrid$_shouldLazyLoad() {
        // var $K = voltmx.$kwebfw$, $KW = $K.widget, flag = false;
        //TODO: IF LAZY LOADING IS REQ
        /*if($KW.isFixedHeight(this)
        && this._kwebfw_.prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
            flag = true;
        }*/

        return false;
    };


    //All the functions will be called in the scope of widget instance
    var _sortDataBasedOnColumnId = function DataGrid$_sortDataBasedOnColumnId(columnId) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop,
            columnData = [], sortedData = [], i = 0,
            index = null;

        $KU.each(prop.data, function(val) {
            if(parseInt(val[columnId])) {
                columnData.push(parseInt(val[columnId]));
            } else {
                columnData.push(val[columnId]);
            }
        });

        columnData.sort();

        for(i = 0; i < columnData.length; i++) {
            if(columnData.indexOf(prop.data[i][columnId]) >= 0) {
                index = columnData.indexOf(prop.data[i][columnId]);
            } else if(columnData.indexOf(parseInt(prop.data[i][columnId])) >= 0) {
                index = columnData.indexOf(parseInt(prop.data[i][columnId]));
            }
            if(index > -1) {
                columnData[index] = null;
                sortedData[index] = prop.data[i];
            }
        }

        prop.data = sortedData;
    };


    //All the functions will be called in the scope of widget instance
    var _sortDataIfNeeded = function DataGrid$_sortDataIfNeeded() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
            prop = _.prop;

        $KU.each(prop.columnHeadersConfig, function(config) {
            if(config.isColumnSortable && config.columnType === constants.DATAGRID_COLUMN_TYPE_TEXT) {
                _sortDataBasedOnColumnId.call(this, config.columnID);
                return true;
            }
        }, this);
    };


    //All the functions will be called in the scope of widget instance
    var _updateDomIndex = function DataGrid$_updateDomIndex() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, $KW = $K.widget,
            _ = this._kwebfw_, prop = _.prop, el = $KW.el(this), row = null, item = null, index = null,
            updateTemplateIndexes = function(clone, index) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils;

                if(!$KU.is(clone, null) && clone._kwebfw_.view) {
                    $KW.iterate(clone, function(model) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget,
                            $KD = $K.dom, _ = model._kwebfw_;

                        _.ii = index;

                        if(_.view) {
                            $KD.setAttr(_.view, 'kwi', index);
                            $KW.replaceWAPIndex(model, index);
                            $KD.setAttr(_.view, 'kwp', _.wap);
                            $KD.setAttr(_.view, 'aria-rowindex', index[0] + 1);
                            $KD.setAttr(_.view, 'aria-colindex', index[1] + 1);
                        }
                    }, {tabs:false});
                }
            };

        $KU.each(prop.data, function(value, rowindex) {
            $KU.each(prop.columnHeadersConfig, function(col, colindex) {
                index = [rowindex, colindex];
                row = $KD.childAt(el.table, _deduceRowIndexGivenModelIndex(rowindex));
                $KD.setAttr(row, 'aria-rowindex', rowindex + 1);
                item = $KD.childAt(row, colindex);
                $KD.setAttr(item, 'kii', index.join(','));
                $KD.setAttr(item, 'aria-rowindex', rowindex + 1);
                if(col.columnType === 'template') {
                    updateTemplateIndexes.call(this, _.clones[1][rowindex][colindex], [rowindex, colindex]);
                }
            });
        });
    };


    //All the functions will be called in the scope of widget instance
    var _updateSpecialProperties = function DataGrid$_updateSpecialProperties(self, model/*, index*/) {
        model._kwebfw_.oid = self._kwebfw_.uid;
        model._kwebfw_.wap = self._kwebfw_.wap + ('[' + model._kwebfw_.ii + ']_') + model._kwebfw_.wap;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        DataGrid: {
            allowColumnResize: function DataGrid$_valid_allowColumnResize(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            columnHeadersConfig: function DataGrid$_valid_columnHeadersConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array')) {
                    flag = true;

                    $KU.each(value, function(config) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if(!$KU.is(config, 'object')) {
                            flag = false;
                            return true;
                        } else if(!($KU.is(config.columnID, 'string') && config.columnID
                        && [constants.DATAGRID_COLUMN_TYPE_TEXT,
                            constants.DATAGRID_COLUMN_TYPE_IMAGE,
                            constants.DATAGRID_COLUMN_TYPE_TEMPLATE].indexOf(config.columnType) >= 0
                        && ($KU.is(config.columnHeaderText, 'string')
                        || $KU.is(config.columnHeaderTemplate, 'widget', 'FlexContainer')
                        || ($KU.is(config.columnHeaderTemplate, 'string') && config.columnHeaderTemplate))
                        && $KU.is(config.columnWidthInPercentage, 'number')
                        && config.columnWidthInPercentage >= 0)) {
                            flag = false;
                            return true;
                        } else if(config.columnType === constants.DATAGRID_COLUMN_TYPE_TEMPLATE
                        && (!($KU.is(config.columnDataTemplate, 'widget', 'FlexContainer')
                        || ($KU.is(config.columnDataTemplate, 'string') && config.columnDataTemplate)))) {
                            flag = false;
                            return true;
                        } else if(Object.prototype.hasOwnProperty.call(config, 'isColumnSortable')
                        && !$KU.is(config.isColumnSortable, 'boolean')) {
                            flag = false;
                            return true;
                        } else if(Object.prototype.hasOwnProperty.call(config, 'columnOnClick')
                        && !$KU.is(config.columnOnClick, 'function')) {
                            flag = false;
                            return true;
                        } else if(Object.prototype.hasOwnProperty.call(config, 'columnContentAlignment')
                        && [constants.CONTENT_ALIGN_TOP_LEFT,
                            constants.CONTENT_ALIGN_TOP_CENTER,
                            constants.CONTENT_ALIGN_TOP_RIGHT,
                            constants.CONTENT_ALIGN_MIDDLE_LEFT,
                            constants.CONTENT_ALIGN_CENTER,
                            constants.CONTENT_ALIGN_MIDDLE_RIGHT,
                            constants.CONTENT_ALIGN_BOTTOM_LEFT,
                            constants.CONTENT_ALIGN_BOTTOM_CENTER,
                            constants.CONTENT_ALIGN_BOTTOM_RIGHT
                        ].indexOf(config.columnContentAlignment) === -1) {
                            flag = false;
                            return true;
                        }
                    });
                }

                return flag;
            },

            data: function DataGrid$_valid_data(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            dockingHeader: function DataGrid$_valid_dockingHeader(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            enableScrollBar: function DataGrid$_valid_enableScrollBar(value) {
                var flag = false, options = [
                    constants.DATAGRID_SCROLLBAR_NONE,
                    constants.DATAGRID_SCROLLBAR_VERTICAL
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            gridlineColor: function DataGrid$_valid_gridlineColor(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    value = value.toUpperCase();
                    flag = $KU.is(value, 'color');
                }

                return (flag ? [value, flag] : flag);
            },

            headerSkin: function DataGrid$_valid_headerSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            isMultiSelect: function DataGrid$_valid_isMultiSelect(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            onRowSelected: function DataGrid$_valid_onRowSelected(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                } else if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            rowAlternateSkin: function DataGrid$_valid_rowAlternateSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            rowCount: function DataGrid$_valid_rowCount(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'integer') && value >= 0) {
                    flag = true;
                }

                return flag;
            },

            rowFocusSkin: function DataGrid$_valid_rowFocusSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            rowNormalSkin: function DataGrid$_valid_rowNormalSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            selectedCellIndex: function DataGrid$_valid_selectedCellIndex(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'array') && value.length === 2
                && $KU.is(value[0], 'integer') && value[0] >= 0
                && $KU.is(value[1], 'string')) {
                    flag = true;
                }

                return flag;
            },

            selectedCellItem: function DataGrid$_valid_selectedCellItem(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')
                || $KU.is(value, 'object')
                || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            selectedIndex: function DataGrid$_valid_selectedIndex(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'integer') && value >= 0) {
                    flag = true;
                }

                return flag;
            },

            selectedIndices: function DataGrid$_valid_selectedIndices(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            selectedItem: function DataGrid$_valid_selectedItem(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null') || $KU.is(value, 'object')) {
                    flag = true;
                }

                return flag;
            },

            selectedItems: function DataGrid$_valid_selectedItems(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            showColumnHeaders: function DataGrid$_valid_showColumnHeaders(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        DataGrid: {
            allowColumnResize: false,

            columnHeadersConfig: false,

            data: function DataGrid$_view_data(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    _ = this._kwebfw_, prop =_.prop, rowIndex = -1;

                _clearSelectedIndices.call(this);
                _removeAllRows.call(this);
                _flushClones(_.clones[1]);
                _.rows = [];
                _.clones[1] = [];

                if(prop.data) {
                    prop.rowCount = 0;
                    _sortDataIfNeeded.call(this);

                    if(_shouldLazyLoad.call(this)) {
                        //todo
                    } else {
                        $KU.each(prop.data, function(data, rowIndex) {
                            $KU.each(prop.columnHeadersConfig, function(config, colIndex) {
                                if(config.columnType === constants.DATAGRID_COLUMN_TYPE_TEMPLATE) {
                                    _getClonedTemplateCell.call(this, config, data, [rowIndex, colIndex]);
                                } else {
                                    if($KU.is(_.clones[1][rowIndex], 'undefined')) {
                                        _.clones[1][rowIndex] = [];
                                    }
                                    _.clones[1][rowIndex][colIndex] = null;
                                }
                            }, this);
                            _.rows.push(_.clones[1][rowIndex]);
                        }, this);

                        $KU.each(prop.data, function(data) {
                            var $K = voltmx.$kwebfw$, $KD = $K.dom;
                            rowIndex = prop.rowCount;
                            $KD.add(el.table, _createRow.call(this, data, rowIndex, null, _.rows[rowIndex]));
                            prop.rowCount +=1;
                        }, this);
                    }
                    _view.DataGrid.gridlineColor.call(this, el);
                    _applyRowsSkin.call(this);
                    $KD.setAttr(el.table, 'aria-rowcount', prop.rowCount);
                }
            },

            dockingHeader: false,

            enableScrollBar: false,

            gridlineColor: function DataGrid$_view_gridlineColor(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                    color = '', prop = this._kwebfw_.prop, header = null,
                    columnlength = null, rowlength = null;

                el = $KW.el(this);

                if(prop.gridlineColor && prop.columnHeadersConfig) {
                    columnlength = prop.columnHeadersConfig.length;
                    color = $KU.convertHexToRGBA(this.gridlineColor);
                    header = prop.dockingHeader ? el.dockedheader : el.header;
                    $KU.each($KD.children(header), function(cell, colindex) {
                        $KD.style(cell, 'border-top', ('1px solid '+color));
                        $KD.style(cell, 'border-bottom', ('1px solid '+color));
                        $KD.style(cell, 'border-left', ('1px solid '+color));
                        if(colindex === columnlength - 1) {
                            $KD.style(cell, 'border-right', ('1px solid '+color));
                        }
                    });
                    if(prop.data) {
                        rowlength = prop.data.length;
                        $KU.each($KD.children(el.table), function(row, rowindex) {
                            if($KD.getAttr(row, 'kr') === 'row') {
                                $KU.each($KD.children(row), function(cell, colindex) {
                                    $KD.style(cell, 'border-bottom', ('1px solid '+color));
                                    $KD.style(cell, 'border-left', ('1px solid '+color));
                                    if(colindex === columnlength - 1) {
                                        $KD.style(cell, 'border-right', ('1px solid '+color));
                                    }
                                    if(rowindex === rowlength) {
                                        $KD.style(cell, 'border-bottom', ('1px solid '+color));
                                    }
                                    if(!prop.showColumnHeaders && rowindex === 1) {
                                        $KD.style(cell, 'border-top', ('1px solid' +color));
                                    }
                                });
                            }
                        });
                    }
                }
            },

            headerSkin: function DataGrid$_view_headerSkin(/*el, old*/) {
                _applyHeaderSkin.call(this);
            },

            isMultiSelect: true,

            onRowSelected: true,

            rowAlternateSkin: function DataGrid$_view_rowAlternateSkin(/*el, old*/) {
                _applyRowsSkin.call(this);
            },

            rowCount: false,

            rowFocusSkin: function DataGrid$_view_rowFocusSkin(/*el, old*/) {
                _applyRowsSkin.call(this);
            },

            rowNormalSkin: function DataGrid$_view_rowNormalSkin(/*el, old*/) {
                _applyRowsSkin.call(this);
            },

            selectedCellIndex: false,

            selectedCellItem: false,

            selectedIndex: false,

            selectedIndices: false,

            selectedItem: false,

            selectedItems: false,

            showColumnHeaders: function DataGrid$_view_showColumnHeaders(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.showColumnHeaders && this.dockingHeader) {
                    $KD.removeAttr(el.header, 'hidden');
                    $KD.removeAttr(el.dockedheader, 'hidden');
                } else if(this.showColumnHeaders && !this.dockingHeader) {
                    $KD.removeAttr(el.header, 'hidden');
                } else if(!this.showColumnHeaders && this.dockingHeader) {
                    $KD.setAttr(el.header, 'hidden', true);
                    $KD.setAttr(el.dockedheader, 'hidden', true);
                } else {
                    $KD.setAttr(el.header, 'hidden', true);
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'DataGrid', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.DataGrid constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var DataGrid = function DataGrid(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    allowColumnResize: false, //Readonly
                    columnHeadersConfig: [],
                    data: null,
                    dockingHeader: false, //Readonly
                    enableScrollBar: constants.DATAGRID_SCROLLBAR_NONE, //Readonly
                    gridlineColor: '666666',
                    headerSkin: 'slDataGridHead',
                    isMultiSelect: false,
                    onRowSelected: null,
                    rowAlternateSkin: 'slDataGridAltRow',
                    rowCount: 0, //Readonly
                    rowFocusSkin: 'slDataGridFocusedRow',
                    rowNormalSkin: 'slDataGridRow',
                    selectedCellIndex: null, //Readonly
                    selectedCellItem: null, //Readonly
                    selectedIndex: null, //Readonly
                    selectedIndices: [], //Readonly
                    selectedItem: null, //Readonly
                    selectedItems: [], //Readonly
                    showColumnHeaders: true
                };
            }

            _populateUnderscore.DataGrid.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            DataGrid.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.DataGrid, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.DataGrid.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to DataGrid
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.DataGrid[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.DataGrid>, but not in <_valid.DataGrid> namespace.');
                        } else {
                            valid = _valid.DataGrid[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to DataGrid
                $KU.each(_view.DataGrid, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function DataGrid$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.DataGrid[key], 'function')) {
                            return _getter.DataGrid[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function DataGrid$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.DataGrid[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.DataGrid[key], 'function')) {
                                        _setter.DataGrid[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.DataGrid().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.DataGrid().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.DataGrid, 'function')) {
                    _postInitialization.DataGrid.call(this);
                }
            }


            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(DataGrid, voltmx.ui.BasicWidget);


        /**
         * Takes care of flushing out the widget reference to clean memory.
         *
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.DataGrid
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     void
         */
        var datagrid__flush = function DataGrid$_flush(config) {
            var $super = voltmx.ui.DataGrid.base.prototype;

            _flushClones.call(this, this._kwebfw_.clones[0], config);
            _flushClones.call(this, this._kwebfw_.clones[1], config);
            $super._flush.call(this);
        };


        /**
         * Builds the view layer for voltmx.ui.DataGrid widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.DataGrid
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  DataGrid view.
         */
        var datagrid__render = function DataGrid$_render(tag) {
            var $super = voltmx.ui.DataGrid.base.prototype, el = null,
                _ = this._kwebfw_, $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KW = $K.widget, $KD = $K.dom, view = _.view,
                docker = null, table = null, header = null;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    docker = $KD.create('UL', {kr:'docker'}, {
                        position:'absolute', top:'0px', left:'0px', zIndex: 1
                    }); $KD.setAttr(docker, 'hidden', true);
                    table = $KD.create('UL', {role:'grid'}, {height: '100%'});
                    header = $KD.create('LI', {kr:'header'});

                    if(this.dockingHeader) {
                        $KD.add(docker, $KU.clone(header));
                    }

                    $KU.each(_.prop.columnHeadersConfig, function(config, columnIndex) {
                        var $K = voltmx.$kwebfw$, $KD = $K.dom, th = null;

                        th = _createColumnHeaderCell.call(this, config, columnIndex);
                        _applyHeightinPercent.call(this, config, th, header, true);
                        $KD.add(header, th);
                    }, this);

                    $KD.add(table, header);

                    view = $super._render.call(this, tag, [table, docker]);
                    $KD.setAttr(table, 'kwh-keydown', 'onKeyDown');
                    $KD.setAttr(table, 'aria-colcount', _getColumnCount.call(this));
                    _dockColumnHeader.call(this, docker);
                }

                el = $KW.el(view);

                _enableScrollBar.call(this, el);
                _view.DataGrid.gridlineColor.call(this, el);
                _view.DataGrid.headerSkin.call(this, el, this.headerSkin);
                _view.DataGrid.data.call(this, el, _.prop.data);
                _view.DataGrid.showColumnHeaders.call(this, el, _.prop.showColumnHeaders);
                $KW.accessibility(this);
            }

            return view;
        };


        var datagrid_addAll = function DataGrid$addAll(data) {
            var _ = this._kwebfw_, prop = _.prop, rowIndex = null;

            if(!_valid.DataGrid.data.call(this, data)) {
                throw new Error('Invalid data.');
            } else {
                if(!prop.data) prop.data = [];
                rowIndex = prop.data.length;
                _onRowChange.call(this, rowIndex, 'addAll', data);
            }
        };


        var datagrid_addDataAt = function DataGrid$addDataAt(data, index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

            if(!prop.data) prop.data = [];
            if($KU.is(data, 'object') && $KU.is(index, 'integer')
            && index >= 0 && index <= prop.data.length) {
                _onRowChange.call(this, index, 'addDataAt', data);
            } else {
                throw new Error('Invalid data or index.');
            }
        };


        var datagrid_applyCellSkin = function DataGrid$applyCellSkin(rowIndex, columnID, skin) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                prop = this._kwebfw_.prop, tr = null, td = null, columnIndex = -1,
                el = null;

            if($KU.is(rowIndex, 'integer') && rowIndex >= 0 && rowIndex < prop.data.length
            && (($KU.is(skin, 'string') && skin.split(' ').length === 1) || $KU.is(skin, 'object'))) {
                columnIndex = _getColumnIndexById.call(this, columnID);

                if(columnIndex !== -1) {
                    el = $KW.el(this);

                    if(el.table) {
                        tr = $KD.childAt(el.table, _deduceRowIndexGivenModelIndex.call(this, rowIndex));
                        td = $KD.childAt(tr, columnIndex);

                        td.className = skin;
                        _setContentAlignment.call(this, td, prop.columnHeadersConfig[columnIndex]);
                    }
                } else {
                    throw new Error('Invalid column ID');
                }
            } else {
                throw new Error('Invalid parameter');
            }
        };


        var datagrid_removeAll = function DataGrid$removeAll() {
            _action.DataGrid._removeAll.call(this);
        };


        var datagrid_removeAt = function DataGrid$removeAt(rowIndex) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
                prop = _.prop;
            if($KU.is(rowIndex, 'number') && rowIndex >= 0 && rowIndex < prop.data.length) {
                _onRowChange.call(this, rowIndex, 'removeAt');
            } else {
                throw new Error('Invalid parameter');
            }
        };


        var datagrid_selectAllRows = function DataGrid$selectAllRows(select) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
                prop = _.prop;

            if($KU.is(select, 'boolean')) {
                if(prop.isMultiSelect) {
                    if(select) {
                        _.selectedIndices = [];
                        _.selectedItems = [];
                        $KU.each(prop.data, function(row, index) {
                            _.selectedItems.push(row);
                            _.selectedIndices.push(index);
                        }, this);
                    } else {
                        _.selectedIndices = [];
                        _.selectedItems = [];
                    }
                    _setSelectedRowRelatedProperties.call(this);
                    _applyRowsSkin.call(this);
                } else {
                    throw new Error('isMultiSelect is false');
                }
            } else {
                throw new Error('Invalid parameter');
            }
        };


        var datagrid_setCellDataAt = function DataGrid$setCellDataAt(rowIndex, columnID, data) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                _ = this._kwebfw_, prop = _.prop, config = prop.columnHeadersConfig,
                tr = null, td = null, columnIndex = -1, el = null, index = null,
                tempdata = {}, tpl = null;

            if($KU.is(rowIndex, 'integer') && rowIndex >= 0
            && rowIndex < prop.data.length
            && $KU.is(columnID, 'string') && columnID) {
                columnIndex = _getColumnIndexById.call(this, columnID);
                index = [rowIndex, columnIndex];

                if(columnIndex !== -1) {
                    config = config[columnIndex];
                    prop.data[rowIndex][columnID] = data;
                    if(_.selectedIndices.indexOf(rowIndex)>=0) {
                        if($KU.is(prop.selectedCellIndex, 'equals', [columnIndex, columnID])) {
                            _.selectedCellPos = [];
                        }
                        _.selectedItems.splice(_.selectedIndices.indexOf(rowIndex), 1);
                        _.selectedIndices.splice(_.selectedIndices.indexOf(rowIndex), 1);
                    }
                    _flushClones(_.clones[1][rowIndex][columnIndex]);
                    _.clones[1][rowIndex][columnIndex] = null;

                    if((config.columnType === constants.DATAGRID_COLUMN_TYPE_TEXT && $KU.is(data, 'string'))
                    || (config.columnType === constants.DATAGRID_COLUMN_TYPE_IMAGE && $KU.is(data, 'string') && data)
                    || (config.columnType === constants.DATAGRID_COLUMN_TYPE_TEMPLATE && $KU.is(data, 'object'))) {
                        el = $KW.el(this);

                        if(el.table) {
                            tr = $KD.childAt(el.table, _deduceRowIndexGivenModelIndex.call(this, rowIndex));
                            td = $KD.childAt(tr, columnIndex);

                            if(config.columnType === constants.DATAGRID_COLUMN_TYPE_TEXT) {
                                $KD.text(td, data);
                            } else if(config.columnType === constants.DATAGRID_COLUMN_TYPE_IMAGE) {
                                $KD.setAttr($KD.first(td), 'src', $KU.getImageURL(data));
                            } else if(config.columnType === constants.DATAGRID_COLUMN_TYPE_TEMPLATE) {
                                $KD.html(td, '');
                                tempdata[columnID] = data;
                                tpl = _getClonedTemplateCell.call(this, config, tempdata, index);
                                tpl = tpl._render();
                                $KW.iterate(tpl, function(widget) {
                                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                                        view = widget._kwebfw_.view;

                                    if(view) {
                                        $KD.setAttr(view, 'aria-colindex', index[1] + 1);
                                        $KD.setAttr(view, 'aria-rowindex', index[0] + 1);
                                    }
                                }, {tabs:false});
                                $KD.style(tpl, {position: 'relative'});
                                $KD.add(td, tpl);
                                _applyHeightinPercent.call(this, config, td, tr);
                                _.rows[rowIndex][columnIndex] = _.clones[1][rowIndex][columnIndex];
                            }
                        }
                        _setSelectedRowRelatedProperties.call(this);
                        _applyRowsSkin.call(this);
                        _view.DataGrid.gridlineColor.call(this, el);
                    } else {
                        throw new Error('Invalid data');
                    }
                } else {
                    throw new Error('Invalid column ID');
                }
            } else {
                throw new Error('Invalid parameter');
            }
        };


        var datagrid_setData = function DataGrid$setData(data) {
            var _ = this._kwebfw_;

            _flushClones(_.clones[1]);
            _.clones[1] = [];
            _.rows = [];
            this.data = data;
        };


        var datagrid_setDataAt = function DataGrid$setDataAt(data, index, arg2, arg3, arg4) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, _ = this._kwebfw_,
                prop = _.prop, widget = null, colIndex = null,
                key = null, colId = null, rowIndex = null,
                _constructObject = function(widget, data, key) {
                    var defaultProp = null, value = null;

                    if($KU.is(data, 'string')) {
                        defaultProp = $KW.getDefaultProperty(widget);
                        value = data;
                        data = {};
                        data[defaultProp] = value;
                    } else {
                        data = {};
                    }

                    data[key] = widget[key];
                    return data;
                };

            if(arguments.length === 5 && $KU.is(data, 'widget')) {
                widget = data;
                key = index;
                rowIndex = arg3;
                colIndex = arg4;

                if(rowIndex === -1 && colIndex > -1) {
                    if($KU.is(prop.columnHeadersConfig[colIndex].columnHeaderTemplate.data[widget.id], 'object')) {
                        prop.columnHeadersConfig[colIndex].columnHeaderTemplate.data[widget.id][key] = widget[key];
                    } else {
                        prop.columnHeadersConfig[colIndex].columnHeaderTemplate.data[widget.id] = _constructObject(widget, prop.data[rowIndex][colId][widget.id], key);
                    }
                } else {
                    colId = _getColumnIdByIndex.call(this, colIndex);

                    if(colId) {
                        if($KU.is(prop.data[rowIndex][colId][widget.id], 'object')) {
                            prop.data[rowIndex][colId][widget.id][key] = widget[key];
                        } else {
                            prop.data[rowIndex][colId][widget.id] = _constructObject(widget, prop.data[rowIndex][colId][widget.id], key);
                        }
                    }
                }
            } else if(prop.data) {
                if($KU.is(data, 'object') && $KU.is(index, 'integer')
                && index >= 0 && index < prop.data.length) {
                    _onRowChange.call(this, index, 'update', data);
                } else {
                    throw new Error('Invalid parameter');
                }
            }
        };


        var datagrid_setHeaderCellDataAt = function DataGrid$setHeaderCellDataAt(columnID, data) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, prop = this._kwebfw_.prop,
                $KD = $K.dom, columnIndex = -1, tpl = null, tr = null, th = null, el = null;

            if($KU.is(columnID, 'string') && columnID
            && ($KU.is(data, 'string') || $KU.is(data, 'number') || $KU.is(data, 'object'))) {
                columnIndex = _getColumnIndexById.call(this, columnID);

                if(columnIndex !== -1) {
                    el = $KW.el(this);

                    if(el.head) {
                        tr = $KD.first(el.table);
                    } else if(el.dockedheader) {
                        tr = $KD.first(el.docker);
                    }
                    if(tr) {
                        th = $KD.childAt(tr, columnIndex);
                        if(!prop.columnHeadersConfig[columnIndex].columnHeaderTemplate) {
                            $KD.text(th, data);
                            prop.columnHeadersConfig[columnIndex].columnHeaderText = data;
                        } else {
                            tpl = _getClonedTemplateCell.call(this, prop.columnHeadersConfig[columnIndex], data, [-1, columnIndex], true);
                            tpl = tpl._render();
                            $KW.iterate(tpl, function(widget) {
                                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                                    view = widget._kwebfw_.view;

                                if(view) {
                                    $KD.setAttr(view, 'aria-colindex', columnIndex);
                                }
                            }, {tabs:false});
                            prop.columnHeadersConfig[columnIndex].columnHeaderTemplate.data = data;
                            $KD.html(th, '');
                            $KD.style(tpl, {position: 'relative'});
                            $KD.add(th, tpl);
                        }
                    }
                } else {
                    throw new Error('Invalid column ID');
                }
            } else {
                throw new Error('Invalid parameter');
            }
        };


        $K.defVoltmxProp(DataGrid.prototype, [
            {keey:'_flush', value:datagrid__flush},
            {keey:'_render', value:datagrid__render},
            {keey:'addAll', value:datagrid_addAll},
            {keey:'addDataAt', value:datagrid_addDataAt},
            {keey:'applyCellSkin', value:datagrid_applyCellSkin},
            {keey:'removeAll', value:datagrid_removeAll},
            {keey:'removeAt', value:datagrid_removeAt},
            {keey:'selectAllRows', value:datagrid_selectAllRows},
            {keey:'setCellDataAt', value:datagrid_setCellDataAt},
            {keey:'setData', value:datagrid_setData},
            {keey:'setDataAt', value:datagrid_setDataAt},
            {keey:'setHeaderCellDataAt', value:datagrid_setHeaderCellDataAt}
        ]);


        return DataGrid;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmximage.js' */
(function() {
    var $K = voltmx.$kwebfw$, _cache = {}; //e.g. _cache['image_name.png'] = {path:'', height:-1, width:-1}


    $K.defVoltmxProp($K.ui, [
        {keey:'Image2', value:{}, items:[
            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, tabindex = '';

                if($KW.disabled(this)) {
                    $KD.setAttr(dom, 'aria-disabled', true);
                    $KD.setAttr(dom, 'tabindex', -1);
                } else if(!$KW.interactable(this)) {
                    $KD.setAttr(dom, 'tabindex', -1);
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(dom, 'aria-disabled');

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        $KD.removeAttr(dom, 'tabindex');
                    }
                }
            }}
        ]}
    ]);


    //This function must be called in the scope of widget instance
    var _applyScaleMode = function() {
        var offset = this._kwebfw_.ui.offset;

        switch(this.imageScaleMode) {
            case constants.IMAGE_SCALE_MODE_CROP:
                _scaleMode.crop.call(this, offset.height, offset.width);
                break;

            case constants.IMAGE_SCALE_MODE_FIT_TO_DIMENSIONS:
                _scaleMode.fit.call(this, offset.height, offset.width);
                break;

            case constants.IMAGE_SCALE_MODE_MAINTAIN_ASPECT_RATIO:
                _scaleMode.maintain.call(this, offset.height, offset.width);
                break;
            default :
                throw new Error('SPADW: Invalid Scale Mode applied' + this.imageScaleMode);
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        Image2: {
            toolTip: function Image2$_getter_toolTip() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, toolTip = prop.toolTip;

                if(prop.i18n_toolTip) {
                    toolTip = $KU.getI18Nvalue(prop.i18n_toolTip);
                }

                return toolTip;
            }
        }


    };


    var _imageErrorHandler = function Image2$_imageErrorHandler(/*e*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, model = $KW.model($KD.parent(this));

        if(model.imageWhenFailed) {
            this.src = $KU.getImageURL(model.imageWhenFailed);
        } else {
            $KW.fire(model, 'onDownloadComplete', model, {
                src: (model.base64 || model.src),
                isSuccess: false
            });
        }
    };


    var _imageLoadHandler = function Image2$_imageLoadHandler(/*e*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
            model = $KW.model($KD.parent(this)), _ = model._kwebfw_,
            el = $KW.el(model), src = this.src, fmodel = null,
            failedSrc = $KU.getImageURL(model.imageWhenFailed);

        if(src) {
            if(!_cache[src]) {
                _cache[src] = {
                    height:this.naturalHeight,
                    width:this.naturalWidth
                };
            }

            _.ui.offset.height = _cache[src].height;
            _.ui.offset.width = _cache[src].width;
        }

        if(model.base64 && src === ('data:image/png;base64,'+model.base64)) {
            _.ui.offset.height = this.naturalHeight;
            _.ui.offset.width = this.naturalWidth;
        }

        _applyScaleMode.call(model);
        $KD.style(el.node, 'background-image', null);
        $KD.style(el.image, 'visibility', null);

        if(!$KW.isFixedHeight(model) || !$KW.isFixedWidth(model)) {
            $KW.markRelayout(model);
            fmodel = $KW.model($K.app.currentFormUID);
            fmodel.forceLayout();
        }

        if(src !== failedSrc) {
            _.loaded = true;
            _.animator && _.animator.animate(model);
        }

        $KW.fire(model, 'onDownloadComplete', model, {
            src: (model.base64 || model.src),
            isSuccess: _.loaded
        });
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        Image2: function Image2$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Image2', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Image2', null);
                }
            }

            if(!_.ui) $KU.defineProperty(_, 'ui', {}, null);
            $KU.defineProperty(_, 'loaded', false, true);
            $KU.defineProperty(_.ui, 'offset', {width:-1, height:-1}, true);
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        Image2: function Image2$_postInitialization() {
            var _ = this._kwebfw_, prop = _.prop;

            if(prop.i18n_toolTip) {
                prop.toolTip = prop.i18n_toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        Image2: function Image2$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        Image2: function Image2$_relayoutPassiveTriggerer() {
            return ['base64', 'src'];
        }
    };


    //All the functions will be called in the scope of widget instance
    var _scaleMode = {
        maintain: function(height, width) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                el = $KW.el(this), referenceHeight = -1, referenceWidth = -1,
                view = null, frame = null, computedHeight = -1, computedWidth = -1;

            if($KU.is(height, 'number') && height >= 0
            && $KU.is(width, 'number') && width >= 0) {
                if($KW.isFixedHeight(this) || $KW.isFixedWidth(this)) {
                    view = this._kwebfw_.view;
                    frame = this._kwebfw_.prop.frame;

                    if(frame.width === -1 && $KW.isFixedWidth(this)) {
                        frame.width = view.offsetWidth;
                    }

                    if(frame.height === -1 && $KW.isFixedHeight(this)) {
                        frame.height = view.offsetHeight;
                    }
                }

                referenceWidth = ($KW.isFixedWidth(this)) ? frame.width : width;
                referenceHeight = ($KW.isFixedHeight(this)) ? frame.height : height;

                if(referenceHeight >= height && referenceWidth >= width) {
                    computedHeight = height;
                    computedWidth = width;
                } else {
                    computedHeight = ((height/width) * referenceWidth);

                    if(computedHeight <= referenceHeight) {
                        computedWidth = referenceWidth;
                    } else {
                        computedWidth = ((width/height) * referenceHeight);
                        computedHeight = referenceHeight;
                    }
                }

                $KD.style(el.image, {width:(computedWidth+'px'), height:(computedHeight+'px')});
            }
        },

        crop: function(/*height, width*/) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget,
                $KD = $K.dom, el = $KW.el(this);

            $KD.style(el.image, {'max-width':'100%'});
        },

        fit: function(height, width) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                $KD = $K.dom, el = $KW.el(this);

            if($KU.is(height, 'number') && height >= 0
            && $KU.is(width, 'number') && width >= 0) {
                if(!$KW.isFixedHeight(this)) {
                    $KD.style(el.node, 'height', (height+'px'));
                }
                if(!$KW.isFixedWidth(this)) {
                    $KD.style(el.node, 'width', (width+'px'));
                }

                $KD.style(el.image, {height:'100%', width:'100%'});
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        Image2: {
            toolTip: function Image2$_setter_toolTip(/*old*/) {
                this._kwebfw_.prop.i18n_toolTip = '';
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Image2: {
            base64: function Image2$_valid_base64(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            rawBytes: function Image2$_valid_rawBytes(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            imageScaleMode: function Image2$_valid_imageScaleMode(value) {
                var flag = false, options = [
                    constants.IMAGE_SCALE_MODE_CROP,
                    constants.IMAGE_SCALE_MODE_FIT_TO_DIMENSIONS,
                    constants.IMAGE_SCALE_MODE_MAINTAIN_ASPECT_RATIO
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            imageWhenFailed: function Image2$_valid_imageWhenFailed(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            imageWhileDownloading: function Image2$_valid_imageWhileDownloading(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            i18n_toolTip: function Image2$_valid_i18n_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            onDownloadComplete: function Image2$_valid_onDownloadComplete(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            src: function Image2$_valid_src(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            toolTip: function Image2$_valid_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            zoomEnabled: function Image2$_valid_zoomEnabled(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            zoomValue: function Image2$_valid_zoomValue(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number') && value >= 1) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        Image2: {
            base64: function Image2$_view_base64(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                this._kwebfw_.loaded = false;

                if(this.base64) {
                    $KD.setAttr(el.image, 'src', (this.base64).includes('data:image/png;base64') ? (this.base64) : ('data:image/png;base64,'+ this.base64));
                    $KD.setAttr(el.image, 'alt', '');
                } else {
                    $KD.removeAttr(el.image, 'src');
                    $KD.removeAttr(el.image, 'alt');
                }
            },

            rawBytes: function Image2$_view_rawBytes(el) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                this._kwebfw_.loaded = false;

                if(this.rawBytes) {
                    $KD.setAttr(el.image, 'src', (this.rawBytes).includes('data:image/png;base64') ? (this.rawBytes) : ('data:image/png;base64,'+ this.rawBytes));
                    $KD.setAttr(el.image, 'alt', '');
                } else {
                    $KD.removeAttr(el.image, 'src');
                    $KD.removeAttr(el.image, 'alt');
                }
            },

            imageScaleMode: function Image2$_view_imageScaleMode(/*el, old*/) {
                _applyScaleMode.call(this);
            },

            imageWhenFailed: true,

            imageWhileDownloading: true,

            i18n_toolTip: false,

            onDownloadComplete: true,

            src: function Image2$_view_src(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                this._kwebfw_.loaded = false;

                if(this.src) {
                    if(this.imageWhileDownloading) {
                        $KD.style(el.node, {
                            backgroundImage: ('url('+$KU.getImageURL(this.imageWhileDownloading)+')')
                        });
                    }

                    $KD.style(el.image, 'visibility', 'hidden');
                    $KD.setAttr(el.image, 'src', $KU.getImageURL(this.src));
                    $KD.setAttr(el.image, 'alt', '');
                } else {
                    $KD.style(el.node, 'background-image', null);
                    $KD.removeAttr(el.image, 'src');
                    $KD.removeAttr(el.image, 'alt');
                }
            },

            toolTip: function Image2$_view_toolTip(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.toolTip) {
                    $KD.setAttr(el.node, 'title', this.toolTip);
                } else {
                    $KD.removeAttr(el.node, 'title');
                }
            },

            zoomEnabled: true,

            zoomValue: true
        }
    };


    Object.defineProperty(voltmx.ui, 'Image2', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Image2 constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var Image2 = function Image2(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    base64: '',
                    rawBytes: '',
                    imageScaleMode: constants.IMAGE_SCALE_MODE_MAINTAIN_ASPECT_RATIO,
                    imageWhenFailed: '',
                    imageWhileDownloading: '',
                    i18n_toolTip: '',
                    onDownloadComplete: null,
                    src: 'imagedrag.png',
                    toolTip: '',
                    zoomEnabled: false,
                    zoomValue: 1
                };
            }

            _populateUnderscore.Image2.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            Image2.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Image2, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Image2.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to Image2
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Image2[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Image2>, but not in <_valid.Image2> namespace.');
                        } else {
                            valid = _valid.Image2[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Image2
                $KU.each(_view.Image2, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Image2$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Image2[key], 'function')) {
                            return _getter.Image2[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Image2$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, el = null,
                            old = null, valid = false, $KW = $K.widget,
                            rmodel = null, final = null, message = '';

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Image2[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Image2[key], 'function')) {
                                        _setter.Image2[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Image2().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Image2().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.Image2, 'function')) {
                    _postInitialization.Image2.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Image2, voltmx.ui.BasicWidget);


        /**
         * Takes care of flushing out the widget reference to clean memory.
         *
         * @override
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.Image2
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     void
         */
        var image2__flush = function Image2$_flush() {
            var $super = voltmx.ui.Image2.base.prototype,
                $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, el = $KW.el(this);

            if(el.image) {
                $KD.removeAttr(el.image, 'loading');
                $KD.off(el.image); //Remove all event listeners to avoid memory leaks
                $KD.style(el.image, 'visibility', null);
            }

            $super._flush.call(this);
        };


        /**
         * Builds the view layer for voltmx.ui.Image2 widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Image2
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  Image2 view.
         */
        var image2__render = function Image2$_render(tag) {
            var $super = voltmx.ui.Image2.base.prototype, _ = this._kwebfw_,
                $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                view = _.view, el = $KW.el(view), img = null, prop = _.prop;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    img = $KD.create('IMG');
                    if(this.height !== voltmx.flex.USE_PREFERRED_SIZE) {
                        $KD.setAttr(img, 'loading', 'lazy');
                    }

                    $KD.on(img, 'mousedown', 'image', function(evt) {
                        $KD.preventDefault(evt);
                    });
                    $KD.on(img, 'load', 'image', _imageLoadHandler);
                    $KD.on(img, 'error', 'image', _imageErrorHandler);
                    view = $super._render.call(this, tag, [img]);

                    el = $KW.el(view);

                    if(prop.base64) {
                        _view.Image2.base64.call(this, el, this.base64);
                    } else {
                        _view.Image2.src.call(this, el, this.src);
                    }
                }

                _view.Image2.toolTip.call(this, el, this.toolTip);

                $KW.accessibility(this);
            }

            return view;
        };


        var image2_addOverlayWidgets = function Image2$addOverlayWidgets() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, final = null;

            //TODO:: addOverlayWidgets API

            if(_relayoutActiveTriggerer.Image2().indexOf('addOverlayWidgets') >= 0) {
                $KW.markRelayout(this);
            }

            if(_relayoutPassiveTriggerer.Image2().indexOf('addOverlayWidgets') >= 0) {
                final = this._kwebfw_.flex.final;

                if(!(final.height && final.width)) {
                    $KW.markRelayout(this);
                }
            }
        };

        /*eslint-disable  no-console*/
        var image2_cropToRect = function Image2$cropToRect() {
            console.warn('This Image method is not supported in SPA.');
        };


        var image2_getImageAsRawBytes = function Image2$getImageAsRawBytes() {
            console.warn('This Image method is not supported in SPA.');
        };


        var image2_getImageHeight = function Image2$getImageHeight() {
            console.warn('This Image method is not supported in SPA.');
        };


        var image2_getImageWidth = function Image2$getImageWidth() {
            console.warn('This Image method is not supported in SPA.');
        };
        /*eslint-enable no-console*/


        var image2_removeOverlayWidgets = function Image2$removeOverlayWidgets() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, final = null;

            //TODO:: removeOverlayWidgets API

            if(_relayoutActiveTriggerer.Image2().indexOf('removeOverlayWidgets') >= 0) {
                $KW.markRelayout(this);
            }

            if(_relayoutPassiveTriggerer.Image2().indexOf('removeOverlayWidgets') >= 0) {
                final = this._kwebfw_.flex.final;

                if(!(final.height && final.width)) {
                    $KW.markRelayout(this);
                }
            }
        };

        /*eslint-disable no-console*/
        var image2_scale = function Image2$scale() {
            console.warn('This Image method is not supported in SPA.');
        };
        /*eslint-enable no-console*/


        $K.defVoltmxProp(Image2.prototype, [
            {keey:'_flush', value:image2__flush},
            {keey:'_render', value:image2__render},
            {keey:'addOverlayWidgets', value:image2_addOverlayWidgets},
            {keey:'cropToRect', value:image2_cropToRect},
            {keey:'getImageAsRawBytes', value:image2_getImageAsRawBytes},
            {keey:'getImageHeight', value:image2_getImageHeight},
            {keey:'getImageWidth', value:image2_getImageWidth},
            {keey:'removeOverlayWidgets', value:image2_removeOverlayWidgets},
            {keey:'scale', value:image2_scale}
        ]);


        return Image2;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxlabel.js' */
(function() {
    //This function must be called in the scope of widget instance
    var _deduceTagName = function Label$_deduceTagName(tag) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, ariaLevel = -1,
            a11y = this._kwebfw_.prop.accessibilityConfig;

        tag = 'label';

        if(a11y && a11y.tagName) {
            tag = a11y.tagName.toLowerCase();
        } else if(a11y && a11y.a11yARIA) {
            if(a11y.a11yARIA.role === 'heading') {
                tag = 'h1';
                ariaLevel = a11y.a11yARIA['aria-level'];

                if($KU.is(ariaLevel, 'numeric')) {
                    ariaLevel = parseFloat(ariaLevel, 10);
                }

                if($KU.is(ariaLevel, 'integer')
                && ariaLevel >= 1 && ariaLevel <= 6) {
                    tag = ('h'+ariaLevel);
                }
            }
        }

        return tag;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        Label: {
            text: function Label$_getter_text() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, text = prop.text;

                if(prop.i18n_text) {
                    text = $KU.getI18Nvalue(prop.i18n_text);
                }

                return text;
            },

            textStyle: function Label$_getter_textStyle() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, textStyle = null;

                if(prop.textStyle) {
                    textStyle = $KU.clone(prop.textStyle);
                }

                return textStyle;
            },

            toolTip: function Label$_getter_toolTip() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, toolTip = prop.toolTip;

                if(prop.i18n_toolTip) {
                    toolTip = $KU.getI18Nvalue(prop.i18n_toolTip);
                }

                return toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        Label: function Label$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Label', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Label', null);
                }
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        Label: function Label$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = this._kwebfw_, prop = _.prop;

            if($KU.is(prop.padding, 'null')) {
                prop.padding = [0, 0, 0, 0];
            }

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'defLabel';
            }

            if(prop.i18n_text) {
                prop.text = prop.i18n_text;
            }

            if(prop.i18n_toolTip) {
                prop.toolTip = prop.i18n_toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        Label: function Label$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        Label: function Label$_relayoutPassiveTriggerer() {
            return ['text', 'textStyle'];
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        Label: {
            text: function Label$_setter_text(/*old*/) {
                this._kwebfw_.prop.i18n_text = '';
            },

            toolTip: function Label$_setter_toolTip(/*old*/) {
                this._kwebfw_.prop.i18n_toolTip = '';
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Label: {
            i18n_text: function Label$_valid_i18n_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            i18n_toolTip: function Label$_valid_i18n_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            text: function Label$_valid_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    flag = ['', true];
                }

                return flag;
            },

            textCopyable: function Label$_valid_textCopyable(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            textStyle: function Label$_valid_textStyle(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')
                && (!Object.prototype.hasOwnProperty.call(value, 'lineSpacing')
                    || ($KU.is(value.lineSpacing, 'integer')
                        && value.lineSpacing >= 0))
                && (!Object.prototype.hasOwnProperty.call(value, 'letterSpacing')
                    || $KU.is(value.letterSpacing, 'integer'))
                && (!Object.prototype.hasOwnProperty.call(value, 'strikeThrough')
                    || $KU.is(value.strikeThrough, 'boolean'))) {
                    flag = true;
                }

                return flag;
            },

            toolTip: function Label$_valid_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        Label: {
            i18n_text: false,

            i18n_toolTip: false,

            text: function Label$_view_text(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.text(el.node, this.text);
            },

            textCopyable: function Label$_view_textCopyable(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.textCopyable) {
                    $KD.style(el.node, 'userSelect', 'text');
                } else {
                    $KD.style(el.node, 'user-select', null);
                }
            },

            textStyle: function Label$_view_textStyle(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                    fontSize = 0, value = this._kwebfw_.prop.textStyle;

                if(!value) {
                    $KD.style(el.node, 'line-height', null);
                    $KD.style(el.node, 'letter-spacing', null);
                    $KD.style(el.node, 'text-decoration', null);
                } else {
                    if(Object.prototype.hasOwnProperty.call(value, 'lineSpacing')) {
                        if($KW.isRendered(this)) {
                            //Similar IF block can be found in voltmxwidget.js file _onrender widget based function
                            fontSize = $KD.style(this._kwebfw_.view, 'font-size').replace('px', '');

                            if($KU.is(fontSize, 'numeric')) {
                                fontSize = parseInt(fontSize, 10);
                                $KD.style(el.node, 'lineHeight', ((fontSize+value.lineSpacing)+'px'));
                            } else {
                                $KD.style(el.node, 'line-height', null);
                            }
                        }
                    } else {
                        $KD.style(el.node, 'line-height', null);
                    }

                    if(Object.prototype.hasOwnProperty.call(value, 'letterSpacing')) {
                        $KD.style(el.node, 'letterSpacing', (value.letterSpacing+'px'));
                    } else {
                        $KD.style(el.node, 'letter-spacing', null);
                    }

                    if(value.strikeThrough === true) {
                        $KD.style(el.node, 'textDecoration', 'line-through');
                    } else {
                        $KD.style(el.node, 'text-decoration', null);
                    }
                }
            },

            toolTip: function Label$_view_toolTip(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.toolTip) {
                    $KD.setAttr(el.node, 'title', this.toolTip);
                } else {
                    $KD.removeAttr(el.node, 'title');
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'Label', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Label constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var Label = function Label(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    i18n_text: '',
                    i18n_toolTip: '',
                    text: '',
                    textCopyable: false,
                    textStyle: null,
                    toolTip: ''
                };
            }

            _populateUnderscore.Label.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            Label.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Label, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Label.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to Label
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Label[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Label>, but not in <_valid.Label> namespace.');
                        } else {
                            valid = _valid.Label[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Label
                $KU.each(_view.Label, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Label$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Label[key], 'function')) {
                            return _getter.Label[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Label$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Label[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Label[key], 'function')) {
                                        _setter.Label[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Label().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Label().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.Label, 'function')) {
                    _postInitialization.Label.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Label, voltmx.ui.BasicWidget);


        /**
         * Builds the view layer for voltmx.ui.Label widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Label
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  Label view.
         */
        var label__render = function Label$_render(tag) {
            var $super = voltmx.ui.Label.base.prototype, _ = this._kwebfw_,
                $K = voltmx.$kwebfw$, $KW = $K.widget, view = _.view, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, _deduceTagName.call(this, tag));
                    el = $KW.el(view);

                    _view.Label.textCopyable.call(this, el, this.textCopyable);
                    _view.Label.textStyle.call(this, el, this.textStyle);
                }

                _view.Label.toolTip.call(this, el, this.toolTip);
                _view.Label.text.call(this, el, this.text);

                $KW.accessibility(this);
            }

            return view;
        };


        $K.defVoltmxProp(Label.prototype, [
            {keey:'_render', value:label__render}
        ]);


        return Label;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxlistbox.js' */
(function() {
    var $K = voltmx.$kwebfw$, _renderListBox = {};

    $K.defVoltmxProp($K.ui, [
        {keey:'ListBox', value:{}, items:[
            {keey:'onChange', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    prop = this._kwebfw_.prop, options = [], o = 0, olen = 0;

                if(evt.target.tagName === 'SELECT') {
                    options = evt.target.options;
                    olen = options.length;
                    prop.selectedKey = null;
                    prop.selectedKeyValue = null;
                    prop.selectedKeys = null;
                    prop.selectedKeyValues = null;

                    for(o=0; o<olen; o++) {
                        if(options[o].selected) {
                            if(!$KU.is(prop.selectedKeys, 'array')) {
                                prop.selectedKeys = [];
                                prop.selectedKeyValues = [];
                            }

                            prop.selectedKeys.push(options[o].value);
                            prop.selectedKeyValues.push($KW.getGroupSelectedKeyValueByKey(this, options[o].value));
                        }
                    }

                    if(prop.selectedKeys) {
                        prop.selectedKey = prop.selectedKeys[(prop.selectedKeys.length -1)];
                        prop.selectedKeyValue = prop.selectedKeyValues[(prop.selectedKeyValues.length -1)];
                        $KW.onPropertyChange(this, 'selectedKeys');
                    }

                    $KW.onPropertyChange(this, 'selectedKey');
                    $K.apm.send(this, 'Touch', {type:(this._kwebfw_.name+'_Selection')});
                    $KW.fire(this, 'onSelection', this);
                }

                return false;
            }},

            {keey:'onFocusOut', value:function(/* evt */) {
                var timeout = null, self = this;

                timeout = setTimeout(function() {
                    _closePicker.call(self);

                    clearTimeout(timeout); self = timeout = null; //For GC
                }, 160);

                return false;
            }},

            {keey:'onItemSelection', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    li = $KD.closest(evt.target, 'tag', 'LI'), el = null,
                    key = '', prop = this._kwebfw_.prop, disabledkeys = prop.disabledKeys || [];

                if(li) {
                    el = $KW.el(this);
                    key = $KD.getAttr(li, 'value');
                    if(disabledkeys.indexOf(key) === -1) {
                        this.selectedKey = $KD.getAttr(li, 'value');
                        $KD.setAttr(el.input, 'value', this.selectedKeyValue[1]);
                        _closePicker.call(this);
                        $KD.focus(el.input);
                    }
                }

                return false;
            }},

            {keey:'onIconClick', value:function(/* evt */) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    $KD = $K.dom, el = $KW.el(this);

                if(!this._kwebfw_.picker) {
                    _openPicker.call(this);
                } else {
                    _closePicker.call(this);
                }

                if($KD.hasAttr(el.icon, 'tabindex')) {
                    $KD.focus(el.icon);
                }

                return false;
            }},

            {keey:'onIconKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_,
                    li = null, code = evt.keyCode || evt.which, skin = '';

                if([27, 38, 40].indexOf(code) >= 0) { //Escape, Up Arrow or Down Arrow
                    $KD.preventDefault(evt);

                    if(code === 27) { //Escape
                        _closePicker.call(this);
                    } else if([38, 40].indexOf(code) >= 0) { //Up Arrow or Down Arrow
                        if(_.picker) {
                            if(code === 38) { //Up Arrow
                                if(!_.option) {
                                    li = $KD.last(_.picker);
                                } else {
                                    li = $KD.prev(_.option);
                                    li = _updateDisableItemOption.call(this, li, code);
                                    if(!li) li = $KD.last(_.picker);
                                }
                            } else if(code === 40) { //Down Arrow
                                if(!_.option) {
                                    li = $KD.first(_.picker);
                                } else {
                                    li = $KD.next(_.option);
                                    li = _updateDisableItemOption.call(this, li, code);
                                    if(!li) li = $KD.first(_.picker);
                                }
                            }
                            li = _updateDisableItemOption.call(this, li, code);

                            if(li && li !== _.option) {
                                skin = _getHoverSkinForListItem.call(this);

                                if(_.option) {
                                    $KD.removeCls(_.option, skin + '-hover');
                                }
                                $KD.addCls(li, skin + '-hover');
                                li.scrollIntoView({behavior: 'smooth', block: 'nearest'});
                                _.option = li;
                            }
                        }
                    }
                }

                return false;
            }},

            {keey:'onIconKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_, $KW = $K.widget,
                    $KU = $K.utils, code = evt.keyCode || evt.which, el = $KW.el(this),
                    isValidValue = false, key = null;

                if([13, 32].indexOf(code) >= 0) { //Enter or Space
                    $KD.preventDefault(evt);

                    if(_.option) {
                        $KD.setAttr(el.input, 'value', _.option.innerText);
                        this.selectedKey = $KD.getAttr(_.option, 'value');
                    }

                    $KU.each(this.masterData, function(data) {
                        if(data[1] === el.input.value) {
                            isValidValue = true;
                            key = data[0];
                        }
                    }, this);

                    if(_.picker && isValidValue) {
                        this.selectedKey = key;
                        _closePicker.call(this);
                    } else {
                        _openPicker.call(this);
                    }
                }

                return false;
            }},

            {keey:'onInputKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_,
                    li = null, code = evt.keyCode || evt.which, skin = '';

                if([27, 38, 40].indexOf(code) >= 0) { //Escape, Up Arrow or Down Arrow
                    $KD.preventDefault(evt);

                    if(code === 27) { //Escape
                        _closePicker.call(this);
                    } else if([38, 40].indexOf(code) >= 0) { //Up Arrow or Down Arrow
                        if(_.picker) {
                            if(code === 38) { //Up Arrow
                                if(!_.option) {
                                    li = $KD.last(_.picker);
                                } else {
                                    li = $KD.prev(_.option);
                                    li = _updateDisableItemOption.call(this, li, code);
                                    if(!li) li = $KD.last(_.picker);
                                }
                            } else if(code === 40) { //Down Arrow
                                if(!_.option) {
                                    li = $KD.first(_.picker);
                                } else {
                                    li = $KD.next(_.option);
                                    li = _updateDisableItemOption.call(this, li, code);
                                    if(!li) li = $KD.first(_.picker);
                                }
                            }
                            li = _updateDisableItemOption.call(this, li, code);

                            if(li && li !== _.option) {
                                skin = _getHoverSkinForListItem.call(this);

                                if(_.option) {
                                    $KD.removeCls(_.option, skin + '-hover');
                                }
                                $KD.addCls(li, skin + '-hover');
                                li.scrollIntoView({behavior: 'smooth', block: 'nearest'});
                                _.option = li;
                            }
                        }
                    }
                }

                return false;
            }},

            {keey:'onInputKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_, $KW = $K.widget, $KU = $K.utils,
                    code = evt.keyCode || evt.which, el = $KW.el(this), isValidValue = false, key = null;

                if(code === 13) { //Enter
                    if(_.option) {
                        $KD.setAttr(el.input, 'value', _.option.innerText);
                        this.selectedKey = $KD.getAttr(_.option, 'value');
                    }

                    $KU.each(this.masterData, function(data) {
                        if(data[1] === el.input.value) {
                            isValidValue = true;
                            key = data[0];
                        }
                    }, this);

                    if(_.picker && isValidValue) {
                        this.selectedKey = key;
                        _closePicker.call(this);
                    } else {
                        _openPicker.call(this);
                    }
                } else if([38, 40].indexOf(code) === -1) {
                    _closePicker.call(this);
                    _openPicker.call(this);
                }

                return false;
            }},


            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    $KD = $K.dom, el = $KW.el(this), tabindex = '';

                if(!$KW.interactable(this)) {
                    if($KW.disabled(this)) {
                        $KD.setAttr(dom, 'disabled', 'disabled');
                    } else {
                        $KD.setAttr(dom, 'readonly', 'readonly');
                    }

                    $KD.setAttr(dom, 'tabindex', -1);

                    if(this.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                        $KD.removeAttr(el.icon, 'tabindex');
                    }
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(dom, 'disabled');

                    $KD.setAttr(dom, 'tabindex', tabindex);

                    if(this.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                        $KD.setAttr(el.icon, 'tabindex', tabindex);
                    }
                }
            }}
        ]}
    ]);


    //remove and set skin on option of listbox
    var _applySkinOnListItem = function ListBox$_applySkinOnListItem(prop, option) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, disabledkeys = prop.disabledKeys || [],
            itemNormalSkin = prop.itemNormalSkin, itemDisabledSkin = prop.itemDisabledSkin || '-voltmx-option-disabled';

        $KD.removeAttr(option, 'class');
        if(disabledkeys.length !== 0 && disabledkeys.indexOf(option.getAttribute('value')) !== -1) {
            $KD.addCls(option, itemDisabledSkin);//if the option is disabled
            if(itemDisabledSkin === '-voltmx-option-disabled') {
                $KD.addCls(option, itemNormalSkin);
            }
        } else if(itemNormalSkin !== '') {
            $KD.addCls(option, itemNormalSkin);
        } else if(prop.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
            $KD.addCls(option, prop.skin);
        }
    };

    //This functions will be called in the scope of widget instance
    var _closePicker = function ListBox$_closePicker() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, _ = this._kwebfw_, el = null;

        if($KU.is(_.picker, 'dom')) {
            delete _.option;
            $KD.remove(_.picker);
            delete _.picker;
            el = $KW.el(this);
            $KD.setAttr(el.icon, 'aria-expanded', 'false');

            $KW.dismissPicker(this);
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {
        ListBox: function ListBox$_dependentPropertiesValidationMessage(prop, bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, message = '', keys = [],
                disabledKeys = (pspconfig && pspconfig.disabledKeys) || bconfig.disabledKeys,
                masterData = (pspconfig && pspconfig.masterData) || bconfig.masterData,
                masterDataMap = (pspconfig && pspconfig.masterDataMap) || bconfig.masterDataMap,
                multiSelect = (pspconfig && pspconfig.multiSelect) || bconfig.multiSelect,
                selectedKey = (pspconfig && pspconfig.selectedKey) || bconfig.selectedKey,
                selectedKeys = (pspconfig && pspconfig.selectedKeys) || bconfig.selectedKeys;

            disabledKeys = ($KU.is(disabledKeys, 'null') || $KU.is(disabledKeys, 'array')) ? disabledKeys : prop.disabledKeys;
            masterData = ($KU.is(masterData, 'null') || $KU.is(masterData, 'array')) ? masterData : prop.masterData;
            masterDataMap = ($KU.is(masterDataMap, 'null') || $KU.is(masterDataMap, 'array')) ? masterDataMap : prop.masterDataMap;
            multiSelect = ($KU.is(multiSelect, 'boolean')) ? multiSelect : prop.multiSelect;
            selectedKey = ($KU.is(selectedKey, 'null') || $KU.is(selectedKey, 'string')) ? selectedKey : prop.selectedKey;
            selectedKeys = ($KU.is(selectedKeys, 'null') || $KU.is(selectedKeys, 'array')) ? selectedKeys : prop.selectedKeys;

            if($KU.is(selectedKeys, 'array') && $KU.is(selectedKey, 'string')) {
                if(!multiSelect && selectedKeys.length > 1) {
                    message += '<selectedKeys> must hold only one key for non-multiselect ListBox.';
                } else if(selectedKeys[(selectedKeys.length - 1)] !== selectedKey) {
                    message += '<selectedKey> must be the last key of <selectedKeys> of ListBox.';
                }
            } else if((masterData || masterDataMap)
            && ($KU.is(selectedKey, 'string') || selectedKeys)) {
                $KU.each((masterData || masterDataMap), function(data) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    keys.push(($KU.is(data, 'array')) ? data[0] : data[masterDataMap[1]]);
                });

                if($KU.is(selectedKey, 'string')
                && keys.indexOf(selectedKey) === -1) {
                    message += 'Invalid selectedKey <'+selectedKey+'>.';
                }

                $KU.each(selectedKeys, function(name) {
                    if(keys.indexOf(name) === -1) {
                        message += 'Invalid selectedKey(s) <'+name+'>.';
                        return true;
                    }
                });
            } else if((masterData || masterDataMap)
            && ($KU.is(disabledKeys, 'null') || $KU.is(disabledKeys, 'array'))) {
                $KU.each((masterData || masterDataMap), function(data) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    keys.push(($KU.is(data, 'array')) ? data[0] : data[masterDataMap[1]]);
                });

                $KU.each(disabledKeys, function(name) {
                    if(keys.indexOf(name) === -1) {
                        message += 'Invalid disabledKey(s) <'+name+'>.';
                        return true;
                    }
                });
            }

            return message;
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        ListBox: {
            disabledKeys: function ListBox$_getter_disabledKeys(value) {
                return (value) ? value.slice(0) : null;
            },

            masterData: function ListBox$_getter_masterData(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, data = null;

                if(value) {
                    data = [];

                    $KU.each(value, function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, val = [item[0], item[1]];

                        if($KU.is(item[2], 'object')) {
                            val.push($KW.getAccessibilityConfig(item[2]));
                        }

                        if($KU.is(val[1], 'i18n')) {
                            val[1] = $KU.getI18Nvalue(val[1]);
                        }

                        data.push(val);
                    });
                }

                return data;
            },

            masterDataMap: function ListBox$_getter_masterDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    data = null, keyName = '', valName = '', masterDataMap = null;

                if(value) {
                    data = [];
                    keyName = value[1];
                    valName = value[2];

                    $KU.each(value[0], function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, val = {};

                        val[keyName] = item[keyName];
                        val[valName] = item[valName];

                        if($KU.is(item.accessibilityConfig, 'object')) {
                            val.accessibilityConfig = $KW.getAccessibilityConfig(item.accessibilityConfig);
                        }

                        if($KU.is(val[valName], 'string')
                        && val[valName].toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') !== -1) {
                            val[valName] = $KU.getI18Nvalue(val[valName]);
                        }

                        data.push(val);
                    });
                    masterDataMap = [data, keyName, valName];
                }

                return masterDataMap;
            },

            selectedKeys: function ListBox$_getter_selectedKeys(value) {
                return (value) ? value.slice(0) : null;
            },

            selectedKeyValue: function ListBox$_getter_selectedKeyValue(value) {
                return (value) ? value.slice(0) : null;
            },

            selectedKeyValues: function ListBox$_getter_selectedKeyValues(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            }
        }
    };

    //This functions will be called in the scope of widget instance
    var _getHoverSkinForListItem = function ListBox$_getHoverSkinForListItem() {
        var _ = this._kwebfw_, prop = _.prop, skin = '';

        if(prop.itemHoverSkin !== '') {
            skin = prop.itemHoverSkin;
        } else {
            skin = prop.hoverSkin;
        }

        return skin;
    };

    //This functions will be called in the scope of widget instance
    var _getValueByKey = function ListBox$_getValueByKey(ki) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, value = '', k = '', v = '',
            prop = this._kwebfw_.prop, masterdata = prop.masterData;

        if(!masterdata && prop.masterDataMap) {
            masterdata = [];
            k = prop.masterDataMap[1];
            v = prop.masterDataMap[2];

            $KU.each(prop.masterDataMap[0], function(data) {
                masterdata.push([data[k], data[v]]);
            });
        }

        $KU.each(masterdata, function(data) {
            if(ki === data[0]) {
                value = data[1];
                return true;
            }
        });

        return value;
    };


    //This functions will be called in the scope of widget instance
    //iterate list option nodes
    var _iterateListItemNodes = function ListBox$_iterateListItemNodes(el) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            prop = this._kwebfw_.prop, options = null;

        options = $KD.find(el.node, 'option');
        if(this.viewType === constants.LISTBOX_VIEW_TYPE_LISTVIEW) {
            if(options.length) {
                $KU.each(options, function(option) {
                    _applySkinOnListItem(prop, option);
                });
            }
        }
    };


    //This functions will be called in the scope of widget instance
    var _openPicker = function ListBox$_openPicker() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, _ = this._kwebfw_, el = null, pel = null,
            pickers = {}, picker = {};

        if(!$KU.is(_.picker, 'dom')) {
            pickers = $KW.pickers(this);

            pickers[_.uid] = _.uid;
            picker = _.picker = _renderPicker.call(this);

            el = $KW.el(this);

            $KD.style(picker, {
                left: (el.node.offsetLeft + 'px'),
                top: (el.node.offsetTop + el.node.offsetHeight + 'px'),
                width: (el.node.offsetWidth + 'px')
            });

            $KD.setAttr(el.icon, 'aria-expanded', 'true');
            pel = $KW.el($KW.pmodel(this));
            $KW.addToView((pel.scrolee || pel.viewport || pel.node), picker);
        }
    };

    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        ListBox: function ListBox$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.ListBox', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'ListBox', null);
                }
            }

            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        ListBox: function ListBox$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KW = $K.widget, prop = this._kwebfw_.prop;

            $KW.normalizeGroupMasterData(this);

            if(!prop.multiSelect && $KU.is(prop.selectedKey, 'null')
            && prop.masterData && prop.masterData.length > 0) {
                prop.selectedKey = prop.masterData[0][0];
            }

            if(this.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                prop.multiSelect = false;
                prop.multiSelectRows = null;

                if($KU.is(prop.selectedKeys, 'array')
                && prop.selectedKeys.length > 1) {
                    prop.selectedKeys.splice(0, (prop.selectedKeys.length - 1));
                }

                if($KU.is(prop.selectedKeyValues, 'array')
                && prop.selectedKeyValues.length > 1) {
                    prop.selectedKeyValues.splice(0, (prop.selectedKeyValues.length - 1));
                }
            }

            if($KU.is(prop.padding, 'null')) {
                prop.padding = [3, 0, 0, 0];
            }

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'defListBoxNormal';
            }

            if($KU.is(prop.selectedKey, 'null')) {
                prop.selectedKeyValue = null;
            }

            if($KU.is(prop.selectedKeys, 'null')) {
                prop.selectedKeyValues = null;
            } else if($KU.is(prop.selectedKeys, 'array')) {
                prop.selectedKeyValues = [];
            }

            if(prop.multiSelect) {
                if($KU.is(prop.selectedKey, 'null')
                && $KU.is(prop.selectedKeys, 'array') && prop.selectedKeys.length) {
                    prop.selectedKey = prop.selectedKeys[(prop.selectedKeys.length - 1)];
                    prop.selectedKeyValues = [];

                    $KU.each(prop.selectedKeys, function(selectedKey) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget,
                            selectedKeyValue = $KW.getGroupSelectedKeyValueByKey(this, selectedKey);

                        prop.selectedKeyValues.push(selectedKeyValue);
                    }, this);

                    prop.selectedKeyValue = prop.selectedKeyValues[(prop.selectedKeyValues.length - 1)];
                } else if($KU.is(prop.selectedKey, 'string')
                && $KU.is(prop.selectedKeys, 'null')) {
                    prop.selectedKeys = [prop.selectedKey];
                    prop.selectedKeyValue = $KW.getGroupSelectedKeyValueByKey(this, prop.selectedKey);
                    prop.selectedKeyValues = [prop.selectedKeyValue];
                }
            } else if($KU.is(prop.selectedKey, 'string')
            && $KU.is(prop.selectedKeys, 'null')) {
                prop.selectedKeys = [prop.selectedKey];
                prop.selectedKeyValue = $KW.getGroupSelectedKeyValueByKey(this, prop.selectedKey);
                prop.selectedKeyValues = [prop.selectedKeyValue];
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        ListBox: function ListBox$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        ListBox: function ListBox$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //This function will be called in the scope of widget instance
    _renderListBox[constants.LISTBOX_VIEW_TYPE_LISTVIEW] = function ListBox$_renderListBox_listview() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KD = $K.dom, prop = null, masterdata = null,
            $KW = $K.widget, $super = voltmx.ui.ListBox.base.prototype,
            el = null, _ = this._kwebfw_, view = _.view;

        view = $super._render.call(this, 'SELECT');
        el = $KW.el(view);

        $KD.setAttr(view, 'kv', this.viewType);
        $KD.setAttr(view, 'kwh-change', 'onChange');

        if(view) {
            prop = this._kwebfw_.prop;
            masterdata = this.masterData;

            if(!masterdata && prop.masterDataMap) {
                masterdata = this.masterDataMap[0];
            }

            $KD.html(view, '');
            view.multiple = this.multiSelect;

            $KU.each(masterdata, function(data) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, key = '',
                    prop = this._kwebfw_.prop, option = null, value = '', a11y = null;

                key = ($KU.is(data, 'array')) ? data[0] : data[prop.masterDataMap[1]];
                value = ($KU.is(data, 'array')) ? data[1] : data[prop.masterDataMap[2]];
                a11y = ($KU.is(data, 'array')) ? data[2] : data['accessibilityConfig'];

                option = $KD.create('OPTION', {value:key});
                option.text = ($KU.is(value, 'i18n') ? $KU.getI18Nvalue(value) : value);
                $KW.applyGroupA11Y(option, a11y, value, (_.uid+'_'+key+'_hint'));

                //TODO: disabled true based on the widget model.

                $KD.add(view, option);
            }, this);
        }

        if(this.multiSelect) {
            _view.ListBox.selectedKeys.call(this, el, _.prop.selectedKeys);
            _view.ListBox.multiSelectRows.call(this, el, this.multiSelectRows);
        } else {
            _view.ListBox.selectedKey.call(this, el, _.prop.selectedKey);
        }
        _view.ListBox.disabledKeys.call(this, el);
        _view.ListBox.itemNormalSkin.call(this, el);
        return view;
    };


    //This function will be called in the scope of widget instance
    _renderListBox[constants.LISTBOX_VIEW_TYPE_EDITVIEW] = function ListBox$_renderListBox_editview() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            prop = this._kwebfw_.prop, masterdata = null, icon = null,
            $KW = $K.widget, $super = voltmx.ui.ListBox.base.prototype,
            el = null, _ = this._kwebfw_, view = _.view, input = null;

        input = $KD.create('INPUT', {
            type:'text', autocomplete:'off'
        });

        icon = $KD.create('IMG', {
            alt:'ListBox Icon', role:'button',
            loading:'lazy'
        });
        $KD.on(icon, 'mousedown', 'image', function(e) {
            $KD.preventDefault(e);
        });
        $KD.setAttr(icon, 'aria-label', 'ListBox Icon');
        $KD.setAttr(icon, 'aria-haspopup', 'true');
        $KD.setAttr(icon, 'aria-expanded', 'false');
        $KD.setAttr(icon, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(icon, 'kwh-click', 'onIconClick');
        $KD.setAttr(icon, 'kwh-keyup', 'onIconKeyUp');
        $KD.setAttr(icon, 'kwh-keydown', 'onIconKeyDown');
        $KD.setAttr(input, 'kwh-focusout', 'onFocusOut');
        $KD.setAttr(input, 'kwh-keydown', 'onInputKeyDown');
        $KD.setAttr(input, 'kwh-keyup', 'onInputKeyUp');
        $KD.setAttr(icon, 'src', $KU.getImageURL('select_arrow.gif'));

        view = $super._render.call(this, 'DIV', [input, icon]);
        el = $KW.el(view);

        $KD.setAttr(view, 'kv', this.viewType);

        if(view) {
            prop = this._kwebfw_.prop;
            masterdata = this.masterData;

            if(!masterdata && prop.masterDataMap) {
                masterdata = this.masterDataMap[0];
            }
        }

        _view.ListBox.selectedKey.call(this, el, _.prop.selectedKey);

        return view;
    };


    //This function will be called in the scope of widget instance
    var _renderPicker = function ListBox$_renderPicker() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            _ = this._kwebfw_, prop = _.prop,
            uid = _.uid, masterdata = prop.masterData, picker = null;

        if(!masterdata && prop.masterDataMap) {
            masterdata = this.masterDataMap[0];
        }

        picker = $KD.create('ul', {
            id:(uid+'_picker'), kwf:uid
        }, {
            position:'absolute',
            listStyleType:'none',
            maxHeight:'200px',
            overflowX:'hidden',
            overflowY:'auto',
            zIndex:2147483647
        });


        $KU.each(masterdata, function(data) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, $KW = $K.widget,
                prop = this._kwebfw_.prop, el = $KW.el(this),
                option = null, key = '', value = '', a11y = null;

            key = ($KU.is(data, 'array')) ? data[0] : data[prop.masterDataMap[1]];
            value = ($KU.is(data, 'array')) ? data[1] : data[prop.masterDataMap[2]];
            a11y = ($KU.is(data, 'array')) ? data[2] : data['accessibilityConfig'];

            if(!el.input.value || value.toLowerCase().indexOf(el.input.value.toLowerCase()) >= 0) {
                option = $KD.create('LI', {
                    kr:'option',
                    value:key, role:'option'
                });
                $KD.text(option, ($KU.is(value, 'i18n') ? $KU.getI18Nvalue(value) : value));
                $KD.setAttr(option, 'kwh-click', 'onItemSelection');
                $KW.applyGroupA11Y(option, a11y, value, (_.uid+'_'+key+'_hint'));

                _applySkinOnListItem(prop, option);

                //TODO: disabled true based on the widget model.
                $KD.add(picker, option);
            }
        }, this);

        return picker;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        ListBox: {
            multiSelect: function ListBox$_setter_multiSelect(old) {
                var prop = this._kwebfw_.prop, count = -1;

                if(old && prop.selectedKeys && prop.selectedKeys.length > 1) {
                    count = (prop.selectedKeys.length - 1);
                    prop.selectedKeys.splice(0, count);
                    prop.selectedKeyValues.splice(0, count);
                }
            },

            masterData: function ListBox$_setter_masterData(/* old */) {
                var prop = this._kwebfw_.prop;

                prop.disabledKeys = null;
                prop.selectedKey = null;
                prop.selectedKeys = null;
                prop.selectedKeyValue = null;
                prop.selectedKeyValues = null;
            },

            masterDataMap: function ListBox$_setter_masterDataMap(/* old */) {
                var prop = this._kwebfw_.prop;

                if(!prop.masterData) {
                    prop.disabledKeys = null;
                    prop.selectedKey = null;
                    prop.selectedKeys = null;
                    prop.selectedKeyValue = null;
                    prop.selectedKeyValues = null;
                }
            },

            selectedKey: function ListBox$_setter_selectedKey(/* old */) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    index = -1, _ = this._kwebfw_, prop = _.prop;

                if($KU.is(prop.selectedKey, 'null')) {
                    prop.selectedKeys = null;
                    prop.selectedKeyValue = null;
                    prop.selectedKeyValues = null;
                } else {
                    prop.selectedKeyValue = $KW.getGroupSelectedKeyValueByKey(this, prop.selectedKey);

                    if($KU.is(prop.selectedKeys, 'null')) {
                        prop.selectedKeys = [prop.selectedKey];
                        prop.selectedKeyValues = [prop.selectedKeyValue];
                    } else {
                        if(!prop.multiSelect) {
                            prop.selectedKeys = [prop.selectedKey];
                            prop.selectedKeyValues = [prop.selectedKeyValue];
                        } else {
                            index = prop.selectedKeys.indexOf(prop.selectedKey);

                            if(index >= 0) {
                                prop.selectedKeys.splice(index, 1);
                                prop.selectedKeyValues.splice(index, 1);
                            }

                            prop.selectedKeys.push(prop.selectedKey);
                            prop.selectedKeyValues.push(prop.selectedKeyValue);
                        }
                    }
                }
            },

            selectedKeys: function ListBox$_setter_selectedKeys(/* old */) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if(!prop.selectedKeys) {
                    prop.selectedKey = null;
                    prop.selectedKeyValue = null;
                    prop.selectedKeyValues = null;
                } else if(!prop.selectedKeys.length) {
                    prop.selectedKeyValues = [];
                    prop.selectedKey = null;
                    prop.selectedKeyValue = null;
                } else {
                    prop.selectedKeyValues = [];

                    $KU.each(prop.selectedKeys, function(value) {
                        var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = this._kwebfw_.prop,
                            keyval = $KW.getGroupSelectedKeyValueByKey(this, value);

                        prop.selectedKeyValues.push(keyval);
                    }, this);

                    prop.selectedKey = prop.selectedKeys[(prop.selectedKeys.length - 1)];
                    prop.selectedKeyValue = prop.selectedKeyValues[(prop.selectedKeyValues.length - 1)];
                }
            }
        }
    };


    //update hover and li on input key down
    var _updateDisableItemOption = function ListBox$_updateDisableItemOption(li, code) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, _ = this._kwebfw_, prop = _.prop,
            disabledkeys = prop.disabledKeys || [], option = null;
        if(li && disabledkeys.indexOf($KD.getAttr(li, 'value')) !== -1) {
            if(code === 40) {
                option = $KD.next(li);
                option = _updateDisableItemOption.call(this, option, code);
            } else if(code === 38) {
                option = $KD.prev(li);
                option = _updateDisableItemOption.call(this, option, code);
            }
        } else if(li) {
            option = li;
        } else {
            option = null;
        }
        return option;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        ListBox: {

            disabledKeys: function ListBox$_valid_disabledKeys(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
                    prop = this._kwebfw_.prop, keys = [];

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'array')) {
                    flag = true;

                    if(flag && value) {
                        if((Object.prototype.hasOwnProperty.call(prop, 'masterData') && prop.masterData)
                        || (Object.prototype.hasOwnProperty.call(prop, 'masterDataMap') && prop.masterDataMap)) {
                            $KU.each((prop.masterData || prop.masterDataMap[0]), function(data) {
                                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                                keys.push(($KU.is(data, 'array')) ? data[0] : data[prop.masterDataMap[1]]);
                            });

                            $KU.each(value, function(name) {
                                if(keys.indexOf(name) === -1) {
                                    flag = false;
                                    return true;
                                }
                            });
                        }
                    }
                }
            },

            itemHoverSkin: function ListBox$_valid_itemHoverSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') && value.split(' ').length === 1) {
                    flag = true;
                }

                return flag;
            },

            itemDisabledSkin: function ListBox$_valid_itemHoverSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') && value.split(' ').length === 1) {
                    flag = true;
                }

                return flag;
            },

            itemNormalSkin: function ListBox$_valid_itemNormalSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') && value.split(' ').length === 1) {
                    flag = true;
                }

                return flag;
            },

            masterData: function ListBox$_valid_masterData(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;

                    $KU.each(value, function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if(!$KU.is(item, 'array')) {
                            flag = false;
                            return true;
                        }
                    });
                }

                return flag;
            },

            masterDataMap: function ListBox$_valid_masterDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value[0], 'array')
                && $KU.is(value[1], 'string') && value[1]
                && value[2] && $KU.is(value[2], 'string')) {
                    flag = true;

                    $KU.each(value[0], function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if(!$KU.is(item, 'object')) {
                            flag = false;
                            return true;
                        }
                    });
                }

                return flag;
            },

            multiSelect: function ListBox$_valid_multiSelect(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                if(flag && value && this.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                    flag = false;
                }

                return flag;
            },

            multiSelectRows: function ListBox$_valid_multiSelectRows(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if(($KU.is(value, 'integer') && value >= 0) || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && value && this.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                    flag = false;
                }

                return flag;
            },

            selectedKey: function ListBox$_valid_selectedKey(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
                    prop = this._kwebfw_.prop, keys = [];

                if($KU.is(value, 'string') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'string')
                && (Object.prototype.hasOwnProperty.call(prop, 'masterData'))
                && (Object.prototype.hasOwnProperty.call(prop, 'masterDataMap'))) {
                    if(prop.masterData || prop.masterDataMap) {
                        $KU.each((prop.masterData || prop.masterDataMap[0]), function(data) {
                            var $K = voltmx.$kwebfw$, $KU = $K.utils;

                            keys.push(($KU.is(data, 'array')) ? data[0] : data[prop.masterDataMap[1]]);
                        });

                        if(keys.indexOf(value) === -1) {
                            flag = false;
                        }
                    }
                }

                return flag;
            },

            selectedKeys: function ListBox$_valid_selectedKeys(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
                    prop = this._kwebfw_.prop, keys = [];

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'array')) {
                    flag = true;

                    if((Object.prototype.hasOwnProperty.call(prop, 'multiSelect'))
                        && !prop.multiSelect && value.length > 1) {
                        flag = false;
                    }

                    if(flag && value
                    && (Object.prototype.hasOwnProperty.call(prop, 'masterData'))
                    && (Object.prototype.hasOwnProperty.call(prop, 'masterDataMap'))) {
                        if(prop.masterData || prop.masterDataMap) {
                            $KU.each((prop.masterData || prop.masterDataMap[0]), function(data) {
                                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                                keys.push(($KU.is(data, 'array')) ? data[0] : data[prop.masterDataMap[1]]);
                            });

                            $KU.each(value, function(name) {
                                if(keys.indexOf(name) === -1) {
                                    flag = false;
                                    return true;
                                }
                            });
                        }
                    }
                }

                return flag;
            },

            selectedKeyValue: function ListBox$_valid_selectedKeyValue(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            selectedKeyValues: function ListBox$_valid_selectedKeyValues(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            viewType: function ListBox$_valid_viewType(value) {
                var flag = false, options = [
                    constants.LISTBOX_VIEW_TYPE_EDITVIEW,
                    constants.LISTBOX_VIEW_TYPE_LISTVIEW
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        ListBox: {
            disabledKeys: function ListBox$_view_disableKeys(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    prop = this._kwebfw_.prop, options = null,
                    disabledkeys = prop.disabledKeys || [];

                if(this.viewType === constants.LISTBOX_VIEW_TYPE_LISTVIEW) {
                    options = $KD.find(el.node, 'option');
                    if(options.length) {
                        $KU.each(options, function(option) {
                            option.disabled = false;
                            _applySkinOnListItem(prop, option);
                            if(disabledkeys.indexOf(option.getAttribute('value')) !== -1) {
                                option.disabled = true;
                            }
                        });
                    }
                }
            },

            itemHoverSkin: function ListBox$_view_itemHoverSkin(/* el, old */) {},

            itemDisabledSkin: function ListBox$_view_itemDisabledSkin(el/* , old */) {
                _iterateListItemNodes.call(this, el);
            },

            itemNormalSkin: function ListBox$_view_itemNormalSkin(el/* , old */) {
                _iterateListItemNodes.call(this, el);
            },

            masterData: function ListBox$_view_masterData(el/* , old */) {
                var $K=voltmx.$kwebfw$, $KW = $K.widget;

                $KW.normalizeGroupMasterData(this);
                _renderListBox[this.viewType].call(this, el.node);
            },

            masterDataMap: function ListBox$_view_masterDataMap(el/* , old */) {
                var $K=voltmx.$kwebfw$, $KW = $K.widget;

                $KW.normalizeGroupMasterDataMap(this);
                _renderListBox[this.viewType].call(this, el.node);
            },

            multiSelect: false,

            multiSelectRows: function ListBox$_view_multiSelectRows(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                if(this.multiSelect && $KU.is(this.multiSelectRows, 'integer')) {
                    $KD.setAttr(el.node, 'size', this.multiSelectRows);
                } else {
                    $KD.removeAttr(el.node, 'size');
                }
            },

            selectedKey: function ListBox$_view_selectedKey(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.viewType === constants.LISTBOX_VIEW_TYPE_LISTVIEW) {
                    el.node.value = this.selectedKey;
                } else if(this.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                    if(this.selectedKey !== null) {
                        $KD.setAttr(el.input, 'value', _getValueByKey.call(this, this.selectedKey));
                    } else {
                        $KD.setAttr(el.input, 'value', '');
                    }
                }
            },

            selectedKeys: function ListBox$_view_selectedKeys(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    $KD = $K.dom, prop = this._kwebfw_.prop;

                if(prop.viewType === constants.LISTBOX_VIEW_TYPE_LISTVIEW) {
                    $KU.each($KD.find(el.node, 'option'), function(option) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                        if(!$KU.is(prop.selectedKeys, 'array')) {
                            option.selected = false;
                        } else {
                            option.selected = (prop.selectedKeys.indexOf(option.value) !== -1);
                        }
                    }, this);
                } else if(prop.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                    if($KU.is(prop.selectedKeys, 'array') && prop.selectedKeys.length === 1) {
                        $KD.setAttr(el.input, 'value', _getValueByKey.call(this, prop.selectedKeys[0]));
                    } else {
                        $KD.setAttr(el.input, 'value', '');
                    }
                }
            },

            selectedKeyValue: false,

            selectedKeyValues: false,

            viewType: function ListBox$_view_viewType(/* el, old */) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, view = null,
                    append = false, next = $KD.next(this._kwebfw_.view);

                if(!next) {
                    append = true;
                    next = $KW.holder(this.parent);
                }

                if(next) {
                    $KD.remove(this._kwebfw_.view);
                    this._kwebfw_.view = null;
                    view = _renderListBox[this.viewType].call(this);

                    if(append) {
                        $KD.add(next, view);
                    } else {
                        $KD.before(next, view);
                    }
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'ListBox', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
        * voltmx.ui.ListBox constructor.
        *
        * @class
        * @namespace   voltmx.ui
        * @extends     voltmx.ui.BasicWidget
        * @author      Goutam Sahu <goutam.sahu@voltmx.com>
        *
        * @param       {object} bconfig - An object with basic properties.
        * @param       {object} lconfig - An object with layout properties.
        * @param       {object} pspconfig - An object with platform specific properties.
        *
        * @throws      {InvalidArgumentException} - Invalid argument is passed.
        * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
        *
        * @classdesc   A brief description about the class.
        *              -
        *              -
        *
        * @todo        Anything that thought for but not yet implemented.
        *              -
        *              -
        */
        var ListBox = function ListBox(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    disabledKeys: null,
                    itemHoverSkin: '',
                    itemDisabledSkin: '',
                    itemNormalSkin: '',
                    masterData: null,
                    masterDataMap: null,
                    multiSelect: false,
                    multiSelectRows: null,
                    selectedKey: null,
                    selectedKeys: null,
                    selectedKeyValue: null,
                    selectedKeyValues: null,
                    viewType: constants.LISTBOX_VIEW_TYPE_LISTVIEW
                };
            }

            _populateUnderscore.ListBox.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name+$KU.uid());
            }

            ListBox.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.ListBox, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.ListBox.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to ListBox
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!(Object.prototype.hasOwnProperty.call(bconfig, key))) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.ListBox[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.ListBox>, but not in <_valid.ListBox> namespace.');
                        } else {
                            valid = _valid.ListBox[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to ListBox
                $KU.each(_view.ListBox, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function ListBox$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.ListBox[key], 'function')) {
                            return _getter.ListBox[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function ListBox$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.ListBox[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.ListBox[key], 'function')) {
                                        _setter.ListBox[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.ListBox().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.ListBox().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    p.masterDataMap = null;
                }

                if($KU.is(_postInitialization.ListBox, 'function')) {
                    _postInitialization.ListBox.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(ListBox, voltmx.ui.GroupWidget);


        /**
        * Builds the view layer for voltmx.ui.ListBox widget.
        *
        * @override
        * @access      protected
        * @method      _render
        * @memberof    voltmx.ui.ListBox
        * @author      Goutam Sahu <goutam.sahu@voltmx.com>
        *
        * @returns     {HTMLElement}  SampleWidget view.
        */
        var listbox__render = function ListBox$_render(/* tag */) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                _ = this._kwebfw_, view = _.view, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                view = _renderListBox[this.viewType].call(this);
                el = $KW.el(view);

                if(this.viewType === constants.LISTBOX_VIEW_TYPE_EDITVIEW) {
                    $KD.setAttr(el.icon, 'aria-expanded', 'false');
                }

                $KW.accessibility(this);
            }

            return view;
        };


        var listbox_setFocus = function ListBox$_setFocus(value) {
            var $super = voltmx.ui.ListBox.base.prototype, $K = voltmx.$kwebfw$,
                $KU = $K.utils, $KW = $K.widget, $KD = $K.dom, el = $KW.el(this);

            if($KU.is(value, 'boolean') && el.node) {
                if(value === true) {
                    $super.setFocus.call(this, value);
                    $KD.focus(el.node);
                } else {
                    $KD.blur(el.node);
                }
            }
        };


        $K.defVoltmxProp(ListBox.prototype, [
            {keey:'_render', value:listbox__render},
            {keey:'setFocus', value:listbox_setFocus}
        ]);


        return ListBox;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxmap.js' */
/* globals InfoBox */
/* globals google  */
(function() {
    var $K = voltmx.$kwebfw$, _scriptsRequested = false;

    $K.defVoltmxProp($K.ui, [
        {keey:'Map', value:{}, items:[
            {keey:'onLoad', value:function() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KA = $K.app;

                $KW.iterate($KW.model($KA.currentFormUID), function(widget) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    if($KU.is(widget, 'widget', 'Map') && $KW.visible(widget)) {
                        _initializeInfoBox.call(widget);
                        _setUpInteractiveCanvasMap.call(widget);
                    }
                }, {tabs:false});
            }},


            {keey:'onMapClick', value:function(/*evt*/) {
                return false;
            }},

            {keey:'InfoWindow', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, $KU = $K.utils,
                    loc = null, mapPointNo = $KD.getAttr(evt.target, 'mappointno');

                if($KU.is(parseInt(mapPointNo, 10), 'number')) {
                    loc = this._kwebfw_.prop.locationData[parseInt(mapPointNo, 10)];
                } else {
                    loc = this._kwebfw_.gmapoptions.navigateToLocationData;
                }

                $KW.fire(this, 'onSelection', this, {location: loc});
                return false;
            }},

            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, tabindex = '';

                if($KW.disabled(this)) {
                    $KD.setAttr(dom, 'aria-disabled', true);
                    $KD.removeAttr(dom, 'tabindex');
                    $KD.addCls(dom, '-voltmx-blocker');
                } else if(!$KW.interactable(this)) {
                    $KD.removeAttr(dom, 'tabindex');
                    $KD.addCls(dom, '-voltmx-blocker');
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(dom, 'aria-disabled');

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        $KD.removeAttr(dom, 'tabindex');
                    }
                    $KD.removeCls(dom, '-voltmx-blocker');
                }
            }}
        ]}
    ]);


    //All the functions will be called in the scope of widget instance
    var _cachePinSizeAndSetupMarkers = function Map$_cachePinSizeAndSetupMarkers(imageObj, markerOptions) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, mapModel = this, img = null,
            imgName = null, anchorPosition = voltmx.map.PIN_IMG_ANCHOR_BOTTOM_CENTER,
            imgURL = _getPinImageURL(imageObj);

        if(typeof imageObj === 'object' && imageObj.anchor) {
            anchorPosition = imageObj.anchor;
        }

        markerOptions.icon = imgURL;

        if(anchorPosition === voltmx.map.PIN_IMG_ANCHOR_BOTTOM_CENTER) {
            _setMarkerOnMap.call(this, markerOptions);
        } else {
            imgName = imgURL.slice(imgURL.lastIndexOf('/') + 1);

            if(this._kwebfw_.gmapoptions.pinImageSize[imgName]) {
                _invokeAnchorMarker.call(this, markerOptions, imgURL, anchorPosition);
            } else {
                img = $KD.create('IMG', {
                    loading: 'lazy'
                });
                $KD.on(img, 'mousedown', 'image', function(e) {
                    $KD.preventDefault(e);
                });
                $KD.on(img, 'load', 'image', function() {
                    mapModel._kwebfw_.gmapoptions.pinImageSize[imgName] = {
                        height: this.naturalHeight,
                        width: this.naturalWidth
                    };
                    _invokeAnchorMarker.call(mapModel, markerOptions, imgURL, anchorPosition);
                });

                $KD._setAttr(img, 'src', imgURL);
            }
        }
    };


    //All the functions will be called in the scope of widget instance
    var _createMarkersForLocations = function Map$_createMarkersForLocations(locationdata) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.each(locationdata, function(locationitem, index) {
            var imageURL = null, markerOptions = null,
                gLatlng = new google.maps.LatLng(locationitem.lat, locationitem.lon);

            imageURL = locationitem.image || this.defaultPinImage;
            markerOptions = {
                position: gLatlng,
                html:  locationitem.desc,
                hdrdescp: locationitem.name,
                map: this._kwebfw_.gmapoptions.map,
                indexpoint: index,
                visible: true,
                pinId: (locationitem.id || 'noPinId' + index),
                coData: (locationitem.calloutData || locationitem.calloutdata),
                showcallout: (locationitem.showcallout || locationitem.showCallout)
            };

            _cachePinSizeAndSetupMarkers.call(this, imageURL, markerOptions);
        }, this);
    };


    //All the functions will be called in the scope of widget instance
    var _createInfobox = function Map$_createInfobox(infoOptions) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
            _ = this._kwebfw_, calloutPostion = _.prop.calloutPostion,
            el = $KW.el(this), icon = null, iconKey =null, infobox = null,
            infobox_left = 0, infobox_top = 0, infobox_width = 0;

        if(_.prop.enableMultipleCallouts) {
            infobox = new InfoBox();
        } else {
            _pinInfoWindowCloseAll.call(this);
            infobox = _.gmapoptions.infobox;
        }

        if(_.prop.calloutWidth < 1 || _.prop.calloutWidth > 100) {
            _.prop.calloutWidth = 80;
        }

        infobox_width = (_.prop.calloutWidth * 0.01 * el.node.offsetWidth) + 'px';
        infobox_left = parseInt(infobox_width, 10) / -2;
        if(calloutPostion !== 'bottom') {
            infobox.alignBottom_ = true;
            icon = infoOptions.icon;

            if($KU.is(infoOptions.icon, 'object')) {
                icon = infoOptions.icon.url;
            }

            iconKey = icon.slice(icon.lastIndexOf('/') + 1);
            if(_.gmapoptions.pinImageSize[iconKey]) {
                infobox_top = -(_.gmapoptions.pinImageSize[iconKey].height);
            } else {
                infobox_top = -30;
            }
        }

        infobox.content_ = _getContentNode.call(this, infoOptions.coData);
        infobox.disableAutoPan_ = false;
        infobox.position_ = infoOptions.position;
        infobox.maxWidth_ = 450,
        infobox.pixelOffset_ = new google.maps.Size(infobox_left, infobox_top);
        infobox.zIndex_ = 10;
        infobox.boxStyle_ = {
            opacity: 1,
            width: infobox_width,
            background: 'none'
        };
        infobox.enableEventPropagation_ = true;
        infobox.closeBoxURL_ = '';
        infobox.infoBoxClearance_ = new google.maps.Size(0, 0);

        return infobox;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All the functions will be called in the scope of widget instance
    var _drawCircle = function Map$_drawCircle(circledt) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, lineColor = '#FF0000', _circle = null,
            fillColor = 'white', lineWidth = 2, navigateandzoom = true,
            centerLoc = null, latValue = null, lonValue = null, radius = null;

        if(!$KU.is(circledt, 'undefined')) {
            latValue = circledt.centerLocation.lat;
            lonValue = circledt.centerLocation.lon;
            radius = circledt.radius * 10000;
            centerLoc = new google.maps.LatLng(latValue, lonValue);

            if(circledt.circleConfig) {
                lineColor = circledt.circleConfig.lineColor;
                fillColor = circledt.circleConfig.fillColor;
                lineWidth = circledt.circleConfig.lineWidth;
            }

            if(circledt.navigateAndZoom) {
                navigateandzoom = circledt.navigateAndZoom;
            }

            if(navigateandzoom) {
                this._kwebfw_.gmapoptions.map.panTo(centerLoc);
            }

            _circle = new google.maps.Circle({
                strokeColor: lineColor,
                strokeWeight: lineWidth,
                fillColor: fillColor,
                map: this._kwebfw_.gmapoptions.map,
                center: centerLoc,
                radius: radius
            });

            this._kwebfw_.gmapoptions.circleDataMap[circledt.id] = _circle;
        }
    };


    //All the functions will be called in the scope of widget instance
    var _drawPolygon = function Map$_drawPolygon(polygondt) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, polyGon = null,
            lineColor = '#FF0000', fillColor = 'white',
            lineWidth = 2, polyArrya = [];

        if(!$KU.is(polygondt, 'undefined')) {
            $KU.each(polygondt.locations, function(polydata/*, index*/) {
                polyArrya.push(new google.maps.LatLng(polydata.lat, polydata.lon));
            });

            if(polygondt.polygonConfig) {
                lineColor = polygondt.polygonConfig.lineColor;
                fillColor = polygondt.polygonConfig.fillColor;
                lineWidth = polygondt.polygonConfig.lineWidth;

                $KU.each(polygondt.polygonConfig.innerPolygons, function(innerpolydata/*, index*/) {
                    $KU.each(innerpolydata, function(innerpd/*, index*/) {
                        polyArrya.push(new google.maps.LatLng(innerpd.lat, innerpd.lon));
                    });
                });
            }
        }

        polyGon = new google.maps.Polygon({
            strokeColor: lineColor,
            strokeWeight: lineWidth,
            fillColor: fillColor
        });

        polyGon.setMap(this._kwebfw_.gmapoptions.map);
        polyGon.setPaths(polyArrya);
        this._kwebfw_.gmapoptions.polygonDataMap[polygondt.id] = polyGon;
    };


    //All the functions will be called in the scope of widget instance
    var _drawPolyline = function Map$_drawPolyline(polylinedata) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, polyLine = null,
            polyCoords = null, lineColor = '#FF0000', lineWidth = 2,
            polylineCoordinates = [], pindata = [];

        if(!$KU.is(polylinedata, 'undefined')) {
            pindata = _getPolylinePinData.call(this, polylinedata);

            if(pindata.length > 0) {
                _createMarkersForLocations.call(this, pindata);
            }

            polyCoords = polylinedata.locations;

            $KU.each(polyCoords, function(polydata/*, index*/) {
                polylineCoordinates.push(new google.maps.LatLng(polydata.lat, polydata.lon));
            });

            if(polylinedata.polygonConfig) {
                lineColor = polylinedata.polygonConfig.lineColor;
                lineWidth = polylinedata.polygonConfig.lineWidth;
            }
        }

        polyLine = new google.maps.Polyline({
            path: polylineCoordinates,
            strokeColor: lineColor,
            strokeWeight: lineWidth
        });

        polyLine.setMap(this._kwebfw_.gmapoptions.map);
        this._kwebfw_.gmapoptions.polylineDataMap[polylinedata.id] = polyLine;
    };


    //All the functions will be called in the scope of widget instance
    var _drawShapes = function Map$_drawShapes() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_;

        $KU.each(_.gmapoptions.circleData, function(circleData) {
            _drawCircle.call(this, circleData);
        }, this);

        $KU.each(_.gmapoptions.polygonData, function(polygonData) {
            _drawPolygon.call(this, polygonData);
        }, this);

        $KU.each(_.gmapoptions.polylineData, function(polylineData) {
            _drawPolyline.call(this, polylineData);
        }, this);
    };


    var _getAnchorMarkerIcon = function Map$_getAnchorMarkerIcon(imgURL, anchorPosition, height, width) {
        switch(anchorPosition) {
            case voltmx.map.PIN_IMG_ANCHOR_TOP_LEFT:
                height = height + height;
                break;
            case voltmx.map.PIN_IMG_ANCHOR_TOP_RIGHT:
                height = height + height;
                width = 0;
                break;
            case voltmx.map.PIN_IMG_ANCHOR_TOP_CENTER:
                height = height + height;
                width = parseInt(width / 2, 10);
                break;
            case voltmx.map.PIN_IMG_ANCHOR_CENTER:
                height = parseInt(height / 2, 10) + height;
                width = parseInt(width / 2, 10);
                break;
            case voltmx.map.PIN_IMG_ANCHOR_BOTTOM_LEFT:
                break;
            case voltmx.map.PIN_IMG_ANCHOR_BOTTOM_RIGHT:
                width = 0;
                break;
            case voltmx.map.PIN_IMG_ANCHOR_MIDDLE_LEFT:
                height = parseInt(height / 2, 10) + height;
                break;
            case voltmx.map.PIN_IMG_ANCHOR_MIDDLE_RIGHT:
                height = parseInt(height / 2, 10) + height;
                width = 0;
                break;
            case voltmx.map.PIN_IMG_ANCHOR_BOTTOM_CENTER:
                width = parseInt(width / 2, 10);
                break;
            default : break;
        }

        return {
            url: imgURL,
            anchor: new google.maps.Point(width, height)
        };
    };


    //All the functions will be called in the scope of widget instance
    var _getContentNode = function Map$_getContentNode(mapCalloutData) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = this._kwebfw_.prop,
            $KD = $K.dom, contentNode = null, tpl = null, template = null;

        tpl = mapCalloutData.template || prop.calloutTemplate;
        tpl = $KW.getTemplate(this, tpl);

        if(tpl) {
            template = $KW.cloneTemplate(tpl, mapCalloutData, prop.widgetDataMapForCallout);
            template._kwebfw_.forceLayout = true;
            contentNode = template._render();
            $KD.style(contentNode, {position:'relative'});
            template.forceLayout();
        }

        return contentNode;
    };


    var _getMapMode = function Map$_getMapMode(mode) {
        var mapMode = null;

        switch(mode) {
            case constants.MAP_VIEW_MODE_SATELLITE:
                mapMode = window.google.maps.MapTypeId.SATELLITE;
                break;

            case constants.MAP_VIEW_MODE_HYBRID:
                mapMode = window.google.maps.MapTypeId.HYBRID;
                break;

            case constants.MAP_VIEW_MODE_TERRAIN:
                mapMode = window.google.maps.MapTypeId.TERRAIN;
                break;

            case constants.MAP_VIEW_MODE_NORMAL:
            default:
                mapMode = window.google.maps.MapTypeId.ROADMAP;
        }

        return mapMode;
    };


    //All the functions will be called in the scope of widget instance
    var _getPinAndIndexFromLocationData = function Map$_getPinAndIndexFromLocationData(pinId) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, output = null,
            locDataArr = this._kwebfw_.prop.locationData;

        $KU.each(locDataArr, function(locationdata, index) {
            if(locationdata.id === pinId) {
                output = {index:index, data:locationdata};
                return true;
            }
        });

        return output;
    };


    var _getPinImageURL = function Map$_getPinImageURL(imageURL) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(imageURL, 'object')) {
            imageURL = imageURL.source;
        }

        return $KU.getImageURL(imageURL);
    };


    var _getPolylinePinData = function Map$_getPolylinePinData(polylinedata) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, pindata = [],
            locationpts = ['startLocation', 'endLocation'];

        $KU.each(locationpts, function(locationpt/*, index*/) {
            var pinLocation = polylinedata[locationpt];

            if(pinLocation && !pinLocation.id) {
                pinLocation.id = polylinedata.id + '_' + locationpt;
                pindata.push(pinLocation);
            }
        });

        return pindata;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        Map: {
            locationData: function Map$_getter_locationData(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            }
        }
    };


    var _initializeInfoBox = function Map$_initializeInfoBox() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            $KG = $K.globals, src = null,
            gmapoptions = this._kwebfw_.gmapoptions;

        if($KU.is(window.InfoBox, 'undefined')) {
            src = $KG.platform+'/jslib/tparty/googlemaps/infobox.js';
            $KU.loadScript(src, false, function() {
                gmapoptions.infobox = new InfoBox();
            });
        }
    };


    var _invokeAnchorMarker = function Map$_invokeAnchorMarker(markerOptions, imgURL, anchorPosition) {
        var height = null, width = null, imgName = null;

        if(anchorPosition !== voltmx.map.PIN_IMG_ANCHOR_BOTTOM_CENTER) {
            imgName = imgURL.slice(imgURL.lastIndexOf('/') + 1);
            height = this._kwebfw_.gmapoptions.pinImageSize[imgName].height;
            width = this._kwebfw_.gmapoptions.pinImageSize[imgName].width;
            markerOptions.icon = _getAnchorMarkerIcon(imgURL, anchorPosition, height, width);
            _setMarkerOnMap.call(this, markerOptions);
        }
    };


    //All the functions will be called in the scope of widget instance
    var _loadMapScripts = function Map$_loadMapScripts() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            script = null, src = '', clientId = null, mapKey = null;

        if(!_scriptsRequested
        && ($KU.is(window.google, 'undefined')
        || $KU.is(window.google.maps, 'undefined'))) {
            mapKey = this.mapKey;
            clientId = this.mapClientId;
            _scriptsRequested = true;

            src = '';
            src += '//maps-api-ssl.google.com/maps/api/js?callback=voltmx.$kwebfw$.ui.Map.onLoad';
            src += (mapKey) ? ('&key=' + mapKey) : ('&client=' + clientId);

            script = $KD.create('script', {'type':'text/javascript', 'src':src});
            $KD.add($KD.body(), script);
        } else {
            window.google && $K.ui.Map.onLoad();
        }
    };


    //All the functions will be called in the scope of widget instance
    var _mapBoundsChangeHandler = function Map$_mapBoundsChangeHandler() {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            bounds = null, boundsval = null;

        if(this.onBoundsChanged) {
            bounds = this._kwebfw_.gmapoptions.map.getBounds();
            boundsval = {
                center: [bounds.getCenter().lat(), bounds.getCenter().lng()],
                northEast: [bounds.getNorthEast().lat(), bounds.getNorthEast().lng()],
                southWest: [bounds.getSouthWest().lat(), bounds.getSouthWest().lng()],
                latspan: bounds.toSpan().lat(),
                lonspan: bounds.toSpan().lng()
            };

            $KW.fire(this, 'onBoundsChanged', this, boundsval);
        }
    };


    //All the functions will be called in the scope of widget instance
    var _mapClickEventHandler = function Map$_mapClickEventHandler(event) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget,
            lat = null, lng = null, latLng = null;

        if(this._kwebfw_.prop.onClick) {
            lat = event.latLng && event.latLng.lat();
            lng = event.latLng && event.latLng.lng();
            latLng = {lat:lat, lon:lng};

            $KW.fire(this, 'onClick', this, {latLng:latLng});
        }

        event.preventDefault && event.preventDefault();
        event.stopPropagation && event.stopPropagation();
    };


    //All the functions will be called in the scope of widget instance
    var _markerClickListener = function Map$_markerClickListener(markerOptions) {
        var mapModel = this;

        return function() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                $KU = $K.utils, infowindow = null, infobox = null,
                b = null, br = null, div = null, _ = mapModel._kwebfw_;

            if(!this.eventFromNavigateTo) {
                $KW.fire(mapModel, 'onPinClick', mapModel, {locationData: _.prop.locationData[this.indexpoint]});
                //$KAR && $KAR.sendRecording(mapModel, 'clickOnPin', {locationData: _.prop.locationData[this.indexpoint], eventType: 'uiAction'});
            }

            _pinInfoWindowClose.call(mapModel, this.pinId);

            if($KU.is(this.showcallout, 'undefined') || this.showcallout) {
                if(!$KU.is(this.coData, 'undefined')) {
                    if($KW.visible(mapModel)) {
                        infobox = _createInfobox.call(mapModel, markerOptions);
                        infobox.open(this.map, this);
                        _.gmapoptions.pinInfowindow[this.pinId] = infobox;
                    }
                } else {
                    infowindow = new google.maps.InfoWindow({
                        content: 'holding...'
                    });

                    div = $KD.create('DIV', {'kwh-click': 'InfoWindow', kwf: mapModel._kwebfw_.uid, mappointno: this.indexpoint});
                    b = $KD.create('B', {mappointno: this.indexpoint});
                    $KD.text(b, this.hdrdescp);
                    br = $KD.create('BR');
                    $KD.add(div, b);
                    $KD.add(div, br);
                    $KD.add(div, document.createTextNode(this.html));
                    infowindow.setContent(div);
                    infowindow.open(this.map, this);

                    if(mapModel.autoCenterPinOnClick) {
                        this.map.setCenter(this.getPosition());
                    }

                    _.gmapoptions.pinInfowindow[this.pinId] = infowindow;
                }
            }

            this.eventFromNavigateTo = false;
        };
    };


    //All the functions will be called in the scope of widget instance
    var _navigateTo = function Map$_navigateTo() {
        var _ = this._kwebfw_, mapdata = this.locationData, centrallon = 0,
            centrallat = 0, index = _.gmapoptions.navigateToArgs.index,
            marker = _.gmapoptions.markers[index];

        if(mapdata[index]) {
            centrallat = mapdata[index].lat;
            centrallon = mapdata[index].lon;
            if(mapdata[index].lat === undefined) {
                centrallat = mapdata[index][0];
                centrallon = mapdata[index][1];
            }
        }

        _.gmapoptions.map.setCenter(new google.maps.LatLng(centrallat, centrallon));

        if(_.gmapoptions.navigateToArgs.showCallout) {
            marker.eventFromNavigateTo = true;
            marker && google.maps.event.trigger(marker, 'click');
        }
        _.gmapoptions.navigateToArgs = null;
    };


    //All the functions will be called in the scope of widget instance
    var _navigateToLocation = function() {
        var marker = null, _= this._kwebfw_, lat = null, lon = null,
            desc = null, name = null, imageURL = null, urlt = '', position = null,
            navArgs = _.gmapoptions.navigateToLocationArgs, markerOptions = null,
            data = navArgs.navLocationData;

        lat = (data.lat) ? data.lat : data[0];
        lon = (data.lon) ? data.lon : data[1];
        desc = (data.lat === undefined) ? data[3] : data.desc;
        name = (data.lat === undefined) ? data[2] : data.name;
        imageURL = (data.lat === undefined) ? data[4] : (data.image || this.defaultPinImage);

        position = new google.maps.LatLng(lat, lon);
        _.gmapoptions.map.setCenter(position);
        _.gmapoptions.navigateToLocationData = data;

        markerOptions = {
            position: position,
            html: desc,
            icon: _getPinImageURL(imageURL),
            hdrdescp: name,
            visible: navArgs.dropPin,
            map: _.gmapoptions.map,
            indexpoint: 'navLoc',
            pinId: 'navPinId',
            coData: (data.calloutData || data.calloutdata),
            showcallout: navArgs.showCallout
        };

        _cachePinSizeAndSetupMarkers.call(this, urlt, markerOptions);

        if(navArgs.showCallout && navArgs.dropPin) {
            marker = _.gmapoptions.pinMarkers[markerOptions.pinId];
            marker.eventFromNavigateTo = true;
            marker && google.maps.event.trigger(marker, 'click');
        }

        _.gmapoptions.navigateToLocationArgs = null;
    };


    //All the functions will be called in the scope of widget instance
    var _onMapLoadedHandler = function Map$_onMapLoadedHandler() {
        var $K = voltmx.$kwebfw$, $KW = $K.widget;

        if(!this._kwebfw_.gmapoptions.loadedFlag) {
            this._kwebfw_.gmapoptions.loadedFlag = true;

            if(this.onMapLoaded) {
                $KW.fire(this, 'onMapLoaded', this);
            }
        }

        new google.maps.event.removeListener(this._kwebfw_.gmapoptions.tilesLoadedEventListener);
    };


    //All the functions will be called in the scope of widget instance
    var _pinInfoWindowClose = function Map$_pinInfoWindowClose(pinId) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            infowindow = this._kwebfw_.gmapoptions.pinInfowindow[pinId];

        if(!$KU.is(infowindow, 'undefined')) {
            infowindow.close();
            delete this._kwebfw_.gmapoptions.pinInfowindow[pinId];
        }
    };


    //All the functions will be called in the scope of widget instance
    var _pinInfoWindowCloseAll = function Map$_pinInfoWindowCloseAll() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.each(this._kwebfw_.gmapoptions.pinInfowindow, function(pinData, pinId) {
            _pinInfoWindowClose.call(this, pinId);
        }, this);
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        Map: function Map$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null,
                gmapoptionsVal = {
                    circleData: {},
                    circleDataMap: {},
                    infobox:  null,
                    map: '',
                    markers: [],
                    pinInfowindow: {},
                    pinImageSize: {},
                    pinMarkers: {},
                    polygonData: {},
                    polygonDataMap: {},
                    polylineData: {},
                    polylineDataMap: {},
                    tilesLoadedEventListener: '',
                    polygonModePath: null,
                    navigateToLocationData: null
                };

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Map', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Map', null);
                }
            }

            if(!_.gmapoptions) $KU.defineProperty(_, 'gmapoptions', gmapoptionsVal, null);
            //This holds the templateControllers used in this Map
            if(!_.templates) $KU.defineProperty(_, 'templates', {}, null);
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {};


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        Map: function Map$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        Map: function Map$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //This functions will be called in the scope of widget instance
    var _removeShape = function Map$_removeShape(shapeType, shapeId) {
        var _ = this._kwebfw_;

        if(_.gmapoptions[shapeType+'DataMap'][shapeId]) {
            _.gmapoptions[shapeType+'DataMap'][shapeId].setMap(null);
            delete _.gmapoptions[shapeType+'DataMap'][shapeId];
            delete _.gmapoptions[shapeType+'Data'][shapeId];
        }
    };


    //All the functions will be called in the scope of widget instance
    var _setMarkerOnMap = function Map$_setMarkerOnMap(markerOptions) {
        var marker = null, gmapoptions = this._kwebfw_.gmapoptions;

        if(gmapoptions.pinMarkers[markerOptions.pinId]) {
            marker = gmapoptions.pinMarkers[markerOptions.pinId];
            marker.setMap(null);
        }

        marker = new google.maps.Marker(markerOptions);
        gmapoptions.markers.push(marker);
        new google.maps.event.addListener(marker, 'click', _markerClickListener.call(this, markerOptions));
        if(markerOptions.visible) {
            marker.setMap(markerOptions.map);
        }
        gmapoptions.pinMarkers[markerOptions.pinId] = marker;
    };


    //All the functions will be called in the scope of widget instance
    var _setPins = function Map$_setPins(mapData) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, pinIdsArr = [],
            locDataArr = this._kwebfw_.prop.locationData;

        $KU.each(locDataArr, function(locationdata/*, index*/) {
            pinIdsArr.push(locationdata.id);
        });

        $KU.each(mapData, function(locationdata/*, index*/) {
            if(pinIdsArr.indexOf(locationdata.id) === -1) {
                locDataArr.push(locationdata);
            }
        });
        _setUpInteractiveCanvasMap.call(this);
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        Map: {
            //
        }
    };


    /**
     * One liner description about what this function/method is for.
     *
     * @access      private
     * @method      setUpInteractiveCanvasMap
     * @memberof    voltmx.ui.Map
     * @author      Shanker Pulugam <shanker.pulugam@voltmx.com>
     *
     * @param       None
     *
     * @fires       Once Google map scripts loaded or New locationData is set.
     *
     * @throws      None
     *
     * @returns     None
     *
     * @desc        A brief description about the class.
     *              -
     *              -
     *
     * @todo        None
     *              -
     *              -
     */
    var _setUpInteractiveCanvasMap = function Map$_setUpInteractiveCanvasMap() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, prop = _.prop,
            map = null, mapdata = null, mapOptions = null,
            points = [], bermudaTriangle = null, geocoder = null;

        if($KU.is(window.google, 'undefined')
        || $KU.is(window.google.maps, 'undefined')) {
            _.gmapoptions.loadedFlag = false;
            return;
        }

        mapdata = prop.locationData;
        mapOptions= {
            zoom: prop.zoomLevel,
            disableDefaultUI: true,
            zoomControl: prop.showZoomControl,
            navigationControl: true,
            mapTypeControl: this.displaymaptypecontrols,
            scaleControl: true,
            mapTypeId: _getMapMode(prop.mode)
        };

        $KU.each(this._kwebfw_.gmapoptions.markers, function(marker/*, index*/) {
            marker.setMap(null);
        });

        this._kwebfw_.gmapoptions.markers = [];
        this._kwebfw_.gmapoptions.pinMarkers = {};

        if(_.gmapoptions.map) {
            map = _.gmapoptions.map;
        } else {
            map = new google.maps.Map(_.view, mapOptions);
            _.gmapoptions.map = map;
        }

        if(mapdata.length > 0) {
            mapOptions.center = new google.maps.LatLng(mapdata[0].lat, mapdata[0].lon);
            map.setOptions(mapOptions);

            if(prop.mode !== constants.MAP_VIEW_MODE_POLYGON) {
                _createMarkersForLocations.call(this, mapdata);
            } else {
                $KU.each(mapdata, function(mdata/*, index*/) {
                    var polyPoint = null;

                    if(mdata.lat === undefined) {
                        polyPoint = new google.maps.LatLng(mdata[0], mdata[0]);
                    } else {
                        polyPoint = new google.maps.LatLng(mdata.lat, mdata.lon);
                    }
                    points.push(polyPoint);
                });

                bermudaTriangle = new google.maps.Polygon({
                    paths: points,
                    strokeColor: '#FF0000',
                    strokeOpacity: 0.8,
                    strokeWeight: 3,
                    fillColor: '#FF0000',
                    fillOpacity: 0.35
                });
                bermudaTriangle.setMap(map);
                _.gmapoptions.polygonModePath = bermudaTriangle;
            }
        } else if(prop.address && prop.address.location) {
            geocoder = new google.maps.Geocoder();
            geocoder.geocode({
                'address': prop.address.location
            }, function(results, status) {
                if(status === google.maps.GeocoderStatus.OK) {
                    map.setCenter(results[0].geometry.location);
                    new google.maps.Marker({
                        map: map,
                        position: results[0].geometry.location
                    });
                }
            });
        } else {
            map.setCenter(new google.maps.LatLng(0, 0));
        }

        if(_.gmapoptions.navigateToArgs) {
            _navigateTo.call(this);
        }

        if(_.gmapoptions.navigateToLocationArgs) {
            _navigateToLocation.call(this);
        }

        new google.maps.event.addListener(map, 'zoom_changed', function() {
            _.prop.zoomLevel = map.getZoom();
        });
        new google.maps.event.addListener(map, 'click', _mapClickEventHandler.bind(this));
        new google.maps.event.addListener(map, 'bounds_changed', _mapBoundsChangeHandler.bind(this));
        _.gmapoptions.tilesLoadedEventListener = new google.maps.event.addListener(map, 'tilesloaded', _onMapLoadedHandler.bind(this));
        _drawShapes.call(this);
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Map: {
            address: function Map$_valid_address(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')) {
                    flag = true;
                }

                return flag;
            },

            autoCenterPinOnClick: function Map$_valid_autoCenterPinOnClick(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            calloutPostion: function Map$_valid_calloutPostion(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            calloutTemplate: function Map$_valid_calloutTemplate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object') || $KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            calloutWidth: function Map$_valid_calloutWidth(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number')) {
                    flag = true;
                }

                return flag;
            },

            defaultPinImage: function Map$_valid_defaultPinImage(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') || $KU.is(value, 'object')) {
                    flag = true;
                }

                return flag;
            },

            displayMapTypeControls: function Map$_valid_displayMapTypeControls(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            enableMultipleCallouts: function Map$_valid_enableMultipleCallouts(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            locationData: function Map$_valid_locationData(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array')) {
                    flag = true;
                }

                return flag;
            },

            mapKey: function Map$_valid_mapKey(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            mapClientId: function Map$_valid_mapClientId(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            mapSource: function Map$_valid_mapSource(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            mode: function Map$_valid_mode(value) {
                var flag = false, options = [
                    constants.MAP_VIEW_MODE_HYBRID,
                    constants.MAP_VIEW_MODE_NORMAL,
                    constants.MAP_VIEW_MODE_SATELLITE,
                    constants.MAP_VIEW_MODE_POLYGON,
                    constants.MAP_VIEW_MODE_TERRAIN
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            navControlsImageConfig: function Map$_valid_navControlsImageConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')) {
                    flag = true;
                }

                return flag;
            },

            onBoundsChanged: function Map$_valid_onBoundsChanged(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function')) {
                    flag = true;
                }

                return flag;
            },

            onMapLoaded: function Map$_valid_onMapLoaded(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function')) {
                    flag = true;
                }

                return flag;
            },

            onPinClick: function Map$_valid_onPinClick(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function')) {
                    flag = true;
                }

                return flag;
            },

            onSelection: function Map$_valid_onSelection(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function')) {
                    flag = true;
                }

                return flag;
            },

            provider: function Map$_valid_provider(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            showZoomControl: function Map$_valid_showZoomControl(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            widgetDataMapForCallout: function Map$_valid_widgetDataMapForCallout(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')) {
                    flag = true;
                }

                return flag;
            },

            zoomLevel: function Map$_valid_zoomLevel(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        Map: {
            address: function Map$_view_locationData(/*el, old*/) {
                _setUpInteractiveCanvasMap.call(this);
            },

            autoCenterPinOnClick: true,

            calloutPostion: true,

            calloutTemplate:  true,

            calloutWidth: true,

            defaultPinImage: function Map$_view_defaultPinImage(/*el, old*/) {
                _setUpInteractiveCanvasMap.call(this);
            },

            displayMapTypeControls: true,

            enableMultipleCallouts: true,

            locationData: function Map$_view_locationData(/*el, old*/) {
                _setUpInteractiveCanvasMap.call(this);
            },

            mapKey: true,

            mapClientId: false,

            mapSource: false,

            mode: function Map$_view_mode(/*el,*/ old) {
                var _ = this._kwebfw_, mapMode = null;

                if(_.gmapoptions.polygonModePath) {
                    _.gmapoptions.polygonModePath.setMap(null);
                    _.gmapoptions.polygonModePath = null;
                }

                if(_.gmapoptions.loadedFlag) {
                    if(old === constants.MAP_VIEW_MODE_POLYGON
                    || _.prop.mode === constants.MAP_VIEW_MODE_POLYGON) {
                        _setUpInteractiveCanvasMap.call(this);
                    } else {
                        mapMode = _getMapMode(_.prop.mode);
                        _.gmapoptions.map.setMapTypeId(mapMode);
                    }
                }
            },

            navControlsImageConfig: true,

            onBoundsChanged: true,

            onMapLoaded: true,

            onPinClick: true,

            onSelection: true,

            provider: false,

            showZoomControl: function Map$_view_showZoomControl(/*el, old*/) {
                var _ = this._kwebfw_;

                if(_.gmapoptions.loadedFlag) {
                    _.gmapoptions.map.setOptions({zoomControl: _.prop.showZoomControl});
                }
            },

            widgetDataMapForCallout: true,

            zoomLevel: function Map$_view_zoomLevel(/*el, old*/) {
                var _ = this._kwebfw_;

                if(_.gmapoptions.loadedFlag) _.gmapoptions.map.setZoom(_.prop.zoomLevel);
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'Map', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Map constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Shanker Pulugam <shanker.pulugam@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        None
         *              -
         *              -
         */
        var Map = function Map(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    address: {},
                    autoCenterPinOnClick: false,
                    calloutPostion: 'top',
                    calloutTemplate: '',
                    calloutWidth: 80,
                    defaultPinImage: 'pinb.png',
                    displayMapTypeControls: true,
                    enableMultipleCallouts: false,
                    locationData: [],
                    mapKey: '',
                    mapClientId: '',
                    mapSource: '',
                    mode: constants.MAP_VIEW_MODE_NORMAL,
                    navControlsImageConfig: '',
                    onBoundsChanged: '',
                    onMapLoaded: '',
                    onPinClick: '',
                    onSelection: '',
                    provider: constants.MAP_PROVIDER_GOOGLE,
                    showZoomControl: true,
                    widgetDataMapForCallout: '',
                    zoomLevel: 15
                };
            }

            _populateUnderscore.Map.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name+$KU.uid());
            }

            Map.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Map, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Map.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to Map
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Map[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Map>, but not in <_valid.Map> namespace.');
                        } else {
                            valid = _valid.Map[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Map
                $KU.each(_view.Map, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Map$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Map[key], 'function')) {
                            return _getter.Map[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Map$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Map[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Map[key], 'function')) {
                                        _setter.Map[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Map().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Map().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    if($KU.is(p.navControlsImageConfig, undefined)) p.navControlsImageConfig = '';
                    if($KU.is(p.onBoundsChanged, undefined)) p.onBoundsChanged = '';
                    if($KU.is(p.onMapLoaded, undefined)) p.onMapLoaded = '';
                    if($KU.is(p.onPinClick, undefined)) p.onPinClick = '';
                    if($KU.is(p.onSelection, undefined)) p.onSelection = '';
                    if($KU.is(p.widgetDataMapForCallout, undefined)) p.widgetDataMapForCallout = '';
                    if($KU.is(p.address, undefined)) p.address = {};
                }

                if($KU.is(_postInitialization.Map, 'function')) {
                    _postInitialization.Map.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Map, voltmx.ui.BasicWidget);

        /**
         * Resets markers and  pinMarker to empty for voltmx.ui.Map widget.
         *
         * @override
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.Map
         * @author      Shanker Pulugam <shanker.pulugam@voltmx.com>
         *
         * @returns     void
         */
        var map__flush = function Map$_flush(/*tag*/) {
            var $super = voltmx.ui.Map.base.prototype,
                $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.each(this._kwebfw_.gmapoptions.markers, function(marker/*, index*/) {
                marker.setMap(null);
            }, this);

            this._kwebfw_.gmapoptions.markers = [];
            this._kwebfw_.gmapoptions.pinMarkers = {};
            this._kwebfw_.gmapoptions.map = null;

            $super._flush.call(this);
        };


        /**
         * Builds the view layer for voltmx.ui.Map widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Map
         * @author      Shanker Pulugam <shanker.pulugam@voltmx.com>
         *
         * @returns     {HTMLElement}  Map view.
         */
        var map__render = function Map$_render(tag) {
            var $super = voltmx.ui.Map.base.prototype, _ = this._kwebfw_, el = null,
                $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, view = _.view;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, tag);
                    el = $KW.el(view);
                    $KD.setAttr(el.node, 'kwh-click', 'onMapClick');

                    _loadMapScripts.call(this);
                }

                $KW.accessibility(this);
                _.gmapoptions.loadedFlag = false;
            }

            return view;
        };


        var map_dismissCallout = function Map$dismissCallout(location) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, pinId = null,
                ginfobox = this._kwebfw_.gmapoptions.infobox;

            if(!this._kwebfw_.prop.enableMultipleCallouts) {
                /*if(!$KU.is(infobox, 'null')) infobox.close();*/
                if(!$KU.is(ginfobox, 'null')) ginfobox.close();
            } else if(location) {
                if(location instanceof Array) {
                    pinId = location[0].id;
                } else {
                    pinId = location.id;
                }
                _pinInfoWindowClose.call(this, pinId);
            }
        };


        var map_addPin = function Map$addPin(pindata) {
            _setPins.call(this, [pindata]);
        };


        var map_addPins = function Map$addPins(pindataArr) {
            _setPins.call(this, pindataArr);
        };


        var map_updatePin = function Map$updatePin(pindata) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, existingPindata = null,
                existingPindataObj = _getPinAndIndexFromLocationData.call(this, pindata.id);

            if(!$KU.is(existingPindataObj, 'null')) {
                existingPindata = existingPindataObj.data;
                map_removePin.call(this, pindata, false);
                $KU.each(pindata, function(value, key) {
                    existingPindata[key] = value;
                });
                this._kwebfw_.prop.locationData[existingPindataObj.index] = existingPindata;
                _createMarkersForLocations.call(this, [existingPindata]);
            }
        };


        var map_updatePins = function Map$updatePins(pindataArr) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.each(pindataArr, function(pindata/*, index*/) {
                map_updatePin.call(this, pindata);
            }, this);
        };


        var map_removePin = function Map$removePin(pindata, delLocDataFlag) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, existingPindataObj = null,
                marker = this._kwebfw_.gmapoptions.pinMarkers[pindata.id];

            if(!$KU.is(marker, 'undefined')) {
                marker.setMap(null);
                delLocDataFlag = ($KU.is(delLocDataFlag, 'undefined')) ? true : delLocDataFlag;
                if(delLocDataFlag) {
                    existingPindataObj = _getPinAndIndexFromLocationData.call(this, pindata.id);
                    if(!$KU.is(existingPindataObj, 'null')) {
                        this._kwebfw_.prop.locationData.splice(existingPindataObj.index, 1);
                    }
                }
                delete this._kwebfw_.gmapoptions.pinMarkers[pindata.id];
            }
        };


        var map_removePins = function Map$removePins(pindataArr) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.each(pindataArr, function(pindata/*, index*/) {
                map_removePin.call(this, pindata, true);
            }, this);
        };


        var map_addPolygon = function Map$addPolygon(polydata) {
            map_removePolygon.call(this, polydata.id);
            this._kwebfw_.gmapoptions.polygonData[polydata.id] = polydata;
            _drawPolygon.call(this, polydata);
        };


        var map_addCircle = function Map$addCircle(circledata) {
            map_removeCircle.call(this, circledata.id);
            this._kwebfw_.gmapoptions.circleData[circledata.id] = circledata;
            _drawCircle.call(this, circledata);
        };


        var map_addPolyline = function Map$addPolyline(polylinedata) {
            if(this._kwebfw_.gmapoptions.polylineData[polylinedata.id]) {
                map_removePolyline.call(this, polylinedata.id);
            }
            this._kwebfw_.gmapoptions.polylineData[polylinedata.id] = polylinedata;
            _drawPolyline.call(this, polylinedata);
        };


        var map_removePolygon = function Map$removePolygon(polygonID) {
            _removeShape.call(this, 'polygon', polygonID);
        };


        var map_removeCircle = function Map$removeCircle(circleID) {
            _removeShape.call(this, 'circle', circleID);
        };


        var map_removePolyline = function Map$removePolyline(polylineID) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, pindata = [],
                polylinedata = this._kwebfw_.gmapoptions.polylineData[polylineID];

            if(!$KU.is(polylinedata, 'undefined')) {
                pindata = _getPolylinePinData.call(this, polylinedata);
                if(pindata.length > 0) {
                    _createMarkersForLocations.call(this, pindata);
                }
                if(pindata.length > 0) {
                    map_removePins.call(this, pindata, false);
                }
                _removeShape.call(this, 'polyline', polylineID);
            }
        };


        var map_setCalloutVisibility = function Map$setCalloutVisibility(visibilityFlag, pindataArr) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            if(!this._kwebfw_.prop.enableMultipleCallouts)
                return;

            $KU.each(pindataArr, function(pindata/*, index*/) {
                var marker = null;

                if(visibilityFlag) {
                    marker = this._kwebfw_.gmapoptions.pinMarkers[pindata.id];
                    marker && google.maps.event.trigger(marker, 'click');
                } else {
                    _pinInfoWindowClose.call(this, pindata.id);
                }
            }, this);
        };


        var map_clear = function Map$clear() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.each(this._kwebfw_.gmapoptions.circleDataMap, function(circleData, circleId) {
                map_removeCircle.call(this, circleId);
            }, this);
            $KU.each(this._kwebfw_.gmapoptions.polygonDataMap, function(polygonData, polygonId) {
                map_removePolygon.call(this, polygonId);
            }, this);
            $KU.each(this._kwebfw_.gmapoptions.polylineDataMap, function(polylinenData, polylineId) {
                map_removePolyline.call(this, polylineId);
            }, this);

            $KU.each(this._kwebfw_.gmapoptions.markers, function(marker/*, index*/) {
                marker.setMap(null);
            });

            _pinInfoWindowCloseAll.call(this);

            this._kwebfw_.gmapoptions.markers = [];
            this._kwebfw_.gmapoptions.pinMarkers = {};
            this._kwebfw_.prop.locationData = [];
        };


        var map_navigateTo = function Map$navigateTo(index, showcallout) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget,
                mapdata = this._kwebfw_.prop.locationData;

            index = parseInt(index);

            if(index < 1 || index >= mapdata.length) {
                return;
            }

            if(!this._kwebfw_.gmapoptions.navigateToArgs) {
                this._kwebfw_.gmapoptions.navigateToArgs = {
                    'index': index,
                    'showCallout': showcallout
                };
            }

            if($KW.visible(this)) _navigateTo.call(this);
        };


        var map_navigateToLocation = function Map$navigateToLocation(locationData, showcallout, dropPin) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_;

            if(!_.gmapoptions.navigateToLocationArgs) {
                _.gmapoptions.navigateToLocationArgs = {
                    'navLocationData': locationData,
                    'showCallout': showcallout,
                    'dropPin': dropPin
                };
            }

            if($KW.visible(this)) _navigateToLocation.call(this);
        };


        $K.defVoltmxProp(Map.prototype, [
            {keey:'_flush', value:map__flush},
            {keey:'_render', value:map__render},
            {keey:'addCircle', value:map_addCircle},
            {keey:'addPin', value:map_addPin},
            {keey:'addPins', value:map_addPins},
            {keey:'addPolygon', value:map_addPolygon},
            {keey:'addPolyline', value:map_addPolyline},
            {keey:'clear', value:map_clear},
            {keey:'dismissCallout', value:map_dismissCallout},
            {keey:'navigateTo', value:map_navigateTo},
            {keey:'navigateToLocation', value:map_navigateToLocation},
            {keey:'removeCircle', value:map_removeCircle},
            {keey:'removePin', value:map_removePin},
            {keey:'removePins', value:map_removePins},
            {keey:'removePolygon', value:map_removePolygon},
            {keey:'removePolyline', value:map_removePolyline},
            {keey:'setCalloutVisibility', value:map_setCalloutVisibility},
            {keey:'updatePin', value:map_updatePin},
            {keey:'updatePins', value:map_updatePins}
        ]);

        return Map;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxradiobuttongroup.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'RadioButtonGroup', value:{}, items:[
            {keey:'onChange', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    _ = this._kwebfw_, prop = _.prop, payload = null;

                if(evt.target.tagName === 'INPUT'
                && $KD.getAttr(evt.target, 'type', 'radio')) {
                    payload = {checked:evt.target.checked, key:evt.target.value};

                    prop.selectedKey = payload.key;
                    prop.selectedKeyValue = $KW.getGroupSelectedKeyValueByKey(this, payload.key);

                    $KW.onPropertyChange(this, 'selectedKey');
                    $K.apm.send(this, 'Touch', {type:(this._kwebfw_.name+'_Selection')});
                    $KW.fire(this, 'onSelection', this);
                }

                return false;
            }},

            {keey:'onKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, radiobutton = null,
                    code = evt.keyCode || evt.which;

                if([39, 40].indexOf(code) >= 0) {
                    radiobutton = $KD.first(evt.target);

                    if(radiobutton) {
                        $KD.preventDefault(evt);

                        radiobutton = $KD.first(radiobutton);
                        $KD.removeAttr(radiobutton, 'tabindex');
                        $KD.focus(radiobutton);
                    }
                }

                return false;
            }},

            {keey:'onRadioButtonBlur', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget;

                $KD.setAttr(evt.target, 'tabindex', -1);
                $KW.fire(this, 'onBlur', this);
                return false;
            }},

            {keey:'onRadioButtonFocus', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, tabindex = $KW.tabIndex(this);

                if($KU.is(tabindex, 'integer') && tabindex >= 0) {
                    $KD.removeAttr(evt.target, 'tabindex');
                } else {
                    $KD.blur(evt.target);
                }

                $KW.fire(this, 'onFocus', this);
                return false;
            }},

            {keey:'onRadioButtonKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    radio = null, code = evt.keyCode || evt.which;

                if([37, 38, 39, 40].indexOf(code) >= 0) {
                    radio = $KD.parent(evt.target);

                    if([37, 38].indexOf(code) >= 0) {
                        radio = $KD.prev(radio);
                    } else if([39, 40].indexOf(code) >= 0) {
                        radio = $KD.next(radio);
                    }

                    if(radio) {
                        $KD.preventDefault(evt);

                        radio = $KD.first(radio);
                        $KD.focus(radio);
                    }
                }

                return false;
            }},

            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                    tabindex = '', radios = $KD.find(dom, 'input[type="radio"]');

                if($KW.disabled(this)) {
                    $KD.setAttr(dom, 'aria-disabled', 'true');
                    $KD.removeAttr(dom, 'tabindex');

                    $KU.each(radios, function(radio) {
                        radio.disabled = true;
                    });
                } else if(!$KW.interactable(this)) {
                    $KD.removeAttr(dom, 'tabindex');

                    $KU.each(radios, function(radio) {
                        var $K = voltmx.$kwebfw$, $KD = $K.dom,
                            parent = $KD.parent(radio),
                            modal = $KD.create('DIV');

                        $KD.removeAttr(radio, 'tabindex');

                        $KD.style(parent, {
                            position:'relative',
                            top:'0px', left:'0px'
                        });

                        $KD.style(modal, {
                            position:'absolute',
                            top:'0px', left:'0px',
                            height:'100%', width:'100%'
                        });

                        $KD.add(parent, modal);
                    });
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(dom, 'aria-disabled');

                    $KU.each(radios, function(radio) {
                        var $K = voltmx.$kwebfw$, $KD = $K.dom,
                            parent = $KD.parent(radio),
                            modal = $KD.last(parent);

                        radio.disabled = false;

                        $KD.style(parent, {
                            position:null,
                            top:null, left:null
                        });

                        if(modal && modal.tagName === 'DIV') {
                            $KD.remove(modal);
                        }
                    });

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        $KD.removeAttr(dom, 'tabindex');
                    }
                }
            }}
        ]}
    ]);


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {
        RadioButtonGroup: function RadioButtonGroup$_dependentPropertiesValidationMessage(prop, bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, message = '', keys = [],
                masterData = (pspconfig && pspconfig.masterData) || bconfig.masterData,
                masterDataMap = (pspconfig && pspconfig.masterDataMap) || bconfig.masterDataMap,
                selectedKey = (pspconfig && pspconfig.selectedKey) || bconfig.selectedKey;

            masterData = ($KU.is(masterData, 'null') || $KU.is(masterData, 'array')) ? masterData : prop.masterData;
            masterDataMap = ($KU.is(masterDataMap, 'null') || $KU.is(masterDataMap, 'array')) ? masterDataMap : prop.masterDataMap;
            selectedKey = ($KU.is(selectedKey, 'null') || $KU.is(selectedKey, 'string')) ? selectedKey : prop.selectedKey;

            if($KU.is(selectedKey, 'string') && (masterData || masterDataMap)) {
                $KU.each((masterData || masterDataMap), function(data) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    keys.push(($KU.is(data, 'array')) ? data[0] : data[masterDataMap[1]]);
                });

                if($KU.is(selectedKey, 'string')
                && keys.indexOf(selectedKey) === -1) {
                    message += 'Invalid selectedKey <'+selectedKey+'>.';
                }
            }

            return message;
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        RadioButtonGroup: {
            masterData: function RadioButtonGroup$_getter_masterData(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, data = null;

                if(value) {
                    data = [];

                    $KU.each(value, function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            val = [item[0], item[1]];

                        if($KU.is(item[2], 'object')) {
                            val.push($KW.getAccessibilityConfig(item[2]));
                        }

                        if($KU.is(val[1], 'i18n')) {
                            val[1] = $KU.getI18Nvalue(val[1]);
                        }

                        data.push(val);
                    });
                }

                return data;
            },

            masterDataMap: function RadioButtonGroup$_getter_masterDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    data = null, keyName = '', valName = '';

                if(value) {
                    data = [];
                    keyName = value[1];
                    valName = value[2];

                    $KU.each(value[0], function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, val = {};

                        val[keyName] = item[keyName];
                        val[valName] = item[valName];

                        if($KU.is(item.accessibilityConfig, 'object')) {
                            val.accessibilityConfig = $KW.getAccessibilityConfig(item.accessibilityConfig);
                        }

                        if($KU.is(val[valName], 'string')
                        && val[valName].toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') !== -1) {
                            val[valName] = $KU.getI18Nvalue(val[valName]);
                        }

                        data.push(val);
                    });
                }

                return [data, keyName, valName];
            },

            selectedKeyValue: function RadioButtonGroup$_getter_selectedKeyValue(value) {
                return (value) ? value.slice(0) : null;
            },

            toolTip: function RadioButtonGroup$_getter_toolTip() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, toolTip = prop.toolTip;

                if(prop.i18n_toolTip) {
                    toolTip = $KU.getI18Nvalue(prop.i18n_toolTip);
                }

                return toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        RadioButtonGroup: function RadioButtonGroup$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.RadioButtonGroup', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'RadioButtonGroup', null);
                }
            }

            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        RadioButtonGroup: function RadioButtonGroup$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                _ = this._kwebfw_, prop = _.prop;

            $KW.normalizeGroupMasterData(this);

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'slRadioButtonGroup';
            }

            if($KU.is(prop.padding, 'null')) {
                prop.padding = [0, 0, 0, 0];
            }

            if(prop.i18n_toolTip) {
                prop.toolTip = prop.i18n_toolTip;
            }

            _setter[_.name].selectedKey.call(this, prop.selectedKey);
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        RadioButtonGroup: function RadioButtonGroup$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        RadioButtonGroup: function RadioButtonGroup$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //This functions will be called in the scope of widget instance
    var _renderRadioButtonGroup = function RadioButtonGroup$_renderRadioButtonGroup(holder) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            $KW = $K.widget, _ = this._kwebfw_, prop = _.prop,
            masterdata = this.masterData;

        if(!masterdata && prop.masterDataMap) {
            masterdata = this.masterDataMap[0];
        }

        $KD.html(holder, '');

        $KU.each(masterdata, function(data) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                $KD = $K.dom, div = $KD.create('DIV', {kr:'option'}), key = '', val = '',
                _ = this._kwebfw_, prop = _.prop, input = null, txt = null, a11y = null;

            key = ($KU.is(data, 'array')) ? data[0] : data[prop.masterDataMap[1]];
            val = ($KU.is(data, 'array')) ? data[1] : data[prop.masterDataMap[2]];
            a11y = ($KU.is(data, 'array')) ? data[2] : data['accessibilityConfig'];

            txt = document.createTextNode(($KU.is(val, 'i18n') ? $KU.getI18Nvalue(val) : val));
            input = $KD.create('INPUT', {type:'radio', name:this._kwebfw_.uid, value:key, tabindex:-1});

            $KD.setAttr(input, 'kwh-focusin', 'onRadioButtonFocus');
            $KD.setAttr(input, 'kwh-focusout', 'onRadioButtonBlur');
            $KD.setAttr(input, 'kwh-keydown', 'onRadioButtonKeyDown');

            $KW.applyGroupA11Y(input, a11y, val, (_.uid+'_'+key+'_hint'));

            if(prop.itemOrientation === constants.RADIOGROUP_ITEM_ORIENTATION_VERTICAL) {
                $KD.setAttr(holder, 'ko', 'vertical');
            } else if(prop.itemOrientation === constants.RADIOGROUP_ITEM_ORIENTATION_HORIZONTAL) {
                $KD.setAttr(holder, 'ko', 'horizontal');
            }

            $KD.add(div, input);
            $KD.add(div, txt);
            $KW.addToView(holder, div);
        }, this);

        $KW.accessibility(this);
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        RadioButtonGroup: {
            masterData: function RadioButtonGroup$_setter_masterData(old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = this._kwebfw_.prop;

                prop.selectedKey = null;
                prop.selectedKeyValue = null;
                $KW.clearGroupA11y(this, old, prop.masterDataMap);
            },

            masterDataMap: function RadioButtonGroup$_setter_masterDataMap(old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = this._kwebfw_.prop;

                if(!prop.masterData) {
                    prop.selectedKey = null;
                    prop.selectedKeyValue = null;
                }

                $KW.clearGroupA11y(this, prop.masterData, old);
            },

            selectedKey: function RadioButtonGroup$_setter_selectedKey(/* old */) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, prop = this._kwebfw_.prop;

                prop.selectedKeyValue = $KW.getGroupSelectedKeyValueByKey(this, prop.selectedKey);
            },

            toolTip: function RadioButtonGroup$_setter_toolTip(/* old */) {
                this._kwebfw_.prop.i18n_toolTip = '';
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        RadioButtonGroup: {
            itemOrientation: function RadioButtonGroup$_valid_itemOrientation(value) {
                var options = [
                        constants.RADIOGROUP_ITEM_ORIENTATION_HORIZONTAL,
                        constants.RADIOGROUP_ITEM_ORIENTATION_VERTICAL
                    ], flag = (options.indexOf(value) >= 0);

                return flag;
            },

            i18n_toolTip: function RadioButtonGroup$_valid_i18n_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            masterData: function RadioButtonGroup$_valid_masterData(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;

                    $KU.each(value, function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if(!$KU.is(item, 'array')) {
                            flag = false;
                            return true;
                        }
                    });
                }

                return flag;
            },

            masterDataMap: function RadioButtonGroup$_valid_masterDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value[0], 'array')
                && $KU.is(value[1], 'string') && value[1]
                && value[2] && $KU.is(value[2], 'string')) {
                    flag = true;

                    $KU.each(value[0], function(item) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if(!$KU.is(item, 'object')) {
                            flag = false;
                            return true;
                        }
                    });
                }

                return flag;
            },

            selectedKey: function RadioButtonGroup$_valid_selectedKey(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
                    prop = this._kwebfw_.prop, keys = [];

                if($KU.is(value, 'string') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(flag && $KU.is(value, 'string')) {
                    if(prop.masterData || prop.masterDataMap) {
                        $KU.each((prop.masterData || prop.masterDataMap[0]), function(data) {
                            var $K = voltmx.$kwebfw$, $KU = $K.utils;

                            keys.push(($KU.is(data, 'array')) ? data[0] : data[prop.masterDataMap[1]]);
                        });

                        if(keys.indexOf(value) === -1) {
                            flag = false;
                        }
                    }
                }

                return flag;
            },

            selectedKeyValue: function RadioButtonGroup$_valid_selectedKeyValue(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            toolTip: function RadioButtonGroup$_valid_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        RadioButtonGroup: {
            itemOrientation: false,

            i18n_toolTip: false,

            masterData: function RadioButtonGroup$_view_masterData(el/* , old */) {
                var $K=voltmx.$kwebfw$, $KW = $K.widget;

                $KW.normalizeGroupMasterData(this);
                _renderRadioButtonGroup.call(this, el.node);
            },

            masterDataMap: function RadioButtonGroup$_view_masterDataMap(el/* , old */) {
                var $K=voltmx.$kwebfw$, $KW = $K.widget;

                $KW.normalizeGroupMasterDataMap(this);
                _renderRadioButtonGroup.call(this, el.node);
            },

            selectedKey: function RadioButtonGroup$_view_selectedKey(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                $KU.each($KD.find(el.node, 'input'), function(radio) {
                    radio.checked = (this.selectedKey === radio.value);
                }, this);
            },

            selectedKeyValue: false,

            toolTip: function RadioButtonGroup$_view_toolTip(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.toolTip) {
                    $KD.setAttr(el.node, 'title', this.toolTip);
                } else {
                    $KD.removeAttr(el.node, 'title');
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'RadioButtonGroup', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.RadioButtonGroup constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var RadioButtonGroup = function RadioButtonGroup(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    itemOrientation: constants.RADIOGROUP_ITEM_ORIENTATION_VERTICAL,
                    i18n_toolTip: '',
                    masterData: null,
                    masterDataMap: null,
                    selectedKey: null,
                    selectedKeyValue: null,
                    toolTip: ''
                };
            }

            _populateUnderscore.RadioButtonGroup.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            RadioButtonGroup.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.RadioButtonGroup, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.RadioButtonGroup.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to RadioButtonGroup
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.RadioButtonGroup[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.RadioButtonGroup>, but not in <_valid.RadioButtonGroup> namespace.');
                        } else {
                            valid = _valid.RadioButtonGroup[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to RadioButtonGroup
                $KU.each(_view.RadioButtonGroup, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function RadioButtonGroup$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.RadioButtonGroup[key], 'function')) {
                            return _getter.RadioButtonGroup[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function RadioButtonGroup$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.RadioButtonGroup[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.RadioButtonGroup[key], 'function')) {
                                        _setter.RadioButtonGroup[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.RadioButtonGroup().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.RadioButtonGroup().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });


                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    p.masterDataMap = null;
                }

                if($KU.is(_postInitialization.RadioButtonGroup, 'function')) {
                    _postInitialization.RadioButtonGroup.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(RadioButtonGroup, voltmx.ui.GroupWidget);


        /**
         * Builds the view layer for voltmx.ui.RadioButtonGroup widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.RadioButtonGroup
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  SampleWidget view.
         */
        var radiobuttongroup__render = function RadioButtonGroup$_render(tag) {
            var $super = voltmx.ui.RadioButtonGroup.base.prototype,
                _ = this._kwebfw_, view = _.view, $K = voltmx.$kwebfw$,
                $KW = $K.widget, $KD = $K.dom, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, tag);

                    $KD.setAttr(view, 'kwh-change', 'onChange');
                    $KD.setAttr(view, 'kwh-keydown', 'onKeyDown');
                }

                el = $KW.el(view);

                _renderRadioButtonGroup.call(this, view);
                _view.RadioButtonGroup.selectedKey.call(this, el, this._kwebfw_.prop.selectedKey);
                _view.RadioButtonGroup.toolTip.call(this, el, this.toolTip);
            }

            return view;
        };


        $K.defVoltmxProp(RadioButtonGroup.prototype, [
            {keey:'_render', value:radiobuttongroup__render}
        ]);


        return RadioButtonGroup;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxrichtext.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'RichText', value:{}, items:[
            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, tabindex = '';

                if($KW.disabled(this)) {
                    $KD.setAttr(dom, 'aria-disabled', true);
                    $KD.removeAttr(dom, 'tabindex');
                    $KW.toggleChildren(this);
                } else if(!$KW.interactable(this)) {
                    $KD.removeAttr(dom, 'tabindex');
                    $KW.toggleChildren(this);
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(dom, 'aria-disabled');

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        $KD.removeAttr(dom, 'tabindex');
                    }

                    $KW.toggleChildren(this);
                }
            }}
        ]}
    ]);


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        RichText: {
            text: function RichText$_getter_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if(prop.i18n_text) {
                    value = $KU.getI18Nvalue(prop.i18n_text);
                }

                return value;
            },

            toolTip: function RichText$_getter_toolTip() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, toolTip = prop.toolTip;

                if(prop.i18n_toolTip) {
                    toolTip = $KU.getI18Nvalue(prop.i18n_toolTip);
                }

                return toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        RichText: function RichText$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.RichText', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'RichText', null);
                }
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        RichText: function RichText$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = this._kwebfw_, prop = _.prop;

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'defRichTextNormal';
            }

            if($KU.is(prop.padding, 'null')) {
                prop.padding = [0, 0, 0, 0];
            }

            if(prop.i18n_text) {
                prop.text = prop.i18n_text;
            }

            if(prop.i18n_toolTip) {
                prop.toolTip = prop.i18n_toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        RichText: function RichText$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        RichText: function RichText$_relayoutPassiveTriggerer() {
            return ['text'];
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        RichText: {
            text: function RichText$_setter_text(/*old*/) {
                this._kwebfw_.prop.i18n_text = '';
            },

            toolTip: function RichText$_setter_toolTip(/*old*/) {
                this._kwebfw_.prop.i18n_toolTip = '';
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        RichText: {
            i18n_text: function RichText$_valid_i18n_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            i18n_toolTip: function RichText$_valid_i18n_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            linkFocusSkin: function RichText$_valid_linkFocusSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            linkSkin: function RichText$_valid_linkSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            text: function RichText$_valid_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    flag = ['', true];
                }

                return flag;
            },

            toolTip: function RichText$_valid_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        RichText: {
            i18n_text: false,

            i18n_toolTip: false,

            linkFocusSkin: function RichText$_view_linkFocusSkin(el, old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    prop = this._kwebfw_.prop;

                if(this.linkFocusSkin) {
                    $KW.removeSkin(old + '-linkfocus', el.node);
                    $KW.addSkin(prop.linkFocusSkin + '-linkfocus', el.node);
                } else {
                    $KW.removeSkin(old + '-linkfocus', el.node);
                }
            },

            linkSkin: function RichText$_view_linkSkin(el, old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    prop = this._kwebfw_.prop;

                if(this.linkSkin) {
                    $KW.removeSkin(old + '-link', el.node);
                    $KW.addSkin(prop.linkSkin + '-link', el.node);
                } else {
                    $KW.removeSkin(old + '-link', el.node);
                }
            },

            text: function RichText$_view_text(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;
                let value = "<div>" + this.text + "</div>";

                $KD.html(el.node, value);
            },

            toolTip: function RichText$_view_toolTip(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.toolTip) {
                    $KD.setAttr(el.node, 'title', this.toolTip);
                } else {
                    $KD.removeAttr(el.node, 'title');
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'RichText', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.RichText constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Maruthi Doradla <maruthi.doradala@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var RichText = function RichText(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    i18n_text: '',
                    i18n_toolTip: '',
                    linkFocusSkin: 'defRichTextNormal',
                    linkSkin: 'defRichTextLink',
                    text: '',
                    toolTip: ''
                };
            }

            _populateUnderscore.RichText.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            RichText.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.RichText, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.RichText.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to RichText
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.RichText[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.RichText>, but not in <_valid.RichText> namespace.');
                        } else {
                            valid = _valid.RichText[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to RichText
                $KU.each(_view.RichText, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function RichText$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.RichText[key], 'function')) {
                            return _getter.RichText[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function RichText$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.RichText[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.RichText[key], 'function')) {
                                        _setter.RichText[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.RichText().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.RichText().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.RichText, 'function')) {
                    _postInitialization.RichText.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(RichText, voltmx.ui.BasicWidget);


        /**
         * Builds the view layer for voltmx.ui.RichText widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.RichText
         * @author      Maruthi Doradla <maruthi.doradala@voltmx.com>
         *
         * @returns     {HTMLElement}  RichText view.
         */
        var richtext__render = function RichText$_render(tag) {
            var $super = voltmx.ui.RichText.base.prototype,
                $K = voltmx.$kwebfw$, $KW = $K.widget,
                _ = this._kwebfw_, view = _.view, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, tag);
                    el = $KW.el(view);

                    _view.RichText.text.call(this, el, this.text);
                    _view.RichText.linkSkin.call(this, el, this.linkSkin);
                    _view.RichText.linkFocusSkin.call(this, el, this.linkFocusSkin);
                }

                _view.RichText.toolTip.call(this, el, this.toolTip);

                $KW.accessibility(this);
            }

            return view;
        };


        $K.defVoltmxProp(RichText.prototype, [
            {keey:'_render', value:richtext__render}
        ]);


        return RichText;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxsegment.js' */
(function() {
    var $K = voltmx.$kwebfw$, _frameworkHeaderTemplate = null;


    $K.defVoltmxProp($K.ui, [
        {keey:'SegmentedUI2', value:{}, items:[
            {keey:'onKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    model = this._kwebfw_.rows[0],
                    code = evt.keyCode || evt.which;

                if(model && model._kwebfw_.view) {
                    if([40].indexOf(code) >= 0) {
                        $KD.preventDefault(evt);

                        if(code === 40) { //Down Arrow
                            $KD.focus($KD.parent(model._kwebfw_.view));
                        }
                    }
                }

                return false;
            }},

            {keey:'doLayout', value:function(/*frame*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    prop = this._kwebfw_.prop, el = $KW.el(this);

                if(prop.viewType === constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
                    _view.SegmentedUI2.data.call(this, el, prop.data);
                } else if(prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW
                        && _shouldLazyLoad.call(this)) {
                    if(prop.frame.height > 0 && this._kwebfw_.height !== prop.frame.height) {//this._kwebfw_.height stores prev segment height to prevent from re-render if height doesnt change
                        _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(this);
                    }

                    this._kwebfw_.height = prop.frame.height;
                }
            }},

            {keey:'onRowClick', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    index = null, secIndex = -1, rowIndex = -1;

                index = $KD.closest(evt.target, 'kr', 'item');

                if(index) {
                    index = $KD.getAttr(index, 'kii').split(',');
                    secIndex = parseInt(index[0], 10);
                    rowIndex = parseInt(index[1], 10);

                    $K.apm.send(this, 'Touch', {type:(this._kwebfw_.name+'_Row_Click')});
                    $KW.fire(this, 'onRowClick', this, {secIndex:secIndex, rowIndex:rowIndex});
                }

                return false;
            }},

            {keey:'onRowKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, li = null,
                    code = evt.keyCode || evt.which;

                if([38, 40].indexOf(code) >= 0) {
                    if(code === 38) { //Up Arrow
                        li = $KD.prev(evt.target);
                    } else if(code === 40) { //Down Arrow
                        li = $KD.next(evt.target);
                    }

                    if(li) {
                        $KD.preventDefault(evt);
                        $KD.focus(li);
                    }
                }

                return false;
            }},

            {keey:'onRowKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    code = evt.keyCode || evt.which, secIndex = -1, rowIndex = -1, li = null;

                if([13, 32].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 13 || code === 32) { //Enter or Space
                        li = $KD.closest(evt.target, 'kr', 'item');
                        rowIndex = $KD.getAttr(li, 'kii').split(',');
                        secIndex = parseInt(rowIndex[0], 10);
                        rowIndex = parseInt(rowIndex[1], 10);
                        $K.apm.send(this, 'Touch', {type:(this._kwebfw_.name+'_Row_Click')});
                        $KW.fire(this, 'onRowClick', this, {secIndex:secIndex, rowIndex:rowIndex});
                    }
                }

                return false;
            }}
        ]}
    ]);


    //All the functions will be called in the scope of widget instance
    //Segment APIs actions - add, update and remove will be called
    var _action = {
        SegmentedUI2: {
            _remove: function SegmentedUI2$_action_remove(secIndex, rowIndex) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    el = $KW.el(this), _ = this._kwebfw_, $KU = $K.utils,
                    data = _.prop.data, section = _isSectionDS(data[0]), absIndex = null,
                    isRowRendered = _isRowRendered.call(this, secIndex, rowIndex),
                    removeSelectedIndex = -1;

                if(section) data[secIndex][1].splice(rowIndex, 1);
                else data.splice(rowIndex, 1);

                if(_.selectedRows.length > 0) {
                    $KU.each(_.selectedRows, function(row, index) {
                        if(row[0] === secIndex && row[1] > rowIndex) {
                            row[1] = row[1] - 1;
                        } else if(row[0] === secIndex && row[1] === rowIndex) {
                            removeSelectedIndex = index;
                        }
                    });
                    if(removeSelectedIndex !== -1) {
                        _.selectedRows.splice(removeSelectedIndex, 1);
                    }
                    _setSelectedRowsRelatedProperties.call(this);
                }
                if(el.node) {
                    if(section) {
                        _flushClones(_.clones[secIndex][1][rowIndex]);
                        _.clones[secIndex][1].splice(rowIndex, 1);
                    } else {
                        _flushClones(_.clones[rowIndex]);
                        _.clones.splice(rowIndex, 1);
                    }

                    if(_shouldLazyLoad.call(this)) {
                        _lazyLoad.SegmentedUI2._action._removeAt.call(this, secIndex, rowIndex);
                    } else {
                        absIndex = _absoluteIndexInClones.call(this, secIndex, rowIndex);
                        if(isRowRendered) {
                            _.rows.splice(absIndex, 1);
                            $KD.removeAt(el.scrolee, absIndex);
                        }
                        if(section) _searcher.SegmentedUI2.removeAtHeaderVisibility.call(this, secIndex);
                        _updateIndexes.call(this, rowIndex, secIndex);
                    }
                    if(_.swipeContext) {
                        if(_.swipeContext.currentPage === 0) {
                            _.swipeContext = null;
                        } else if(rowIndex <= _.swipeContext.currentPage) {
                            _.swipeContext.currentPage = _.swipeContext.currentPage - 1;
                        } else {
                            _.swipeContext.currentPage = _.swipeContext.currentPage + 1;
                        }
                    }
                }
            },

            _removeAll: function SegmentedUI2$_action_removeAll() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    el = null, _ = this._kwebfw_;

                _.prop.data = [];
                _.rows = [];
                _flushClones(_.clones);
                _.clones = [];
                _clearSelectedIndices.call(this);
                $KW.markRelayout(this);

                if(_.view) {
                    el = $KW.el(this);
                    $KD.html(el.scrolee, '');
                    _updateAriaRowCount.call(this, 0, el);

                    if(_.prop.viewType === constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
                        _setPageView.call(this, el);
                    }

                    if(_shouldLazyLoad.call(this)) {
                        _lazyLoad.SegmentedUI2._resetParity.call(this, el);
                    }
                }
            },

            _removeSectionAt: function SegmentedUI2$_action_removeSectionAt(secIndex, rowIndex, updateIndicesFlag) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    $KU =$K.utils, _ = this._kwebfw_, data = _.prop.data,
                    clones = null, el = $KW.el(this), index = 0, removeSelectedSectionIndices = [],
                    absIndex = null;

                if(!$KU.is(updateIndicesFlag, 'boolean')) updateIndicesFlag = true;
                data.splice(secIndex, 1);

                if(updateIndicesFlag && _.selectedRows.length > 0) {
                    $KU.each(_.selectedRows, function(row, index) {
                        if(row[0] > secIndex) {
                            row[0] = row[0] - 1;
                        } else if(row[0] === secIndex) {
                            removeSelectedSectionIndices.push(index);
                        }
                    });

                    for(index = removeSelectedSectionIndices.length - 1; index >= 0; index--) {
                        _.selectedRows.splice(removeSelectedSectionIndices[index], 1);
                    }

                    _setSelectedRowsRelatedProperties.call(this);
                }

                if(el.node) {
                    clones = _.clones[secIndex];
                    _flushClones([_.clones[secIndex]]);
                    _.clones.splice(secIndex, 1);

                    if(_shouldLazyLoad.call(this)) {
                        _lazyLoad.SegmentedUI2._action._removeSectionAt.call(this, secIndex, rowIndex);
                    } else {
                        absIndex = _absoluteIndexInClones.call(this, secIndex, rowIndex);
                        //header node removal of given section index
                        if(clones[0] && clones[0].isVisible) {
                            $KD.removeAt(el.scrolee, absIndex);
                            _.rows.splice(absIndex, 1);
                        }

                        //row nodes removal of given section index
                        $KU.each(clones[1], function(clone) {
                            if(clone && clone.isVisible) {
                                $KD.removeAt(el.scrolee, absIndex);
                                _.rows.splice(absIndex, 1);
                            }
                        });
                        if(updateIndicesFlag) _updateIndexes.call(this, secIndex, -1);
                    }
                }
                if(_.swipeContext) _.swipeContext = null;
            },

            add: function SegmentedUI2$_action_add(secIndex, rowIndex, widgetdata, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, $KU = $K.utils,
                    clone = null, el = $KW.el(this), _ = this._kwebfw_,
                    data = _.prop.data, section = _isSectionDS(data[0]),
                    absIndex = null, rowNode = null;

                if(section) data[secIndex][1].splice(rowIndex, 0, widgetdata);
                else data.splice(rowIndex, 0, widgetdata);

                if(_.selectedRows.length > 0) {
                    $KU.each(_.selectedRows, function(row) {
                        if(row[0] === secIndex && row[1] >= rowIndex) {
                            row[1] = row[1] + 1;
                        }
                    });
                    _setSelectedRowsRelatedProperties.call(this);
                }
                if(el.node) {
                    if(section) _.clones[secIndex][1].splice(rowIndex, 0, undefined);
                    else _.clones.splice(rowIndex, 0, undefined);

                    if(_shouldLazyLoad.call(this)) {
                        _lazyLoad.SegmentedUI2._action._addDataAt.call(this, secIndex, rowIndex, widgetdata, anim);
                    } else {
                        absIndex = _absoluteIndexInClones.call(this, secIndex, rowIndex);
                        clone = _getClonedTemplate.call(this, [secIndex, rowIndex]);
                        if(clone) {
                            rowNode = _renderRows.call(this, [clone]);
                            if(absIndex === _.rows.length) {
                                _.rows.push(clone);
                                $KD.add(el.scrolee, rowNode);
                            } else {
                                _.rows.splice(absIndex, 0, clone);
                                $KD.addAt(el.scrolee, rowNode, absIndex);
                            }

                            if(secIndex === -1) secIndex = 0;
                            _searcher.SegmentedUI2.updateSearchText.call(this, [clone], section);

                            if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                                _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.ADD, [clone]);
                                _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'adddataat', rowNode, rowIndex, secIndex, anim);
                            }
                        }
                        _updateIndexes.call(this, rowIndex, secIndex);
                    }
                }
            },

            update: function SegmentedUI2$_action_update(secIndex, rowIndex, widgetdata, anim) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                    clone = null, el = $KW.el(this), _ = this._kwebfw_, rowNode = null,
                    data = _.prop.data, section = _isSectionDS(data[0]), absIndex = null,
                    isRowRendered = _isRowRendered.call(this, secIndex, rowIndex);


                if(section) data[secIndex][1][rowIndex] = widgetdata;
                else data[rowIndex] = widgetdata;

                if(_.selectedRows.length > 0) {
                    $KU.each(_.selectedRows, function(row, index) {
                        if(row[0] === secIndex && row[1] === rowIndex) {
                            _.selectedRows.splice(index, 1);
                            return true;
                        }
                    });
                    _setSelectedRowsRelatedProperties.call(this);
                }
                if(el.node) {
                    if(_shouldLazyLoad.call(this)) {
                        _lazyLoad.SegmentedUI2._action._setDataAt.call(this, secIndex, rowIndex, widgetdata, anim);
                    } else {
                        absIndex = _absoluteIndexInClones.call(this, secIndex, rowIndex);
                        clone = _getClonedTemplate.call(this, [secIndex, rowIndex]);

                        if(clone) {
                            rowNode = _renderRows.call(this, [clone]);
                            if(isRowRendered) {
                                _.rows[absIndex] = clone;
                                $KD.replace(rowNode, $KD.childAt(el.scrolee, absIndex));
                            } else {
                                if(absIndex === _.rows.length) {
                                    _.rows.push(clone);
                                    $KD.add(el.scrolee, rowNode);
                                } else {
                                    _.rows.splice(absIndex, 0, clone);
                                    $KD.addAt(el.scrolee, rowNode, absIndex);
                                }
                            }

                            if(secIndex === -1) secIndex = 0;
                            _searcher.SegmentedUI2.updateSearchText.call(this, [clone], section);

                            if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                                _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.UPDATE, [clone]);
                                _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'setdataat', rowNode, rowIndex, secIndex, anim);
                            }
                        } else if(isRowRendered && $KU.is(_.rows[absIndex], 'widget')) {
                            _.rows.splice(absIndex, 1);
                            $KD.removeAt(el.scrolee, absIndex);
                        }
                    }
                }
            },

            remove: function SegmentedUI2$_action_remove(secIndex, rowIndex, anim) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    _ = this._kwebfw_, absIndex = null, rowNode = null;
                if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                    if(_shouldLazyLoad.call(this)) {
                        absIndex = _lazyLoad.SegmentedUI2._absoluteIndexInRows.call(this, secIndex, rowIndex);
                    } else {
                        absIndex = _absoluteIndexInClones.call(this, secIndex, rowIndex);
                    }

                    if(absIndex !== -1) {
                        rowNode = $KD.parent(_.rows[absIndex]._kwebfw_.view);
                        _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.REMOVE, [_.rows[absIndex]]);
                        _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'removeat', rowNode, rowIndex, secIndex, anim);
                    }
                } else {
                    _action.SegmentedUI2._remove.call(this, secIndex, rowIndex);
                }
            },

            addall: function SegmentedUI2$_action_addall(secIndex, rowIndex, newdata, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    clones = null, el = $KW.el(this), _ = this._kwebfw_,
                    data = _.prop.data, rows = null, prevLength;

                data.push.apply(data, newdata);

                if(el.node) {
                    if(_shouldLazyLoad.call(this)) {
                        _lazyLoad.SegmentedUI2._action._addAll.call(this, el, [secIndex, rowIndex], anim);
                    } else {
                        clones = _getRenderableClones.call(this, [secIndex, rowIndex]);
                        if(clones.length > 0) {
                            prevLength = $KD.children(el.scrolee).length;
                            $KD.add(el.scrolee, _renderRows.call(this, clones));
                            _.rows.push.apply(_.rows, clones);

                            if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                                rows = [].slice.call($KD.children(el.scrolee), prevLength);
                                _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.ADD, clones);
                                _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'addall', rows, -1, -1, anim);
                            }
                        }
                        _searcher.SegmentedUI2.updateSearchText.call(this, clones, _isSectionDS(data[0]));
                    }
                }
            },

            addsectionat: function SegmentedUI2$_action_addsectionat(secIndex, rowIndex, newdata, updateIndicesFlag, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, $KU = $K.utils,
                    clones = null, el = $KW.el(this), _ = this._kwebfw_, data = _.prop.data,
                    absIndex = null, prevLength, rows = [], row = null;

                if(!$KU.is(updateIndicesFlag, 'boolean')) updateIndicesFlag = true;

                data.splice(secIndex, 0, newdata);

                if(updateIndicesFlag && _.selectedRows.length > 0) {
                    $KU.each(_.selectedRows, function(row) {
                        if(row[0] >= secIndex) {
                            row[0] = row[0] + 1;
                        }
                    });

                    _setSelectedRowsRelatedProperties.call(this);
                }

                if(el.node) {
                    //modify clones
                    _.clones.splice(secIndex, 0, new Array(2));
                    _.clones[secIndex][1] = new Array(data[secIndex][1].length);

                    if(_shouldLazyLoad.call(this)) {
                        _lazyLoad.SegmentedUI2._action._addSectionAt.call(this, secIndex, rowIndex, newdata, anim);
                    } else {
                        absIndex = _absoluteIndexInClones.call(this, secIndex, rowIndex);
                        clones = _getRenderableClones.call(this, [secIndex, rowIndex], [secIndex, newdata.length]);

                        if(absIndex === _.rows.length) {
                            if(clones.length > 0) {
                                prevLength = $KD.children(el.scrolee).length;
                                $KD.add(el.scrolee, _renderRows.call(this, clones));
                                _.rows.splice.apply(_.rows, [absIndex, 0].concat(clones));
                                if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                                    rows = [].slice.call($KD.children(el.scrolee), prevLength);
                                    _animator.SegmentedUI2.onRowDisplayHandler.call(this, updateIndicesFlag ? voltmx.segment.ADD: voltmx.segment.UPDATE, clones);
                                    _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'addsectionat', rows, -1, -1, anim);
                                }
                            }
                        } else {
                            _.rows.splice.apply(_.rows, [absIndex, 0].concat(clones));
                            $KU.each(clones, function(clone/*, ii*/) {
                                row = _renderRows.call(this, [clone]);
                                rows.push(row);
                                $KD.addAt(el.scrolee, row, absIndex++);
                            }, this);
                            if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                                _animator.SegmentedUI2.onRowDisplayHandler.call(this, updateIndicesFlag ? voltmx.segment.ADD: voltmx.segment.UPDATE, clones);
                                _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'addsectionat', rows, -1, -1, anim);
                            }
                        }
                        if(updateIndicesFlag) _updateIndexes.call(this, secIndex, -1);
                        _searcher.SegmentedUI2.updateSearchText.call(this, clones, true);
                    }
                }
            },

            setsectionat: function SegmentedUI2$_action_setsectionat(secIndex, rowIndex, newdata, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this),
                    _ = this._kwebfw_;

                if(_.selectedRows.length > 0) {
                    _.selectedRows.splice(0, _.selectedRows.length);
                    _setSelectedRowsRelatedProperties.call(this);
                }

                if(_shouldLazyLoad.call(this)) {
                    _lazyLoad.SegmentedUI2._action._setSectionAt.call(this, secIndex, rowIndex, newdata, anim);
                } else {
                    _action.SegmentedUI2.removesectionat.call(this, secIndex, rowIndex, false);
                    _action.SegmentedUI2.addsectionat.call(this, secIndex, rowIndex, newdata, false, anim);
                    if(el.node) _updateIndexes.call(this, secIndex, -1);
                }
            },

            removesectionat: function SegmentedUI2$_action_removesectionat(secIndex, rowIndex, updateIndicesFlag, anim) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    $KU =$K.utils, _ = this._kwebfw_, clones = null, counter = 0,
                    el = $KW.el(this), absIndex = null, rows = [], cloneModels = [];

                if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                    if(el.node) {
                        if(_shouldLazyLoad.call(this)) {
                            _lazyLoad.SegmentedUI2._action._removesectionat.call(this, secIndex, rowIndex, anim);
                        } else {
                            absIndex = _absoluteIndexInClones.call(this, secIndex, rowIndex);
                            clones = _.clones[secIndex];
                            //header node removal of given section index
                            if(clones[0] && clones[0].isVisible) {
                                rows.push($KD.childAt(el.scrolee, absIndex));
                                counter ++;
                            }

                            //row nodes removal of given section index
                            $KU.each(clones[1], function(clone) {
                                if(clone && clone.isVisible) {
                                    rows.push($KD.childAt(el.scrolee, absIndex + counter));
                                    cloneModels.push(clone);
                                    counter ++;
                                }
                            });
                            _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.REMOVE, cloneModels);
                            _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'removesectionat', rows, rowIndex, secIndex, anim);
                        }
                    }
                } else {
                    _action.SegmentedUI2._removeSectionAt.call(this, secIndex, rowIndex, updateIndicesFlag);
                }
            }
        }
    };


    //All the functions will be called in the scope of widget instance
    var _animator = {
        SegmentedUI2: {
            applyRowsAnimationByAPI: function SegmentedUI2$_animator_applyRowsAnimationByAPI(action, listItems, rowIndex, secIndex, animObj) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, animDef = null,
                    segmodel = this, row = null, rows = [],

                    _wrapRemoveAtCallback = function(callback) {
                        var wrapper = function() {
                            _action.SegmentedUI2._remove.call(segmodel, secIndex, rowIndex);
                            callback && callback.apply(this, arguments);
                        };
                        return wrapper;
                    },
                    _wrapRemoveAllCallback = function(callback) {
                        var wrapper = function() {
                            _action.SegmentedUI2._removeAll.call(segmodel);
                            callback && callback.apply(this, arguments);
                        };
                        return wrapper;
                    },
                    _wrapRemoveSectionAtCallback = function(callback) {
                        var wrapper = function() {
                            _action.SegmentedUI2._removeSectionAt.call(segmodel, secIndex, rowIndex, true);
                            callback && callback.apply(this, arguments);
                        };
                        return wrapper;
                    };

                animDef = animObj.definition;

                if(action === 'removeat') {
                    if(!animObj.callbacks) animObj.callbacks = {};
                    animObj.callbacks.animationEnd = _wrapRemoveAtCallback(animObj.callbacks.animationEnd);
                }

                if(action === 'removeall') {
                    if(!animObj.callbacks) animObj.callbacks = {};
                    animObj.callbacks.animationEnd = _wrapRemoveAllCallback(animObj.callbacks.animationEnd);
                }

                if(action === 'removesectionat') {
                    if(!animObj.callbacks) animObj.callbacks = {};
                    animObj.callbacks.animationEnd = _wrapRemoveSectionAtCallback(animObj.callbacks.animationEnd);
                }

                switch(action) {
                    case 'adddataat':
                    case 'setdataat':
                    case 'removeat':
                        row = listItems.firstChild;
                        animDef.applyRowAnimation([row], animObj.config, animObj.callbacks);
                        break;

                    case 'addall':
                    case 'addsectionat':
                    case 'removesectionat':
                        $KU.each(listItems, function(row) {
                            rows.push(row.firstChild);
                        });
                        animDef.applyRowAnimation(rows, animObj.config, animObj.callbacks);
                        break;

                    case 'setdata':
                    case 'removeall':
                        $KU.each(listItems, function(row) {
                            rows.push(row._kwebfw_.view);
                        });
                        animDef.applyRowAnimation(rows, animObj.config, animObj.callbacks);
                        break;
                    default:
                        break;
                }
            },

            animateRows: function SegmentedUI2$_animator_animateRows(animContext) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, animInfo = {},
                    el = $KW.el(this), rows = [], widgetId, widgets = [], elsToAnimate = [];

                if($KU.is(el.node, 'null')) {
                    return;
                }

                if(animContext) {
                    rows = animContext.context || animContext.rows;
                    animInfo = animContext.animation;
                    if(!rows || !$KU.is(rows, 'array') || !animInfo || !animInfo.definition) {
                        return;
                    }

                    widgetId = animContext.widgetID;
                    widgets = animContext.widgets || [];

                    if(widgetId) widgets.push(widgetId);

                    $KU.each(rows, function(rowContext/*, key*/) {
                        var absIndex = 0, model = null, templateModel = null,
                            el = null;

                        if(!_shouldLazyLoad.call(this)) {
                            absIndex = _absoluteIndexInClones.call(this, rowContext.sectionIndex, rowContext.rowIndex);
                        } else {
                            absIndex = _lazyLoad.SegmentedUI2._absoluteIndexInRows.call(this, rowContext.sectionIndex, rowContext.rowIndex);
                        }

                        templateModel = this._kwebfw_.rows[absIndex];
                        if(templateModel && templateModel._kwebfw_.view) {//template visible false case
                            if(widgets.length) {
                                $KU.each(widgets, function(widgetId/*, key*/) {
                                    model = $KU.get(widgetId, templateModel);
                                    el = model._kwebfw_.view;
                                    elsToAnimate.push(el);
                                });
                            } else {
                                model = templateModel;
                                el = model._kwebfw_.view;
                                elsToAnimate.push(el);
                            }
                        }
                    }, this);
                }
                animInfo.definition.applyRowAnimation(elsToAnimate, animInfo.config, animInfo.callbacks);
            },

            caf: function SegmentedUI2$_animator_caf(callback) {
                cancelAnimationFrame(callback);
            },

            canAnimate: function SegmentedUI2$_animator_canAnimate(animObj) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, result = true;


                if(!animObj || !animObj.definition || !animObj.definition.applyRowAnimation) {
                    result = false;
                }

                if(!$KW.visible(this)) {
                    result = false;
                }

                return result;
            },

            getRowVisibleState: function SegmentedUI2$_animator_getRowVisibleState(li) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, el = null, offsetTop,
                    offsetHeight, scrollTop, segHeight, state;

                el = $KW.el(this);

                offsetTop = li.offsetTop + el.scrolee.offsetTop;
                offsetHeight = li.offsetHeight;

                scrollTop = el.viewport.scrollTop;
                segHeight = el.viewport.offsetHeight;

                if(offsetTop + offsetHeight <= scrollTop) {
                    state = 'past';
                } else if(offsetTop >= scrollTop + segHeight) {
                    state = 'future';
                } else {
                    state = 'present';
                }

                return state;
            },

            handleStateAnimations: function SegmentedUI2$_animator_handleStateAnimations() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils, $KD = $K.dom,
                    visibleFirstRow = null, visibleLastRow = null, _ = this._kwebfw_;

                if(_.prop.onRowDisplay) {
                    visibleFirstRow = _getVisibleRow.call(this, {firstRow: true, lastRow: false});
                    visibleLastRow = _getVisibleRow.call(this, {firstRow: false, lastRow: true});
                }

                $KU.each(_.rows, function(clone/*, index*/) {
                    var li = null, state = null, animObj = null, visibleState = null, currentRowContext = null;

                    if(clone && clone._kwebfw_.view) {
                        li = $KD.closest(clone._kwebfw_.view, 'kr', 'item');
                    }

                    if(li) {
                        state = _animator.SegmentedUI2.getRowVisibleState.call(this, li);
                        if(clone._kwebfw_.animState !== state) {
                            if(state === 'present') {
                                animObj = _.visibleAnim;
                                visibleState = voltmx.segment.VISIBLE;
                            } else {
                                animObj = _.invisibleAnim;
                                visibleState = voltmx.segment.INVISIBLE;
                            }

                            currentRowContext = _getRowContext(clone);
                            if(this._kwebfw_.prop.onRowDisplay
                            && currentRowContext.rowIndex !== -1) {
                                $KW.fire(this, 'onRowDisplay', this,
                                    {
                                        model: this,
                                        state : visibleState,
                                        currentRowContext: currentRowContext,
                                        startRowContext: visibleFirstRow,
                                        endRowContext: visibleLastRow
                                    }
                                );
                            }

                            if(animObj) {
                                animObj.definition.applyRowAnimation([clone], animObj.config, animObj.callbacks);
                            }
                            clone._kwebfw_.animState = state;
                        }
                    }
                }, this);

                this._kwebfw_.rafValue = _animator.SegmentedUI2.raf(_animator.SegmentedUI2.handleStateAnimations.bind(this));
            },

            onRowDisplayHandler: function SegmentedUI2$_animator_onRowDisplayHandler(action, rows) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils, _ = this._kwebfw_,
                    visibleLastRow = null, visibleFirstRow = null, config = {}, currentRowContext = null;

                if(_.prop.onRowDisplay) {
                    visibleFirstRow = _getVisibleRow.call(this, {firstRow: true, lastRow: false});
                    visibleLastRow = _getVisibleRow.call(this, {firstRow: false, lastRow: true});

                    $KU.each(rows, function(clone/*, index*/) {
                        currentRowContext = _getRowContext(clone);
                        config = {
                            model: this,
                            state : action,
                            currentRowContext: currentRowContext,
                            startRowContext: visibleFirstRow,
                            endRowContext: visibleLastRow
                        };
                        if(currentRowContext.rowIndex !== -1) {
                            $KW.fire(this, 'onRowDisplay', this, config);
                        }
                    }, this);
                }
            },

            raf: function SegmentedUI2$_animator_raf(callback) {
                return requestAnimationFrame(callback);
            },

            scrolled: false,

            scrollEnd: function SegmentedUI2$_animator_scrollEnd() {
                this._kwebfw_.rafValue && _animator.SegmentedUI2.caf(this._kwebfw_.rafValue);
            },

            scrollStart: function SegmentedUI2$_animator_scrollStart() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    segNode = null, model = null;

                segNode = $KD.closest(this, 'kw');
                if(segNode) {
                    model = $KW.model(segNode);

                    if(!_animator.SegmentedUI2.scrolled) {
                        if(model._kwebfw_.visibleAnim
                           || model._kwebfw_.invisibleAnim
                           || model._kwebfw_.prop.onRowDisplay) {
                            _animator.SegmentedUI2.setAnimationStates.call(model);
                            model._kwebfw_.rafValue = _animator.SegmentedUI2.raf(_animator.SegmentedUI2.handleStateAnimations.bind(model));
                        }
                        _animator.SegmentedUI2.scrolled = true;
                    }

                    if(_animator.SegmentedUI2.scrollTimer) {
                        clearTimeout(_animator.SegmentedUI2.scrollTimer);
                    }

                    _animator.SegmentedUI2.scrollTimer = setTimeout(function() {
                        _animator.SegmentedUI2.scrollEnd.call(model);
                        clearTimeout(_animator.SegmentedUI2.scrollTimer);
                        _animator.SegmentedUI2.scrollTimer = null;
                        _animator.SegmentedUI2.scrolled = false;
                    }, 250);
                }
            },

            scrollTimer: null,

            setAnimations: function SegmentedUI2$_animator_setAnimations(animInfo) {
                var animObj = null, _ = this._kwebfw_;

                _.visibleAnim = null;
                _.invisibleAnim = null;

                if(animInfo) {
                    if(animInfo.visible) {
                        animObj = animInfo.visible;
                        if(animObj && animObj.definition && animObj.definition.applyRowAnimation) {
                            _.visibleAnim = animObj;
                        }
                    }

                    if(animInfo.invisible) {
                        animObj = animInfo.invisible;
                        if(animObj && animObj.definition && animObj.definition.applyRowAnimation) {
                            _.invisibleAnim = animObj;
                        }
                    }
                }
            },

            setAnimationStates: function SegmentedUI2$_animator_setAnimationStates() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                $KU.each(this._kwebfw_.rows, function(clone/*, index*/) {
                    var li = null, state = null;

                    if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                        li = $KD.closest(clone._kwebfw_.view, 'kr', 'item');
                    }

                    if(li) {
                        state = _animator.SegmentedUI2.getRowVisibleState.call(this, li);
                        clone._kwebfw_.animState = state;
                    }
                }, this);
            }
        }
    };


    //This function will be called in the scope of widget instance
    //This function is not yet tested, specially when section index value is there
    var _absoluteIndexInData = function SegmentedUI2$_absoluteIndexInData(index) {
        var data = this._kwebfw_.prop.data, absIndex = -1, secIndex = -1, rowIndex = -1;

        index = _deduceIndex.call(this, index);
        secIndex = index[0]; rowIndex = index[1];

        if(!(secIndex === -1 && rowIndex === -1)) {
            if(_isSectionDS(data[0])) {
                if(secIndex >= 0) {
                    if(secIndex < data.length) {
                        for(index=0; index<=secIndex; index++) {
                            absIndex += 1;

                            if(index < secIndex) {
                                absIndex += data[index][1].length;
                            } else if(rowIndex > -1 && rowIndex < data[index][1].length) {
                                absIndex += (rowIndex + 1);
                            }
                        }
                    } else {
                        //SectionIndex exceeds its max boundary for a sectionable segment.
                    }
                } else {
                    //Negative SectionIndex found for a sectionable segment.
                }
            } else { //Non sectionable segment
                if(rowIndex >= 0) {
                    if(rowIndex < data.length) {
                        absIndex = rowIndex;
                    } else {
                        //RowIndex exceeds its max boundary for a non-sectionable segment.
                    }
                } else {
                    //Negative RowIndex found for a non-sectionable segment.
                }
            }
        }

        return absIndex;
    };


    //This function will be called in the scope of widget instance
    //This function is not yet tested, specially when section index value is there
    var _absoluteIndexInClones = function SegmentedUI2$_absoluteIndexInClones(secIndex, rowIndex) {
        var absIndex = 0, _ = this._kwebfw_, data = _.prop.data, clones = _.clones;

        var increment = function(clone, index) {
            if(clone && clone.isVisible) index++;

            return index;
        };

        if(clones.length > 0) {
            if(_isSectionDS(data[0])) {
                if(rowIndex === -1) {
                    secIndex--;
                    if(secIndex >= 0) rowIndex = data[secIndex][1].length - 1;
                } else {
                    rowIndex = rowIndex - 1;
                }
                while(secIndex < data.length && secIndex >= 0) {
                    if(rowIndex === -1) {
                        absIndex = increment(clones[secIndex][0], absIndex);
                        secIndex--;
                        if(secIndex >= 0) rowIndex = data[secIndex][1].length - 1;
                    } else if(rowIndex < data[secIndex][1].length && rowIndex > -1) {
                        absIndex = increment(clones[secIndex][1][rowIndex], absIndex);
                        rowIndex--;
                    }
                }
            } else {
                rowIndex = rowIndex - 1;
                while(rowIndex < data.length && rowIndex >= 0) {
                    absIndex = increment(clones[rowIndex], absIndex);
                    rowIndex--;
                }
            }
        }

        return absIndex;
    };

    var _applyNodeStyles = function SegmentedUI2$__applyNodeStyles() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, index = 0, isHeaderNode = false,
            firstRow = null, firstRowIndex = null;

        firstRow = _getFirstRederedRow.call(this);
        firstRowIndex = _deduceIndex.call(this, firstRow);

        if(firstRowIndex[1] !== -1) {
            index = firstRowIndex[1];
        }

        $KU.each(this._kwebfw_.rows, function(clone) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                li = null, ii = clone._kwebfw_.ii;

            if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                li = $KD.closest(clone._kwebfw_.view, 'kr', 'item');
            }

            if(isHeaderNode) {
                firstRowIndex = _deduceIndex.call(this, clone);
                if(firstRowIndex[1] !== -1) {
                    index = firstRowIndex[1];
                }
                isHeaderNode = false;
            }

            if(li) {
                _applyRowAndHeaderSkin.call(this, li, clone, index);
                _applyRowSeparator.call(this, li, clone);

                if(ii.indexOf(',-1') !== -1) {
                    isHeaderNode = true;
                } else {
                    index++;
                }
            }
        }, this);
    };


    //This function will be called in the scope of widget instance
    var _applyRowSeparator = function SegmentedUI2$_applyRowSeparator(li, clone) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, color = '',
            index = _deduceIndex.call(this, clone), thickness = '',
            rowIndex = index[1], prop = this._kwebfw_.prop;

        if(prop.separatorRequired && prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
            //If not the first row, then add separator
            if(!((rowIndex === -1) || (rowIndex === 0))) {
                thickness = (prop.separatorThickness + 'px');
                color = $KU.convertHexToRGBA(prop.separatorColor);
                $KD.style(li, 'borderTop', (thickness+' solid '+(color || 'transparent')));
            } else {
                $KD.style(li, 'border-top', null);
            }
        } else {
            $KD.style(li, 'border-top', null);
        }
    };


    //This function will be called in the scope of widget instance
    var _applyRowAndHeaderSkin = function SegmentedUI2$_applyRowAndHeaderSkin(li, clone, index) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, ii = clone._kwebfw_.ii,
            prop = this._kwebfw_.prop, rowSkin = prop.rowSkin;

        if(ii.indexOf(',-1') !== -1) {
            // sectionHeaderSkin
            $KD.setAttr(li, 'class', prop.sectionHeaderSkin);
        } else {
            // Row Skin and alternate Row Skin
            if(prop.alternateRowSkin && prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
                if(index % 2 !== 0) rowSkin = prop.alternateRowSkin;
            }
            $KD.setAttr(li, 'class', rowSkin);
        }
    };

    //This function will be called in the scope of widget instance
    var _clearSelectedIndices = function SegmentedUI2$_clearSelectedIndices() {
        var _ = this._kwebfw_, rows = _.selectedRows;

        rows.splice(0, rows.length);

        _setSelectedRowsRelatedProperties.call(this);

        if(_.swipeContext) _.swipeContext = null;
    };


    //This function will be called in the scope of widget instance
    var _deduceIndex = function SegmentedUI2$_deduceIndex(index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, secIndex = -1,
            rowIndex = -1;

        if($KU.is(index, 'widget')) {
            index = index._kwebfw_.ii;
        }

        if($KU.is(index, 'string') && index) {
            index = index.split(',');
            if(index.length === 2) {
                secIndex = parseInt(index[0], 10);
                rowIndex = parseInt(index[1], 10);

                if(!$KU.is(secIndex, 'number')) {
                    secIndex = -1;
                }
                if(!$KU.is(rowIndex, 'number')) {
                    rowIndex = -1;
                }
            }
        } else if($KU.is(index, 'number')) {
            secIndex = -1;
            rowIndex = index;
        } else if($KU.is(index, 'array')
        && $KU.is(index[0], 'number')
        && $KU.is(index[1], 'number')) {
            secIndex = index[0];
            rowIndex = index[1];
        }

        if(secIndex < -1) secIndex = -1;
        if(rowIndex < -1) rowIndex = -1;

        return [secIndex, rowIndex];
    };

    //This function must be called in the scope of widget instance
    var _deduceTagName = function SegmentedUI2$_deduceTagName(tag) {
        var a11y = this._kwebfw_.prop.accessibilityConfig;

        tag = (a11y && a11y.tagName) ? a11y.tagName.toLowerCase() : 'ul';

        return tag;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {
        SegmentedUI2: function SegmentedUI2$_dependentPropertiesValidationMessage(prop, bconfig/*, lconfig, pspconfig*/) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false, message = '',
                sectionable = false, data = bconfig.data || prop.data,
                index = bconfig.selectedRowIndex || prop.selectedRowIndex;

            if($KU.is(index, 'null')) {
                flag = true;
            } else if(data && data.length && $KU.is(index, 'array') && index.length === 2
            && $KU.is(index[0], 'number') && $KU.is(index[1], 'number')) {
                sectionable = _isSectionDS(data[0]);

                if(!sectionable) {
                    if(index[0] === 0 && index[1] >= 0 && index[1] < data.length) {
                        flag = true;
                    }
                } else if(index[0] >= 0 && index[0] < data.length) {
                    if(index[1] >= -1 && index[1] < data[index[0]][1].length) {
                        flag = true;
                    }
                }
            }

            if(!flag) {
                message += 'Segment <selectedRowIndex> value is invalid';
            }

            return message;
        }
    };


    //This function will be called in the scope of widget instance
    var _executeOnRow = function SegmentedUI2$_executeOnRow(index, callback, args) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, tpl = null,
            data = this._kwebfw_.prop.data, item = null, secIndex = -1, rowIndex = -1;

        index = _deduceIndex.call(this, index);
        secIndex = index[0]; rowIndex = index[1];

        if(secIndex === -1 && rowIndex === -1) return;

        if(_isSectionDS(data[0])) {
            if(secIndex >= 0 && secIndex < data.length) {
                if(rowIndex < 0) {
                    if($KU.is(callback, 'function')) {
                        if(!$KU.is(args, 'array')) args = [];
                        item = data[secIndex][0];
                        if($KU.is(item, 'string')) {
                            tpl = _getFrameworkHeaderTemplate();
                        } else {
                            tpl = item.template || this.sectionHeaderTemplate;
                        }

                        tpl = $KW.getTemplate(this, tpl);

                        if(!$KU.is(this._kwebfw_.clones[secIndex], 'array')) {
                            this._kwebfw_.clones[secIndex] = [null, []];
                        } else if($KU.is(this._kwebfw_.clones[secIndex][0], 'widget')) {
                            _flushClones(this._kwebfw_.clones[secIndex][0]);
                            this._kwebfw_.clones[secIndex][0] = null;
                        }

                        args.splice(0, 0, [secIndex, rowIndex]);
                        args.splice(1, 0, item);
                        args.splice(2, 0, tpl);
                        args.splice(3, 0, this._kwebfw_.clones[secIndex][0]);

                        callback.apply(this, args);
                    }
                } else if(rowIndex >= 0 && rowIndex < data[secIndex][1].length) {
                    if($KU.is(callback, 'function')) {
                        if(!$KU.is(args, 'array')) args = [];
                        item = data[secIndex][1][rowIndex];
                        tpl = item.template || this.rowTemplate;
                        tpl = $KW.getTemplate(this, tpl);

                        if(!$KU.is(this._kwebfw_.clones[secIndex], 'array')) {
                            this._kwebfw_.clones[secIndex] = [null, []];
                        }

                        if($KU.is(this._kwebfw_.clones[secIndex][1][rowIndex], 'widget')) {
                            _flushClones(this._kwebfw_.clones[secIndex][1][rowIndex]);
                            this._kwebfw_.clones[secIndex][1][rowIndex] = null;
                        }

                        args.splice(0, 0, [secIndex, rowIndex]);
                        args.splice(1, 0, item);
                        args.splice(2, 0, tpl);
                        args.splice(3, 0, this._kwebfw_.clones[secIndex][1][rowIndex]);

                        callback.apply(this, args);
                    }
                }
            }
        } else if(secIndex < 0) {
            if(rowIndex >= 0 && rowIndex < data.length) {
                if($KU.is(callback, 'function')) {
                    if(!$KU.is(args, 'array')) args = [];
                    item = data[rowIndex];
                    tpl = item.template || this.rowTemplate;
                    tpl = $KW.getTemplate(this, tpl);

                    if($KU.is(this._kwebfw_.clones[rowIndex], 'widget')) {
                        _flushClones(this._kwebfw_.clones[rowIndex]);
                        this._kwebfw_.clones[rowIndex] = null;
                    }

                    args.splice(0, 0, [secIndex, rowIndex]);
                    args.splice(1, 0, item);
                    args.splice(2, 0, tpl);
                    args.splice(3, 0, this._kwebfw_.clones[rowIndex]);

                    callback.apply(this, args);
                }
            }
        }
    };

    //This function will be called in the scope of widget instance
    var _flushClones = function SegmentedUI2$_flushClones(clones, config) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if(config) {
            config.iterate = true;
        } else {
            config = {iterate : true};
        }

        if($KU.is(clones, 'widget')) clones = [clones];

        if($KU.is(clones, 'array')) {
            $KU.each(clones, function(section) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                if($KU.is(section, 'array')) {
                    if($KU.is(section[0], 'widget')) {
                        section[0]._flush(config);
                    }

                    $KU.each(section[1], function(row) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(row, 'widget')) {
                            row._flush(config);
                        }
                    });
                } else if($KU.is(section, 'widget')) {
                    section._flush(config);
                }
            }, this);
        }
    };

    var _flushPageNav = function SegmentedUI2$_flushClones(el) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

        $KU.each($KD.children(el), function(img) {
            $KD.off(img);
            $KD.removeAttr(img, 'loading');
        });
    };

    //This function will be called in the scope of widget instance
    var _getClonedTemplate = function SegmentedUI2$_getClonedTemplate(index) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, template = null;

        _executeOnRow.call(this, index, function(index, item, tpl/*, clone*/) {
            var secIndex = index[0], rowIndex = index[1],
                prop = this._kwebfw_.prop, self = this;

            template = $KW.cloneTemplate(tpl, item, prop.widgetDataMap, function(model/*, pmodel, windex*/) {
                model._kwebfw_.ii = index.join(',');
                _updateSpecialProperties.call(self, model);
                _setBehaviorConfig.call(self, model);
            });

            if(secIndex === -1) {
                this._kwebfw_.clones[rowIndex] = template;
            } else {
                if(rowIndex === -1) {
                    this._kwebfw_.clones[secIndex][0] = template;
                } else {
                    this._kwebfw_.clones[secIndex][1][rowIndex] = template;
                }
            }

            //if segment lazy load enabled the cloned template and its children need not marked for relayout
            if(_shouldLazyLoad.call(this)) {
                _lazyLoad.SegmentedUI2._removeFromRelayout.call(this, template);
            }
        });

        return (template && template.isVisible) ? template : null;
    };


    var _getFrameworkHeaderTemplate = function SegmentedUI2$_getFrameworkHeaderTemplate() {
        var flx = null, lbl = null, bconfig = null;

        if(_frameworkHeaderTemplate === null) {
            bconfig = {
                'id': 'flxkwebfwHeader',
                'layoutType': voltmx.flex.FREE_FORM,
                'height': voltmx.flex.USE_PREFERRED_SIZE,
                'autogrowMode': voltmx.flex.AUTOGROW_HEIGHT
            };

            flx = new voltmx.ui.FlexContainer(bconfig);
            lbl = new voltmx.ui.Label({'id': 'labelkwebfwHeader'});
            flx.add(lbl);
            _frameworkHeaderTemplate = flx;
        }


        return _frameworkHeaderTemplate;
    };


    var _getIndex = function SegmentedUI2$_getIndex(find, list) {
        var position = -1, i = 0, ilen = list.length;

        for(i=0; i<ilen; i++) {
            if(list[i][0] === find[0] && list[i][1] === find[1]) {
                position = i;
                break;
            }
        }

        return position;
    };


    //This function will be called in the scope of widget instance
    var _getIndexedInfo = function SegmentedUI2$_getIndexedInfo(index, data) {
        var item = null, _ = this._kwebfw_, prop =_.prop, secIndex = -1, rowIndex = -1;

        index = _deduceIndex.call(this, index);
        secIndex = index[0]; rowIndex = index[1];

        if(secIndex === -1 && rowIndex === -1) return null;

        if(secIndex < 0) {
            if(rowIndex >= 0 && rowIndex < prop.data.length) {
                item = data[rowIndex];
            }
        } else if(_isSectionDS(prop.data[0])) {
            if(secIndex >= 0 && secIndex < prop.data.length) {
                if(rowIndex < 0) {
                    item = data[secIndex][0];
                } else if(rowIndex >= 0 && rowIndex < prop.data[secIndex][1].length) {
                    item = data[secIndex][1][rowIndex];
                }
            }
        }

        return item;
    };


    var _getInvertedDataMap = function SegmentedUI2$_getInvertedDataMap(map) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, invertedMap = {};

        if($KU.is(map, 'object')) {
            $KU.each(map, function(value, key) {
                invertedMap[value] = key;
            });
        }

        return invertedMap;
    };

    var _getFirstRederedRow = function SegmentedUI2$_getFirstRederedRow() {
        var rows = this._kwebfw_.rows;

        return rows[0];
    };

    var _getLastRenderedRow = function SegmentedUI2$_getLastRenderedRow() {
        var rows = this._kwebfw_.rows;

        return rows[rows.length-1];
    };


    //This function will be called in the scope of widget instance
    var _getRenderableClones = function SegmentedUI2$_getRenderableClones(startIndex, endIndex) {
        var data = this._kwebfw_.prop.data, rows = [], startSecIndex = startIndex[0],
            startRowIndex = startIndex[1], endSecIndex = -1, endRowIndex = -1,
            datalen = 0;

        var cloneRow = function(model, index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                tpl = _getClonedTemplate.call(model, index);

            if($KU.is(tpl, 'widget')) {
                rows.push(tpl);
            }
        };

        if(startSecIndex <= -1 && startRowIndex <= -1) return rows;

        if(data) {
            datalen = data.length - 1;

            if(!endIndex) {
                if(_isSectionDS(data[0])) endSecIndex = datalen;
                else endRowIndex = datalen;
            } else {
                endSecIndex = endIndex[0];
                endRowIndex = endIndex[1];
                if(_isSectionDS(data[0])) {
                    if(endSecIndex > datalen) endSecIndex = datalen;
                } else {
                    if(endRowIndex > datalen) endRowIndex = datalen;
                }
            }

            if(_isSectionDS(data[0])) {
                while(startSecIndex <= endSecIndex) {
                    if(startRowIndex >= data[startSecIndex][1].length) {
                        startSecIndex++;
                        startRowIndex = -1;
                    } else {
                        cloneRow(this, [startSecIndex, startRowIndex]);
                        startRowIndex++;
                    }
                }
            } else {
                while(startRowIndex <= endRowIndex && startRowIndex >= 0) {
                    cloneRow(this, [startSecIndex, startRowIndex]);
                    startRowIndex++;
                }
            }
        }

        return rows;
    };


    //This function will be called in the scope of widget instance
    var _getRowContext = function SegmentedUI2$_getRowContext(clone) {
        var cindex = clone._kwebfw_.ii.split(','),
            secIndex = parseInt(cindex[0], 10),
            rowIndex = parseInt(cindex[1], 10);
        return {
            sectionIndex: (secIndex === -1 ? 0 :secIndex),
            rowIndex: rowIndex
        };
    };


    //This function will be called in the scope of widget instance
    var _getRowCount = function SegmentedUI2$_getRowCount() {
        var prop = this._kwebfw_.prop, rowcount = 0,
            secIndex = -1, rowIndex = -1;

        if(prop.data && prop.data.length) {
            if(_isSectionDS(prop.data[0])) {
                secIndex = (prop.data.length - 1);
                rowIndex = (prop.data[secIndex][1].length - 1);
            } else {
                rowIndex = (prop.data.length - 1);
            }
            rowcount = (_absoluteIndexInData.call(this, [secIndex, rowIndex]) + 1);
        }

        return rowcount;
    };

    //This function will be called in the scope of widget instance
    var _getTemplateByIndex = function SegmentedUI2$_getTemplateByIndex(index) {
        var tpl = null,  _ = this._kwebfw_, data = _.prop.data,
            clones = _.clones, secIndex = -1, rowIndex = -1;

        index = _deduceIndex.call(this, index);
        secIndex = index[0];
        rowIndex = index[1];

        if (secIndex === -1 && rowIndex === -1) return null;

        if (secIndex < 0) {
            if (rowIndex >= 0 && rowIndex < data.length) {
                tpl = clones[rowIndex];
            }
        } else if (_isSectionDS(data[0])) {
            if (secIndex >= 0 && secIndex < data.length) {
                if (rowIndex < 0) {
                    tpl = clones[secIndex][0];
                } else if (
                    rowIndex >= 0 &&
                    rowIndex < data[secIndex][1].length
                ) {
                    tpl = clones[secIndex][1][rowIndex];
                }
            }
        }

        return tpl;
    };

    var _getVisibleRow = function SegmentedUI2$_getVisibleRow(config) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KU = $K.utils,
            $KD = $K.dom, el = $KW.el(this), visibleRow = null,
            scrollTop = 0, scrollBottom = 0, index = null, visibleIndex = null,
            prop = this._kwebfw_.prop, rowNodes = [];

        if(el.node) {
            rowNodes = $KD.children(el.scrolee);
        }

        if(rowNodes.length > 0) {
            scrollTop = el.viewport.scrollTop;
            scrollBottom = scrollTop + el.viewport.offsetHeight;

            $KU.each(rowNodes, function(li, index) {
                var rowTop = li.offsetTop + el.scrolee.offsetTop, rowBottom = rowTop + li.offsetHeight;

                if(config.firstRow && scrollTop < rowBottom) {
                    visibleRow = li;
                    return true;
                }

                if(config.lastRow
                && (scrollBottom < rowTop || scrollBottom <= rowBottom + 1
                    || index === rowNodes.length - 1)) {
                    visibleRow = li;
                    return true;
                }
            });

            index = visibleRow && $KD.getAttr(visibleRow, 'kii');
            index = _deduceIndex.call(this, index);

            if(_isSectionDS(prop.data[0])) {
                visibleIndex = {sectionIndex: index[0]};
                if(index[1] !== -1) visibleIndex['rowIndex'] = index[1];
            } else {
                visibleIndex = {rowIndex: index[1]};
            }
        }

        return visibleIndex;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        SegmentedUI2: {
            contentOffset: function FlexScrollContainer$_getter_contentOffset(value) {
                return {x:value.x, y:value.y};
            },

            contentOffsetMeasured: function SegmentedUI2$_getter_contentOffsetMeasured(value) {
                var _ = this._kwebfw_, prop = _.prop, scroll = _.ui.scroll, rowIndex = -1;

                if(prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
                    value.x = scroll.x;
                    value.y = scroll.y;
                } else {
                    if(_.swipeContext && _.swipeContext.currentPage > -1) {
                        rowIndex = _.swipeContext.currentPage;
                    } else if(prop.selectedRowIndex && prop.selectedRowIndex.length === 2) {
                        rowIndex = prop.selectedRowIndex[1];
                    }
                    if(_.swipeContext && _.swipeContext.imageWidth) {
                        value.x = rowIndex * (_.swipeContext.imageWidth);
                    } else {
                        value.x = 0;
                    }
                    value.y = 0;
                }
                return {x:value.x, y:value.y};
            },

            data: function SegmentedUI2$_getter_data(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, data = [];

                if(!value) {
                    return value;
                }
                if(!_isSectionDS(value)) {
                    data = value.slice(0);
                } else {
                    $KU.each(value, function(section) {
                        data.push([section[0], section[1].slice(0)]);
                    });
                }

                return data;
            },

            scrollingEvents: function SegmentedUI2$_getter_scrollingEvents(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    scrollingEvents = value ? {} : null;

                $KU.each(value, function(val, key) {
                    scrollingEvents[key] = val;
                });

                return scrollingEvents;
            },

            selectedRowIndex: function SegmentedUI2$_getter_selectedRowIndex(value) {
                var prop = this._kwebfw_.prop, index = null;

                if(prop.selectedRowIndex) {
                    if(value[0] === -1) {
                        index = [0, value[1]];
                    } else {
                        index = value.slice(0);
                    }
                }

                return index;
            },

            selectedRowIndices: function SegmentedUI2$_getter_selectedRowIndices(/*value*/) {
                var prop = this._kwebfw_.prop, indices = null, s = 0,
                    slen = 0, sindex = 0, rindexes = null;

                if(prop.selectedRowIndices) {
                    indices = [];
                    slen = prop.selectedRowIndices.length;

                    for(s=0; s<slen; s++) {
                        sindex = prop.selectedRowIndices[s][0];
                        rindexes = prop.selectedRowIndices[s][1];

                        if(sindex === -1) sindex = 0;
                        indices.push([sindex, rindexes.slice(0)]);
                    }
                }

                return indices;
            },

            widgetDataMap: function SegmentedUI2$_getter_widgetDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _iterateOverData = function SegmentedUI2$_iterateOverData(data, callback) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            s = 0, r = 0, slen = 0, rlen = 0;

        if(!$KU.is(callback, 'function')) return;

        if($KU.is(data, 'array')) {
            if(_isSectionDS(data[0])) {
                slen = data.length;

                for(s=0; s<slen; s++) {
                    rlen = data[s][1].length;

                    if(callback.call(this, data[s][0], -1, s) === true) {
                        break;
                    }

                    for(r=0; r<rlen; r++) {
                        if(callback.call(this, data[s][1][r], r, s) === true) {
                            break;
                        }
                    }
                }
            } else {
                rlen = data.length;

                for(r=0; r<rlen; r++) {
                    if(callback.call(this, data[r], r, -1) === true) {
                        break;
                    }
                }
            }
        }
    };


    //This function will be called in the scope of widget instance
    //eslint-disable-next-line no-unused-vars
    var _isSectionCollapsed = function SegmentedUI2$_isSectionCollapsed(index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = null,
            _ = this._kwebfw_, prop = _.prop, collapsed = false;

        if(prop.data) {
            if($KU.is(index, 'number') && index >= 0
            && index < prop.data.length) {
                data = prop.data[index][0];

                if($KU.is(data.metaInfo, 'object')
                && data.metaInfo.collapsed === true) {
                    collapsed = true;
                }
            }
        }

        return collapsed;
    };


    var _isSectionDS = function SegmentedUI2$_isSectionDS(data) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

        if($KU.is(data, 'array')
        && ($KU.is(data[0], 'object') || $KU.is(data[0], 'string'))
        && $KU.is(data[1], 'array')) {
            flag = true;
        }

        return flag;
    };


    //This function will be called in the scope of widget instance
    var _isRowRendered = function SegmentedUI2$_isRowRendered(secIndex, rowIndex) {
        var flag = false, clone = null, r = 0, _ = this._kwebfw_,
            clones = _.clones, rows = _.rows, rlen = rows.length;

        if(clones.length > 0) {
            if(_isSectionDS(_.prop.data[0])) {
                if(rowIndex <= -1) clone = clones[secIndex];
                else clone = clones[secIndex][1][rowIndex];
            } else {
                clone = clones[rowIndex];
            }

            if(clone) {
                for(r=0; r<rlen; r++) {
                    if(rows[r] === clone) {
                        flag = true;
                        break;
                    }
                }
            }
        }

        return flag;
    };

    var _lazyLoad = {
        SegmentedUI2: {
            _action: {
                _addAll: function SegmentedUI2$_lazyLoad_action_addAll(el, index, anim) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        _ = this._kwebfw_, clones = _.clones, data = _.prop.data,
                        rows = null, prevLength, isSec = _isSectionDS(data[0]),
                        rowIndex = index[1], sectionIndex = index[0];

                    if(_.searcher) {
                        _searcher.SegmentedUI2.updateFilterResult.call(this);
                    }
                    if(el.node && $KW.visible(this)) {
                        //check scroll before update and store in _.hasScroll
                        _.hasScroll = _lazyLoad.SegmentedUI2._hasScroll.call(this, el);

                        if(isSec) {
                            for(sectionIndex; sectionIndex < data.length; sectionIndex++) {
                                if(clones[sectionIndex] === undefined) {
                                    _.clones[sectionIndex] = new Array(2);
                                    _.clones[sectionIndex][1] = new Array(data[sectionIndex].length);
                                }
                            }
                        } else {
                            for(rowIndex; rowIndex < data.length; rowIndex++) {
                                if(clones[rowIndex] === undefined) {
                                    _.clones.length++;
                                }
                            }
                        }

                        if(_.rows.length === 0) {
                            index = isSec ? [0, -1] : [-1, 0];
                        } else {
                            index = null;
                        }
                        _lazyLoad.SegmentedUI2._addBottomBuffer.call(this, _lazyLoad.SegmentedUI2._getBufferSize(), index);
                        _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(this);

                        if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                            prevLength = $KD.children(el.scrolee).length;
                            rows = [].slice.call($KD.children(el.scrolee), prevLength);
                            _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.ADD, clones);
                            _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'addall', rows, -1, -1, anim);
                        }
                    }
                },

                _addDataAt: function SegmentedUI2$_lazyLoad_action_addDataAt(secIndex, rowIndex, widgetdata, anim) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, clone = null,
                        el = $KW.el(this), _ = this._kwebfw_, data = _.prop.data,
                        needToTouchView = false, section = _isSectionDS(data[0]), absIndex = null,
                        rowNode = null, firstRowIndex = null, lastRowIndex = null;

                    if($KW.visible(this)) {
                        _.hasScroll = _lazyLoad.SegmentedUI2._hasScroll.call(this, el);

                        //update indices(ii)
                        _updateIndexes.call(this, rowIndex, secIndex);

                        firstRowIndex = _deduceIndex.call(this, _getFirstRederedRow.call(this));
                        lastRowIndex = _deduceIndex.call(this, _getLastRenderedRow.call(this));

                        needToTouchView = _lazyLoad.SegmentedUI2._needToTouchView(secIndex, rowIndex, firstRowIndex, lastRowIndex, section);

                        if(needToTouchView) {
                            clone = _getClonedTemplate.call(this, [secIndex, rowIndex]);
                            if(clone) {
                                rowNode = _renderRows.call(this, [clone]);
                                absIndex = _lazyLoad.SegmentedUI2._absoluteIndexInRows.call(this, secIndex, rowIndex, true);
                                if(absIndex === _.rows.length) {
                                    _.rows.push(clone);
                                    $KD.add(el.scrolee, rowNode);
                                } else {
                                    _.rows.splice(absIndex, 0, clone);
                                    $KD.addAt(el.scrolee, rowNode, absIndex);
                                }

                                _lazyLoad.SegmentedUI2._getRowsHeight.call(this, [clone]);
                            }
                        } else if(firstRowIndex[0] === -1 && firstRowIndex[1] === -1) {
                            //if there are no rows in the view port, render from first section
                            _lazyLoad.SegmentedUI2._renderFromIndex.call(this, [secIndex, rowIndex], el);
                        }

                        if(section) {
                            if(secIndex > lastRowIndex[0]
                                || (secIndex === lastRowIndex[0] && rowIndex > lastRowIndex[1])) {
                                _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'bottom');
                            } else if(secIndex < firstRowIndex[0]
                                || (secIndex === firstRowIndex[0] && rowIndex < firstRowIndex[1])) {
                                _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'top', [secIndex, rowIndex]);
                            }
                        } else {
                            if(rowIndex > lastRowIndex[1]) {
                                _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'bottom');
                            } else if(rowIndex < firstRowIndex[1]) {
                                _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'top', [secIndex, rowIndex]);
                            }
                        }
                        _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(this);

                        if(clone && _animator.SegmentedUI2.canAnimate.call(this, anim)) {
                            _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.ADD, [clone]);
                            _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'adddataat', rowNode, rowIndex, secIndex, anim);
                        }

                        if(_.searcher) {
                            _searcher.SegmentedUI2.updateFilterResult.call(this);
                            _searcher.SegmentedUI2.updateSearchText.call(this, clone);
                        }
                    }
                },

                _addSectionAt: function SegmentedUI2$_lazyLoad_action_addSectionAt(secIndex, rowIndex, newdata, anim) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, removedHeight = 0,
                        clones = [], el = $KW.el(this), _ = this._kwebfw_,
                        firstRowIndex = null, lastRowIndex = null, rows = [];

                    //Handle Search
                    if(_.searcher) {
                        _searcher.SegmentedUI2.updateFilterResult.call(this);
                    }
                    if($KW.visible(this)) {
                        _.hasScroll = _lazyLoad.SegmentedUI2._hasScroll.call(this, el);

                        _updateIndexes.call(this, secIndex, -1);

                        //get firstRowIndex and lastRowIndex in the view port
                        firstRowIndex = _deduceIndex.call(this, _getFirstRederedRow.call(this));
                        lastRowIndex = _deduceIndex.call(this, _getLastRenderedRow.call(this));

                        if(firstRowIndex[0] === -1 && firstRowIndex[1] === -1) {
                            //if there are no rows in the view port, render from first section
                            _lazyLoad.SegmentedUI2._renderFromIndex.call(this, [secIndex, -1], el);
                        } else if(secIndex > firstRowIndex[0] && secIndex < lastRowIndex[0]) {
                            //if the section to be set with in the view port, then remove all rows from the given section index
                            //and re-render from the given section index
                            removedHeight = _lazyLoad.SegmentedUI2._removeRowsFromViewFromIndex.call(this, [secIndex, rowIndex]);
                            _lazyLoad.SegmentedUI2._addRowsTillGivenHeight.call(this, removedHeight);
                            _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'bottom');
                        } else {
                            if(secIndex < firstRowIndex[0]) {
                                _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'top', [secIndex, -1]);
                            } else if(secIndex > lastRowIndex[0]) {
                                _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'bottom');
                            }
                        }
                        _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(this);

                        //Handle Animation
                        if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                            _lazyLoad.SegmentedUI2._getRowsToAnimate.call(this, secIndex, rowIndex, clones, rows);
                            _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.ADD, clones);
                            _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'addsectionat', rows, -1, -1, anim);
                        }
                    }
                },

                _removeAt: function SegmentedUI2$_lazyLoad_action_removeAt(secIndex, rowIndex) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        el = $KW.el(this), _ = this._kwebfw_, data = _.prop.data,
                        needToTouchView = false, section = _isSectionDS(data[0]),
                        firstRowIndex = null, lastRowIndex = null, absIndex = null;

                    if(_.searcher) {
                        _searcher.SegmentedUI2.updateFilterResult.call(this);
                    }
                    if($KW.visible(this)) {
                        _.hasScroll = _lazyLoad.SegmentedUI2._hasScroll.call(this, el);

                        firstRowIndex = _deduceIndex.call(this, _getFirstRederedRow.call(this));
                        lastRowIndex = _deduceIndex.call(this, _getLastRenderedRow.call(this));

                        needToTouchView = _lazyLoad.SegmentedUI2._needToTouchView(secIndex, rowIndex, firstRowIndex, lastRowIndex, section);

                        if(needToTouchView) {
                            absIndex = _lazyLoad.SegmentedUI2._absoluteIndexInRows.call(this, secIndex, rowIndex);
                            if(absIndex !== -1) {
                                _.rows.splice(absIndex, 1);
                                $KD.removeAt(el.scrolee, absIndex);
                            }
                        }

                        _updateIndexes.call(this, rowIndex, secIndex);
                        _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(this);
                    }
                },

                _removesectionat: function SegmentedUI2$_lazyLoad_action_removesectionat(secIndex, rowIndex, anim) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        $KU =$K.utils, _ = this._kwebfw_, clones = null,
                        el = $KW.el(this), rows = [], cloneModels = [];

                    clones = _.clones[secIndex];
                    $KU.each(_.rows, function(row, nodeIndex) {
                        var index = _deduceIndex.call(this, row);
                        if(index[0] === secIndex) {
                            rows.push($KD.childAt(el.scrolee, nodeIndex));
                        }
                    }, this);

                    $KU.each(clones[1], function(clone/*, index*/) {
                        if(clone && $KU.is(clone, 'widget') && clone.isVisible) {
                            cloneModels.push(clone);
                        }
                    });
                    _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.REMOVE, cloneModels);
                    _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'removesectionat', rows, rowIndex, secIndex, anim);
                },

                _removeSectionAt: function SegmentedUI2$_lazyLoad_action_removeSectionAt(secIndex, rowIndex) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        $KU =$K.utils, _ = this._kwebfw_, absIndex = -1, delCount = 0,
                        el = $KW.el(this), firstRowIndex = [], lastRowIndex = [],
                        rows = _.rows;

                    if(_.searcher) {
                        _searcher.SegmentedUI2.updateFilterResult.call(this);
                    }
                    if($KW.visible(this)) {
                        _.hasScroll = _lazyLoad.SegmentedUI2._hasScroll.call(this, el);

                        firstRowIndex = _deduceIndex.call(this, _getFirstRederedRow.call(this));
                        lastRowIndex = _deduceIndex.call(this, _getLastRenderedRow.call(this));

                        if(secIndex >= firstRowIndex[0] && secIndex <= lastRowIndex[0]) {
                            $KU.each(rows, function(row, rowindex) {
                                rowIndex = _deduceIndex.call(this, row);
                                if(rowIndex[0] === secIndex && row.isVisible) {
                                    if(absIndex === -1) {
                                        absIndex = rowindex;
                                    }
                                    $KD.removeAt(el.scrolee, absIndex);
                                    delCount++;
                                }
                            }, this);
                            _.rows.splice(absIndex, delCount);
                        }
                        _updateIndexes.call(this, secIndex, -1);
                        _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(this);
                    }
                },

                _setDataAt: function SegmentedUI2$_lazyLoad_action_setDataAt(secIndex, rowIndex, widgetdata, anim) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                        clone = null, el = $KW.el(this), _ = this._kwebfw_, rowNode = null,
                        data = _.prop.data, needToTouchView = false, section = _isSectionDS(data[0]),
                        lastRowIndex = null, firstRowIndex = null, absIndex = null, prevIndex = null;

                    if(_.searcher) {
                        _searcher.SegmentedUI2.updateFilterResult.call(this);
                    }

                    if($KW.visible(this)) {
                        _.hasScroll = _lazyLoad.SegmentedUI2._hasScroll.call(this, el);

                        if(section && _.clones[secIndex][1][rowIndex]) {
                            _flushClones(_.clones[secIndex][1][rowIndex]);
                            _.clones[secIndex][1][rowIndex] = undefined;
                        } else if(!section && _.clones[rowIndex]) {
                            _flushClones(_.clones[rowIndex]);
                            _.clones[rowIndex] = undefined;
                        }

                        firstRowIndex = _deduceIndex.call(this, _getFirstRederedRow.call(this));
                        lastRowIndex = _deduceIndex.call(this, _getLastRenderedRow.call(this));
                        needToTouchView = _lazyLoad.SegmentedUI2._needToTouchView(secIndex, rowIndex, firstRowIndex, lastRowIndex, section);

                        if(needToTouchView) {
                            clone = _getClonedTemplate.call(this, [secIndex, rowIndex]);

                            //if the row can be rendered, them clone is not null
                            if(clone) {
                                rowNode = _renderRows.call(this, [clone]);

                                absIndex = _lazyLoad.SegmentedUI2._absoluteIndexInRows.call(this, secIndex, rowIndex, true);
                                prevIndex = _deduceIndex.call(this, _.rows[absIndex]);

                                if(secIndex !== prevIndex[0] || (secIndex === prevIndex[0] && rowIndex !== prevIndex[1])) {
                                    _.rows.splice(absIndex, 0, clone);
                                    $KD.addAt(el.scrolee, rowNode, absIndex);
                                } else {
                                    _.rows[absIndex] = clone;
                                    $KD.replace(rowNode, $KD.childAt(el.scrolee, absIndex));
                                }
                                if(_.searcher) {
                                    _searcher.SegmentedUI2.updateSearchText.call(this, clone);
                                }
                                _lazyLoad.SegmentedUI2._getRowsHeight.call(this, [clone]);

                                if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                                    _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.UPDATE, [clone]);
                                    _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'setdataat', rowNode, rowIndex, secIndex, anim);
                                }
                            } else {
                                //if the row cannot be rendered in case of visibility false on row template,
                                //then clone will be null
                                absIndex = _lazyLoad.SegmentedUI2._absoluteIndexInRows.call(this, secIndex, rowIndex, false);

                                //if the clone is null, and the row is already present in view port we need to remove it
                                if(absIndex >= 0) {
                                    _.rows.splice(absIndex, 1);
                                    $KD.removeAt(el.scrolee, absIndex);
                                }
                            }
                        }

                        if(secIndex < firstRowIndex[0] || (secIndex === firstRowIndex[0] && rowIndex < firstRowIndex[1])) {
                            _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'top', [secIndex, rowIndex]);
                        }
                        if(secIndex > lastRowIndex[0] || (secIndex === lastRowIndex[0] && rowIndex > lastRowIndex[1])) {
                            _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'bottom');
                        }

                        _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(this);
                    }
                },

                _setSectionAt: function SegmentedUI2$_lazyLoad_action_setSectionAt(secIndex, rowIndex, newdata, anim) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, removedHeight = 0,
                        clones = [], el = $KW.el(this), _ = this._kwebfw_, data = _.prop.data,
                        firstRowIndex = null, lastRowIndex = null, rows = [];

                    //Add new data to data
                    data.splice(secIndex, 1, newdata);

                    //Handle Search
                    if(_.searcher) {
                        _searcher.SegmentedUI2.updateFilterResult.call(this);
                    }

                    if($KW.visible(this)) {
                        _.hasScroll = _lazyLoad.SegmentedUI2._hasScroll.call(this, el);

                        //Remove old section from clone and create space for new section
                        _flushClones([_.clones[secIndex]]);
                        _.clones.splice(secIndex, 1, new Array(2));
                        _.clones[secIndex][1] = new Array(data[secIndex][1].length);

                        //update Indices
                        _updateIndexes.call(this, secIndex, -1);

                        //get firstRowIndex and lastRowIndex in the view port
                        firstRowIndex = _deduceIndex.call(this, _getFirstRederedRow.call(this));
                        lastRowIndex = _deduceIndex.call(this, _getLastRenderedRow.call(this));

                        if(firstRowIndex[0] === -1 && firstRowIndex[1] === -1) {
                            //if there are no rows in the view port, render from first section
                            _lazyLoad.SegmentedUI2._renderFromIndex.call(this, [secIndex, -1], el);
                        } else if(secIndex === firstRowIndex[0]) {
                            //if the section to be set is 1st section in the view port, remove all rows from the view port
                            //and re-render from the given section index
                            removedHeight = el.scrolee.scrollHeight;
                            this._kwebfw_.rows = [];
                            $KD.html(el.scrolee, '');
                            _lazyLoad.SegmentedUI2._addRowsTillGivenHeight.call(this, removedHeight, [secIndex, firstRowIndex[1]]);
                            //Check scroll Height and add Top buffer
                            _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'top', [secIndex, -1]);
                        } else if(secIndex > firstRowIndex[0] && secIndex <= lastRowIndex[0]) {
                            //if the section to be set with in the view port, then remove all rows from the given section index
                            //and re-render from the given section index
                            removedHeight = _lazyLoad.SegmentedUI2._removeRowsFromViewFromIndex.call(this, [secIndex, rowIndex]);
                            _lazyLoad.SegmentedUI2._addRowsTillGivenHeight.call(this, removedHeight);
                            //Check scroll Height and add Bottom buffer
                            _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'bottom');
                        } else {
                            if(secIndex < firstRowIndex[0]) {
                                //Check scroll Height and add Top buffer
                                _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'top', [secIndex, -1]);
                            } else if(secIndex > lastRowIndex[0]) {
                                //Check scroll Height and add bottom buffer
                                _lazyLoad.SegmentedUI2._checkScrollHeightandAddBufferByDir.call(this, el, 'bottom');
                            }
                        }
                        _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(this);

                        //Handle Animation
                        if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                            _lazyLoad.SegmentedUI2._getRowsToAnimate.call(this, secIndex, rowIndex, clones, rows);
                            _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.UPDATE, clones);
                            _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'addsectionat', rows, -1, -1, anim);
                        }
                    }
                }
            },

            _addBottomBuffer: function SegmentedUI2$_lazyLoad_addBottomBuffer(bufferSize, index) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    count = _lazyLoad.SegmentedUI2._getNextRenderableRowCount(),
                    el = $KW.el(this), lastRow = null, rows = null, nextRowObj = null;

                if(!index) {
                    lastRow = _getLastRenderedRow.call(this);

                    // if the last row is null which means there are no rows in the view port then return
                    if(!lastRow) {
                        return;
                    }

                    index = _deduceIndex.call(this, lastRow);
                }

                //Add row to bottom till bufferSize
                while(bufferSize > 0) {
                    nextRowObj = _lazyLoad.SegmentedUI2._getNextRenderableRows.call(this, index, count, 'bottom');
                    rows = nextRowObj.rows;
                    index = nextRowObj.index;

                    if(!rows.length) {
                        break;
                    }

                    _lazyLoad.SegmentedUI2._addRows.call(this, 'bottom', rows);

                    this._kwebfw_.rows = this._kwebfw_.rows.concat(rows);
                    bufferSize = bufferSize - _lazyLoad.SegmentedUI2._getRowsHeight.call(this, rows);
                }

                //set bottom parity
                _lazyLoad.SegmentedUI2._keepBottomParity.call(this, el);
            },

            //this function will add row to view in bottom and then top direction till given height
            _addRowsTillGivenHeight : function SegmentUI2$_lazyLoad_addRowsTillGivenHeight(height, firstIndexToRender) {
                var index = [-1, -1], lastRow = null, firstRow = null, rowsObject = null,
                    rows = [];

                if(height === 0) return;

                var addRowsToViewByDir = function(count, dir, index) {
                    var nextRowObj = null, rows = [];

                    nextRowObj = _lazyLoad.SegmentedUI2._getNextRenderableRows.call(this, index, count, dir);
                    rows = nextRowObj.rows;
                    index = nextRowObj.index;

                    _lazyLoad.SegmentedUI2._addRows.call(this, dir, rows);

                    return nextRowObj;
                };

                if(firstIndexToRender) {
                    height = height - _lazyLoad.SegmentedUI2._renderFirstRow.call(this, firstIndexToRender);
                }

                //Add rows To bottom
                lastRow = _getLastRenderedRow.call(this);

                if(lastRow) {
                    index = _deduceIndex.call(this, lastRow);

                    while(height > 0) {
                        rowsObject = addRowsToViewByDir.call(this, 1, 'bottom', index);
                        rows = rowsObject.rows;
                        index = rowsObject.index;

                        if(!rows.length) {
                            break;
                        }

                        this._kwebfw_.rows = this._kwebfw_.rows.concat(rows);
                        height = height - _lazyLoad.SegmentedUI2._getRowsHeight.call(this, rows);
                    }
                }

                // Add rows to top
                firstRow = _getFirstRederedRow.call(this);

                if(firstRow) {
                    index = _deduceIndex.call(this, firstRow);

                    while(height > 0) {
                        rowsObject = addRowsToViewByDir.call(this, 1, 'top', index);
                        rows = rowsObject.rows;
                        index = rowsObject.index;

                        if(!rows.length) {
                            break;
                        }

                        this._kwebfw_.rows = rows.concat(this._kwebfw_.rows);
                        height = height - _lazyLoad.SegmentedUI2._getRowsHeight.call(this, rows);
                    }
                }
            },

            _addTopBuffer: function SegmentedUI2$_lazyLoad_addTopBuffer(bufferSize, index) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    count = _lazyLoad.SegmentedUI2._getNextRenderableRowCount(),
                    el = $KW.el(this), firstRow = null, nextRowObj = null, rows= null;

                if(!index) {
                    firstRow = _getFirstRederedRow.call(this);

                    if(!firstRow) {
                        return;
                    }

                    index = _deduceIndex.call(this, firstRow);
                }

                while(bufferSize > 0) {
                    nextRowObj = _lazyLoad.SegmentedUI2._getNextRenderableRows.call(this, index, count, 'top');
                    rows = nextRowObj.rows;
                    index = nextRowObj.index;

                    if(!rows.length) {
                        break;
                    }

                    _lazyLoad.SegmentedUI2._addRows.call(this, 'top', rows);
                    this._kwebfw_.rows = rows.concat(this._kwebfw_.rows);
                    bufferSize = bufferSize - _lazyLoad.SegmentedUI2._getRowsHeight.call(this, rows);
                }

                _lazyLoad.SegmentedUI2._keepTopParity.call(this, el);
            },

            _addRows: function SegmentedUI2$_lazyLoad_addRows(direction, rows) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, el = $KW.el(this);

                if(!rows.length) {
                    return;
                }

                if(direction === 'bottom') {
                    $KD.add(el.scrolee, _renderRows.call(this, rows));
                } else if(direction === 'top') {
                    if(!el.scrolee.children.length) {
                        $KD.add(el.scrolee, _renderRows.call(this, rows));
                    } else {
                        $KD.addAt(el.scrolee, _renderRows.call(this, rows), 0);
                    }
                }
            },

            _adjustRowsOnViewUpdate: function SegmentedUI2$_lazyLoad_adjustRowsOnViewUpdate() {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_, el = $KW.el(this),
                    bufferSize = _lazyLoad.SegmentedUI2._getBufferSize.call(this), heightDiff = 0,
                    rowsHeight = _lazyLoad.SegmentedUI2._getRowsHeight.call(this, _.rows),
                    segHeight = _.prop.frame.height, rootContainer = $KW.getRootNode(this);

                if(_.rows.length > 0) {
                    if(rowsHeight <= (segHeight + (2*bufferSize))) {
                        heightDiff = segHeight - rowsHeight;

                        _lazyLoad.SegmentedUI2._addRowsTillGivenHeight.call(this, heightDiff);
                        _lazyLoad.SegmentedUI2._addTopBuffer.call(this, bufferSize);
                        _lazyLoad.SegmentedUI2._addBottomBuffer.call(this, bufferSize);

                        //All Rows in the view should go for relayout in twoCases
                        //case1 : Segment without scroll, on Updation scroll bar added
                        //case2 : Segment with scroll, on Updation scroll bar removed
                        if(_lazyLoad.SegmentedUI2._hasScroll.call(this, el) !== _.hasScroll) {
                            //Mark the segment for relayout only if there is a difference
                            //in hasScroll Flag already stored in the model and after updating
                            $KW.markRelayout(this);
                            rootContainer.forceLayout();
                        }
                    } else {
                        _lazyLoad.SegmentedUI2._keepTopParity.call(this, el);
                        _lazyLoad.SegmentedUI2._keepBottomParity.call(this, el);
                    }

                    _applyNodeStyles.call(this);
                    _lazyLoad.SegmentedUI2._handleSelectionBehavior.call(this);
                    this._kwebfw_.scrollTop = el.node.scrollTop;
                } else if(_.prop.data && _.prop.data.length) {
                    if(_isSectionDS(_.prop.data[0])) {
                        _lazyLoad.SegmentedUI2._renderFromIndex.call(this, [0, -1], el);
                    } else {
                        _lazyLoad.SegmentedUI2._renderFromIndex.call(this, [-1, 0], el);
                    }
                } else {
                    //if there are no rows in the view and the data is empty, then reset parities to 0px
                    _lazyLoad.SegmentedUI2._resetParity.call(this, el);
                }
            },

            _applySkin: function(li, clone, index) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    ii = clone._kwebfw_.ii, prop = this._kwebfw_.prop,
                    rowSkin = prop.rowSkin;

                if(ii.indexOf(',-1') !== -1) {
                    $KD.setAttr(li, 'class', prop.sectionHeaderSkin);
                } else {
                    if(prop.alternateRowSkin) {
                        if(index % 2 !== 0) {
                            rowSkin = prop.alternateRowSkin;
                        }
                    }

                    $KD.setAttr(li, 'class', rowSkin);
                }
            },

            _canAddRow: function SegmentedUI2$_lazyLoad_canAddRow(row) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, flag = false;

                if($KU.is(row, 'widget') && $KW.visible(row)) {
                    flag = true;
                }

                return flag;
            },

            _checkScrollHeightandAddBufferByDir: function SegmentedUI2$_lazyLoad_checkScrollHeightandAddBufferByDir(el, dir, index) {
                var bufferSize = _lazyLoad.SegmentedUI2._getBufferSize.call(this),
                    segHeight = this._kwebfw_.prop.frame.height, scrollHeight = 0;

                if(dir === 'bottom') {
                    //if the direction is bottom get the scrollBottom
                    scrollHeight = (el.node.scrollHeight - el.node.scrollTop) - segHeight;

                    //if the scroll Bottom is less than buffer size, add Bottom buffer
                    if(scrollHeight <= bufferSize) {
                        _lazyLoad.SegmentedUI2._addBottomBuffer.call(this, bufferSize);
                        _lazyLoad.SegmentedUI2._removeTopBuffer.call(this, bufferSize);
                    }
                } else if(dir === 'top') {
                    //if the direction is top get the scrolTop
                    scrollHeight = el.node.scrollTop;

                    if(scrollHeight === 0) {
                        //if the scroll Top is 0, then render from the given index
                        _lazyLoad.SegmentedUI2._renderFromIndex.call(this, index, el);
                    } else if(scrollHeight <= bufferSize) {
                        //if the scroll Top less than bufferSize, then just add TopBuffer and remove bottom buffer
                        _lazyLoad.SegmentedUI2._addTopBuffer.call(this, bufferSize);
                        _lazyLoad.SegmentedUI2._removeBottomBuffer.call(this, bufferSize);
                    }
                }
            },

            _deduceHeightTillSelectedIndex: function SegmentedUI2$_lazyLoad_deduceHeightTillSelectedIndex(el, selectedIndex) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, height = 0, rows = this._kwebfw_.rows,
                    rowIndex = selectedIndex[1], sectionIndex = selectedIndex[0], self = this,
                    topscroleeHeight = el.topscrolee.offsetHeight;

                $KU.each(rows, function(clone) {
                    var currentIndex = [];

                    currentIndex = _deduceIndex.call(self, clone);

                    if(currentIndex[0] === sectionIndex && currentIndex[1] === rowIndex) {
                        return true;
                    }

                    height += clone._kwebfw_.rowHeight;
                });

                return (height + topscroleeHeight);
            },

            _absoluteIndexInRows: function SegmentedUI2$_lazyLoad_absoluteIndexInRows(secIndex, rowIndex, getNext) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, rows = this._kwebfw_.rows,
                    absIndex = -1, index = [-1, -1], data = this._kwebfw_.prop.data;

                if(!_isSectionDS(data[0])) {
                    secIndex = -1;
                }

                $KU.each(rows, function(row, rindex) {
                    index = _deduceIndex.call(this, row);
                    if(index[0] === secIndex && index[1] === rowIndex) {
                        absIndex = rindex;
                    }
                }, this);

                if(absIndex === -1 && getNext) {
                    index[0] = secIndex;
                    index[1] = rowIndex;
                    index = _lazyLoad.SegmentedUI2._updateIndexWithDirection.call(this, index, 'bottom');
                    absIndex = _lazyLoad.SegmentedUI2._absoluteIndexInRows.call(this, index[0], index[1], getNext);
                }

                return absIndex;
            },

            _getBufferSize: function SegmentedUI2$_lazyLoad_getBufferSize() {
                return 200;
            },

            _getNextRenderableRowCount: function SegmentedUI2$_lazyLoad_getNextRenderableRowCount() {
                return 2;
            },

            _getNextRenderableRows: function SegmentedUI2$_lazyLoad_getNextRenderableRows(index, count, dir) {
                var row = null, rows = [], data = this._kwebfw_.prop.data,
                    obj = {rows : rows, index : index}, temp = null;

                index = _lazyLoad.SegmentedUI2._getNextIndexByDirection.call(this, index, dir, data);
                while(count > 0 && index) {// if count exceed bottom most or topmost
                    row = _lazyLoad.SegmentedUI2._getRow.call(this, index);

                    if(dir === 'bottom') {
                        if(_lazyLoad.SegmentedUI2._canAddRow.call(this, row)) {
                            rows.push(row);
                        } else {
                            temp = _lazyLoad.SegmentedUI2._getNextRenderableRows.call(this, index, 1, 'bottom');
                            rows = rows.concat(temp.rows);
                            index = temp.index;
                        }
                    } else {
                        if(_lazyLoad.SegmentedUI2._canAddRow.call(this, row)) {
                            rows.unshift(row);
                        } else {
                            temp = _lazyLoad.SegmentedUI2._getNextRenderableRows.call(this, index, 1, 'top');
                            rows = temp.rows.concat(rows);
                            index = temp.index;
                        }
                    }
                    obj.index = index;
                    obj.rows = rows;
                    index = _lazyLoad.SegmentedUI2._getNextIndexByDirection.call(this, index, dir, data);
                    count--;
                }

                return obj;
            },

            _getRow: function SegmentedUI2$_lazyLoad_getRow(index) {
                var _ = this._kwebfw_, row = null;

                //this internal function checks for index in the clones and returns valid row
                var _getRowIfCached = function() {
                    var clones = _.clones, data = _.prop.data[0];

                    if(_isSectionDS(data)) {
                        if(index[1] === -1) {
                            if(clones[index[0]][0] !== undefined) {
                                row = clones[index[0]][0];
                            }
                        } else {
                            if(clones[index[0]][1][index[1]] !== undefined) {
                                row = clones[index[0]][1][index[1]];
                            }
                        }
                    } else {
                        if(clones[index[1]] !== undefined) {
                            row = clones[index[1]];
                        }
                    }
                    return row;
                };

                row = _getRowIfCached();

                //if the row is not in clone, then clone the row
                if(!row) {
                    row = _getClonedTemplate.call(this, index);
                }

                return row;
            },

            _getRowsHeight: function SegmentedUI2$_lazyLoad_getRowsHeight(rows) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, height = 0,
                    prop = this._kwebfw_.prop, separatorThickness = 0;

                if(prop.separatorRequired) {
                    separatorThickness = prop.separatorThickness;
                }

                $KU.each(rows, function(clone/*, index*/) {
                    if(typeof clone._kwebfw_.rowHeight === 'undefined') {
                        //TO-DO - do we need to have it for fixed template?
                        clone.forceLayout();
                        clone._kwebfw_.rowHeight = clone._kwebfw_.view.offsetHeight;
                        clone._kwebfw_.prop.doLayout = _lazyLoad.SegmentedUI2._wrapDoLayout.call(this, clone.doLayout);
                    }
                    height += (clone._kwebfw_.rowHeight + separatorThickness);
                }, this);

                return height;
            },

            _getAverageRowHeight: function SegmentedUI2$_lazyLoad_getAverageRowHeight() {
                var _ = this._kwebfw_, rows = _.rows, avgRowHeight = 0,
                    rowsHeight = _lazyLoad.SegmentedUI2._getRowsHeight.call(this, rows);

                avgRowHeight = (rowsHeight/rows.length).toFixed();

                return avgRowHeight;
            },

            _getTotalHeight: function SegmentedUI2$_lazyLoad_getTotalHeight() {
                var noOfRows = _getRowCount.call(this), totalHeight = 0,
                    avgRowHeight = _lazyLoad.SegmentedUI2._getAverageRowHeight.call(this);

                totalHeight = avgRowHeight * noOfRows;

                return totalHeight;
            },

            _getRowsToAnimate : function SegmentedUI2$_lazyLoad_getRowsToAnimate(sectionIndex, rowIndex, clones, rowNodes) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, rows = this._kwebfw_.rows,
                    absoluteRowIndex = -1, index = [];

                absoluteRowIndex = _lazyLoad.SegmentedUI2._absoluteIndexInRows.call(this, sectionIndex, rowIndex);

                for(absoluteRowIndex; absoluteRowIndex < rows.length; absoluteRowIndex++) {
                    index = _deduceIndex.call(this, rows[absoluteRowIndex]);

                    if(index[0] !== sectionIndex) {
                        break;
                    }

                    clones.push(rows[absoluteRowIndex]);
                    //push li's for animation
                    rowNodes.push($KD.parent(rows[absoluteRowIndex]._kwebfw_.view));
                }
            },

            //This function takes absolute value and returns the valid row index for the given value
            _getIndexFromAbsoluteValue: function SegmentedUI2$_lazyLoad_getIndexFromAbsoluteValue(value) {
                var _ = this._kwebfw_, data = _.prop.data, rowCount = _getRowCount.call(this),
                    sectionIndex = -1, rowIndex = -1, noOfSections = 0, rowsInSection = 0,
                    index = 0;

                if(_isSectionDS(data[0])) {
                    noOfSections = data.length;

                    if(value >= rowCount) {
                        sectionIndex = noOfSections - 1; //last section
                        rowIndex = data[noOfSections - 1][1].length - 1; // last row in last section
                    } else {
                        for(index = 0; index < noOfSections; index++) {
                            rowsInSection = data[index][1].length;
                            if(value <= rowsInSection) {
                                sectionIndex = index;
                                rowIndex = value - 1;
                                break;
                            } else {
                                value = value - (rowsInSection + 1); // considering section also as a row
                            }
                        }
                    }
                } else {
                    if(value >= rowCount) {
                        rowIndex = rowCount - 1;
                    } else {
                        rowIndex = value;
                    }
                }

                return [sectionIndex, rowIndex];
            },

            _getUpdatedRowHeight: function SegmentedUI2$_lazyLoad_getUpdatedRowHeight(row) {
                var rowHeight = 0, prop = this._kwebfw_.prop, separatorThickness = 0;

                if(prop.separatorRequired) {
                    separatorThickness = prop.separatorThickness;
                }

                if(row) {
                    rowHeight = row._kwebfw_.rowHeight;
                }

                return (rowHeight + separatorThickness);
            },

            //this function checks if the node contains scrollbar or not
            _hasScroll: function SegmentedUI2$_lazyLoad_hasScroll(el) {
                if(el.node.scrollHeight === this._kwebfw_.prop.frame.height) {
                    //if the scrollHeight and frameHeight is same then, there is no scrollbar, so returns false
                    return false;
                }

                return true;
            },

            //set top scrolee height
            _keepTopParity: function SegmentedUI2$_lazyLoad_keepTopParity(el, height) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, topScroleeHeight = el.topscrolee.offsetHeight,
                    topHeight = 0, firstRow = null, index = [], nextRow = null;

                if(height === undefined) {
                    //get first rendered row
                    firstRow = _getFirstRederedRow.call(this);
                    index = _deduceIndex.call(this, firstRow);

                    //get next renderable row
                    nextRow = _lazyLoad.SegmentedUI2._getNextRenderableRows.call(this, index, 1, 'top');
                    // if there is no next renderable row, then top parity height should be 0
                    if(nextRow.rows.length) {
                        //absolute index gives the gives the number of rows till the given index with/without section
                        topHeight = _absoluteIndexInData.call(this, index) * _lazyLoad.SegmentedUI2._getAverageRowHeight.call(this);
                    }
                } else {
                    topHeight = topScroleeHeight + height;
                }

                if(topHeight === 0) {
                    this._kwebfw_.topPendingHeight = -(_lazyLoad.SegmentedUI2._getBufferSize.call(this));
                }

                $KD.style(el.topscrolee, {height : topHeight+'px'});
            },

            //set bottom scrolee height and top
            _keepBottomParity: function SegmentedUI2$_lazyLoad_keepBottomParity(el, height) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, bottomHeight = 0, bottomScrolleeHeight = el.bottomscrolee.offsetHeight,
                    lastRow = null, nextRow = null, index = [], top = 0;

                if(height === undefined) {
                    lastRow = _getLastRenderedRow.call(this);
                    index = _deduceIndex.call(this, lastRow);
                    nextRow = _lazyLoad.SegmentedUI2._getNextRenderableRows.call(this, index, 1, 'bottom');

                    if(nextRow.rows.length) {
                        bottomHeight = (_getRowCount.call(this) - _absoluteIndexInData.call(this, index)) * _lazyLoad.SegmentedUI2._getAverageRowHeight.call(this);
                    }
                } else {
                    bottomHeight = bottomScrolleeHeight + height;
                }

                if(bottomHeight === 0) {
                    this._kwebfw_.bottomPendingHeight = -(_lazyLoad.SegmentedUI2._getBufferSize.call(this));
                }

                //As the UL(scrolee) height is 100%, if the content inside the UL(scrolee) exceeds 100%
                //then fix the top of the bottomscrolee by calculating top as below
                top = el.scrolee.scrollHeight - el.scrolee.offsetHeight;

                $KD.style(el.bottomscrolee, {height : bottomHeight+'px', top : top+'px'});
            },

            //This function returns a boolean whether there is a need to touch the view or not on update openations
            _needToTouchView: function SegmentUI2$_lazyLoad_needToTouchView(secIndex, rowIndex, firstRowIndex, lastRowIndex, isSection) {
                var flag = false;

                //in case of section, need to touch view in four cases
                //case1 : if the given section index is the only section in the view and given rowIndex is with in the view
                //case2 : if the given section index is equals to firstSection in the view and given rowIndex is with in the view
                //case3 : if the given section index is equals to lastSection in the view and given rowIndex is with in the view
                //case4 : if the given section index is between first and last section in the view
                if(isSection) {
                    if(((secIndex === firstRowIndex[0] && secIndex === lastRowIndex[0])
                    && (rowIndex >= firstRowIndex[1] && rowIndex <= lastRowIndex[1]))
                    || ((secIndex === firstRowIndex[0] && secIndex !== lastRowIndex[0]) && rowIndex >= firstRowIndex[1])
                    || ((secIndex === lastRowIndex[0] && secIndex !== firstRowIndex[0]) && rowIndex <= lastRowIndex[1])
                    || (secIndex > firstRowIndex[0] && secIndex < lastRowIndex[0])) {
                        flag =true;
                    }
                } else { // in case of with out section, if the given rowindex is between firstRowIndex and lastRowIndex
                    if(rowIndex >= firstRowIndex[1] && rowIndex <= lastRowIndex[1]) {
                        flag =true;
                    }
                }

                return flag;
            },

            _onScroll : function SegmentedUI2$_lazyLoad_onScroll(scrollTop) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, el = $KW.el(this), delta = 0,
                    bufferSize = _lazyLoad.SegmentedUI2._getBufferSize(), _ = this._kwebfw_, sections = [],
                    segHeight = this._kwebfw_.prop.frame.height, index = [], rowHeight = 0, rowToRender = null;


                if(this._kwebfw_.scrollTop === scrollTop) {
                    return;
                }

                delta = Math.abs(this._kwebfw_.scrollTop - scrollTop);

                if(delta > (segHeight + bufferSize)) { // To handle the fast scroll
                    rowHeight = _lazyLoad.SegmentedUI2._getAverageRowHeight.call(this);
                    rowToRender = parseInt((scrollTop / rowHeight).toFixed());
                    index = _lazyLoad.SegmentedUI2._getIndexFromAbsoluteValue.call(this, rowToRender);

                    _lazyLoad.SegmentedUI2._renderFromIndex.call(this, index, el);
                } else {
                    if(scrollTop > this._kwebfw_.scrollTop) {
                        //scroll down
                        if(delta > bufferSize) {
                            _lazyLoad.SegmentedUI2._addBottomBuffer.call(this, delta);
                            _lazyLoad.SegmentedUI2._removeTopBuffer.call(this, bufferSize);
                            _applyNodeStyles.call(this);
                            _lazyLoad.SegmentedUI2._handleSelectionBehavior.call(this);
                            this._kwebfw_.scrollTop = scrollTop;
                        }
                    } else {
                        //scroll up
                        if(delta > bufferSize) {
                            _lazyLoad.SegmentedUI2._addTopBuffer.call(this, delta);
                            _lazyLoad.SegmentedUI2._removeBottomBuffer.call(this, bufferSize);
                            _applyNodeStyles.call(this);
                            _lazyLoad.SegmentedUI2._handleSelectionBehavior.call(this);
                            this._kwebfw_.scrollTop = scrollTop;
                        }
                    }
                }

                if(_isSectionDS(_.prop.data[0]) && _.searcher) {
                    $KU.each(_.rows, function(record, index) {
                        sections.push(index);
                    });
                    _searcher.SegmentedUI2.updateHeaderVisibility.call(this, sections, _.searcher.filterResultWithHeader);
                }
            },

            //This function remove Rows from given given Index in the view port and returns removed height
            _removeRowsFromViewFromIndex: function SegmentedUI2$_lazyload_removeRowsFromViewFromIndex(index) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, $KU = $K.utils, absIndex = -1,
                    _ = this._kwebfw_, rows = _.rows, secIndex = index[0], el = $KW.el(this), removedHeight = 0, removeCount = 0;

                if(el.node) {
                    $KU.each(rows, function(row, rowindex) {
                        var rowIndex = _deduceIndex.call(this, row);
                        if(rowIndex[0] >= secIndex && row.isVisible) {
                            if(absIndex === -1) {
                                absIndex = rowindex;
                            }

                            removedHeight += row._kwebfw_.rowHeight;
                            $KD.removeAt(el.scrolee, absIndex);
                            removeCount++;
                        }
                    }, this);
                    rows.splice(absIndex, removeCount);
                }

                return removedHeight;
            },

            _removeTopBuffer: function SegmentedUI2$_lazyLoad_removeTopBuffer(bufferSize) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, el = $KW.el(this),
                    rowToRemove = _getFirstRederedRow.call(this), heightToRemove = 0,
                    parityHeight = 0;

                bufferSize = bufferSize + this._kwebfw_.topPendingHeight;

                if(bufferSize < 0) {
                    return;
                }

                heightToRemove = _lazyLoad.SegmentedUI2._getUpdatedRowHeight.call(this, rowToRemove);

                while(heightToRemove < bufferSize) {
                    //Remove From View
                    $KD.removeAt(el.scrolee, 0);

                    //remove from rows
                    this._kwebfw_.rows.shift();

                    //update top parity
                    parityHeight += heightToRemove;


                    bufferSize = bufferSize - heightToRemove;
                    rowToRemove = _getFirstRederedRow.call(this);
                    heightToRemove = _lazyLoad.SegmentedUI2._getUpdatedRowHeight.call(this, rowToRemove);
                }

                _lazyLoad.SegmentedUI2._keepTopParity.call(this, el, parityHeight);

                this._kwebfw_.topPendingHeight = bufferSize;
            },

            _removeBottomBuffer: function SegmentedUI2$_lazyLoad_removeBottomBuffer(bufferSize) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, el = $KW.el(this),
                    rowToRemove = _getLastRenderedRow.call(this), heightToRemove = 0,
                    parityHeight = 0;

                bufferSize += this._kwebfw_.bottomPendingHeight;

                heightToRemove = _lazyLoad.SegmentedUI2._getUpdatedRowHeight.call(this, rowToRemove);

                while(heightToRemove < bufferSize) {
                    //Remove From View
                    $KD.remove($KD.last(el.scrolee));

                    //remove from rows
                    this._kwebfw_.rows.pop();


                    parityHeight += heightToRemove;
                    bufferSize = bufferSize - heightToRemove;
                    rowToRemove = _getLastRenderedRow.call(this);
                    heightToRemove = _lazyLoad.SegmentedUI2._getUpdatedRowHeight.call(this, rowToRemove);
                }

                _lazyLoad.SegmentedUI2._keepBottomParity.call(this, el, parityHeight);

                this._kwebfw_.bottomPendingHeight = bufferSize;
            },

            //This function render first row in the view port from the given index
            _renderFirstRow : function SegmentedUI2$_lazyLoad_renderFirstRow(index) {
                var nextRowObj = null, height = 0, row = null, rows = [];

                row = _lazyLoad.SegmentedUI2._getRow.call(this, index);

                if(_lazyLoad.SegmentedUI2._canAddRow.call(this, row)) {
                    rows = row && [row];
                } else {
                    nextRowObj = _lazyLoad.SegmentedUI2._getNextRenderableRows.call(this, index, 1, 'bottom');
                    index = nextRowObj.index;
                    rows = nextRowObj.rows;
                }

                if(rows.length) {
                    _lazyLoad.SegmentedUI2._addRows.call(this, 'bottom', rows);

                    this._kwebfw_.rows = this._kwebfw_.rows.concat(rows);
                    height = _lazyLoad.SegmentedUI2._getRowsHeight.call(this, rows);
                }

                return height;
            },

            _renderFromIndex: function SegmentedUI2$_lazyLoad_renderFromIndex(index, el) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                    dir = 'bottom', _ = this._kwebfw_, nextRowObj = null,
                    height = this._kwebfw_.prop.frame.height, row = null,
                    rows = [], selectedIndex = index, scrollTop = null,
                    rootContainer = $KW.getRootNode(this);

                _updateAriaRowCount.call(this, _getRowCount.call(this), el);
                $KD.html(el.scrolee, '');

                this._kwebfw_.rows = [];

                if(height> 0 && el.node && $KW.visible(this)) {
                    //First Row generation
                    if(_.searcher && _getIndex(index, _.searcher.filterResultWithHeader) === -1) {
                        index = _searcher.SegmentedUI2.getNextIndexFromFilterList.call(this, index);
                    }

                    row = _lazyLoad.SegmentedUI2._getRow.call(this, index);

                    if(_lazyLoad.SegmentedUI2._canAddRow.call(this, row)) {
                        rows = row && [row];
                    } else {
                        nextRowObj = _lazyLoad.SegmentedUI2._getNextRenderableRows.call(this, index, 1, dir);
                        index = nextRowObj.index;
                        selectedIndex = index;
                        rows = nextRowObj.rows;
                    }

                    if(rows.length) {
                        _lazyLoad.SegmentedUI2._addRows.call(this, 'bottom', rows);

                        this._kwebfw_.rows = this._kwebfw_.rows.concat(rows);
                        height -= _lazyLoad.SegmentedUI2._getRowsHeight.call(this, rows);
                    }

                    _lazyLoad.SegmentedUI2._addRowsTillGivenHeight.call(this, height);
                    _lazyLoad.SegmentedUI2._addTopBuffer.call(this, _lazyLoad.SegmentedUI2._getBufferSize());
                    _lazyLoad.SegmentedUI2._addBottomBuffer.call(this, _lazyLoad.SegmentedUI2._getBufferSize());
                    _applyNodeStyles.call(this);
                    _lazyLoad.SegmentedUI2._handleSelectionBehavior.call(this);


                    scrollTop = _lazyLoad.SegmentedUI2._deduceHeightTillSelectedIndex.call(this, el, selectedIndex);
                    el.node.scrollTop = scrollTop;
                    this._kwebfw_.scrollTop = el.node.scrollTop;


                    //Added forcelayout to handle layout issues after rows are added in lazy load
                    $KW.markRelayout(this);
                    //To-do : need change to parent.forceLayout Logic
                    rootContainer.forceLayout();
                }
            },

            //This function iterates through the given model and remove from relayout
            _removeFromRelayout: function SegmentedUI2$_lazyload_removeFromRelayout(model) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                $KW.iterate(model, function(widget) {
                    //Iterate over childrens and remove from relayout
                    $KW.removeMarkedLayout(widget);
                });
            },

            //This function sets top scrolee and bottom scrolee height to 0px
            _resetParity : function SegmentedUI2$_lazyLoad_resetParity(el) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.style(el.topscrolee, {height : '0px'});
                $KD.style(el.bottomscrolee, {height : '0px'});
            },

            _setLoadingPlaceholder : function SegmentedUI2$_lazyLoad_setLoadingPlaceholder(el) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils, _ = this._kwebfw_,
                    loadingPlaceholderImage = _.prop.loadingPlaceholderImage,
                    style = null;

                if(!loadingPlaceholderImage) {
                    loadingPlaceholderImage = 'loadingplaceholder.gif';
                }

                style = {
                    'background-image': 'url(' +$KU.getImageURL(loadingPlaceholderImage)+ ')',
                    'background-attachment': 'scroll',
                    'background-repeat': 'repeat-y',
                    'background-position': 'top left'
                };

                $KD.style(el.topscrolee, style);
                $KD.style(el.bottomscrolee, style);
            },

            _handleSelectionBehavior: function SegmentedUI2$_lazyLoad__handleSelectionBehavior() {
                var _ = this._kwebfw_, prop = _.prop;

                if(!prop.selectedRowIndex) {
                    if(prop.selectionBehavior !== constants.SEGUI_DEFAULT_BEHAVIOR) {
                        _updateBehaviorImgs.call(this, true);
                    }
                } else if(prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
                    if(prop.selectionBehavior === constants.SEGUI_SINGLE_SELECT_BEHAVIOR) {
                        _updateBehaviorImgs.call(this, false, _.deSelectedRows, [prop.selectedRowIndex.slice(0)]);
                    } else if(prop.selectionBehavior === constants.SEGUI_MULTI_SELECT_BEHAVIOR) {
                        _updateBehaviorImgs.call(this, false, _.deSelectedRows, _.selectedRows);
                    }
                }
            },

            _getNextIndexByDirection : function(index, dir, data) {
                var nextIndex = null;

                nextIndex = _lazyLoad.SegmentedUI2._updateIndexWithDirection.call(this, index, dir);

                if(!_lazyLoad.SegmentedUI2._validateIndex.call(this, data, nextIndex)) {
                    nextIndex = null;
                }

                return nextIndex;
            },

            _updateIndexWithDirection: function SegmentedUI2$_lazyLoad_updateRowandSectionIndex(index, dir) {
                var _ = this._kwebfw_, secIndex = index[0], rowIndex = index[1], data = this._kwebfw_.prop.data,
                    retIndex = null, filterRes = null, lastIndex;

                if(_.searcher) {
                    if(_isSectionDS(data[0])) {
                        filterRes = _.searcher.filterResultWithHeader;
                    } else {
                        filterRes = _.searcher.filteredResult;
                    }
                }

                if(dir === 'bottom') {
                    if(filterRes) {
                        if(_isSectionDS(data[0])) {
                            lastIndex = _getIndex([secIndex, rowIndex], filterRes);
                            retIndex = filterRes[lastIndex+1] ? [filterRes[lastIndex+1][0], filterRes[lastIndex+1][1]] : null;
                        } else {
                            lastIndex = _getIndex([0, rowIndex], filterRes);
                            retIndex = filterRes[lastIndex+1] ? [secIndex, filterRes[lastIndex+1][1]] : null;
                        }

                        if(lastIndex === -1) {
                            retIndex = _searcher.SegmentedUI2.getNextIndexFromFilterList.call(this, [secIndex, rowIndex]);
                        }
                    } else {
                        if(_isSectionDS(data[0]) && data[secIndex][1].length - 1 === rowIndex && secIndex !== data.length -1) {
                            retIndex = [++secIndex, -1];
                        } else {
                            retIndex = [secIndex, ++rowIndex];
                        }
                    }
                } else if(dir === 'top') {
                    if(filterRes) {
                        if(_isSectionDS(data[0])) {
                            lastIndex = _getIndex([secIndex, rowIndex], filterRes);
                            retIndex = filterRes[lastIndex-1] ? [filterRes[lastIndex-1][0], filterRes[lastIndex-1][1]] : null;
                        } else {
                            lastIndex = _getIndex([0, rowIndex], filterRes);
                            retIndex = filterRes[lastIndex-1] ? [secIndex, filterRes[lastIndex-1][1]] : null;
                        }
                    } else {
                        if(_isSectionDS(data[0]) && rowIndex === -1 && secIndex !== 0) {
                            secIndex--;
                            retIndex = [secIndex, data[secIndex][1].length-1];
                        } else {
                            retIndex = [secIndex, --rowIndex];
                        }
                    }
                }

                return retIndex;
            },

            _validateIndex: function SegmentedUI2$_lazyLoad_validateIndex(data, index) {
                var firstRowIndex = -1, lastRowIndex = -1, lastSectionIndex = -1, flag = false;

                if(index && _isSectionDS(data[0])) {
                    lastSectionIndex = data.length - 1;

                    if(index[0] >= 0 && index[0] <= lastSectionIndex) {
                        firstRowIndex = -1;
                        lastRowIndex = data[index[0]][1].length - 1;
                        if(index[1] >= firstRowIndex && index[1] <= lastRowIndex) {
                            flag = true;
                        }
                    }
                } else if(index) {
                    firstRowIndex = 0;
                    lastRowIndex = data.length -1;
                    if(index[1] >= firstRowIndex && index[1] <= lastRowIndex) {
                        flag = true;
                    }
                }

                return flag;
            },

            //doLayout wrapper for clones
            _wrapDoLayout : function SegmentedUI2$_lazyLoad_wrapDoLayout(callback) {
                var self = this;
                var wrapper = function(clone) {
                    if(clone.frame.height !== clone._kwebfw_.rowHeight) {
                        clone._kwebfw_.rowHeight = clone.frame.height;
                        _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(self);
                    }
                    callback && callback.apply(this, arguments);
                };
                return wrapper;
            }
        }
    };


    var _nextPage = function SegmentedUI2$_nextPage(el, swipeContext) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom,
            noOfSwipePages = $KD.children(el.scrolee).length, currentPage = 0;

        currentPage = Math.min(swipeContext.currentPage + 1, noOfSwipePages - 1);
        _setPageViewIndicator.call(this, el, currentPage);
        swipeContext.ignoreRowSelection = true;
    };


    //This function will be called in the scope of widget instance
    var _onDataSet = function SegmentedUI2$_onDataSet() {
        _clearSelectedIndices.call(this);
        _resetBookKeepers.call(this);
    };


    //This function will be called in the scope of widget instance
    var _onRowChange = function SegmentedUI2$_onRowChange(secIndex, rowIndex, action, data, anim) {
        //<action> can be one of "add" / "remove" / "update"/ addsectionat, setsectionat, removesectionat, addall
        var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this);

        if(secIndex === -1 && rowIndex === -1) return;

        if(['add', 'update', 'remove'].indexOf(action) !== -1
        && !_isSectionDS(this._kwebfw_.prop.data[0])) secIndex = -1;

        if(action === 'addsectionat') {
            _action.SegmentedUI2[action].call(this, secIndex, rowIndex, data, true, anim);
        } else {
            _action.SegmentedUI2[action].call(this, secIndex, rowIndex, data, anim);
        }

        if(el.node && this._kwebfw_.prop.viewType === constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
            _setPageView.call(this, el);
        }

        if(el.scrolee) {
            _updateAriaRowCount.call(this, _getRowCount.call(this), el);
        }

        //Apply styles and mark for relayout only if the segment is not enabled for lazy load
        if(!_shouldLazyLoad.call(this)) {
            _applyNodeStyles.call(this);
            $KW.markRelayout(this);
        }
    };

    var _onScrollCallback = function SegmentUI2$_onScrollCallback(segModel, scrollTop) {
        _animator.SegmentedUI2.scrollStart.call(this);
        if(_shouldLazyLoad.call(segModel)) {
            _lazyLoad.SegmentedUI2._onScroll.call(segModel, scrollTop);
        }
    };

    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        SegmentedUI2: function SegmentedUI2$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.SegmentedUI2', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'SegmentedUI2', null);
                }
            }

            if(!_.selectedRows) $KU.defineProperty(_, 'selectedRows', [], null);
            if(!_.deSelectedRows) $KU.defineProperty(_, 'deSelectedRows', [], true);
            if(!_.ui) $KU.defineProperty(_, 'ui', {}, null);
            $KU.defineProperty(_.ui, 'scroll', {x:0, y:0, width:-1, height:-1, minX:-1, maxX:-1, minY:-1, maxY:-1, status:'ended'}, true);
            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }

            //This holds the searcher condition and config when searchText API invoked
            if(!_.searcher) $KU.defineProperty(_, 'searcher', null, true);

            //This holds the swipe context of page view
            if(!_.swipeContext) $KU.defineProperty(_, 'swipeContext', null, true);

            /* ====================== Book keeping properties starts here ====================== */

            //This holds the cloned templates, those will be rendered, and it is a flat list
            if(!_.rows) $KU.defineProperty(_, 'rows', [], true);

            //This holds the cloned templates, in the same DS as that of this.data
            if(!_.clones) $KU.defineProperty(_, 'clones', [], true);

            //This holds prev segment height of the segment to prevent from re-render if height doesnt change
            if(typeof _.height !== 'number') {
                $KU.defineProperty(_, 'height', 0, true);
            }

            //This holds the last scrolled position
            if(typeof _.scrollTop !== 'number') {
                $KU.defineProperty(_, 'scrollTop', 0, true);
            }

            //This is used in lazyloading which holds remaing height to be added to top buffer
            if(typeof _.topPendingHeight !== 'number') {
                $KU.defineProperty(_, 'topPendingHeight', 0, true);
            }

            //This is used in lazyloading which holds remaing height to be added to bottom buffer
            if(typeof _.bottomPendingHeight !== 'number') {
                $KU.defineProperty(_, 'bottomPendingHeight', 0, true);
            }

            /* ======================= Book keeping properties ends here ======================= */
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        SegmentedUI2: function SegmentedUI2$_postInitialization() {
            this._kwebfw_.invertedDataMap = _getInvertedDataMap(this._kwebfw_.prop.widgetDataMap);
            _onDataSet.call(this);
        }
    };


    //This function will be called in the scope of widget instance
    var _previousPage = function SegmentedUI2$_previousPage(el, swipeContext) {
        var currentPage = 0;

        currentPage = Math.max(swipeContext.currentPage - 1, 0);
        _setPageViewIndicator.call(this, el, currentPage);
        swipeContext.ignoreRowSelection = true;
    };


    //This function will be called in the scope of widget instance
    var _registerSwipeGesture = function SegmentedUI2$_registerSwipeGesture(scrolee) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils;

        $KD.on(scrolee, 'swipe', 'segment', function(g) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                _ = this._kwebfw_, prop = _.prop, el = $KW.el(this);

            if(!$KW.interactable(this)) return; /* ---------------------------------------------- */
            if(prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) return;

            if(g.status === 'started') {
                $KD.style(el.scrolee, 'transition', null);
                if($KU.is(_.swipeContext, 'null')) {
                    _.swipeContext = {};
                    _.swipeContext.imageWidth = el.scrolee.firstChild.offsetWidth;
                    _.swipeContext.currentPage = 0;
                }
                //cnutodo need to update swipeContext whenever there is a change in segment width
            }
            if(g.status === 'moving') {
                _translatePage(el.scrolee, (-(_.swipeContext.imageWidth * _.swipeContext.currentPage) + g.distance.x), 0);
            }
            if(g.status === 'ended') {
                if(g.distance.x <= -7) {
                    _nextPage.call(this, el, _.swipeContext);
                    $KW.fire(this, 'onSwipe', this, {rowIndex:_.swipeContext.currentPage});
                } else if(g.distance.x >= 7) {
                    _previousPage.call(this, el, _.swipeContext);
                    $KW.fire(this, 'onSwipe', this, {rowIndex:_.swipeContext.currentPage});
                } else {
                    _translatePage(el.scrolee, (-(_.swipeContext.imageWidth * _.swipeContext.currentPage)), 0);
                }
            }
        }, {scope:this});
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        SegmentedUI2: function SegmentedUI2$_relayoutActiveTriggerer() {
            return ['data'];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        SegmentedUI2: function SegmentedUI2$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //This function will be called in the scope of widget instance
    var _renderRows = function SegmentedUI2$_renderRows(clones) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, c = 0,
            clen = clones.length, fragment = null,
            createRow = function(clone) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    tag = '', li = null, role = '', row = null, a11y = null,
                    index = _deduceIndex.call(this, clone), height = '',
                    absIndex = (_absoluteIndexInData.call(this, index) + 1);

                tag = _deduceTagName.call(this);
                li = (tag === 'div') ? 'div' : (tag === 'table') ? 'tbody' : 'li';
                li = $KD.create(li);
                $KD.setAttr(li, 'kr', 'item'); //NOTE:: This attr/val has high importance
                $KD.setAttr(li, 'kii', index.join(','));
                $KD.setAttr(li, 'kwh-click', 'onRowClick');
                $KD.setAttr(li, 'kwh-keydown', 'onRowKeyDown');
                $KD.setAttr(li, 'kwh-keyup', 'onRowKeyUp');
                $KD.setAttr(li, 'tabindex', -1);

                if(tag === 'div') {
                    a11y = this._kwebfw_.prop.accessibilityConfig;
                    role = (a11y && a11y.a11yARIA
                         && a11y.a11yARIA.role === 'button')
                        ? 'button' : 'row';

                    $KD.setAttr(li, 'role', role);
                    $KD.setAttr(li, 'aria-rowindex', absIndex);
                }

                row = clone._render();
                height = clone._kwebfw_.flex.final.height;

                $KW.iterate(clone, function(widget) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom,
                        view = widget._kwebfw_.view;

                    if(view && tag === 'div') {
                        $KD.setAttr(view, 'aria-sort', 'none');
                    }
                }, {tabs:false});

                if(height) {
                    $KD.style(row, 'height', '100%');
                    $KD.style(li, 'height', height);
                }

                $KD.add(li, row);

                return li;
            };

        if(clen === 1) {
            fragment = createRow.call(this, clones[0]);
        } else if(clen > 1) {
            fragment = $KD.create();

            for(c=0; c<clen; c++) {
                fragment.appendChild(createRow.call(this, clones[c]));
            }
        }

        return fragment;
    };


    //This function will be called in the scope of widget instance
    var _resetBookKeepers = function SegmentedUI2$_resetBookKeepers(/*callback*/) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, data = this._kwebfw_.prop.data;

        this._kwebfw_.scrollTop = 0;
        _flushClones(this._kwebfw_.clones);
        this._kwebfw_.rows = [];
        this._kwebfw_.clones = [];

        if(data && data.length > 0) {
            if(_isSectionDS(data[0])) {
                this._kwebfw_.clones = new Array(data.length);
                $KU.each(data, function(secItem, secIndex) {
                    this._kwebfw_.clones[secIndex] = new Array(2);
                    this._kwebfw_.clones[secIndex][1] = new Array(secItem[1].length);
                }, this);
            } else if($KU.is(data[0], 'object')) {
                this._kwebfw_.clones = new Array(data.length);
            }
        }
    };

    var _searcher = {
        SegmentedUI2: {
            //This function will be called in the scope of widget instance
            clearSearchResult: function SegmentedUI2$_searcher_clearSearchResult() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, firstRow = null, index = [-1, -1],
                    el = $KW.el(this), li = null;



                if(_shouldLazyLoad.call(this)) {
                    firstRow = _getFirstRederedRow.call(this);
                    index = _deduceIndex.call(this, firstRow);
                    _lazyLoad.SegmentedUI2._renderFromIndex.call(this, index, el);
                } else {
                    _iterateOverData.call(this, this._kwebfw_.clones, function(clone) {
                        if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                            li = $KD.parent(clone._kwebfw_.view);
                            if(li) {
                                $KD.style(li, 'display', 'block');
                            }
                        }
                    });
                }
            },


            convertDateToNumber: function SegmentedUI2$_searcher_convertDateToNumber(dc) {
                var dateNumber, valid = false;

                var isLeapYear = function(year) {
                    var date = new Date(year, 1, 29, 0, 0, 0);
                    return (date.getMonth() === 2) ? false : true;
                };

                var isValidDate = function(date, month, year) {
                    if([1, 3, 5, 7, 8, 10, 12].indexOf(month) !== -1
                    && date >= 1 && date <= 31) {
                        return true;
                    } else if([4, 6, 9, 11].indexOf(month) !== -1
                    && date >= 1 && date <= 30) {
                        return true;
                    } else if(month === 2 && date >= 1) {
                        if(isLeapYear(year)) {
                            if(date <= 29) return true;
                        } else {
                            if(date <= 28) return true;
                        }
                    } else {
                        return false;
                    }
                };

                if(dc instanceof Array && [0, 3, 6].indexOf(dc.length) >= 0) {
                    if(dc.length === 0) {
                        return 0;
                    }

                    //NOTE:: Calendar widget has valid year range from 1900-2099
                    if(typeof dc[2] === 'number' && dc[2] >= 1900 && dc[2] <= 2099
                    && typeof dc[1] === 'number' && dc[1] >= 1 && dc[1] <= 12
                    && isValidDate(dc[0], dc[1], dc[2])) {
                        valid = true;
                        dateNumber = new Date(dc[2], dc[1], dc[0]).getTime();
                    } else return null;

                    if(valid && dc.length === 6
                    && typeof dc[3] === 'number' && dc[3] >= 0 && dc[3] <= 23
                    && typeof dc[4] === 'number' && dc[4] >= 0 && dc[4] <= 59
                    && typeof dc[5] === 'number' && dc[5] >= 0 && dc[5] <= 59) {
                        dateNumber = new Date(dc[2], dc[1], dc[0], dc[3], dc[4], dc[5]).getTime();
                    }
                } else if(dc === null) {
                    return 0;
                } else return null;

                return dateNumber;
            },


            convertStringToNumber: function SegmentedUI2$_searcher_convertStringToNumber(widgetData) {
                var regx = new RegExp(/^\s*((\d+(\.\d+)?)|(\.\d+))\s*$/);

                if(regx.test(widgetData)) {
                    widgetData = parseFloat(widgetData);
                }

                return widgetData;
            },


            createFilterResultWithHeader: function SegmentedUI2$_searcher_createFilterResultWithHeader(filterList) {
                var filterResultWithHeader = JSON.parse(JSON.stringify(filterList)), _ = this._kwebfw_;

                if(_isSectionDS(_.prop.data[0])) {
                    filterResultWithHeader.splice(0, 0, [filterList[0][0], -1]);
                    for(var i = 1; i < filterResultWithHeader.length; i++) {
                        if(filterResultWithHeader[i][0] > filterResultWithHeader[i-1][0]) {
                            filterResultWithHeader.splice(i, 0, [filterResultWithHeader[i][0], -1]);
                        }
                    }
                }
                _.searcher.filterResultWithHeader = filterResultWithHeader;
            },


            //This function will be called in the scope of widget instance
            generateExpression: function SegmentedUI2$_searcher_generateExpression(index, rowData, searchCondition) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, matchStr = '';

                $KU.each(searchCondition, function(condition) {
                    var operator = '||';

                    if($KU.is(condition, 'string')) {
                        if(condition === constants.SEGUI_SEARCH_CRITERIA_OPERATOR_AND) {
                            operator = '&&';
                        }
                        matchStr += (' ' + operator + ' ');
                    } else if($KU.is(condition, 'array')) {
                        matchStr += _searcher.SegmentedUI2.generateExpression.call(this, index, rowData, condition);
                    } else {
                        matchStr += _searcher.SegmentedUI2.isOperandPassed.call(this, index, rowData, condition);
                    }
                }, this);

                return ('(' + matchStr + ')');
            },


            //This function will be called in the scope of widget instance
            getFilteredData: function SegmentedUI2$_searcher_getFilteredData() {
                var filterList = [];

                _iterateOverData.call(this, this._kwebfw_.prop.data, function(rowData, rowIndex, secIndex) {
                    var index = null;

                    if(rowIndex !== -1) {
                        if(secIndex === -1) secIndex = 0;
                        index = [secIndex, rowIndex];

                        if(_searcher.SegmentedUI2.isRowMatchingSearchCriteria.call(this, index, rowData)) {
                            filterList.push(index);
                        }
                    }
                });

                return filterList;
            },


            //This function will be called in the scope of widget instance
            getNextIndexFromFilterList: function SegmentedUI2$_searcher_getNextIndexFromList(index) {
                var _ = this._kwebfw_, list = _.searcher.filterResultWithHeader,
                    i = 0, section = _isSectionDS(_.prop.data[0]),
                    secIndex = index[0], rowIndex = index[1], retIndex = [-1, -1];

                if(!section) secIndex = 0;

                if(secIndex < list[0][0]
                ||(secIndex === list[0][0]
                && rowIndex < list[0][1])) retIndex = list[0];

                if(!section) {
                    for(i = 1; i < list.length; i++) {
                        if(rowIndex > list[i-1][1] && rowIndex < list[i][1]) {
                            retIndex = list[i];
                            break;
                        }
                    }
                } else {
                    for(i = 1; i < list.length; i++) {
                        if(secIndex >= list[i-1][0] && (secIndex < list[i][0] || rowIndex < list[i][1])) {
                            retIndex = list[i];
                            break;
                        }
                    }
                }

                if(!section) retIndex[0] = -1;
                return retIndex;
            },


            //This function will be called in the scope of widget instance
            getWidgetIdsFromRowData: function SegmentedUI2$_searcher_getWidgetIdsFromRowData(rowData) {
                var rowDataIds = Object.keys(rowData), r = 0,
                    widgetdatamap = this._kwebfw_.prop.widgetDataMap,
                    rlen = rowDataIds.length, widgetId = '',
                    invertedDataMap = {}, widgetIds = [], rowDataId = '';

                for(widgetId in widgetdatamap) {
                    if(Object.prototype.hasOwnProperty.call(widgetdatamap, widgetId)) {
                        rowDataId = widgetdatamap[widgetId];
                        invertedDataMap[rowDataId] = widgetId;
                    }
                }

                for(r = 0; r < rlen; r++) {
                    widgetIds.push(invertedDataMap[rowDataIds[r]]);
                }

                return widgetIds;
            },


            //This utility might not needed if similar function availbe in utils ??
            getValueFromObjectByPath: function SegmentedUI2$_searcher_getValueFromObjectByPath(keys, obj, delimiter) {
                var k=0, klen = 0, ref = null;

                if(!(typeof delimiter === 'string' && delimiter)) {
                    delimiter = '.';
                }

                if(typeof keys === 'string' && keys) {
                    keys = keys.split(delimiter);
                }

                if(keys instanceof Array && typeof obj === 'object' && obj) {
                    ref = obj;
                    klen = keys.length;

                    for(k=0; k<klen; k++) {
                        if(typeof ref === 'object' && ref && ref[keys[k]]) {
                            ref = ref[keys[k]];
                        } else {
                            break;
                        }
                    }
                }

                return ref;
            },


            //This function will be called in the scope of widget instance
            infoOfSearchableWidgetInRow: function SegmentedUI2$_searcher_infoOfSearchableWidgetInRow(index, rowData, rowDataId, widgetId) {
                var _ = this._kwebfw_, secIndex = index[0], rowIndex = index[1],
                    info = {isValid: false}, cloneModel = null, widget = null, widgetData = null,
                    validWidgetList = ['Button', 'Label', 'TextArea2', 'TextBox2', 'Calendar'];

                if(typeof rowDataId === 'string' && rowDataId
                && typeof widgetId === 'string' && widgetId
                && Object.prototype.hasOwnProperty.call(rowData, rowDataId)) {
                    widgetData = rowData[rowDataId];

                    if(_isSectionDS(_.prop.data[0])) {
                        cloneModel = _.clones[secIndex] ? _.clones[secIndex][1][rowIndex] : null;
                    } else {
                        cloneModel = _.clones[rowIndex];
                    }

                    // clonedModel might be null incase of toplevel flx is invisible.
                    if(!cloneModel) {
                        cloneModel = rowData.template || this.rowTemplate;

                        if(typeof cloneModel === 'string') {
                            cloneModel = _voltmx.mvc.initializeSubViewController(cloneModel);
                        }
                    }

                    widget = _searcher.SegmentedUI2.getValueFromObjectByPath(widgetId, cloneModel);

                    if(widget) {
                        info.widgetType = widget._kwebfw_.name;

                        if(validWidgetList.indexOf(info.widgetType) !== -1) {
                            info.isValid = true;

                            if(info.widgetType === 'Calendar') {
                                info.widgetText = (widgetData instanceof Array)
                                    ? widgetData : widgetData.dateComponents;
                            } else {
                                info.widgetText = (typeof widgetData === 'string')
                                    ? widgetData : widgetData.text;
                            }
                        }
                    }
                }

                return info;
            },


            //This function will be called in the scope of widget instance
            isOperandPassed: function SegmentedUI2$_searcher_isOperandPassed(index, rowData, searchCondition) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, caseSensitive = true,
                    widgetList = null, searchFound = false,
                    searchType = constants.SEGUI_SEARCH_CRITERIA_CONTAINS;

                if(searchCondition.textToSearch) {
                    if($KU.is(searchCondition.caseSensitive, 'boolean')) {
                        caseSensitive = searchCondition.caseSensitive;
                    }

                    if(searchCondition.searchableWidgets) {
                        widgetList = searchCondition.searchableWidgets;
                    } else {
                        widgetList = _searcher.SegmentedUI2.getWidgetIdsFromRowData.call(this, rowData);
                    }

                    if(searchCondition.searchType) searchType = searchCondition.searchType;

                    $KU.each(widgetList, function(widget) {
                        if(_searcher.SegmentedUI2.isOperandPassedByWidgetId.call(
                            this, index, rowData, widget, caseSensitive, searchType, searchCondition.textToSearch)) {
                            searchFound = true;
                            return true;
                        }
                    }, this);
                }

                return searchFound;
            },


            //This function will be called in the scope of widget instance
            isOperandPassedByWidgetId: function SegmentedUI2$_searcher_isOperandPassedByWidgetId(index, rowData, widgetId, caseSensitive, searchType, searchText) {
                var passed = false, rowDataId = this._kwebfw_.prop.widgetDataMap[widgetId],
                    info = _searcher.SegmentedUI2.infoOfSearchableWidgetInRow.call(this, index, rowData, rowDataId, widgetId);

                if(info.isValid) {
                    passed = _searcher.SegmentedUI2.matchWithConditionalOperator(info.widgetType, searchType, searchText, info.widgetText, caseSensitive);
                }

                return passed;
            },


            //This function will be called in the scope of widget instance
            isRowMatchingSearchCriteria: function SegmentedUI2$_searcher_isRowMatchingSearchCriteria(index, rowData) {
                var macthStr = null, searchCondition = this._kwebfw_.searcher.searchCondition;

                macthStr = _searcher.SegmentedUI2.generateExpression.call(this, index, rowData, searchCondition);

                //eslint-disable-next-line no-eval
                return eval(macthStr);
            },


            matchWithConditionalOperator: function SegmentedUI2$_searcher_matchWithConditionalOperator(widgetType, searchType, searchText, widgetText, caseSensitive) {
                var matched = false, substring = '';

                if(!caseSensitive && typeof searchText === 'string') {
                    searchText = searchText.toUpperCase();
                }

                if(!caseSensitive && typeof widgetText === 'string') {
                    widgetText = widgetText.toUpperCase();
                }

                switch(searchType) {
                    case constants.SEGUI_SEARCH_CRITERIA_CONTAINS :
                        if(typeof widgetText === 'string' && widgetText.indexOf(searchText) !== -1) {
                            matched = true;
                        }
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_ENDSWITH :
                        substring = typeof widgetText === 'string'
                            ? widgetText.substr(-searchText.length) : null;

                        if(searchText === substring) matched = true;
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_STARTSWITH :
                        substring = typeof widgetText === 'string'
                            ? widgetText.substr(0, searchText.length) : null;

                        if(searchText === substring) matched = true;
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_GREATER :
                        if(widgetType === 'Calendar' && searchText instanceof Array) {
                            widgetText = _searcher.SegmentedUI2.convertDateToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertDateToNumber(searchText);
                        } else {
                            widgetText = _searcher.SegmentedUI2.convertStringToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertStringToNumber(searchText);
                        }

                        if(typeof widgetText === 'number' && typeof searchText === 'number') {
                            matched = (widgetText > searchText) ? true : false;
                        }
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_GREATER_EQUAL :
                        if(widgetType === 'Calendar' && searchText instanceof Array) {
                            widgetText = _searcher.SegmentedUI2.convertDateToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertDateToNumber(searchText);
                        } else {
                            widgetText = _searcher.SegmentedUI2.convertStringToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertStringToNumber(searchText);
                        }

                        if(typeof widgetText === 'number' && typeof searchText === 'number') {
                            matched = (widgetText >= searchText) ? true : false;
                        }
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_LESSER :
                        if(widgetType === 'Calendar' && searchText instanceof Array) {
                            widgetText = _searcher.SegmentedUI2.convertDateToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertDateToNumber(searchText);
                        } else {
                            widgetText = _searcher.SegmentedUI2.convertStringToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertStringToNumber(searchText);
                        }

                        if(typeof widgetText === 'number' && typeof searchText === 'number') {
                            matched = (widgetText < searchText) ? true : false;
                        }
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_LESSER_EQUAL :
                        if(widgetType === 'Calendar' && searchText instanceof Array) {
                            widgetText = _searcher.SegmentedUI2.convertDateToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertDateToNumber(searchText);

                            if(typeof widgetText === 'number' && typeof searchText === 'number') {
                                matched = (widgetText <= searchText) ? true : false;
                            } else matched = true;
                        } else {
                            widgetText = _searcher.SegmentedUI2.convertStringToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertStringToNumber(searchText);

                            if(typeof widgetText === 'number' && typeof searchText === 'number') {
                                matched = (widgetText <= searchText) ? true : false;
                            }
                        }
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_STRICT_EQUAL :
                        if(widgetType === 'Calendar' && searchText instanceof Array) {
                            widgetText = _searcher.SegmentedUI2.convertDateToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertDateToNumber(searchText);

                            if(typeof widgetText === 'number' && typeof searchText === 'number') {
                                matched = (widgetText === searchText) ? true : false;
                            } else matched = true;
                        } else {
                            widgetText = _searcher.SegmentedUI2.convertStringToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertStringToNumber(searchText);

                            matched = (widgetText === searchText) ? true : false;
                        }
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_NOT_EQUAL :
                        if(widgetType === 'Calendar' && searchText instanceof Array) {
                            widgetText = _searcher.SegmentedUI2.convertDateToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertDateToNumber(searchText);

                            if(typeof widgetText === 'number' && typeof searchText === 'number') {
                                matched = (widgetText === searchText) ? true : false;
                            } else matched = true;
                        } else {
                            widgetText = _searcher.SegmentedUI2.convertStringToNumber(widgetText);
                            searchText = _searcher.SegmentedUI2.convertStringToNumber(searchText);

                            matched = (widgetText !== searchText) ? true : false;
                        }
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_NOT_CONTAINS :
                        if(typeof widgetText === 'string'
                        && widgetText.indexOf(searchText) === -1) {
                            matched = true;
                        }
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_NOT_ENDSWITH :
                        substring = typeof widgetText === 'string'
                            ? widgetText.substr(-searchText.length) : null;

                        if(searchText !== substring) {
                            matched = true;
                        }
                        break;

                    case constants.SEGUI_SEARCH_CRITERIA_NOT_STARTSWITH :
                        substring = typeof widgetText === 'string'
                            ? widgetText.substr(searchText.length) : null;

                        if(searchText !== substring) {
                            matched = true;
                        }
                        break;
                    default:
                        break;
                }

                return matched;
            },

            //This function will be called in the scope of widget instance
            removeAtHeaderVisibility: function SegmentedUI2$_searcher_removeAtHeaderVisibility(secIndex) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, _ = this._kwebfw_,
                    clones = _.clones[secIndex], found = false, li = null, display = '';

                if(_.searcher && _.searcher.config.updateSegment && _.searcher.config.showSectionHeaderFooter) {
                    $KU.each(clones[1], function(clone) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                        if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                            li = $KD.parent(clone._kwebfw_.view);

                            if(li && $KD.style(li, 'display') === 'block') {
                                found = true;
                                return true;
                            }
                        }
                    });

                    // header visibility change
                    if(!$KU.is(clones[0], 'null') && clones[0]._kwebfw_.view) {
                        li = $KD.parent(clones[0]._kwebfw_.view);

                        if(found) {
                            display = 'block';
                        } else {
                            display = 'none';
                        }

                        if(li) $KD.style(li, 'display', display);
                    }
                }
            },


            //This function will be called in the scope of widget instance
            searchText: function SegmentedUI2$_searcher_searchText() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
                    config = _.searcher.config, sections = [],
                    filterList = _searcher.SegmentedUI2.getFilteredData.call(this);

                _.searcher.filteredResult = filterList;
                _searcher.SegmentedUI2.createFilterResultWithHeader.call(this, filterList);
                if(config.updateSegment) {
                    _searcher.SegmentedUI2.setResultOnView.call(this, filterList);

                    if(_isSectionDS(_.prop.data[0])) {
                        $KU.each(this._kwebfw_.clones, function(record, index) {
                            sections.push(index);
                        });
                        _searcher.SegmentedUI2.updateHeaderVisibility.call(this, sections, filterList);
                    }
                }

                return filterList;
            },


            //All the functions will be called in the scope of widget instance
            setResultOnView: function SegmentedUI2$_searcher_setResultOnView(filteredResult) {
                if(_shouldLazyLoad.call(this)) {
                    _searcher.SegmentedUI2.setResultOnViewWithLazyLoad.call(this, filteredResult);
                } else {
                    _iterateOverData.call(this, this._kwebfw_.clones, function(clone, rowIndex, secIndex) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, display = 'block', li = null;

                        if(rowIndex !== -1) {
                            if(secIndex === -1) secIndex = 0;

                            if(_getIndex([secIndex, rowIndex], filteredResult) === -1) {
                                display = 'none';
                            }

                            if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                                li = $KD.parent(clone._kwebfw_.view);
                                if(li) {
                                    $KD.style(li, 'display', display);
                                }
                            }
                        }
                    });
                }
            },


            setResultOnViewWithLazyLoad: function SegmentedUI2$_searcher_setResultOnViewWithLazyLoad(filteredResult) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    index = [-1, -1], el = $KW.el(this), secIndex = 0;

                $KU.each(this._kwebfw_.rows, function(row) {
                    index = _deduceIndex.call(this, row);
                    if(index[0] !== -1) secIndex = index[0];
                    if(_getIndex([secIndex, index[1]], filteredResult) !== -1) {
                        return true;
                    }
                }, this);
                _lazyLoad.SegmentedUI2._renderFromIndex.call(this, index, el);
            },


            updateHeaderVisibility: function SegmentedUI2$_searcher_updateHeaderVisibility(sections, filteredResult) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_,
                    config = _.searcher.config;

                var findSecIndex = function(find, list) {
                    var position = -1, i = 0, ilen = list.length;

                    for(i=0; i<ilen; i++) {
                        if(list[i][0] === find) {
                            position = i;
                            break;
                        }
                    }

                    return position;
                };

                if(_shouldLazyLoad.call(this)) {
                    $KU.each(this._kwebfw_.rows, function(row) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                            li = null, index = _deduceIndex.call(this, row),
                            display = 'none', secIndex = index[0];

                        if(!$KU.is(row, 'null') && index[1] === -1) {
                            if(sections.indexOf(secIndex) !== -1) {
                                li = $KD.parent(row._kwebfw_.view);
                                if(config.showSectionHeaderFooter && findSecIndex(secIndex, filteredResult) !== -1) {
                                    display = 'block';
                                }

                                if(li) $KD.style(li, 'display', display);
                            }
                        }
                    }, this);
                } else {
                    $KU.each(this._kwebfw_.clones, function(clones, secIndex) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                            li = null, display = 'none', clone = clones[0];

                        if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                            if(sections.indexOf(secIndex) !== -1) {
                                li = $KD.parent(clone._kwebfw_.view);
                                if(config.showSectionHeaderFooter && findSecIndex(secIndex, filteredResult) !== -1) {
                                    display = 'block';
                                }

                                if(li) $KD.style(li, 'display', display);
                            }
                        }
                    });
                }
            },


            //All the functions will be called in the scope of widget instance
            updateSearchText: function SegmentedUI2$_searcher_updateSearchText(clones, section) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, sections = [],
                    updateFilterList = [];

                var updateNodeVisibility = function(segmodel, clone, index, widgetdata) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, display = 'none',
                        li = $KD.parent(clone._kwebfw_.view);

                    if(_searcher.SegmentedUI2.isRowMatchingSearchCriteria.call(segmodel, index, widgetdata)) {
                        updateFilterList.push(index);
                        display = 'block';
                    }

                    if(li) $KD.style(li, 'display', display);
                };

                if(_.searcher && _.searcher.config.updateSegment) {
                    if(_shouldLazyLoad.call(this)) {
                        _searcher.SegmentedUI2.updateRowsAfterAPIForLazyLoad.call(this, clones);
                    } else {
                        $KU.each(clones, function(clone) {
                            var prop = this._kwebfw_.prop, data = null,
                                cindex = clone._kwebfw_.ii.split(','),
                                secIndex = parseInt(cindex[0], 10),
                                rowIndex = parseInt(cindex[1], 10);

                            if(rowIndex !== -1) {
                                if(section) {
                                    sections.push(secIndex);
                                    data = prop.data[secIndex][1][rowIndex];
                                    updateNodeVisibility(this, clone, [secIndex, rowIndex], data);
                                } else {
                                    data = prop.data[rowIndex];
                                    updateNodeVisibility(this, clone, [0, rowIndex], data);
                                }
                            }
                        }, this);
                    }

                    if(section) {
                        _searcher.SegmentedUI2.updateHeaderVisibility.call(this, sections, updateFilterList);
                    }
                }
            },


            updateRowsAfterAPIForLazyLoad: function SegmentedUI2$_searcher_updateRowsAfterAPIForLazyLoad(row) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, _ = this._kwebfw_, absIndex,
                    filterList = _.searcher.filteredResult, el = $KW.el(this),
                    index = _deduceIndex.call(this, row), secIndex = index[0];

                if(index[0] === -1) secIndex = 0;
                if(_getIndex([secIndex, index[1]], filterList) === -1) {
                    absIndex = _lazyLoad.SegmentedUI2._absoluteIndexInRows.call(this, index[0], index[1]);
                    $KD.removeAt(el.scrolee, absIndex);
                    this._kwebfw_.rows.splice(absIndex, 1);
                }
            },


            updateFilterResult: function SegmentedUI2$_searcher_updateFilterResult() {
                var _ = this._kwebfw_, filterList = _searcher.SegmentedUI2.getFilteredData.call(this);

                _.searcher.filteredResult = filterList;
                _searcher.SegmentedUI2.createFilterResultWithHeader.call(this, filterList);
            }
        }
    };


    //All the functions will be called in the scope of widget instance
    var _setBehaviorConfig = function SegmentedUI2$_setBehaviorConfig(widget) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop,
            imgId = null, img = null, selImg = null, unSelImg = null;

        if(prop.selectionBehaviorConfig && prop.selectionBehavior !== constants.SEGUI_DEFAULT_BEHAVIOR) {
            imgId = prop.selectionBehaviorConfig.imageIdentifier;
            selImg = prop.selectionBehaviorConfig.selectedStateImage;
            unSelImg = prop.selectionBehaviorConfig.unselectedStateImage;

            if(widget.id === imgId && $KU.is(widget, 'widget', 'Image2')) {
                img = unSelImg;
                $KU.each(this._kwebfw_.selectedRows, function(row) {
                    if(row.join(',') === widget._kwebfw_.ii) {
                        img = selImg;
                        return true;
                    }
                });

                widget._kwebfw_.prop.src = img;
            }
        }
    };


    //All the functions will be called in the scope of widget instance
    var _setPageView = function SegmentedUI2$_setPageView(el) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
            _ = this._kwebfw_, prop = _.prop, rows = _.rows, rowIndex = 0,
            datalen = rows.length;

        var navigationDotsHandler = function(event) {
            rowIndex = event.target.getAttribute('index');

            rowIndex = parseInt(rowIndex, 10);
            _setPageViewIndicator.call(this, el, rowIndex);
        };


        $KD.setAttr(el.scrolee, 'kv', 'pageview');
        _flushPageNav(el.pageNav);
        $KD.html(el.pageNav, '');

        if(datalen > 0) {
            $KU.each(rows, function(clone, index) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    _ = this._kwebfw_, prop = _.prop, img = null,
                    src = prop.pageOffDotImage, li = null;

                img = $KD.create('IMG', {loading: 'lazy'});

                $KD.setAttr(img, 'src', $KU.getImageURL(src));
                $KD.setAttr(img, 'alt', '');
                $KD.setAttr(img, 'index', index);
                $KD.style(img, 'padding-left', '4px');

                $KD.on(img, 'click', 'image', navigationDotsHandler.bind(this));
                $KD.on(img, 'mousedown', 'image', function(evt) {
                    $KD.preventDefault(evt);
                });

                $KD.add(el.pageNav, img);

                if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                    li = $KD.closest(clone._kwebfw_.view, 'kr', 'item');
                    if(li) {
                        $KD.style(li, 'width', (100/datalen) + '%');
                        _applyRowSeparator.call(this, li, clone);
                        _applyRowAndHeaderSkin.call(this, li, clone, index);
                    }
                }
            }, this);
            $KD.style(el.scrolee, 'width', (datalen * 100) + '%');

            if(_.swipeContext && _.swipeContext.currentPage) {
                rowIndex = _.swipeContext.currentPage;
            } else if(prop.selectedRowIndex && prop.selectedRowIndex.length === 2) {
                rowIndex = prop.selectedRowIndex[1];
            }
            _setPageViewIndicator.call(this, el, rowIndex);
        }

        if(prop.needPageIndicator) $KD.style(el.pageNav, 'display', 'block');
    };


    //All the functions will be called in the scope of widget instance
    var _setPageViewIndicator = function SegmentedUI2$_setPageViewIndicator(el, rowIndex) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, _ = this._kwebfw_,
            datalen = 0, rows = _.rows, value = 0;

        if(el.scrolee) {
            datalen = rows.length;
            value = -(rowIndex * (100/datalen));
            $KD.style(el.scrolee, 'transition', 'transform 0.5s ease 0s');
            $KD.style(el.scrolee, 'transform', 'translate3d(' + value + '%, 0, 0)');

            if(!$KU.is(_.swipeContext, 'null')) {
                _.swipeContext.currentPage = rowIndex;
            } else {
                _.swipeContext = {};
                _.swipeContext.imageWidth = el.scrolee.firstChild.offsetWidth;
                _.swipeContext.currentPage = rowIndex;
            }

            $KU.each($KD.children(el.pageNav), function(img, index) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    src = null, prop = this._kwebfw_.prop;

                src = (rowIndex === index) ? prop.pageOnDotImage : prop.pageOffDotImage;

                if(img.src && img.src.substring(img.src.lastIndexOf('/') + 1) !== src) {
                    img.src = $KU.getImageURL(src);
                }
            }, this);
        }
    };


    var _setTableView = function SegmentedUI2$_setTableView(el) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils,
            _ = this._kwebfw_, rows = _.rows;

        if(_shouldLazyLoad.call(this)) {
            //In case of lazyload, on view type change reset all the clones and render from first index
            _onDataSet.call(this);
            _view.SegmentedUI2.data.call(this, el);
        } else if(rows.length > 0) {
            $KU.each(rows, function(clone, index) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    li = null;

                if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                    li = $KD.closest(clone._kwebfw_.view, 'kr', 'item');
                    if(li) {
                        $KD.style(li, 'width', null);
                        _applyRowSeparator.call(this, li, clone);
                        _applyRowAndHeaderSkin.call(this, li, clone, index);
                    }
                }
            }, this);
        }

        _flushPageNav(el.pageNav);

        $KD.html(el.pageNav, '');
        $KD.style(el.pageNav, 'display', 'none');
        $KD.setAttr(el.scrolee, 'kv', 'tableview');
        $KD.style(el.scrolee, {'transition': null, 'transform': null, 'width': null});
    };

    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        SegmentedUI2: {
            data: function SegmentedUI2$_setter_data(/*old*/) {
                _onDataSet.call(this);
            },

            selectedRowIndex: function SegmentedUI2$_setter_selectedRowIndex(/*old*/) {
                var _ = this._kwebfw_, prop = _.prop, index = -1, deSelectedRow = [];

                _.deSelectedRows = [];

                if(prop.selectedRowIndex && !_isSectionDS(prop.data[0])) {
                    prop.selectedRowIndex[0] = -1;
                }

                if(!prop.selectedRowIndex) {
                    deSelectedRow = _.selectedRows.splice(0, _.selectedRows.length);
                    if(prop.selectionBehavior !== constants.SEGUI_DEFAULT_BEHAVIOR) {
                        _updateBehaviorImgs.call(this, false, deSelectedRow);
                    }
                } else if(prop.viewType !== constants.SEGUI_VIEW_TYPE_TABLEVIEW
                || prop.selectionBehavior === constants.SEGUI_DEFAULT_BEHAVIOR) {
                    _.selectedRows.splice(0, _.selectedRows.length, prop.selectedRowIndex.slice(0));
                } else if(prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
                    if(prop.selectionBehavior === constants.SEGUI_SINGLE_SELECT_BEHAVIOR) {
                        deSelectedRow = _.selectedRows.splice(0, _.selectedRows.length, prop.selectedRowIndex.slice(0));
                        _updateBehaviorImgs.call(this, false, [deSelectedRow], [prop.selectedRowIndex.slice(0)]);
                    } else if(prop.selectionBehavior === constants.SEGUI_MULTI_SELECT_BEHAVIOR) {
                        index = _getIndex(prop.selectedRowIndex, _.selectedRows);

                        if(index !== -1) {
                            deSelectedRow = _.selectedRows.splice(index, 1);
                            _updateBehaviorImgs.call(this, false, [deSelectedRow]);
                        } else {
                            _.selectedRows.push(prop.selectedRowIndex.slice(0));
                            _updateBehaviorImgs.call(this, false, [deSelectedRow], [prop.selectedRowIndex.slice(0)]);
                        }
                    }
                }

                _.deSelectedRows = deSelectedRow;
                _setSelectedRowsRelatedProperties.call(this);
            },

            selectedRowIndices: function SegmentedUI2$_setter_selectedRowIndices(/*old*/) {
                var _=this._kwebfw_, prop = _.prop, rows = _.selectedRows,
                    rowIndexes = null, s = 0, slen = 0, r = 0, rlen = 0,
                    deSelectedRows = rows.splice(0, rows.length),
                    rowIndices = prop.selectedRowIndices;

                _.deSelectedRows = [];

                if(rowIndices) {
                    slen = rowIndices.length;

                    for(s=0; s<slen; s++) {
                        rowIndexes = rowIndices[s][1];
                        rlen = rowIndexes.length;

                        for(r=0; r<rlen; r++) {
                            rows.push([rowIndices[s][0], rowIndexes[r]]);
                        }
                    }
                }
                _updateBehaviorImgs.call(this, false, deSelectedRows, rows);
                _.deSelectedRows = deSelectedRows;
                _setSelectedRowsRelatedProperties.call(this);
            },

            widgetDataMap: function SegmentedUI2$_setter_widgetDataMap(old) {
                this._kwebfw_.invertedDataMap = _getInvertedDataMap(old);
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _setSelectedRowsRelatedProperties = function SegmentedUI2$_setSelectedRowsRelatedProperties() {
        var prop = this._kwebfw_.prop, rows = this._kwebfw_.selectedRows,
            section = false, indices = {}, r = 0,
            rlen = rows.length, sindex = -1, rindex = -1, key = '';

        prop.selectedRowItems = [];

        if(prop.data && prop.data.length > 0) {
            section = _isSectionDS(prop.data[0]);
            prop.selectedRowIndex = (!rlen) ? null : rows[(rlen-1)].slice(0);
            prop.selectedRowIndices = (!rlen) ? null : [];

            for(r=0; r<rlen; r++) {
                sindex = rows[r][0];
                rindex = rows[r][1];

                if(!section) {
                    if(sindex === 0) sindex = -1;
                    prop.selectedRowItems.push(prop.data[rindex]);
                } else {
                    prop.selectedRowItems.push(prop.data[sindex][1][rindex]);
                }

                key = sindex.toString();
                if(!Object.prototype.hasOwnProperty.call(indices, key)) {
                    indices[key] = [];
                }
                indices[key].push(rindex);
            }

            for(key in indices) {
                prop.selectedRowIndices.push([parseInt(key, 10), indices[key]]);
            }
        } else {
            prop.selectedRowIndex = null;
            prop.selectedRowIndices = null;
            rows.splice(0, rlen);
        }
    };


    //This function will be called in the scope of widget instance
    var _shouldLazyLoad = function SegmentedUI2$_shouldLazyLoad() {
        var $K = voltmx.$kwebfw$, $KW = $K.widget;

        return $KW.shouldLazyLoad.SegmentedUI2.call(this);
    };


    var _translatePage = function SegmentedUI2$_translatePage(el, distance/*, duration*/) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;

        //cnutodo handle duration

        var transformObj = voltmx.ui.makeAffineTransform();
        transformObj.translate(distance, 0);
        $KD.style(el, 'transform', transformObj.transform.translate);
    };


    //This function will be called in the scope of widget instance
    var _validateInputIndices = function SegmentedUI2$_validateInputIndices(secIndex, rowIndex, action) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, index = -1,
            data = this._kwebfw_.prop.data, rowIndexBoundary = 0,
            errorMessage = '', secIndexBoundary = 0;

        if(!$KU.is(rowIndex, 'number')) {
            errorMessage = 'Invalid row Index.';
        }

        if(!$KU.is(secIndex, 'undefined') && !$KU.is(secIndex, 'number')) {
            errorMessage = 'Invalid section Index.';
        }

        if(data && data.length > 0) {
            if(_isSectionDS(data[0])) {
                index = _deduceIndex.call(this, secIndex+','+rowIndex);
                secIndexBoundary = data.length;

                if(action === 'addsectionat') secIndexBoundary = secIndexBoundary + 1;

                if(index[0] === -1 || index[0] >= secIndexBoundary) {
                    errorMessage = 'Invalid section index.';
                } else if(['add', 'update', 'remove'].indexOf(action) !== -1) {
                    rowIndexBoundary = data[secIndex][1].length;
                    if(action === 'add') rowIndexBoundary = rowIndexBoundary + 1;
                }
            } else {
                if(!$KU.is(secIndex, 'undefined') && secIndex !== 0) {
                    errorMessage = 'Invalid section index.';
                }

                index = _deduceIndex.call(this, '-1,'+rowIndex);
                rowIndexBoundary = data.length;
                if(action === 'add') rowIndexBoundary = rowIndexBoundary + 1;
            }

            if(action !== 'addsectionat' && errorMessage === ''
            && (index[1] === -1 || index[1] >= rowIndexBoundary)) {
                errorMessage = 'Invalid row index.';
            }
        } else {
            if(action !== 'add' && action !== 'addsectionat') {
                errorMessage = 'No data exists.';
            } else if(action === 'addsectionat' && secIndex !== 0) {
                // addsectionat action secIndex rather than ZERO not allowed
                errorMessage = 'Invalid section index.';
            } else if(action === 'add') {
                if(rowIndex !== 0) {
                    // add action rowIndex rather than ZERO not allowed
                    errorMessage = 'Invalid row index.';
                } else if(!$KU.is(secIndex, 'undefined') && secIndex !== 0) {
                    // add action secIndex should be either -1 or undefined
                    errorMessage = 'Invalid section index.';
                }
            }
        }

        return errorMessage;
    };


    //All the functions will be called in the scope of widget instance
    var _updateAriaRowCount = function SegmentedUI2$_updateAriaRowCount(count, el) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
            tag = _deduceTagName.call(this);

        el = el || $KW.el(this);

        if(tag === 'div' && el.scrolee) {
            $KD.setAttr(el.scrolee, 'aria-rowcount', count);
        }
    };


    //All the functions will be called in the scope of widget instance
    var _updateBehaviorImgs = function SegmentedUI2$_updateBehaviorImgs(deSelectedAll, deSelectedRows, selectedRows) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, imgId = null,
            _ = this._kwebfw_, prop = _.prop, rows = _.rows,
            deSelectedIndexes = [], selectedIndexes = [], selImg = null, unSelImg = null;

        var joinRowIndexAsString = function(fromArray, toArray) {
            $KU.each(fromArray, function(row) {
                toArray.push(row.join(','));
            });
        };

        var updateImage = function(clone, imgId, imgUrl) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, len = 0,
                imgPath = imgId.split('.'), containerId = '';

            if(imgPath.length === 1) {
                imgId = imgPath[0];
                containerId = clone.id;
            } else { // incase the image is inside component
                len = imgPath.length;
                imgId = imgPath[len - 1];
                containerId = imgPath[len - 2];
            }
            if(clone) {
                $KW.iterate(clone, function(widget) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                        container = null, el = null;

                    if($KU.is(widget, 'widget', 'Image2')) {
                        if(widget.id === imgId) {
                            container = $KW.rmodel(widget);
                            if(container.id === containerId) {
                                widget._kwebfw_.prop.src = imgUrl;
                                el = $KW.el(widget);
                                if(el && el.image) el.image.src = $KU.getImageURL(imgUrl);
                                return true;
                            }
                        }
                    }
                }, {tabs:false});
            }
        };

        if(prop.selectionBehaviorConfig && prop.selectionBehavior !== constants.SEGUI_DEFAULT_BEHAVIOR) {
            imgId = prop.selectionBehaviorConfig.imageIdentifier;
            selImg = prop.selectionBehaviorConfig.selectedStateImage;
            unSelImg = prop.selectionBehaviorConfig.unselectedStateImage;

            if(deSelectedAll) {
                _iterateOverData.call(this, _.rows, function(clone) {
                    updateImage(clone, imgId, unSelImg);
                });
            } else {
                joinRowIndexAsString(selectedRows, selectedIndexes);
                joinRowIndexAsString(deSelectedRows, deSelectedIndexes);
                $KU.each(rows, function(clone) {
                    if(selectedIndexes.indexOf(clone._kwebfw_.ii) !== -1) {
                        updateImage(clone, imgId, selImg);
                    } else if(deSelectedIndexes.indexOf(clone._kwebfw_.ii) !== -1) {
                        updateImage(clone, imgId, unSelImg);
                    }
                });
            }
        }
    };


    //All the functions will be called in the scope of widget instance
    var _updateSelectionBehaviorConfig = function SegmentedUI2$_updateSelectionBehaviorConfig() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, imgId = null,
            clones = _.clones, prop = _.prop, selImg = null, unSelImg = null, imgPath = [],
            containerId = '', len = 0, templateMap = {};

        if(prop.selectionBehaviorConfig && prop.selectionBehavior !== constants.SEGUI_DEFAULT_BEHAVIOR) {
            imgId = prop.selectionBehaviorConfig.imageIdentifier;
            selImg = prop.selectionBehaviorConfig.selectedStateImage;
            unSelImg = prop.selectionBehaviorConfig.unselectedStateImage;
            imgPath = imgId.split('.');

            if(imgPath.length === 1) {
                imgId = imgPath[0];
                containerId = this.rowTemplate.id;
            } else { // incase the image is inside component
                len = imgPath.length;
                imgId = imgPath[len - 1];
                containerId = imgPath[len - 2];
            }
        }

        if(_isSectionDS(prop.data[0])) { //with sections
            $KU.each(clones, function(clone) {
                $KU.each(clone[1], function(row) {
                    if($KU.is(row, 'widget')) {
                        _updateSelectionBehaviorConfigonRow.call(this, row, imgId, selImg, unSelImg, containerId, templateMap);
                    }
                }, this);
            }, this);
        } else { // without sections
            $KU.each(clones, function(row) {
                if($KU.is(row, 'widget')) {
                    _updateSelectionBehaviorConfigonRow.call(this, row, imgId, selImg, unSelImg, containerId, templateMap);
                }
            }, this);
        }

        $KU.each(templateMap, function(tplWidget) {
            _flushClones.call(this, tplWidget);
        }, this);
    };


    //All the functions will be called in the scope of widget instance
    var _updateSelectionBehavior = function SegmentedUI2$_updateSelectionBehavior() {
        _clearSelectedIndices.call(this);
        if(this._kwebfw_.prop.selectionBehavior !== constants.SEGUI_DEFAULT_BEHAVIOR) {
            _updateBehaviorImgs.call(this, true);
        } else {
            _updateSelectionBehaviorConfig.call(this);
        }
    };

    //this function for updation of selection behavior on each row.
    var _updateSelectionBehaviorConfigonRow = function SegmentedUI2$_updateSelectionBehaviorConfigonRow(clone, imgId, selImg, unSelImg, containerId, templateMap) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget;

        $KW.iterate(clone, function(widget) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, index = null, _ = this._kwebfw_,
                secIndex = -1, rowIndex = -1, item = null, itemimg = null,
                dataId = null, prop = this._kwebfw_.prop, data = prop.data, img = unSelImg,
                container = null, el = null, widgetDataMap = prop.widgetDataMap, currTpl = null;

            if($KU.is(widget, 'widget', 'Image2')) {
                if(widget.id === imgId && prop.selectionBehavior !== constants.SEGUI_DEFAULT_BEHAVIOR) {
                    container = $KW.rmodel(widget);
                    if(container.id === containerId) {
                        $KU.each(_.selectedRows, function(row) {
                            if(row === widget._kwebfw_.ii) {
                                img = selImg;
                                return true;
                            }
                        });
                    }
                } else {
                    index = _deduceIndex.call(this, widget);
                    secIndex = index[0];
                    rowIndex = index[1];
                    if(secIndex === -1) item = data[rowIndex];
                    else item = data[secIndex][1][rowIndex];

                    dataId = widgetDataMap[widget.id];

                    if($KU.is(dataId, 'string') && dataId
                    && Object.prototype.hasOwnProperty.call(item, dataId)) {
                        itemimg = item[dataId];
                    }

                    if(!itemimg) {
                        currTpl = item.template || this.rowTemplate;

                        if($KU.is(currTpl, 'string')) {
                            if(templateMap[currTpl]) {
                                currTpl = templateMap[currTpl];
                            } else {
                                currTpl = $KW.getTemplate(this, currTpl);
                                templateMap[currTpl.id] = currTpl;
                            }
                        }

                        $KW.iterate(currTpl, function(tplwidget) {
                            if(tplwidget.id === widget.id) {
                                img = tplwidget.src;
                                return true;
                            }
                        }, {tabs:false});
                    } else {
                        if($KU.is(itemimg, 'string')) {
                            img = itemimg;
                        } else if($KU.is(itemimg, 'object')) {
                            img = itemimg['src'];
                        }
                    }
                }

                widget._kwebfw_.prop.src = img;
                el = $KW.el(widget);
                if(el && el.image) el.image.src = $KU.getImageURL(img);
            }
        }, {scope:this, tabs:false});
    };


    //This function will be called in the scope of widget instance
    var _updateIndexes = function SegmentedUI2$_updateIndexes(fromIndex, ofSectionIndex) {
        var prop = this._kwebfw_.prop, data = prop.data, rlen = 0,
            clones = this._kwebfw_.clones, r = 0, s = 0, slen = 0;

        var updateIndex = function(segmentmodel, clone, index) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, li = null,
                tag = _deduceTagName.call(segmentmodel), absIndex = null;

            if(clone && clone._kwebfw_.view) {
                li = $KD.closest(clone._kwebfw_.view, 'kr', 'item');

                if(li) {
                    absIndex = (_absoluteIndexInData.call(segmentmodel, index) + 1);
                    $KD.setAttr(li, 'kii', index);

                    if(tag === 'div') {
                        $KD.setAttr(li, 'aria-rowindex', absIndex);
                    }
                }
            }

            $KW.iterate(clone, function(model) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    $KD = $K.dom, _ = model._kwebfw_;

                _.ii = index;

                if(_.view) {
                    $KD.setAttr(_.view, 'kwi', index);
                    $KW.replaceWAPIndex(model, index);
                    $KD.setAttr(_.view, 'kwp', _.wap);
                }
            }, {tabs:false});
        };

        if(data) {
            if(_isSectionDS(data[0])) {
                slen = clones.length;
                if(ofSectionIndex === -1) { //Section has changed
                    //Change index of items[s][0] and items[s][1][r]
                    for(s = fromIndex; s < slen; s++) {
                        updateIndex(this, clones[s][0], (s + ',-1'));

                        rlen = clones[s][1].length;
                        for(r = 0; r < rlen; r++) {
                            updateIndex(this, clones[s][1][r], (s + ',' + r));
                        }
                    }
                } else { //Row of a particular section has changed
                    //Change index of items[r]
                    for(s = ofSectionIndex; s < slen; s++) {
                        rlen = clones[s][1].length;
                        for(r = fromIndex; r < rlen; r++) {
                            updateIndex(this, clones[s][1][r], (s + ',' + r));
                        }
                    }
                }
            } else { //Row of a non-sectionable segment has changed
                //Change index of items[r]
                rlen = clones.length;
                for(r = fromIndex; r < rlen; r++) {
                    updateIndex(this, clones[r], ('-1,' + r));
                }
            }

            _updateAriaRowCount.call(this, _getRowCount.call(this));
        }
    };


    //This function will be called in the scope of widget instance
    var _updateSectionHeaderSkin = function SegmentedUI2$_updateSectionHeaderSkin() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, headerRows = [];

        $KU.each(this._kwebfw_.clones, function(record/*, index*/) {
            headerRows.push(record[0]);
        });

        $KU.each(headerRows, function(clone, index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                li = null;

            if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                li = $KD.closest(clone._kwebfw_.view, 'kr', 'item');
            }

            if(li) {
                _applyRowAndHeaderSkin.call(this, li, clone, index);
            }
        }, this);
    };


    //This function will be called in the scope of widget instance
    var _updateRowSkin = function SegmentedUI2$_updateRowSkin() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, index = 0, isSection = false,
            firstRow = null, firstRowIndex = null;

        firstRow = _getFirstRederedRow.call(this);
        firstRowIndex = _deduceIndex.call(this, firstRow);

        if(firstRowIndex[1] !== -1) {
            index = firstRowIndex[1];
        }

        $KU.each(this._kwebfw_.rows, function(clone) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                li = null, ii = clone._kwebfw_.ii;

            if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                li = $KD.closest(clone._kwebfw_.view, 'kr', 'item');
            }

            if(isSection) {
                firstRowIndex = _deduceIndex.call(this, clone);
                if(firstRowIndex[1] !== -1) {
                    index = firstRowIndex[1];
                }
            }

            if(li) {
                _applyRowAndHeaderSkin.call(this, li, clone, index);

                if(ii.indexOf(',-1') !== -1) {
                    isSection = true;
                } else {
                    index++;
                }
            }
        }, this);
    };


    //This function will be called in the scope of widget instance
    var _updateSeparator = function SegmentedUI2$_updateSeparator() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            prop = this._kwebfw_.prop;

        if(prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
            $KU.each(this._kwebfw_.rows, function(clone/*, index*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    li = null;

                if(!$KU.is(clone, 'null') && clone._kwebfw_.view) {
                    li = $KD.closest(clone._kwebfw_.view, 'kr', 'item');
                }

                if(li) {
                    _applyRowSeparator.call(this, li, clone);
                }
            }, this);
        }
    };


    //This function will be called in the scope of widget instance
    var _updateSpecialProperties = function SegmentedUI2$_updateSpecialProperties(widget) {
        widget._kwebfw_.oid = this._kwebfw_.uid;
        widget._kwebfw_.wap = this._kwebfw_.wap + ('[' + widget._kwebfw_.ii + ']_') + widget._kwebfw_.wap;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        SegmentedUI2: {
            alternateRowSkin: function SegmentedUI2$_valid_alternateRowSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            bounces: function SegmentedUI2$_valid_bounces(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            contentOffset: function SegmentedUI2$_valid_contentOffset(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                && $KU.is(value.x, 'size')
                && $KU.is(value.y, 'size')) {
                    flag = true;
                }

                return flag;
            },

            data: function SegmentedUI2$_valid_data(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            enableLazyLoad: function SegmentedUI2$_valid_enableLazyLoad(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            dockSectionHeaders: function SegmentedUI2$_valid_dockSectionHeaders(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            loadingPlaceholderImage : function SegmentedUI2$_valid_loadingPlaceholderImage(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            needPageIndicator: function SegmentedUI2$_valid_needPageIndicator(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            onRowClick: function SegmentedUI2$_valid_onRowClick(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onRowDisplay: function SegmentedUI2$_valid_onRowDisplay(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },


            onSwipe: function SegmentedUI2$_valid_onSwipe(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            pageOffDotImage: function SegmentedUI2$_valid_pageOffDotImage(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            pageOnDotImage: function SegmentedUI2$_valid_pageOnDotImage(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            retainScrollPositionMode: function SegmentedUI2$_valid_retainScrollPositionMode(value) {
                var flag = false,
                    options = [constants.SEGUI_SCROLL_POSITION_DEFAULT, constants.SEGUI_SCROLL_POSITION_RETAIN,
                        constants.SEGUI_SCROLL_POSITION_TOP];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            retainSelection: function SegmentedUI2$_valid_retainSelection(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            rowFocusSkin: function SegmentedUI2$_valid_rowFocusSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            rowSkin: function SegmentedUI2$_valid_rowSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            rowTemplate: function SegmentedUI2$_valid_rowTemplate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'widget', 'FlexContainer') || $KU.is(value, 'string') || value === null) {
                    flag = true;
                }

                return flag;
            },

            scrollingEvents: function SegmentUI2$_valid_scrollingEvents(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false, subflag = true,
                    names = ['onPush', 'onPull', 'onReachingBegining', 'onReachingEnd'];

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')) {
                    flag = true;

                    $KU.each(names, function(name) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if(Object.prototype.hasOwnProperty.call(value, name)
                        && !$KU.is(value[name], 'function')) {
                            subflag = false;
                            return true;
                        }
                    });
                }

                return (flag && subflag);
            },

            sectionHeaderSkin: function SegmentedUI2$_valid_sectionHeaderSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            sectionHeaderTemplate: function SegmentedUI2$_valid_sectionHeaderTemplate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'widget', 'FlexContainer') || $KU.is(value, 'string') || value === null) {
                    flag = true;
                }

                return flag;
            },

            selectedRowIndex: function SegmentedUI2$_valid_selectedRowIndex(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
                    prop = this._kwebfw_.prop;

                if($KU.is(value, 'array') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if($KU.is(value, 'array') && Object.prototype.hasOwnProperty.call(prop, 'data')
                && Object.prototype.hasOwnProperty.call(prop, 'selectedRowIndex')) {
                    flag = _validIndex.call(this, value.slice(0), true);
                }

                return flag;
            },

            selectedRowIndices: function SegmentedUI2$_valid_selectedRowIndices(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, count = 0, flag = true,
                    s = 0, slen = 0, r = 0, rlen = 0, _ = this._kwebfw_,
                    prop = _.prop, secIndex = -1, rowIndexes = [];

                if($KU.is(value, 'array')) {
                    slen = value.length;
                    for(s=0; s<slen; s++) {
                        if(flag === false) {
                            break;
                        } else {
                            secIndex = value[s][0];
                            rowIndexes = value[s][1];

                            rlen = rowIndexes.length;
                            for(r=0; r<rlen; r++) {
                                flag = _validIndex.call(this, [secIndex, rowIndexes[r]]);
                                if(flag === false) break;
                                else count++;

                                if(!(prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW
                                && prop.selectionBehavior === constants.SEGUI_MULTI_SELECT_BEHAVIOR)) {
                                    if(count > 1) flag = false;
                                }
                            }
                        }
                    }
                    if(flag && value[0][0] === 0 && !_isSectionDS(prop.data[0])) {
                        value[0][0] = -1;
                        flag = [value, true];
                    }
                } else if(!$KU.is(value, 'null')) {
                    flag = false;
                }

                return flag;
            },

            selectedRowItems: function SegmentedUI2$_valid_selectedRowItems(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'array')) {
                    flag = true;
                }

                return flag;
            },

            selectionBehavior: function SegmentedUI2$_valid_selectionBehavior(value) {
                var flag = false, options = [
                    constants.SEGUI_DEFAULT_BEHAVIOR,
                    constants.SEGUI_MULTI_SELECT_BEHAVIOR,
                    constants.SEGUI_SINGLE_SELECT_BEHAVIOR
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            selectionBehaviorConfig: function SegmentedUI2$_valid_selectionBehaviorConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')) {
                    flag = true;
                }

                return flag;
            },

            separatorColor: function SegmentedUI2$_valid_separatorColor(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    value = value.toUpperCase();
                    flag = $KU.is(value, 'color');
                }

                return (flag ? [value, flag] : flag);
            },

            separatorRequired: function SegmentedUI2$_valid_separatorRequired(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            separatorThickness: function SegmentedUI2$_valid_separatorThickness(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number') && value >= 0) {
                    flag = true;
                }

                return flag;
            },

            showScrollbars: function SegmentedUI2$_valid_showScrollbars(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            viewType: function SegmentedUI2$_valid_viewType(value) {
                var flag = false, options = [
                    constants.SEGUI_VIEW_TYPE_PAGEVIEW,
                    constants.SEGUI_VIEW_TYPE_TABLEVIEW
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            widgetDataMap: function SegmentedUI2$_valid_widgetDataMap(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')) {
                    flag = true;
                }

                return flag;
            },

            widgetSkin: function SegmentedUI2$_valid_widgetSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _validIndex = function SegmentedUI2$_validIndex(index, mutate) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
            data = this._kwebfw_.prop.data, sectionable = false;

        if(data && data.length && $KU.is(index, 'array') && index.length === 2
        && $KU.is(index[0], 'number') && $KU.is(index[1], 'number')) {
            sectionable = _isSectionDS(data[0]);

            if(index[0] === 0 && !sectionable) {
                index[0] = -1;
            }

            if(index[0] < -1) index[0] = -1;
            if(index[1] < -1) index[1] = -1;

            if(!sectionable) {
                if(index[0] === -1 && index[1] >= 0 && index[1] < data.length) {
                    flag = true;
                }
            } else if(index[0] >= 0 && index[0] < data.length) {
                if(index[1] >= -1 && index[1] < data[index[0]][1].length) {
                    flag = true;
                }
            }
        }

        return (mutate === true && flag) ? [index, true] : flag;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        SegmentedUI2: {
            alternateRowSkin: function SegmentedUI2$_view_alternateRowSkin(/*el, old*/) {
                _updateRowSkin.call(this);
            },

            bounces: true,

            contentOffset: function SegmentedUI2$_view_contentOffset(/*el, old*/) {
                this.setContentOffset(this.contentOffset, true);
            },

            contentOffsetMeasured: false,

            data: function SegmentedUI2$_view_data(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    prop = this._kwebfw_.prop, clone = null;

                _updateAriaRowCount.call(this, _getRowCount.call(this), el);
                $KD.html(el.scrolee, '');
                $KD.style(el.topscrolee, 'height', '0px');
                $KD.style(el.bottomscrolee, 'height', '0px');

                this._kwebfw_.rows = [];

                if(prop.data && prop.data.length) {
                    if(_shouldLazyLoad.call(this)) {
                        if(_isSectionDS(prop.data[0])) {
                            _lazyLoad.SegmentedUI2._renderFromIndex.call(this, [0, -1], el);
                        } else {
                            _lazyLoad.SegmentedUI2._renderFromIndex.call(this, [-1, 0], el);
                        }
                    } else {
                        _iterateOverData.call(this, prop.data, function(data, rowIndex, secIndex) {
                            clone = _getClonedTemplate.call(this, [secIndex, rowIndex]);
                            clone && this._kwebfw_.rows.push(clone);
                        });

                        if(this._kwebfw_.rows.length) {
                            $KD.add(el.scrolee, _renderRows.call(this, this._kwebfw_.rows));
                        }

                        if(prop.viewType === constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
                            _setPageView.call(this, el);
                        }
                        _applyNodeStyles.call(this);
                    }

                    if(this._kwebfw_.searcher) _searcher.SegmentedUI2.searchText.call(this);
                }
            },

            dockSectionHeaders: true,

            enableLazyLoad : true,

            loadingPlaceholderImage : function SegmentedUI2$_view_loadingPlaceholderImage(el/*, old*/) {
                if(_shouldLazyLoad.call(this)) {
                    _lazyLoad.SegmentedUI2._setLoadingPlaceholder.call(this, el);
                }
            },

            needPageIndicator: function SegmentedUI2$_view_needPageIndicator(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this._kwebfw_.prop.needPageIndicator) {
                    $KD.style(el.pageNav, 'display', 'block');
                } else {
                    $KD.style(el.pageNav, 'display', 'none');
                }
            },

            onRowClick: true,

            onRowDisplay: true,

            onSwipe: true,

            pageOffDotImage: function SegmentedUI2$_view_pageOffDotImage(el/*, old*/) {
                if(this._kwebfw_.prop.viewType === constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
                    _setPageView.call(this, el);
                }
            },

            pageOnDotImage: function SegmentedUI2$_view_pageOnDotImage(el/*, old*/) {
                if(this._kwebfw_.prop.viewType === constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
                    _setPageView.call(this, el);
                }
            },

            retainScrollPositionMode: true,

            retainSelection: true,

            rowFocusSkin: true,

            rowSkin: function SegmentedUI2$_view_rowSkin(/*el, old*/) {
                _updateRowSkin.call(this);
            },

            rowTemplate: true,

            scrollingEvents: true,

            sectionHeaderSkin: function SegmentedUI2$_view_sectionHeaderSkin(/*el, old*/) {
                var prop = this._kwebfw_.prop;

                if(prop.data && prop.data.length > 0 && _isSectionDS(prop.data[0])) {
                    _updateSectionHeaderSkin.call(this);
                }
            },

            sectionHeaderTemplate: true,

            selectedRowIndex: function SegmentedUI2$_view_selectedRowIndex(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_,
                    prop = _.prop, rowIndex = 0, selectedRow = null;

                if($KW.visible(this) && prop.selectedRowIndex) {
                    rowIndex = prop.selectedRowIndex[1];

                    //_.setFocus is set in voltmxevent.js _setOwnerSelectedIndex.SegmentedUI2 function
                    if(prop.viewType === constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
                        _setPageViewIndicator.call(this, el, rowIndex);
                        if(_.setFocus !== false) this.setFocus(true);
                    } else if(_.setFocus !== false) { //IMP:: Must compare with boolean false
                        if(_shouldLazyLoad.call(this)) {
                            _lazyLoad.SegmentedUI2._renderFromIndex.call(this, prop.selectedRowIndex, el);
                        } else {
                            selectedRow = _getIndexedInfo.call(this, prop.selectedRowIndex, _.clones);
                            selectedRow.setFocus(true); // selectedRow might be null ??

                            if($KW.isFixedHeight(this)) {
                                $KW.scrollElementToParentScroller(selectedRow);
                            }
                        }
                    }
                }
            },

            selectedRowIndices: true,

            selectedRowItems: false,

            selectionBehavior: function SegmentedUI2$_view_selectionBehavior(/*el, old*/) {
                _updateSelectionBehavior.call(this);
            },

            selectionBehaviorConfig: function SegmentedUI2$_view_selectionBehaviorConfig(/*el, old*/) {
                _updateSelectionBehaviorConfig.call(this);
            },

            separatorColor: function SegmentedUI2$_view_separatorColor(/*el, old*/) {
                _updateSeparator.call(this);
            },

            separatorRequired: function SegmentedUI2$_view_separatorRequired(/*el, old*/) {
                _updateSeparator.call(this);
                if(_shouldLazyLoad.call(this)) {
                    _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(this);
                }
            },

            separatorThickness: function SegmentedUI2$_view_separatorThickness(/*el, old*/) {
                _updateSeparator.call(this);
                if(_shouldLazyLoad.call(this)) {
                    _lazyLoad.SegmentedUI2._adjustRowsOnViewUpdate.call(this);
                }
            },

            showScrollbars: true,

            viewType: function SegmentedUI2$_view_viewType(el, old) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, prop = this._kwebfw_.prop;

                if(prop.viewType === constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
                    _registerSwipeGesture.call(this, el.scrolee);
                } else {
                    $KD.off(el.scrolee, 'swipe', 'segment');
                }

                if(old !== prop.viewType) {
                    _clearSelectedIndices.call(this);
                    if(prop.viewType === constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
                        _view.SegmentedUI2.data.call(this, el, prop.data);
                    } else {
                        _setTableView.call(this, el);
                    }
                }
            },

            widgetDataMap: true,

            widgetSkin: function SegmentedUI2$_view_widgetSkin(el, old) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, prop = this._kwebfw_.prop;

                if(old !== '') $KD.removeCls(el.node, old);
                if(prop.widgetSkin !== '') $KD.addCls(el.node, prop.widgetSkin);
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'SegmentedUI2', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.SegmentedUI2 constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var SegmentedUI2 = function SegmentedUI2(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    alternateRowSkin: '',
                    bounces: true, //Only for TABLE_VIEW //In doc available, but in SPA code not available
                    containerHeight: '', //In doc not available, but in SPA code available
                    containerHeightReference: '', //In doc not available, but in SPA code available
                    contentOffset: null, //In doc not available, but in SPA code available
                    contentOffsetMeasured: {x: 0, y: 0},
                    data: null,
                    dockSectionHeaders: false,
                    enableScrollBounce: true, //In doc not available, but in SPA code available
                    enableLazyLoad: false, // Temporary prop for lazy loading at segment level
                    needPageIndicator: true,
                    onRowClick: null,
                    onRowDisplay: null,
                    onSwipe: null, //Only for PAGE_VIEW
                    pageOffDotImage: 'blackdot.gif',
                    pageOnDotImage: 'whitedot.gif',
                    retainScrollPositionMode: constants.SEGUI_SCROLL_POSITION_DEFAULT, //In doc not available, but in SPA code available
                    retainSelection: false,
                    rowFocusSkin: 'seg2Focus',
                    rowSkin: 'seg2Normal',
                    rowTemplate: null,
                    scrollingEvents: null,
                    sectionHeaderSkin: '',
                    sectionHeaderTemplate: null,
                    selectedRowIndex: null,
                    selectedRowIndices: null,
                    selectedRowItems: [],
                    selectionBehavior: constants.SEGUI_DEFAULT_BEHAVIOR,
                    selectionBehaviorConfig: null,
                    separatorColor: '00000000',
                    separatorRequired: false,
                    separatorThickness: 1,
                    showScrollbars: true,
                    viewType: constants.SEGUI_VIEW_TYPE_TABLEVIEW,
                    widgetDataMap: {},
                    widgetSkin: ''
                };
            }

            _populateUnderscore.SegmentedUI2.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            SegmentedUI2.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.SegmentedUI2, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.SegmentedUI2.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to SegmentedUI2
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.SegmentedUI2[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.SegmentedUI2>, but not in <_valid.SegmentedUI2> namespace.');
                        } else {
                            valid = _valid.SegmentedUI2[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to SegmentedUI2
                $KU.each(_view.SegmentedUI2, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function SegmentedUI2$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.SegmentedUI2[key], 'function')) {
                            return _getter.SegmentedUI2[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function SegmentedUI2$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.SegmentedUI2[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.SegmentedUI2[key], 'function')) {
                                        _setter.SegmentedUI2[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.SegmentedUI2().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.SegmentedUI2().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    if($KU.is(p.contentOffset, undefined)) p.contentOffset = null;
                    if($KU.is(p.contentOffsetMeasured, undefined)) p.contentOffsetMeasured = {x: 0, y: 0};
                    if($KU.is(p.selectionBehaviorConfig, undefined)) p.selectionBehaviorConfig = null;
                    if($KU.is(p.rowTemplate, undefined)) p.rowTemplate = null;
                    if($KU.is(p.sectionHeaderTemplate, undefined)) p.sectionHeaderTemplate = null;
                }

                if($KU.is(_postInitialization.SegmentedUI2, 'function')) {
                    _postInitialization.SegmentedUI2.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(SegmentedUI2, voltmx.ui.BasicWidget);


        /**
         * Takes care of flushing out the widget reference to clean memory.
         *
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.SegmentedUI2
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     void
         */
        var segment2__flush = function SegmentedUI2$_flush(config) {
            var $super = voltmx.ui.SegmentedUI2.base.prototype;

            _flushClones.call(this, this._kwebfw_.clones, config);
            $super._flush.call(this);
        };


        /**
         * Builds the view layer for SegmentedUI2 widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.SegmentedUI2
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  SegmentedUI2 view.
         */
        var segment2__render = function SegmentedUI2$_render(tag, context) {
            var $super = voltmx.ui.SegmentedUI2.base.prototype, _ = this._kwebfw_,
                $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                ulTag = '', docker = null, view = _.view, blocker = null,
                scrolee = null, hScroll = null, vScroll = null, el = null,
                pageNav = null, topscrolee = null, bottomscrolee = null;

            if(!$KU.is(context, 'object')) context = {};

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    ulTag = _deduceTagName.call(this);

                    scrolee = $KD.create(ulTag, {kv: 'tableview'});
                    topscrolee = $KD.create('DIV', {kr:'topscrolee'}, {position:'relative', width: '100%', height: '0px', top:'0px'});
                    bottomscrolee = $KD.create('DIV', {kr:'bottomscrolee'}, {position:'relative', width: '100%', height: '0px', top:'0px'});
                    docker = $KD.create('DIV', {kr:'docker'}, {position:'absolute', top:'0px', left:'left', width:'100%'});
                    blocker = $KD.create('DIV', {kr:'blocker'}, {position:'absolute', top:'0px', left:'left', width:'100%', height:'100%'});

                    $KD.add(docker, blocker);

                    if($KU.scrollType() !== 'native') {
                        $KD.setAttr(scrolee, 'kr', 'scrolee');
                        hScroll = $KD.create('DIV', {kr:'h-scroll'});
                        vScroll = $KD.create('DIV', {kr:'v-scroll'});
                    }

                    pageNav = $KD.create('DIV', {align:'center'}, {display:'none', position:'absolute', bottom:'0px', width:'100%'});

                    view = $super._render.call(this, tag, [topscrolee, scrolee, bottomscrolee, docker, pageNav, hScroll, vScroll]);

                    $KD.setAttr(view, 'kwh-keydown', 'onKeyDown');

                    if(ulTag === 'div') {
                        $KD.setAttr(scrolee, 'role', 'table');
                    } else if(ulTag === 'table') {
                        $KD.setAttr(scrolee, 'cellpadding', '0');
                        $KD.setAttr(scrolee, 'cellspacing', '0');
                    }

                    el = $KW.el(view);
                    if(_.prop.viewType === constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
                        _view.SegmentedUI2.viewType.call(this, el, _.prop.viewType);
                    } else {
                        $KW.registerNativeScrollEvent(this);
                        var segmodel = $KW.model(this);
                        $KD.on(el.viewport, 'scroll', 'segment', function() {
                            _onScrollCallback.call(this, segmodel, this.scrollTop);
                        });
                    }
                }

                el = $KW.el(view);

                if($KU.scrollType() !== 'native') {
                    $KD.style(el.node, {overflowX:'hidden', overflowY:'hidden'});
                } else {
                    $KD.style(el.viewport, {overflowX:'auto', overflowY:'auto'});
                    $KD.style(el.node, {overflowX:'hidden'});
                }

                if(_.prop.widgetSkin !== '') $KD.addCls(el.node, _.prop.widgetSkin);

                if(_.prop.viewType !== constants.SEGUI_VIEW_TYPE_PAGEVIEW) {
                    _view.SegmentedUI2.data.call(this, el, _.prop.data);
                    if(_shouldLazyLoad.call(this)) {
                        _lazyLoad.SegmentedUI2._setLoadingPlaceholder.call(this, el);
                    }
                }

                $KW.accessibility(this);
            }

            return view;
        };


        var segment2_addAll = function SegmentedUI2$addAll(data, anim) {
            var prop = this._kwebfw_.prop, secIndex = -1, rowIndex = -1;

            if(!_valid.SegmentedUI2.data.call(this, data)) {
                throw new Error('Invalid data.');
            }
            if(!prop.data) prop.data = [];

            if(prop.data.length === 0
            || (_isSectionDS(prop.data[0]) && _isSectionDS(data[0]))
            || (!_isSectionDS(prop.data[0]) && !_isSectionDS(data[0]))) {
                if(_isSectionDS(data[0])) secIndex = prop.data.length;
                else rowIndex = prop.data.length;

                _onRowChange.call(this, secIndex, rowIndex, 'addall', data, anim);
            } else {
                //Throw Error:: Existing data structure of Segment do not match with that of passed data
                throw new Error('Invalid data.');
            }
        };


        var segment2_addDataAt = function SegmentedUI2$addDataAt(data, rowIndex, secIndex, anim) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, errorMessage = null;

            if($KU.is(data, 'object')) {
                errorMessage = _validateInputIndices.call(this, secIndex, rowIndex, 'add');

                if(errorMessage === '') {
                    if(!$KU.is(secIndex, 'number')) secIndex = -1;
                    if(!this._kwebfw_.prop.data) this._kwebfw_.prop.data = [];
                    _onRowChange.call(this, secIndex, rowIndex, 'add', data, anim);
                } else {
                    throw new Error(errorMessage);
                }
            } else {
                throw new Error('Invalid data.');
            }
        };


        var segment2_addSectionAt = function SegmentedUI2$addSectionAt(data, index, anim) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                prop = this._kwebfw_.prop, errorMessage = '';

            if($KU.is(data, 'array') && !_isSectionDS(data)) {
                throw new Error('Invalid data.');
            }

            errorMessage = _validateInputIndices.call(this, index, 0, 'addsectionat');

            if(errorMessage === '') {
                if(!prop.data) prop.data = [];

                if(prop.data.length === 0 || _isSectionDS(prop.data[0])) {
                    _onRowChange.call(this, index, -1, 'addsectionat', data, anim);
                } else {
                    throw new Error('Invalid data.');
                }
            } else {
                throw new Error(errorMessage);
            }
        };


        var segment2_animateRows = function SegmentedUI2$animateRows(animContext) {
            _animator.SegmentedUI2.animateRows.call(this, animContext);
        };


        var segment2_clearSearch = function SegmentedUI2$clearSearch() {
            var _ = this._kwebfw_;

            if(_.searcher) {
                _.searcher = null;
                _searcher.SegmentedUI2.clearSearchResult.call(this);
            }
        };


        var segment2_getFirstVisibleRow = function SegmentedUI2$getFirstVisibleRow() {
            return _getVisibleRow.call(this, {firstRow:true, lastRow:false});
        };


        var segment2_getLastVisibleRow = function SegmentedUI2$getLastVisibleRow() {
            return _getVisibleRow.call(this, {firstRow:false, lastRow:true});
        };


        var segment2_getUpdatedSearchResults = function SegmentedUI2$getUpdatedSearchResults() {
            var _ = this._kwebfw_, filteredResult = null;

            if(_.searcher) {
                filteredResult = _searcher.SegmentedUI2.getFilteredData.call(this);
            }

            return filteredResult;
        };


        var segment2_removeAll = function SegmentedUI2$removeAll(anim) {
            if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.REMOVE, this._kwebfw_.rows);
                _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'removeall', this._kwebfw_.rows, -1, -1, anim);
            } else {
                _action.SegmentedUI2._removeAll.call(this);
            }
        };


        var segment2_removeAt = function SegmentedUI2$removeAt(rowIndex, secIndex, anim) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, errorMessage = null;

            errorMessage = _validateInputIndices.call(this, secIndex, rowIndex, 'remove');
            if(errorMessage === '') {
                if(!$KU.is(secIndex, 'number')) secIndex = -1;
                _onRowChange.call(this, secIndex, rowIndex, 'remove', anim);
            } else {
                throw new Error(errorMessage);
            }
        };


        var segment2_removeSectionAt = function SegmentedUI2$removeSectionAt(index, anim) {
            var prop = this._kwebfw_.prop;

            if(prop.data && prop.data.length > 0 && _isSectionDS(prop.data[0])) {
                if(index >= 0 && index < prop.data.length) {
                    _onRowChange.call(this, index, -1, 'removesectionat', prop.data, anim);
                } else {
                    throw new Error('Invalid index passed.');
                }
            } else {
                throw new Error('Invalid input or no data exists.');
            }
        };


        var segment2_searchText = function SegmentedUI2$searchText(searchCondition, config) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, filteredResult = null;

            if(!$KU.is(searchCondition, 'array')) {
                throw new Error('searchCondition is missing or not an array.');
            } else {
                if($KU.is(config, 'undefined') || !$KU.is(config, 'object')) {
                    config = {updateSegment: true, showSectionHeaderFooter: true};
                } else {
                    if(!$KU.is(config.updateSegment, 'boolean')) {
                        config.updateSegment = true;
                    }

                    if(!$KU.is(config.showSectionHeaderFooter, 'boolean')) {
                        config.showSectionHeaderFooter = true;
                    }
                }

                if(_.searcher) {
                    _searcher.SegmentedUI2.clearSearchResult.call(this);
                }

                _.searcher = {searchCondition: searchCondition, config: config, filteredResult: null, filterResultWithHeader: null};

                filteredResult = _searcher.SegmentedUI2.searchText.call(this);
            }

            return filteredResult;
        };

        var segment2_setActive = function SegmentedUI2$setActive(rowIndex, secIndex, widgetPath) {
            var $K = kony.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                $super = kony.ui.SegmentedUI2.base.prototype, dom = null, tpl = null,
                _ = this._kwebfw_, view = _.view, el = $KW.el(this);

            if (arguments.length === 0) {
                $super.setActive.call(this);
            } else {
                rowIndex = _validIndex.call(this, [secIndex, rowIndex], true);

                if (rowIndex === false) {
                    throw new Error('Invalid index passed.');
                } else if (rowIndex[1] === true) {
                    rowIndex = rowIndex[0];
                    secIndex = rowIndex[0];
                    rowIndex = rowIndex[1];

                    if (_shouldLazyLoad.call(this) && $KW.isRendered(this)) {
                        if (_.searcher) {
                            _searcher.SegmentedUI2.updateFilterResult.call(this);
                        }

                        _lazyLoad.SegmentedUI2._renderFromIndex.call(this, [secIndex, rowIndex], el);
                    }

                    if (!widgetPath) {
                        if (view && $KW.interactable(this)) {
                            dom = $KD.find(view, '[kii="' + secIndex + ',' + rowIndex + '"]')[0];
                        }
                    } else {
                        widgetPath = widgetPath.split('.');
                        tpl = _getTemplateByIndex.call(this, [secIndex, rowIndex, ]);

                        if (widgetPath.length > 1) {
                            tpl = $KU.get(widgetPath.slice(1), tpl);
                        } else if (tpl.id !== widgetPath[0]) {
                            tpl = null;
                        }

                        if (tpl && $KW.interactable(tpl)) {
                            dom = $KW.focusableElement(tpl);
                        }
                    }

                    dom && $KD.focus(dom);
                }
            }
        };
        
        var segment2_setAnimations = function SegmentedUI2$setAnimations(animInfo) {
            _animator.SegmentedUI2.setAnimations.call(this, animInfo);
        };


        var segment2_setContentOffset = function segmentedUI2$setContentOffset(offset, animate) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_,
                prop = _.prop, rowIndex = -1, value = {}, view = _.view;
            if(view) {
                if(prop.viewType === constants.SEGUI_VIEW_TYPE_TABLEVIEW) {
                    $KW.setContentOffset(this, offset, animate);
                } else {
                    value = $KW.getContentOffsetValues(this, offset);
                    rowIndex = value.x && parseInt(value.x / _.swipeContext.imageWidth);
                    if(rowIndex < 0) {
                        rowIndex = 0;
                    } else if(rowIndex >= prop.data.length) {
                        rowIndex = prop.data.length - 1;
                    }
                    _setPageViewIndicator.call(this, $KW.el(this), rowIndex);
                }
            }
        };

        var segment2_setData = function SegmentedUI2$setData(data, anim) {
            this.data = data;
            if(_animator.SegmentedUI2.canAnimate.call(this, anim)) {
                _animator.SegmentedUI2.onRowDisplayHandler.call(this, voltmx.segment.UPDATE, this._kwebfw_.rows);
                _animator.SegmentedUI2.applyRowsAnimationByAPI.call(this, 'setdata', this._kwebfw_.rows, -1, -1, anim);
            }
        };


        var segment2_setDataAt = function SegmentedUI2$setDataAt(data, rowIndex, secIndex, anim, arg4) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, widget = null, key = '',
                _ = this._kwebfw_, prop = _.prop, errorMessage = null, wap = [], widgetId = '',
                _constructObject = function(widget, data, key) {
                    var defaultProp = null, value = null;

                    if($KU.is(data, 'string')) {
                        defaultProp = $KW.getDefaultProperty(widget);
                        value = data;
                        data = {};
                        data[defaultProp] = value;
                    } else {
                        data = {};
                    }

                    data[key] = widget[key];
                    return data;
                };

            if(arguments.length === 5 && $KU.is(data, 'widget')) {
                //Will get into this, when setter of cloned model is called
                widget = data;
                key = rowIndex;
                rowIndex = anim;
                secIndex = arg4;
                wap = $KW.getWidgetDataMapPath(widget);
                widgetId = this.widgetDataMap[wap];

                if(widgetId) {
                    if(secIndex === -1 && rowIndex !== -1) {
                        if($KU.is(prop.data[rowIndex][widgetId], 'object')) {
                            prop.data[rowIndex][widgetId][key] = widget[key];
                        } else {
                            prop.data[rowIndex][widgetId] = _constructObject(widget, prop.data[rowIndex][widgetId], key);
                        }
                    } else if(secIndex !== -1 && rowIndex === -1) {
                        if($KU.is(prop.data[secIndex][0][widgetId], 'object')) {
                            prop.data[secIndex][0][widgetId][key] = widget[key];
                        } else {
                            prop.data[secIndex][0][widgetId] = _constructObject(widget, prop.data[secIndex][0][widgetId], key);
                        }
                    } else if(secIndex !== -1 && rowIndex !== -1) {
                        if($KU.is(prop.data[secIndex][1][rowIndex][widgetId], 'object')) {
                            prop.data[secIndex][1][rowIndex][widgetId][key] = widget[key];
                        } else {
                            prop.data[secIndex][1][rowIndex][widgetId] = _constructObject(widget, prop.data[secIndex][1][rowIndex][widgetId], key);
                        }
                    }
                }
            } else { //This is actual implementation of setDataAt
                if($KU.is(data, 'object')) {
                    errorMessage = _validateInputIndices.call(this, secIndex, rowIndex, 'update');

                    if(errorMessage === '') {
                        if(!$KU.is(secIndex, 'number')) secIndex = -1;
                        _onRowChange.call(this, secIndex, rowIndex, 'update', data, anim);
                    } else {
                        throw new Error(errorMessage);
                    }
                } else {
                    throw new Error('Invalid data.');
                }
            }
        };


        var segment2_setSectionAt = function SegmentedUI2$setSectionAt(data, index, anim) {
            var prop = this._kwebfw_.prop;

            if(prop.data && prop.data.length > 0 && _isSectionDS(prop.data[0])) {
                if(index >= 0 && index < prop.data.length) {
                    _onRowChange.call(this, index, -1, 'setsectionat', data, anim);
                } else {
                    throw new Error('Invalid index passed.');
                }
            } else {
                throw new Error('Invalid input or no data exists.');
            }
        };


        $K.defVoltmxProp(SegmentedUI2.prototype, [
            {keey:'_flush', value:segment2__flush},
            {keey:'_render', value:segment2__render},
            {keey:'addAll', value:segment2_addAll},
            {keey:'addDataAt', value:segment2_addDataAt},
            {keey:'addSectionAt', value:segment2_addSectionAt},
            {keey:'animateRows', value:segment2_animateRows},
            {keey:'clearSearch', value:segment2_clearSearch},
            {keey:'getFirstVisibleRow', value:segment2_getFirstVisibleRow},
            {keey:'getLastVisibleRow', value:segment2_getLastVisibleRow},
            {keey:'getUpdatedSearchResults', value:segment2_getUpdatedSearchResults},
            {keey:'removeAll', value:segment2_removeAll},
            {keey:'removeAt', value:segment2_removeAt},
            {keey:'removeSectionAt', value:segment2_removeSectionAt},
            {keey:'searchText', value:segment2_searchText},
            {keey:'setActive', value: segment2_setActive},
            {keey:'setAnimations', value:segment2_setAnimations},
            {keey:'setContentOffset', value:segment2_setContentOffset},
            {keey:'setData', value:segment2_setData},
            {keey:'setDataAt', value:segment2_setDataAt},
            {keey:'setSectionAt', value:segment2_setSectionAt}
        ]);


        return SegmentedUI2;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxslider.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'Slider', value:{}, items:[
            {keey:'onClick', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    sliderPosition = null, _ = this._kwebfw_, finalPosition = null,
                    value = null, clickPosition = null, sliderEndPosition = null;


                if(this.orientation === constants.SLIDER_HORIZONTAL_ORIENTATION) {
                    sliderPosition = Math.round(_.view.getBoundingClientRect().left);
                    sliderEndPosition = sliderPosition + _.view.offsetWidth;
                    clickPosition = (evt.clientX <= sliderPosition) ? sliderPosition : evt.clientX;
                    clickPosition = (clickPosition >= sliderEndPosition) ? sliderEndPosition : clickPosition;
                    finalPosition = Math.abs(clickPosition - sliderPosition);

                    value = _calculateDeltaValueFromDisplacement.call(this, finalPosition, _.view.offsetWidth);

                    if($KW.shouldApplyRTL(this, 'layoutAlignment')) {
                        value = this.max - value;
                    }
                } else if(this.orientation === constants.SLIDER_VERTICAL_ORIENTATION) {
                    sliderPosition = Math.round(_.view.getBoundingClientRect().bottom);
                    sliderEndPosition = sliderPosition - _.view.offsetHeight;
                    clickPosition = (evt.clientY >= sliderPosition) ? sliderPosition : evt.clientY;
                    clickPosition = (clickPosition <= sliderEndPosition) ? sliderEndPosition : clickPosition;
                    finalPosition = Math.abs(clickPosition - sliderPosition);

                    value = _calculateDeltaValueFromDisplacement.call(this, finalPosition, _.view.offsetHeight);
                }

                this.selectedValue = value;
                $KW.fire(this, 'onSelection', this);

                return false;
            }},

            {keey:'onKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, el = $KW.el(this), _ = this._kwebfw_,
                    prop = _.prop, value = null, code = evt.keyCode || evt.which;

                if([37, 39].indexOf(code) >= 0
                && prop.orientation === constants.SLIDER_HORIZONTAL_ORIENTATION) {
                    $KD.preventDefault(evt);

                    if(!Object.prototype.hasOwnProperty.call(_.ui, 'keydown')) {
                        _.ui.keydown = true;
                        _.selectedValueBeforeSlideStarted = prop.selectedValue;

                        if(prop.focusThumbImage) {
                            $KD.setAttr(el.thumb, 'src', $KU.getImageURL(prop.focusThumbImage));
                        }
                    }

                    if(code === 37) { //Left Arrow
                        value = $KW.shouldApplyRTL(this, 'layoutAlignment') ? (prop.selectedValue + prop.step)
                            : (prop.selectedValue - prop.step);
                    } else if(code === 39) { //Right Arrow
                        value = $KW.shouldApplyRTL(this, 'layoutAlignment') ? (prop.selectedValue - prop.step)
                            :(prop.selectedValue + prop.step);
                    }
                } else if([38, 40].indexOf(code) >= 0
                && this.orientation === constants.SLIDER_VERTICAL_ORIENTATION) {
                    $KD.preventDefault(evt);

                    if(!Object.prototype.hasOwnProperty.call(_.ui, 'keydown')) {
                        _.ui.keydown = true;
                        _.selectedValueBeforeSlideStarted = prop.selectedValue;
                    }

                    if(code === 38) { //Up Arrow
                        value = prop.selectedValue + prop.step;
                    } else if(code === 40) { //Down Arrow
                        value = prop.selectedValue - prop.step;
                    }
                }

                if(!$KU.is(value, 'null')
                && prop.selectedValue !== value
                && value >= prop.min && value <= prop.max) {
                    this.selectedValue = value;
                    $KW.fire(this, 'onSlide', this);
                }

                return false;
            }},

            {keey:'onKeyUp', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                    el = $KW.el(this), _ = this._kwebfw_, prop = _.prop;

                if(_.ui.keydown) {
                    if(prop.focusThumbImage) {
                        $KD.setAttr(el.thumb, 'src', $KU.getImageURL(prop.thumbImage));
                    }

                    delete _.ui.keydown;

                    if(prop.selectedValue !== _.selectedValueBeforeSlideStarted) {
                        $KW.fire(this, 'onSelection', this);
                    }
                }

                return false;
            }},

            {keey:'onTouchEnd', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    _ = this._kwebfw_, prop = _.prop, timeout = null;

                if(prop.focusThumbImage) {
                    //NOTE:: Without timeout updated image src is not reflected
                    timeout = setTimeout(function() {
                        clearTimeout(timeout);
                        $KD.setAttr(evt.target, 'src', $KU.getImageURL(prop.thumbImage));
                        $K = $KU = $KD = _ = prop = timeout = null; //For GC
                    }, 0);
                }

                return false;
            }},

            {keey:'onTouchStart', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                    _ = this._kwebfw_, prop = _.prop;

                if(prop.focusThumbImage) {
                    $KD.setAttr(evt.target, 'src', $KU.getImageURL(prop.focusThumbImage));
                }

                return false;
            }},

            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                    $KD = $K.dom, tabindex = '';

                if($KW.disabled(this)) {
                    $KD.setAttr(dom, 'aria-disabled', 'true');
                    $KD.setAttr(dom, 'tabindex', -1);
                } else if(!$KW.interactable(this)) {
                    $KD.setAttr(dom, 'tabindex', -1);
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(dom, 'aria-disabled');

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        $KD.removeAttr(dom, 'tabindex');
                    }
                }
            }}
        ]}
    ]);


    //This functions will be called in the scope of widget instance
    var _calculateDeltaValueFromDisplacement = function Slider$_calculateDeltaValueFromDisplacement(displacement, size) {
        var diffMaxMin = (this.max - this.min), value = null;

        value = Math.round((displacement/size) * diffMaxMin);
        value = Math.round(value/this.step) * this.step;

        value = this.min + value;

        if(value < this.min) value = value + this.step;
        if(value > this.max) value = value - this.step;

        if(value < this.min) value = this.min;
        if(value > this.max) value = this.max;

        return value;
    };

    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {
        Slider: function Slider$_dependentPropertiesValidationMessage(prop, bconfig /*, lconfig, pspconfig*/) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, message = '',
                min = 0, max = 100, selectedValue = null, step = 1;

            min = ($KU.is(bconfig.min, 'integer')) ? bconfig.min : prop.min;
            max = ($KU.is(bconfig.max, 'integer')) ? bconfig.max : prop.max;
            selectedValue = ($KU.is(bconfig.selectedValue, 'integer')) ? bconfig.selectedValue : prop.selectedValue;
            step = ($KU.is(bconfig.selectedValue, 'integer')) ? bconfig.step : prop.step;

            if(min >= max) {
                message += 'Slider <min> value cannot be greater or equal to <max> value.';
            } else if(!$KU.is(selectedValue, 'null')
            && (selectedValue < min || selectedValue > max)) {
                message += 'Slider <selectedValue> must be between <min> and <max> value (boundary inclusive).';
            } else if(((max - min) % step) !== 0) {
                message += 'Slider <step>, <min>, <max> values combination is invalid.';
            }

            return message;
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        Slider: {
            maxLabel: function Slider$_getter_maxLabel(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if(prop.i18n_maxLabel) {
                    value = $KU.getI18Nvalue(prop.i18n_maxLabel);
                }

                return value;
            },

            minLabel: function Slider$_getter_minLabel(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if(prop.i18n_minLabel) {
                    value = $KU.getI18Nvalue(prop.i18n_minLabel);
                }

                return value;
            },

            selectedValue: function Slider$_getter_selectedValue(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if($KU.is(value, 'null')) {
                    value = Math.abs((prop.min + (prop.min - prop.max) / 2));
                } else if(value < prop.min) {
                    value = prop.min;
                } else if(value > prop.max) {
                    value = prop.max;
                }

                return value;
            },

            thickness: function Slider$_getter_thickness(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    device = $KU.browser('device');

                if(!value) {
                    value = (['ipad', 'iphone'].indexOf(device) >= 0) ? 2 : 5;
                }

                return value;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        Slider: function Slider$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            if(!_.ui) {
                $KU.defineProperty(_, 'ui', {}, null);
                $KU.defineProperty(_.ui, 'size', -1, true);
            }

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Slider', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Slider', null);
                }
            }

            if(!_.percent) $KU.defineProperty(_, 'percent', -1, true);
            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        Slider: function Slider$_postInitialization() {
            var _ = this._kwebfw_, prop = _.prop;

            if(prop.i18n_maxLabel) {
                prop.maxLabel = prop.i18n_maxLabel;
            }

            if(prop.i18n_minLabel) {
                prop.minLabel = prop.i18n_minLabel;
            }
        }
    };


    //This functions will be called in the scope of widget instance
    var _registerSlideGesture = function Slider$_registerSlideGesture(thumb) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;

        $KD.on(thumb, 'basic', 'slider', function(g) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
                $KD = $K.dom, _ = this._kwebfw_, prop = _.prop, dist = 0,
                el = $KW.el(this), moved = false, percent = 0, value = 0, deltaX;

            if(!$KW.interactable(this)) return; /* ---------------------------------------------- */

            if(g.status === 'started') {
                _.selectedValueBeforeSlideStarted = prop.selectedValue;

                if(prop.orientation === constants.SLIDER_HORIZONTAL_ORIENTATION) {
                    _.ui.size = _.view.offsetWidth;
                } else if(prop.orientation === constants.SLIDER_VERTICAL_ORIENTATION) {
                    _.ui.size = _.view.offsetHeight;
                }

                if(prop.focusThumbImage) {
                    $KD.setAttr(el.thumb, 'src', $KU.getImageURL(prop.focusThumbImage));
                }
            }

            if(g.delta.x && prop.orientation === constants.SLIDER_HORIZONTAL_ORIENTATION) {
                moved = true;

                if($KW.shouldApplyRTL(this, 'layoutAlignment')) {
                    deltaX = (-1*g.delta.x);
                } else {
                    deltaX = (g.delta.x);
                }

                percent = ((100/_.ui.size) * deltaX);
            } else if(g.delta.y && prop.orientation === constants.SLIDER_VERTICAL_ORIENTATION) {
                moved = true;
                percent = ((100/_.ui.size) * g.delta.y * -1);
            }

            if(moved && percent) {
                percent += _.percent;
                dist = ((_.ui.size/100) * percent);
                value = _calculateDeltaValueFromDisplacement.call(this, dist, _.ui.size);

                if(prop.selectedValue !== value) {
                    this.selectedValue = value;

                    if(g.status === 'moving') $KW.fire(this, 'onSlide', this);
                }
            }

            if(g.status === 'ended' && prop.selectedValue !== _.selectedValueBeforeSlideStarted) {
                if(prop.focusThumbImage) {
                    $KD.setAttr(el.thumb, 'src', $KU.getImageURL(prop.thumbImage));
                }

                delete _.selectedValueBeforeSlideStarted;
                _.ui.size = -1;
                $KW.fire(this, 'onSelection', this);
            }
        }, {scope:this});
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        Slider: function Slider$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        Slider: function Slider$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        Slider: {
            maxLabel: function Slider$_setter_maxLabel(/*old*/) {
                this._kwebfw_.prop.i18n_maxLabel = '';
            },

            minLabel: function Slider$_setter_minLabel(/*old*/) {
                this._kwebfw_.prop.i18n_minLabel = '';
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Slider: {
            focusThumbImage: function Slider$_valid_focusThumbImage(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            i18n_maxLabel: function Slider$_valid_i18n_maxLabel(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            i18n_minLabel: function Slider$_valid_i18n_minLabel(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            leftSkin: function Slider$_valid_leftSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            max: function Slider$_valid_max(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, flag = false;

                if($KU.is(value, 'integer')) {
                    flag = true;
                }

                if(flag && Object.prototype.hasOwnProperty.call(prop, 'min')
                && Object.prototype.hasOwnProperty.call(prop, 'selectedValue')) {
                    flag = (value > prop.min) ? true : 'Slider <max> value cannot be lesser or equal to <min> value.';

                    if(flag) {
                        flag = (value >= prop.selectedValue) ? true : 'Slider <max> value cannot be lesser than <selectedValue> value.';
                    }
                }

                return flag;
            },

            maxLabel: function Slider$_valid_maxLabel(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            maxLabelSkin: function Slider$_valid_maxLabelSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            min: function Slider$_valid_min(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, flag = false;

                if($KU.is(value, 'integer')) {
                    flag = true;
                }

                if(flag && Object.prototype.hasOwnProperty.call(prop, 'max')
                && Object.prototype.hasOwnProperty.call(prop, 'selectedValue')) {
                    flag = (value < prop.max) ? true : 'Slider <min> value cannot be greater or equal to <max> value.';

                    if(flag) {
                        flag = (value <= prop.selectedValue) ? true : 'Slider <min> value cannot be greater than <selectedValue> value.';
                    }
                }

                return flag;
            },

            minLabel: function Slider$_valid_minLabel(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            minLabelSkin: function Slider$_valid_minLabelSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            retainFlowHorizontalAlignment: function ContainerWidget$_valid_retainFlowHorizontalAlignment(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            onSelection:  function Slider$_valid_onSelection(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onSlide:  function Slider$_valid_onSlide(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            orientation: function Slider$_valid_orientation(value) {
                var flag = false, options = [
                    constants.SLIDER_HORIZONTAL_ORIENTATION,
                    constants.SLIDER_VERTICAL_ORIENTATION
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            rightSkin: function Slider$_valid_rightSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            selectedValue: function Slider$_valid_selectedValue(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, flag = false;

                if($KU.is(value, 'integer')) {
                    flag = true;
                }

                if(flag && Object.prototype.hasOwnProperty.call(prop, 'min')
                && Object.prototype.hasOwnProperty.call(prop, 'max')) {
                    flag = (value >= this.min && value <= this.max) ? true : 'Slider <selectedValue> must be between <min> and <max> value (boundary inclusive).';
                }

                return flag;
            },

            step: function Slider$_valid_step(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, flag = false;

                if($KU.is(value, 'integer')) {
                    flag = true;
                }

                if(flag && Object.prototype.hasOwnProperty.call(prop, 'min')
                && Object.prototype.hasOwnProperty.call(prop, 'max')) {
                    if((this.max-this.min) % value !== 0) {
                        flag = 'Slider <step>, <min>, <max> values combination is invalid.';
                    } else {
                        flag = true;
                    }
                }

                return flag;
            },

            thickness: function Slider$_valid_thickness(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number') && value >= 1 && value <= 25) {
                    flag = true;
                }

                return flag;
            },

            thumbHeight: function Slider$_valid_thumbHeight(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number') && value >= 0) {
                    flag = true;
                }

                return flag;
            },

            thumbImage: function Slider$_valid_thumbImage(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string') && value) {
                    flag = true;
                }

                return flag;
            },

            thumbOffset: function Slider$_valid_thumbOffset(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number') || $KU.is(value, 'null')) {
                    flag = true;
                }

                return flag;
            },

            thumbWidth: function Slider$_valid_thumbWidth(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'number') && value >= 0) {
                    flag = true;
                }

                return flag;
            },

            viewType: function Slider$_valid_viewType(value) {
                var flag = false, options = [
                    constants.SLIDER_VIEW_TYPE_DEFAULT,
                    constants.SLIDER_VIEW_TYPE_PROGRESS
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        Slider: {
            focusThumbImage: true,

            i18n_maxLabel: false,

            i18n_minLabel: false,

            leftSkin: function Slider$_view_leftSkin(el, old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                $KW.removeSkin(old, el.min);
                $KW.addSkin(this.leftSkin, el.min);
            },

            max: function Slider$_view_max(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.setAttr(el.thumb, 'aria-valuemax', this.max);
            },

            maxLabel: function Slider$_view_maxLabel(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.text(el.maxLabel, this.maxLabel);

                if(this.maxLabel) {
                    $KD.removeAttr(el.maxLabel, 'hidden');
                } else {
                    $KD.setAttr(el.maxLabel, 'hidden', true);
                }
            },

            maxLabelSkin: function Slider$_view_maxLabelSkin(el, old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                $KW.removeSkin(old, el.min);
                $KW.addSkin(this.maxLabelSkin, el.maxLabel);
            },

            min: function Slider$_view_min(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.setAttr(el.thumb, 'aria-valuemin', this.min);
            },

            minLabel: function Slider$_view_minLabel(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.text(el.minLabel, this.minLabel);

                if(this.minLabel) {
                    $KD.removeAttr(el.minLabel, 'hidden');
                } else {
                    $KD.setAttr(el.minLabel, 'hidden', true);
                }
            },

            minLabelSkin: function Slider$_view_minLabelSkin(el, old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                $KW.removeSkin(old, el.min);
                $KW.addSkin(this.minLabelSkin, el.minLabel);
            },

            onSelection: true,

            onSlide: true,

            orientation: false,

            retainFlowHorizontalAlignment : false,

            rightSkin: function Slider$_view_rightSkin(el, old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                $KW.removeSkin(old, el.max);
                $KW.addSkin(this.rightSkin, el.max);
            },

            selectedValue: function Slider$_view_selectedValue(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget, min = this.min,
                    value = this.selectedValue, percent = 0, max = this.max;

                if(max - min !== 0){
                    percent = ((100 / (max - min)) * (value - min));
                }

                if(percent < 0) percent = 0;
                if(percent > 100) percent = 100;

                this._kwebfw_.percent = percent;

                if(this.orientation === constants.SLIDER_HORIZONTAL_ORIENTATION) {
                    $KD.style(el.min, 'width', (percent+'%'));

                    if($KW.shouldApplyRTL(this, 'layoutAlignment')) {
                        $KD.style(el.thumb, 'left', ((100 - percent)+'%'));
                    } else {
                        $KD.style(el.thumb, 'left', (percent+'%'));
                    }

                    $KD.style(el.max, 'width', ((100-percent)+'%'));
                } else if(this.orientation === constants.SLIDER_VERTICAL_ORIENTATION) {
                    $KD.style(el.min, 'height', (percent+'%'));
                    $KD.style(el.thumb, 'bottom', (percent+'%'));
                    $KD.style(el.max, 'height', ((100-percent)+'%'));
                }

                $KD.setAttr(el.thumb, 'aria-valuenow', value);
            },

            step: true,

            thickness: function Slider$_view_thickness(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.orientation === constants.SLIDER_HORIZONTAL_ORIENTATION) {
                    $KD.style(el.slider, {height:(this.thickness+'px')});
                } else if(this.orientation === constants.SLIDER_VERTICAL_ORIENTATION) {
                    $KD.style(el.slider, {width:(this.thickness+'px')});
                }
            },

            thumbHeight: function Slider$_view_thumbHeight(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;


                $KD.style(el.thumb, {height:(this.thumbHeight+'px')});
            },

            thumbImage: function Slider$_view_thumbImage(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                $KD.setAttr(el.thumb, 'src', $KU.getImageURL(this.thumbImage));
            },

            thumbOffset: function Slider$_view_thumbOffset(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                if(this.orientation === constants.SLIDER_HORIZONTAL_ORIENTATION) {
                    if($KU.is(this.thumbOffset, 'null')) {
                        $KD.style(el.thumb, {transform: 'translate(-50%, -50%)'});
                    } else {
                        $KD.style(el.thumb, {transform: 'translate('+this.thumbOffset+'px, -50%)'});
                    }
                } else if(this.orientation === constants.SLIDER_VERTICAL_ORIENTATION) {
                    if($KU.is(this.thumbOffset, 'null')) {
                        $KD.style(el.thumb, {transform: 'translate(-50%, 50%)'});
                    } else {
                        $KD.style(el.thumb, {transform: 'translate(-50%, '+this.thumbOffset+'px)'});
                    }
                }
            },

            thumbWidth: function Slider$_view_thumbWidth(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.style(el.thumb, {width:(this.thumbWidth+'px')});
            },

            viewType: function Slider$_view_viewType(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.viewType === constants.SLIDER_VIEW_TYPE_PROGRESS) {
                    $KD.setAttr(el.thumb, 'hidden', true);
                } else if(this.viewType === constants.SLIDER_VIEW_TYPE_DEFAULT) {
                    $KD.removeAttr(el.thumb, 'hidden');
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'Slider', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Slider constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var Slider = function Slider(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null, p = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    focusThumbImage: '',
                    i18n_maxLabel: '',
                    i18n_minLabel: '',
                    leftSkin: 'slSliderLeftBlue',
                    max: 100, //Must be a non-decimal (+/-) value
                    maxLabel: '',
                    maxLabelSkin: 'slSliderRightBlue',
                    min: 0, //Must be a non-decimal (+/-) value
                    minLabel: '',
                    minLabelSkin: 'slSliderLeftBlue',
                    onSelection: null,
                    onSlide: null,
                    orientation: constants.SLIDER_HORIZONTAL_ORIENTATION,
                    retainFlowHorizontalAlignment: false,
                    rightSkin: 'slSliderRightBlue',
                    selectedValue: null, //must be a non-decimal (+/-) value
                    step: 1, //Must be a non-decimal (+) value
                    thickness: 15, //Must be between 1-25
                    thumbHeight: 21, //Must be a non-decimal (+) value
                    thumbImage: 'slider.png',
                    thumbOffset: null, //If provided, must be a non-decimal (+) value
                    thumbWidth: 20, //Must be a non-decimal (+) value
                    viewType: constants.SLIDER_VIEW_TYPE_DEFAULT
                };
            }

            _populateUnderscore.Slider.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            Slider.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Slider, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Slider.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to Slider
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Slider[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Slider>, but not in <_valid.Slider> namespace.');
                        } else {
                            valid = _valid.Slider[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Slider
                $KU.each(_view.Slider, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Slider$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Slider[key], 'function')) {
                            return _getter.Slider[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Slider$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Slider[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Slider[key], 'function')) {
                                        _setter.Slider[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Slider().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Slider().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if(bconfig.isPreValidated) {
                    p = this._kwebfw_.prop;

                    if($KU.is(p.selectedValue, undefined)) p.selectedValue = null;
                }

                if($KU.is(_postInitialization.Slider, 'function')) {
                    _postInitialization.Slider.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Slider, voltmx.ui.BasicWidget);


        /**
         * Takes care of flushing out the widget reference to clean memory.
         *
         * @override
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.Slider
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     void
         */
        var slider__flush = function Slider$_flush() {
            var $super = voltmx.ui.Slider.base.prototype,
                $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, el = $KW.el(this);

            el.thumb && $KD.off(el.thumb); //Remove all event listeners to avoid memory leaks
            $super._flush.call(this);
        };


        /**
         * Builds the view layer for voltmx.ui.Slider widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Slider
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  Slider view.
         */
        var slider__render = function Slider$_render(tag) {
            var $super = voltmx.ui.Slider.base.prototype, _ = this._kwebfw_,
                view = _.view, min = null, $K = voltmx.$kwebfw$, $KW = $K.widget,
                $KD = $K.dom, seekbar = null, slider = null, max = null,
                minLabel = null, maxLabel = null, thumb = null, el = $KW.el(view),
                dir = constants.WIDGET_DIRECTION_LTR;

            if($KW.shouldApplyRTL(this, 'layoutAlignment')) {
                dir = constants.WIDGET_DIRECTION_RTL;
            }

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    slider = $KD.create('DIV', {kr:'slider', ko:this.orientation});
                    minLabel = $KD.create('DIV', {kr:'min-label'});
                    seekbar = $KD.create('DIV', {kr:'seekbar'});
                    min = $KD.create('DIV', {kr:'min'});
                    max = $KD.create('DIV', {kr:'max'});
                    maxLabel = $KD.create('DIV', {kr:'max-label'});
                    thumb = $KD.create('IMG', {
                        kr:'thumb', loading:'lazy'
                    });
                    $KD.on(thumb, 'mousedown', 'image', function(e) {
                        $KD.preventDefault(e);
                    });
                    $KD.setAttr(seekbar, 'kwh-click', 'onClick');
                    $KD.setAttr(thumb, 'role', 'slider');
                    //DONOT DELETE THIS LINE:: $KD.setAttr(thumb, 'kwg', 'Slider');
                    $KD.setAttr(thumb, 'kwh-keydown', 'onKeyDown');
                    $KD.setAttr(thumb, 'kwh-keyup', 'onKeyUp');
                    $KD.setAttr(thumb, 'kwh-mousedown', 'onTouchStart');
                    $KD.setAttr(thumb, 'kwh-mouseup', 'onTouchEnd');
                    $KD.setAttr(thumb, 'kwh-touchstart', 'onTouchStart');
                    $KD.setAttr(thumb, 'kwh-touchend', 'onTouchEnd');
                    $KD.setAttr(thumb, 'aria-orientation', this.orientation);

                    $KD.add(slider, minLabel);
                    $KD.add(slider, seekbar);
                    $KD.add(seekbar, min);
                    $KD.add(seekbar, max);
                    $KD.add(seekbar, thumb);
                    $KD.add(slider, maxLabel);

                    view = $super._render.call(this, tag, [slider]);

                    $KD.setAttr(view, 'kdir', dir);

                    el = $KW.el(view);

                    _view.Slider.thickness.call(this, el, this.thickness);
                    _view.Slider.minLabelSkin.call(this, el, this.minLabelSkin);
                    _view.Slider.leftSkin.call(this, el, this.leftSkin);
                    _view.Slider.rightSkin.call(this, el, this.rightSkin);
                    _view.Slider.maxLabelSkin.call(this, el, this.maxLabelSkin);
                    _view.Slider.thumbOffset.call(this, el, this.thumbOffset);
                    _view.Slider.thumbHeight.call(this, el, this.thumbHeight);
                    _view.Slider.thumbWidth.call(this, el, this.thumbWidth);
                    _view.Slider.thumbImage.call(this, el, this.thumbImage);
                    _view.Slider.viewType.call(this, el, this.viewType);
                    _view.Slider.selectedValue.call(this, el, this.selectedValue);

                    _registerSlideGesture.call(this, el.thumb);
                }

                _view.Slider.minLabel.call(this, el, this.minLabel);
                _view.Slider.maxLabel.call(this, el, this.maxLabel);

                $KW.accessibility(this);
            }

            return view;
        };


        $K.defVoltmxProp(Slider.prototype, [
            {keey:'_flush', value:slider__flush},
            {keey:'_render', value:slider__render}
        ]);


        return Slider;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxswitch.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'Switch', value:{}, items:[
            {keey:'onClick', value:function(/*evt*/) {
                this.selectedIndex = Number(!this.selectedIndex);

                return false;
            }},

            {keey:'onKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    code = evt.keyCode || evt.which;

                if([13, 32].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 13 || code === 32) { //Enter or Space
                        this.selectedIndex = Number(!this.selectedIndex);
                    }
                }

                return false;
            }}
        ]}
    ]);


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        Switch: {
            leftSideText: function Switch$_getter_leftSideText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if(prop.i18n_leftSideText) {
                    value = $KU.getI18Nvalue(prop.i18n_leftSideText);
                }

                return value;
            },

            rightSideText: function Switch$_getter_rightSideText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if(prop.i18n_rightSideText) {
                    value = $KU.getI18Nvalue(prop.i18n_rightSideText);
                }

                return value;
            },

            thumbText: function Switch$_getter_thumbText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, prop = this._kwebfw_.prop;

                if(prop.i18n_thumbText) {
                    value = $KU.getI18Nvalue(prop.i18n_thumbText);
                }

                return value;
            }
        }
    };


    //This functions will be called in the scope of widget instance
    var _getTheme = function Switch$_getTheme() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils,
            device = $KU.browser('device'), theme = '';

        if(this.thumbHeight && this.thumbWidth
        && this.trackHeight && this.trackWidth) {
            theme = 'custom';
        } else {
            theme = 'non-ios-gt6';

            if(['ipad', 'iphone'].indexOf(device) >= 0) {
                theme = 'ios-gt6';
            }
        }

        return theme;
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        Switch: function Switch$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Switch', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Switch', null);
                }
            }

            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        Switch: function Switch$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = this._kwebfw_, prop = _.prop;

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'defSwitchNormal';
            }

            if(prop.i18n_leftSideText) {
                prop.leftSideText = prop.i18n_leftSideText;
            }

            if(prop.i18n_rightSideText) {
                prop.rightSideText = prop.i18n_rightSideText;
            }

            if(prop.i18n_thumbText) {
                prop.thumbText = prop.i18n_thumbText;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        Switch: function Switch$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        Switch: function Switch$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        Switch: {
            leftSideText: function Switch$_setter_leftSideText(/*old*/) {
                this._kwebfw_.prop.i18n_leftSideText = '';
            },

            rightSideText: function Switch$_setter_rightSideText(/*old*/) {
                this._kwebfw_.prop.i18n_rightSideText = '';
            },

            selectedIndex: function Switch$_setter_selectedIndex(old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                if(this.selectedIndex !== old) {
                    $K.apm.send(this, 'Touch', {type:(this._kwebfw_.name+'_Slide')});
                    $KW.fire(this, 'onSlide', this);
                }
            },

            thumbText: function Switch$_setter_thumbText(/*old*/) {
                this._kwebfw_.prop.i18n_thumbText = '';
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Switch: {
            i18n_leftSideText: function Switch$_valid_i18n_leftSideText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            i18n_rightSideText: function Switch$_valid_i18n_rightSideText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            i18n_thumbText: function Switch$_valid_i18n_thumbText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            leftSideText: function Switch$_valid_leftSideText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            onSlide: function Switch$_valid_onSlide(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            rightSideText: function Switch$_valid_rightSideText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            selectedIndex: function Switch$_valid_selectedIndex(value) {
                var flag = false;

                if([0, 1].indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            },

            thumbHeight: function Switch$_valid_thumbHeight(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            thumbOffset: function Switch$_valid_thumbOffset(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'integer')) {
                    flag = true;
                }

                return flag;
            },

            thumbSkin: function Switch$_valid_thumbSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            thumbText: function Switch$_valid_thumbText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            thumbWidth: function Switch$_valid_thumbWidth(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            trackHeight: function Switch$_valid_trackHeight(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            trackWidth: function Switch$_valid_trackWidth(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        Switch: {
            i18n_leftSideText: false,

            i18n_rightSideText: false,

            i18n_thumbText: false,

            leftSideText: function Switch$_view_leftSideText(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(_getTheme.call(this) === 'ios-gt6') {
                    $KD.text($KD.first(el.left), '');
                } else {
                    $KD.text($KD.first(el.left), this.leftSideText);
                }
            },

            onSlide: true,

            rightSideText: function Switch$_view_rightSideText(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(_getTheme.call(this) === 'ios-gt6') {
                    $KD.text($KD.first(el.right), '');
                } else {
                    $KD.text($KD.first(el.right), this.rightSideText);
                }
            },

            selectedIndex: function Switch$_view_selectedIndex(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, timeout = null;

                if(this.selectedIndex) {
                    $KD.removeAttr(el.right, 'hidden');
                    //Timeout with 500ms is causing UI distortion while toggling, converted to 0 [Ticket : MADPSPA-2314]
                    timeout = setTimeout(function() {
                        $KD.setAttr(el.left, 'hidden', true);
                        clearTimeout(timeout); timeout = null;
                    }, 0);

                    //As tranlateX is causing issue in safari14, converted to translate3d [Ticket : MADPSPA-2294]
                    $KD.style(el.left, 'transform', 'translate3d(-100%, 0, 0)');
                    $KD.style(el.thumb, 'transform', 'translate3d(-100%, 0, 0)');
                    $KD.style(el.right, 'transform', 'translate3d(-100%, 0, 0)');
                } else {
                    $KD.removeAttr(el.left, 'hidden');
                    //Timeout with 500ms is causing UI distortion while toggling, converted to 0 [Ticket : MADPSPA-2314]
                    timeout = setTimeout(function() {
                        $KD.setAttr(el.right, 'hidden', true);
                        clearTimeout(timeout); timeout = null;
                    }, 0);

                    //As tranlateX is causing issue in safari14, converted to translate3d [Ticket : MADPSPA-2294]
                    $KD.style(el.left, 'transform', 'translate3d(0%, 0, 0)');
                    $KD.style(el.thumb, 'transform', 'translate3d(0%, 0, 0)');
                    $KD.style(el.right, 'transform', 'translate3d(0%, 0, 0)');
                }

                $KD.setAttr(el.switch, 'aria-checked', (!this.selectedIndex).toString());
            },

            thumbHeight: function Switch$_view_thumbHeight(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.thumbHeight) {
                    $KD.style(el.thumb, 'height', this.thumbHeight);
                } else {
                    $KD.style(el.thumb, 'height', null);
                }
            },

            thumbOffset: function Switch$_view_thumbOffset(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.style(el.thumb, {
                    marginLeft: (this.thumbOffset+'px'),
                    marginRight: (this.thumbOffset+'px')
                });
            },

            thumbSkin: function Switch$_view_thumbSkin(el, old) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                $KW.removeSkin(old, el.thumb);
                $KW.addSkin(this.thumbSkin, el.thumb);
            },

            thumbText: function Switch$_view_thumbText(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.text(el.thumb, ((_getTheme.call(this) === 'ios-gt6') ? '' : this.thumbText));
            },

            thumbWidth: function Switch$_view_thumbWidth(el/*, old*/) {
                var $K = voltmx.$kwebfw$, left = null,
                    $KD = $K.dom, right = null;

                left = $KD.first(el.left); right = $KD.first(el.right);

                if(this.thumbWidth) {
                    $KD.style(el.thumb, 'width', this.thumbWidth);
                    $KD.style(left, 'width', 'calc(100% - '+this.thumbWidth+')');
                    $KD.style(right, 'width', 'calc(100% - '+this.thumbWidth+')');
                } else {
                    $KD.style(el.thumb, 'width', null);
                    $KD.style(left, 'width', null);
                    $KD.style(right, 'width', null);
                }
            },

            trackHeight: function Switch$_view_trackHeight(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.trackHeight) {
                    $KD.style(el.switch, 'height', this.trackHeight);
                } else {
                    $KD.style(el.switch, 'height', null);
                }
            },

            trackWidth: function Switch$_view_trackWidth(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.trackWidth) {
                    $KD.style(el.switch, 'width', this.trackWidth);
                } else {
                    $KD.style(el.switch, 'width', null);
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'Switch', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Switch constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var Switch = function Switch(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    i18n_leftSideText: '',
                    i18n_rightSideText: '',
                    i18n_thumbText: '',
                    leftSideText: 'ON',
                    onSlide: null,
                    rightSideText: 'OFF',
                    selectedIndex: 1,
                    thumbHeight: '',
                    thumbOffset: 0,
                    thumbSkin: '',
                    thumbText: '',
                    thumbWidth: '',
                    trackHeight: ''
                };
            }

            _populateUnderscore.Switch.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            Switch.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Switch, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Switch.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to Switch
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Switch[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Switch>, but not in <_valid.Switch> namespace.');
                        } else {
                            valid = _valid.Switch[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Switch
                $KU.each(_view.Switch, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Switch$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Switch[key], 'function')) {
                            return _getter.Switch[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Switch$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Switch[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Switch[key], 'function')) {
                                        _setter.Switch[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Switch().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Switch().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.Switch, 'function')) {
                    _postInitialization.Switch.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Switch, voltmx.ui.BasicWidget);


        /**
         * Builds the view layer for voltmx.ui.Switch widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Switch
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  Switch view.
         */
        var switch__render = function Switch$_render(tag) {
            var $super = voltmx.ui.Switch.base.prototype, _ = this._kwebfw_,
                left = null, view = _.view, $K = voltmx.$kwebfw$,
                $KW = $K.widget, $KD = $K.dom, el = $KW.el(view),
                $switch = null, right = null, holder = null, thumb = null;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    $switch = $KD.create('DIV', {kr:'switch'});
                    left = $KD.create('DIV', {kr:'left'});
                    right = $KD.create('DIV', {kr:'right'});
                    holder = $KD.create('DIV', {kr:'holder'});
                    thumb = $KD.create('DIV', {kr:'thumb'});

                    $KD.setAttr(holder, 'kwh-click', 'onClick');
                    $KD.setAttr($switch, 'role', 'switch');
                    $KD.setAttr($switch, 'kwh-keyup', 'onKeyUp');
                    $KD.setAttr($switch, 'aria-label', (this.selectedIndex ? this.rightSideText : this.leftSideText));

                    $KD.add($switch, left);
                    $KD.add($switch, right);
                    $KD.add(left, $KD.create('LABEL'));
                    $KD.add(right, $KD.create('LABEL'));
                    $KD.add(holder, thumb);

                    view = $super._render.call(this, tag, [$switch, holder]);

                    el = $KW.el(view);

                    $KD.setAttr(view, 'kt', _getTheme.call(this));

                    _view.Switch.selectedIndex.call(this, el, this.selectedIndex);
                    _view.Switch.thumbHeight.call(this, el, this.thumbHeight);
                    _view.Switch.thumbOffset.call(this, el, this.thumbOffset);
                    _view.Switch.thumbSkin.call(this, el, this.thumbSkin);
                    _view.Switch.thumbWidth.call(this, el, this.thumbWidth);
                    _view.Switch.trackHeight.call(this, el, this.trackHeight);
                    _view.Switch.trackWidth.call(this, el, this.trackWidth);
                }

                _view.Switch.leftSideText.call(this, el, this.leftSideText);
                _view.Switch.rightSideText.call(this, el, this.rightSideText);
                _view.Switch.thumbText.call(this, el, this.thumbText);

                $KW.accessibility(this);
            }

            return view;
        };


        $K.defVoltmxProp(Switch.prototype, [
            {keey:'_render', value:switch__render}
        ]);


        return Switch;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxtabpane.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'TabPane', value:{}, items:[
            {keey:'onTabClick', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, pos = 0,
                    _ = this._kwebfw_, prop = _.prop, li = $KD.closest(evt.target, 'tabid'),
                    index = _getIndexByTabId.call(this, $KD.getAttr(li, 'tabid'));

                //Model should be marked for relayout only if the viewtype is collapsible/tabview
                if(prop.viewType !== constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                    $KW.markRelayout(this[_.tabs[index].id]);
                }

                if(prop.viewType !== constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                    prop.activeTabs.splice(pos, 1, index);
                } else {
                    pos = prop.activeTabs.indexOf(index);

                    if(prop.viewConfig.collapsibleViewConfig.toggleTabs === true) {
                        //If the pos is 0, it means the tab clicked is active
                        //and the tab body should be collapsed
                        if(pos === 0) {
                            prop.activeTabs = [];
                        } else {
                            prop.activeTabs = [index];
                        }
                    } else {
                        if(pos >= 0) {
                            prop.activeTabs.splice(pos, 1);
                        } else {
                            prop.activeTabs.push(index);
                        }
                    }
                }

                _handleViewReflection.call(this);
                $KW.fire(this, 'onTabClick', this, {tabIndex:index});

                return false;
            }},

            {keey:'onTabKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    code = evt.keyCode || evt.which;

                if([13, 32].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 13 || code === 32) { //Enter or Space
                        //TODO:: Tab switch should not happen here, rather in "onTabKeyUp"
                    }
                }

                return false;
            }},

            {keey:'onTabKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    code = evt.keyCode || evt.which;

                if([13, 32].indexOf(code) >= 0) {
                    $KD.preventDefault(evt);

                    if(code === 13 || code === 32) { //Enter or Space
                        //TODO:: Tab switch should happen here
                    }
                }

                return false;
            }},

            {keey:'setupUIInteraction', value:function(/*dom, clone*/) {
                //TODO::
            }}
        ]}
    ]);


    //This function will be called in the scope of widget instance
    var _addTab = function TabPane$_addTab(tabId, tabName, tabImage, tabContainer, index, tpl) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            _ = this._kwebfw_, prop = _.prop, append = false,
            disabled = _.disabled, clone = null, tab = null;

        if($KU.is(this[tabId], 'widget')) {
            throw new Error('Duplicate widget ID <'+tabId+'> encountered.\nAlready added to TabPane with id="'+this.id+'".');
        } else {
            if($KU.is(tabContainer, 'string')) {
                tabContainer = _voltmx.mvc.initializeSubViewController(tabContainer);
            }

            if($KU.is(tabContainer, 'widget', 'FlexContainer')) {
                if($KU.is(tpl, 'string') || $KU.is(tpl, 'widget', 'FlexContainer'))
                    tab = $KW.getTemplate(this, tpl);

                if($KU.is(tab, 'widget', 'FlexContainer')) {
                    //TODO:: How each tab will get their respective tabName ???
                    clone = $KU.clone(tab); //TODO:: May need a revisit
                }

                tabContainer._kwebfw_.is.tab = true;
                $KU.defineProperty(tabContainer._kwebfw_, 'tpid', _.uid, null);
                $KW.root(tabContainer, 'tab', this._kwebfw_.wap);

                if(index === _.tabs.length) append = true;
                tab = {id:tabId, image:tabImage, name:tabName, tab:clone, scroll:{x:0, y:0}};

                if(append) {
                    _.tabs.push(tab);
                } else {
                    _.tabs.splice(index, 0, tab);
                }

                this[tabId] = tabContainer;

                $KW.iterate(tabContainer, function(widget) {
                    var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = widget._kwebfw_;

                    if(disabled && !_.disabled) {
                        _.disabled = true;
                        $KW.handleTabPaneEnablement(widget);
                    } else {
                        return true; //Break the loop
                    }
                }, {scope:tabContainer, tabs:false});

                if(prop.viewType === constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                    if(prop.activeTabs.length > 1
                    && prop.viewConfig.collapsibleViewConfig.toggleTabs === true) {
                        prop.activeTabs = [prop.activeTabs[(prop.activeTabs.length-1)]];
                    }
                } else {
                    if(prop.activeTabs.length === 0 && _.tabs.length === 1) {
                        prop.activeTabs.push(0);
                    }
                }

                _addTabToView.call(this, index);
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _addTabToView = function TabPane$_addTabToView(index) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget,
            $KD = $K.dom, _ = this._kwebfw_, el = $KW.el(this), tab = null,
            comingFromRenderCall = false, tag = 'LI', holder = 'tabs';

        if(el.node && _.prop.viewType !== constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
            if(_.prop.viewType !== constants.TABPANE_VIEW_TYPE_TABVIEW) {
                tag = 'DIV';
                holder = 'scrolee';
            }

            if($KU.is(index, 'integer')) {
                tab = _.tabs[index]; //Call stack is from API call
            } else if($KU.is(index, 'object')) {
                comingFromRenderCall = true;
                tab = index; //Call stack is from render call
                index = _getIndexByTabId.call(this, tab.id);
            }

            if(comingFromRenderCall || index === (_.tabs.length-1)) {
                //NOTE:: Don't switch the order of below 2 lines
                $KD.add(el[holder], _createTab.call(this, tab, tag));
                $KD.add(el.scrolee, this[tab.id]._render());
            } else {
                if(_.prop.viewType === constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                    index = (index * 2);
                }

                //NOTE:: Don't switch the order of below 2 lines
                $KD.addAt(el.scrolee, this[tab.id]._render(), index);
                $KD.addAt(el[holder], _createTab.call(this, tab, tag), index);
            }

            if(!comingFromRenderCall) _handleViewReflection.call(this);
        } else if(el.node && _.prop.viewType === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
            if($KU.is(index, 'integer')) {
                tab = _.tabs[index];
            } else if($KU.is(index, 'object')) {
                comingFromRenderCall = true;
                tab = index;
                index = _getIndexByTabId.call(this, tab.id);
            }

            if(comingFromRenderCall || index === (_.tabs.length-1)) {
                $KD.add(el.scrolee, this[tab.id]._render());
                $KD.add(el[holder], _createTab.call(this, tab, tag));
            } else {
                $KD.addAt(el.scrolee, this[tab.id]._render(), index);
                $KD.addAt(el[holder], _createTab.call(this, tab, tag), index);
            }

            if(!comingFromRenderCall) _handleViewReflection.call(this);
        }
    };


    //This function will be called in the scope of widget instance
    var _createTab = function TabPane$_createTab(tab, tag) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, $KW = $K.widget,
            _ = this._kwebfw_, prop = _.prop, li = null, html = '',
            tpl = null, clonetemp = null, final = null, img = null;

        //tab = {id:<tabId>, image:<tabImage>, name:<tabName>, tab:<clone>};
        li = $KD.create(tag, {tabid:tab.id});
        $KD.setAttr(li, 'kwh-click', 'onTabClick');
        $KD.setAttr(li, 'kwh-keydown', 'onTabKeyDown');
        $KD.setAttr(li, 'kwh-keyup', 'onTabKeyUp');

        if(_.prop.viewType !== constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
            if($KU.is(tab.tab, 'widget', 'FlexContainer')) {
                tpl = $KW.cloneTemplate(tab.tab);
                clonetemp = tpl._render();
                final = tpl._kwebfw_.flex.final;

                if($KW.inPercent(final.width)
                && prop.viewType === constants.TABPANE_VIEW_TYPE_TABVIEW) {
                    $KD.style(li, 'width', final.width);
                    $KD.style(clonetemp, 'width', '100%');
                }

                $KD.add(li, clonetemp);
            } else {
                html += '<img loading="lazy" onmousedown="return false;"';
                if($KU.is(tab.image, 'string') && tab.image) {
                    html += (' src="'+$KU.getImageURL(tab.image)+'"');
                } else {
                    html += ' style="display:none;"';
                }
                html += '/>';

                html += '<label style="width:100%">'+tab.name+'</label>';

                //create div, add tab image and tab name
                html = '<div style="padding:3px 7px; display:flex; width:100%; align-self:center">' + html + '</div>';

                html += '<img loading="lazy" onmousedown="return false;" src="" />';

                if(prop.viewType === constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                    $KD.style(li, 'display', 'flex');
                }

                $KD.html(li, html);
            }
        } else if(_.prop.viewType === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
            $KD.style(li, {paddingLeft: '4px', display: 'inline-block'});

            img = $KD.create('IMG', {onmousedown:'return false;'});

            $KD.setAttr(img, 'src', $KU.getImageURL(prop.viewConfig.pageViewConfig.pageOffDotImage));
            $KD.setAttr(img, 'alt', '');
            $KD.setAttr(img, 'index', _getIndexByTabId.call(this, tab.id));

            $KD.add(li, img);
        }

        return li;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //This function will be called in the scope of widget instance
    var _flushTabs = function TabPane$_flushTabs(tabs, keepHierarchy) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        if($KU.is(tabs, 'array')) {
            $KU.each(tabs, function(tab) {
                if(this[tab.id] && this[tab.id]._kwebfw_.is.tab
                && this[tab.id] instanceof voltmx.ui.FlexContainer) {
                    _removeWidgetHierarchy.call(this, this[tab.id], this, keepHierarchy);

                    if(tab.tab) {
                        _removeWidgetHierarchy.call(this, tab.tab, this, keepHierarchy);
                    }
                }
            }, this);
        }
    };


    //This function will be called in the scope of widget instance
    var _getIndexByTabId = function TabPane$_getIndexByTabId(tabId) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, index = -1;

        $KU.each(_.tabs, function(tab, pos) {
            if(tab.id === tabId) {
                index = pos;
                return true;
            }
        });

        return index;
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        TabPane: {
            activeTabs: function TabPane$_getter_activeTabs(value) {
                var _ = this._kwebfw_;

                if(_.activeTabs) {
                    return _.activeTabs.slice(0);
                }
                return value.slice(0);
            },

            viewConfig: function TabPane$_getter_viewConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            }
        }
    };


    //All the functions will be called in the scope of widget instance
    var _handleViewReflection = function TabPane$_handleViewReflection() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom, $KW = $K.widget,
            _ = this._kwebfw_, el = $KW.el(this), prop = _.prop;

        if(prop.viewType === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
            //when the view is pageview, then the scrolee width should be 100 * no.of.tabs
            $KD.style(el.scrolee, {'width': (100 * (_.tabs.length))+'%'});
        } else {
            $KD.style(el.scrolee, {'width': '100%'});
        }

        $KU.each(_.tabs, function(tab, index) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                _ = this._kwebfw_, prop = _.prop, el = $KW.el(this),
                config = null, li = null, src = '', value = 0;

            if(prop.viewType === constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                li = $KD.childAt(el.scrolee, (index*2));
                $KD.style(li, {display:'flex', flexDirection: 'row'});

                if(prop.viewConfig && prop.viewConfig.collapsibleViewConfig) {
                    config = prop.viewConfig.collapsibleViewConfig;
                }

                if(config && !(tab.tab)) {
                    if(config.imagePosition === constants.TABPANE_COLLAPSIBLE_IMAGE_POSITION_LEFT) {
                        $KD.style(li, 'flexDirection', 'row-reverse');
                    }

                    //get the first div inside the li, and then align the text of the label
                    if(config.tabNameAlignment === constants.TABPANE_COLLAPSIBLE_TABNAME_ALIGNMENT_RIGHT) {
                        $KD.style($KD.childAt($KD.first(li), 1), 'text-align', 'right');
                    } else if(config.tabNameAlignment === constants.TABPANE_COLLAPSIBLE_TABNAME_ALIGNMENT_CENTER) {
                        $KD.style($KD.childAt($KD.first(li), 1), 'text-align', 'center');
                    } else {
                        $KD.style($KD.childAt($KD.first(li), 1), 'text-align', 'left');
                    }
                }
            } else if(prop.viewType === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                li = $KD.childAt(el.tabs, index);
            } else if(prop.viewType === constants.TABPANE_VIEW_TYPE_TABVIEW) {
                li = $KD.childAt(el.tabs, index);

                $KD.style(li, {display:'flex', flexDirection: 'row'});
                if(prop.viewConfig && prop.viewConfig.tabViewConfig) {
                    config = prop.viewConfig.tabViewConfig;

                    if(config.headerContainerWeight) {
                        if(config.headerPosition === constants.TAB_HEADER_POSITION_TOP
                        || config.headerPosition === constants.TAB_HEADER_POSITION_BOTTOM) {
                            $KD.style(li, 'width', config.headerContainerWeight + '%');
                        } else {
                            $KD.style(li, 'width', '100%');
                        }
                    }
                }
            }

            if(li && prop.viewType !== constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                if(prop.activeTabs.indexOf(index) >= 0) {
                    if(_.inited[tab.id] !== true) {
                        _.inited[tab.id] = true;
                        $KW.fire(this[tab.id], 'onInit', this[tab.id]);
                    }

                    $KD.removeCls(li, prop.inactiveSkin);
                    $KD.addCls(li, prop.activeSkin);
                    $KD.removeAttr(this[tab.id]._kwebfw_.view, 'hidden');

                    if(config && config.expandedImage
                    && prop.viewType === constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                        src = config.expandedImage;
                    }
                } else {
                    $KD.removeCls(li, prop.activeSkin);
                    $KD.addCls(li, prop.inactiveSkin);
                    $KD.setAttr(this[tab.id]._kwebfw_.view, 'hidden', true);

                    if(config && config.collapsedImage
                    && prop.viewType === constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                        src = config.collapsedImage;
                    }
                }

                if(src) {
                    $KD.setAttr($KD.last(li), 'src', $KU.getImageURL(src));
                    $KD.style($KD.last(li), 'display', null);
                } else if(prop.viewType === constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                    if(!config.collapsedImage || !config.expandedImage) {
                        $KD.removeAttr($KD.last(li), 'src');
                    }
                } else if(prop.viewType === constants.TABPANE_VIEW_TYPE_TABVIEW) {
                    $KD.removeAttr($KD.last(li), 'src');
                }
            } else if(li && prop.viewType === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                if(prop.activeTabs.indexOf(index) >= 0) {
                    if(_.inited[tab.id] !== true) {
                        _.inited[tab.id] = true;
                        $KW.fire(this[tab.id], 'onInit', this[tab.id]);
                    }

                    //the value for translate left to the view port
                    value = -(index * (100/(_.tabs.length)));

                    //Adding style to view port for transition with calculated value
                    $KD.style(el.scrolee, 'transition', 'transform 0.5s ease 0s');
                    $KD.style(el.scrolee, 'transform', 'translate3d(' + value + '%, 0, 0)');

                    $KD.setAttr($KD.last(li), 'src', $KU.getImageURL(prop.viewConfig.pageViewConfig.pageOnDotImage));
                } else {
                    $KD.setAttr($KD.last(li), 'src', $KU.getImageURL(prop.viewConfig.pageViewConfig.pageOffDotImage));
                }
            }
        }, this);
    };

    //This function will be called on swipe of Tabpane page view (Left swipe)
    var _nextPage = function TabPane$_nextPage() {
        var currentPage = 0, _ = this._kwebfw_, prop = _.prop, noOfPages = (_.tabs.length) - 1,
            nextPage = prop.activeTabs[0] + 1;

        if(nextPage > noOfPages) {
            currentPage = noOfPages;
        } else {
            currentPage = nextPage;
        }

        this.activeTabs = [currentPage];
    };

    //All the functions will be called in the scope of widget instance
    var _normalizeActiveTabs = function TabPane$_normalizeActiveTabs() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, prop = _.prop;

        if(_.activeTabs) {
            prop.activeTabs = [];

            $KU.each(_.activeTabs, function(tabIndex) {
                var _ = this._kwebfw_, prop = _.prop;

                if(tabIndex >= 0 && tabIndex < _.tabs.length) {
                    prop.activeTabs.push(tabIndex);
                }
            }, this);

            if(prop.activeTabs.length > 1
            && (prop.viewType !== constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW
            || prop.viewConfig.collapsibleViewConfig.toggleTabs === true)) {
                prop.activeTabs = [prop.activeTabs[0]];
            } else if(!prop.activeTabs.length && _.tabs.length
            && prop.viewType !== constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                prop.activeTabs = [0];
            }

            delete _.activeTabs;
        }
    };

    var _normalizeViewConfig = function TabPane$_normalizeViewConfig() {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, prop = _.prop;

        if(prop.viewConfig.tabViewConfig) {
            if(!($KU.is(prop.viewConfig.tabViewConfig.image1, 'string'))) {
                prop.viewConfig.tabViewConfig.image1 = 'arrow-left.png';
            }

            if(!($KU.is(prop.viewConfig.tabViewConfig.image2, 'string'))) {
                prop.viewConfig.tabViewConfig.image2 = 'arrow-right.png';
            }
        } else {
            prop.viewConfig.tabViewConfig = {
                headerPosition: constants.TAB_HEADER_POSITION_TOP,
                image1: 'arrow-left.png',
                image2: 'arrow-right.png'
            };
        }

        if(prop.viewConfig.pageViewConfig) {
            if($KU.is(prop.viewConfig.pageViewConfig.needPageIndicator, 'boolean')) {
                prop.viewConfig.pageViewConfig.needPageIndicator = true;
            }

            if(prop.viewConfig.pageViewConfig.needPageIndicator) {
                if(!($KU.is(prop.viewConfig.pageViewConfig.pageOnDotImage, 'string'))) {
                    prop.viewConfig.pageViewConfig.pageOnDotImage = 'pageondot.png';
                }
                if(!($KU.is(prop.viewConfig.pageViewConfig.pageOffDotImage, 'string'))) {
                    prop.viewConfig.pageViewConfig.pageOffDotImage = 'pageoffdot.png';
                }
            }
        } else {
            prop.viewConfig.pageViewConfig = {
                needPageIndicator: true,
                pageOffDotImage: 'pageoffdot.png',
                pageOnDotImage: 'pageondot.png'
            };
        }

        if(!prop.viewConfig.collapsibleViewConfig) {
            prop.viewConfig.collapsibleViewConfig = {
                imagePosition: constants.TABPANE_COLLAPSIBLE_IMAGE_POSITION_RIGHT,
                tabNameAlignment: constants.TABPANE_COLLAPSIBLE_TABNAME_ALIGNMENT_LEFT,
                toggleTabs: false
            };
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        TabPane: function TabPane$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.TabPane', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'TabPane', null);
                }
            }

            if(!_.tabs) $KU.defineProperty(_, 'tabs', [], null);
            if(!_.inited) $KU.defineProperty(_, 'inited', {}, null);

            //This holds the templateControllers used in this TabPane tabHeaderTemplate
            if(!_.templates) $KU.defineProperty(_, 'templates', {}, null);
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        TabPane: function TabPane$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = this._kwebfw_, prop = _.prop;

            if(prop.activeTabs.length) {
                _.activeTabs = prop.activeTabs.slice(0);
                prop.activeTabs = [];
            }

            if($KU.is(prop.padding, 'null')) {
                prop.padding = [0, 0, 0, 0];
            }

            _normalizeViewConfig.call(this);
        }
    };

    //This function will be called on swipe of Tabpane page view (Right swipe)
    var _previousPage = function TabPane$_previousPage() {
        var currentPage = 0, _ = this._kwebfw_, prop = _.prop,
            prevPage = prop.activeTabs[0] - 1;

        if(prevPage > 0) {
            currentPage = prevPage;
        }

        this.activeTabs = [currentPage];
    };

    //Registers swipe gesture for tabpane page view and handles the same
    var _registerSwipeGesture = function TabPane$_registerSwipeGesture(scrolee) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;

        $KD.on(scrolee, 'swipe', 'TabPane', function(g) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                _ = this._kwebfw_, distance = 0, el = $KW.el(this), pageWidth = 0,
                prop = _.prop;

            if(g.status === 'started') {
                $KD.style(el.scrolee, 'transition', null);
            }

            if(g.status === 'moving') {
                pageWidth = $KD.first(el.scrolee).offsetWidth;
                distance = -(pageWidth * prop.activeTabs[0]) + g.distance.x;
                $KD.style(el.scrolee, 'transform', 'translate3d(' + distance + 'px, 0, 0)');
            }

            if(g.status === 'ended') {
                if(g.distance.x <= -7) {
                    _nextPage.call(this, el, _.swipeContext);
                    $KW.fire(this, 'onTabClick', this, {tabIndex:prop.activeTabs[0]});
                } else if(g.distance.x >= 7) {
                    _previousPage.call(this, el, _.swipeContext);
                    $KW.fire(this, 'onTabClick', this, {tabIndex:prop.activeTabs[0]});
                } else {
                    pageWidth = $KD.first(el.scrolee).offsetWidth;
                    distance = -(pageWidth * prop.activeTabs[0]) + g.distance.x;
                    $KD.style(el.scrolee, 'transform', 'translate3d(' + distance + 'px, 0, 0)');
                }
            }
        }, {scope:this});
    };

    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        TabPane: function TabPane$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        TabPane: function TabPane$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //This function will be called in the scope of widget instance
    var _removeTab = function TabPane$_removeTab(index) {
        var _ = this._kwebfw_, tabid = _.tabs[index].id,
            prop = _.prop, pos = prop.activeTabs.indexOf(index);

        _removeTabFromView.call(this, index);

        delete _.inited[tabid];
        _flushTabs.call(this, [_.tabs[index]]);
        _.tabs.splice(index, 1);

        if(pos >= 0) {
            prop.activeTabs.splice(pos, 1);

            if(prop.viewType !== constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                if(!_.tabs[index]) { //Choose previous tab
                    index = ((_.tabs.length) ? (_.tabs.length-1) : -1);
                } //else same index points to next tab

                if(index !== -1) {
                    this.activeTabs = [index];
                }
            }
        } else {
            // if the deleted index is not an active tab and less than active index,
            // then the active tab index should be reduced by one
            if(prop.viewType !== constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                if(index < prop.activeTabs[0]) {
                    prop.activeTabs = [prop.activeTabs[0] - 1];
                }

                //if the view type is page view then the view port width should be updated for every removal
                if(prop.viewType === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                    _handleViewReflection.call(this);
                }
            }
        }
    };


    //This function will be called in the scope of widget instance
    var _removeTabFromView = function TabPane$_removeTabFromView(index) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom, tab = null,
            _ = this._kwebfw_, prop = _.prop, el = $KW.el(this), li = null;

        if(prop.viewType === constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
            li = $KD.childAt(el.scrolee, (index*2));
        } else if(prop.viewType === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
            li = $KD.childAt(el.tabs, index);
        } else if(prop.viewType === constants.TABPANE_VIEW_TYPE_TABVIEW) {
            li = $KD.childAt(el.tabs, index);
        }

        $KD.remove(li);
        tab = this[_.tabs[index].id];
        $KD.remove(tab._kwebfw_.view);
    };

    //This function must be called in the scope of widget instance
    //This function has to be moved to voltmxui
    var _removeWidgetHierarchy = function UI$_removeWidgetHierarchy(cmodel, rmodel, keepHierarchy) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget;

        if($KU.is(rmodel, 'widget')) {
            $KW.iterate(cmodel, function(widget) {
                widget._flush();

                if(keepHierarchy !== true) {
                    delete rmodel[widget.id];
                }
            }, {scope:this, tabs:false});
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        TabPane: {
            activeTabs: function TabPane$_setter_activeTabs(old) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    $KW = $K.widget, _ = this._kwebfw_, prop = _.prop;

                //Model should be marked for relayout only if the viewtype is collapsible/tabview
                if(prop.viewType !== constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                    //Active tabs should be marked for relayout, when activeTabs Property is triggered
                    $KU.each(prop.activeTabs, function(tab) {
                        // if the current tab is not a active tab already, then mark for relayout
                        if(old.indexOf(tab) === -1) {
                            _.tabs[tab] && $KW.markRelayout(this[_.tabs[tab].id]);
                        }
                    }, this);
                }
            },

            viewType: function TabPane$_setter_viewType(old) {
                if(this.viewType !== old) {
                    _normalizeViewConfig.call(this);
                }
            }
        }
    };

    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        TabPane: {
            activeFocusSkin: function TabPane$_valid_activeFocusSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            activeSkin: function TabPane$_valid_activeSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            activeTabs: function TabPane$_valid_activeTabs(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false,
                    _ = this._kwebfw_, prop = _.prop;

                if($KU.is(value, 'array')) {
                    flag = true;

                    if(prop.viewType !== constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW
                    || prop.viewConfig.collapsibleViewConfig.toggleTabs === true) {
                        if(value.length > 1) {
                            flag = false;
                        }
                    }
                }

                return flag;
            },

            inactiveSkin: function TabPane$_valid_inactiveSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            onTabClick: function TabPane$_valid_onTabClick(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            retainPositionInTab: function TabPane$_valid_retainPositionInTab(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            tabHeaderHeight: function TabPane$_valid_tabHeaderHeight(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'integer') && value >= 0) {
                    flag = true;
                }

                return flag;
            },

            tabHeaderTemplate: function TabPane$_valid_tabHeaderTemplate(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'widget', 'FlexContainer')
                || $KU.is(value, 'null') || $KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            viewConfig: function TabPane$_valid_viewConfig(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')) {
                    if($KU.is(value.collapsibleViewConfig, 'object')
                    || $KU.is(value.pageViewConfig, 'object')
                    || $KU.is(value.tabViewConfig, 'object')) {
                        flag = true;
                    }
                }

                return flag;
            },

            viewType: function TabPane$_valid_viewType(value) {
                var flag = false, options = [
                    constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW,
                    constants.TABPANE_VIEW_TYPE_PAGEVIEW,
                    constants.TABPANE_VIEW_TYPE_TABVIEW
                ];

                if(options.indexOf(value) >= 0) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        TabPane: {
            activeFocusSkin: function TabPane$_view_activeFocusSkin(/*el, old*/) {
                _handleViewReflection.call(this);
            },

            activeSkin: function TabPane$_view_activeSkin(/*el, old*/) {
                _handleViewReflection.call(this);
            },

            activeTabs: function TabPane$_view_activeTabs(/*el, old*/) {
                _handleViewReflection.call(this);
            },

            inactiveSkin: function TabPane$_view_inactiveSkin(/*el, old*/) {
                _handleViewReflection.call(this);
            },

            onTabClick: true,

            retainPositionInTab: true,

            tabHeaderHeight: function TabPane$_view_tabHeaderHeight(/*el, old*/) {

                //TODO::
            },

            tabHeaderTemplate: function TabPane$_view_tabHeaderTemplate(/*el, old*/) {
                
                //TODO::
            },

            viewConfig: function TabPane$_view_viewConfig(el, old) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils, li = null,
                    _ = this._kwebfw_, prop = _.prop, config = null, tabHeaderWeight = '';

                _normalizeViewConfig.call(this);

                if(prop.viewType === constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                    if(prop.viewConfig && prop.viewConfig.collapsibleViewConfig) {
                        config = prop.viewConfig.collapsibleViewConfig;
                    }

                    if(config) {
                        if(config.toggleTabs === true && prop.activeTabs.length > 1) {
                            prop.activeTabs = [prop.activeTabs[(prop.activeTabs.length-1)]];
                        }
                    }

                    if(prop.viewConfig !== old) _handleViewReflection.call(this);
                } else if(prop.viewType === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                    if(prop.viewConfig && prop.viewConfig.pageViewConfig) {
                        config = prop.viewConfig.pageViewConfig;
                    }

                    //TODO::
                } else if(prop.viewType === constants.TABPANE_VIEW_TYPE_TABVIEW) {
                    if(prop.viewConfig && prop.viewConfig.tabViewConfig) {
                        config = prop.viewConfig.tabViewConfig;
                    }

                    if(config) {
                        if(config.headerPosition === constants.TAB_HEADER_POSITION_TOP) {
                            $KD.style(el.wrapper, 'flexDirection', 'column');
                            $KD.style(el.tabs, 'flexDirection', 'row');
                        } else if(config.headerPosition === constants.TAB_HEADER_POSITION_BOTTOM) {
                            $KD.style(el.wrapper, 'flexDirection', 'column-reverse');
                            $KD.style(el.tabs, 'flexDirection', 'row');
                        } else if(config.headerPosition === constants.TAB_HEADER_POSITION_LEFT) {
                            $KD.style(el.wrapper, 'flexDirection', 'row');
                            $KD.style(el.tabs, 'flexDirection', 'column');
                        } else if(config.headerPosition === constants.TAB_HEADER_POSITION_RIGHT) {
                            $KD.style(el.wrapper, 'flexDirection', 'row-reverse');
                            $KD.style(el.tabs, 'flexDirection', 'column');
                        }

                        if($KU.is(config.headerContainerWeight, 'number')) {
                            tabHeaderWeight = config.headerContainerWeight + '%';
                        }

                        if(config.headerPosition === constants.TAB_HEADER_POSITION_TOP
                        || config.headerPosition === constants.TAB_HEADER_POSITION_BOTTOM) {
                            $KD.style(el.tabs, 'width', '100%');
                        } else if(tabHeaderWeight) {
                            $KD.style(el.tabs, 'width', tabHeaderWeight);
                        }

                        $KU.each(_.tabs, function(tab, index) {
                            li = $KD.childAt(el.tabs, index);

                            if(config.headerPosition === constants.TAB_HEADER_POSITION_TOP
                            || config.headerPosition === constants.TAB_HEADER_POSITION_BOTTOM) {
                                $KD.style(li, 'width', tabHeaderWeight);
                            } else {
                                $KD.style(li, 'width', '100%');
                            }
                        });
                    }
                }
            },

            viewType: function TabPane$_view_viewType(el, old) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    $KD = $K.dom, _ = this._kwebfw_, prop = _.prop;

                if(prop.viewType !== constants.TABPANE_VIEW_TYPE_TABVIEW && prop.viewType !== constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                    $KD.setAttr(el.tabs, 'hidden', true);
                } else {
                    $KD.removeAttr(el.tabs, 'hidden');
                }

                if(prop.viewType !== old) {
                    //updating kv to the current view type
                    $KD.setAttr(el.node, 'kv', prop.viewType);

                    if(old === constants.TABPANE_VIEW_TYPE_TABVIEW) {
                        $KU.each(_.tabs, function(tab, index) {
                            var $K = voltmx.$kwebfw$, $KD = $K.dom, a = 0, alen = 0,
                                div = $KD.create('DIV'), li = $KD.first(el.tabs),
                                html = li.innerHTML, name = '', value = '';

                            alen = li.attributes.length;
                            for(a=0; a<alen; a++) {
                                name = li.attributes[a].name;
                                value = li.attributes[a].value;
                                $KD.setAttr(div, name, value);
                            }

                            $KD.style(div, 'width', '');
                            $KD.html(div, html);
                            $KD.remove(li);
                            $KD.addAt(el.scrolee, div, (index*2));
                        }, this);

                        if(!_.tabs.length && prop.activeTabs.length) {
                            prop.activeTabs = [];
                        }
                    } else {
                        $KU.each(_.tabs, function(tab, index) {
                            var $K = voltmx.$kwebfw$, $KD = $K.dom, a = 0,
                                li = $KD.create('LI'), alen = 0,
                                div = $KD.childAt(el.scrolee, index),
                                html = div.innerHTML, name = '', value = '';

                            alen = div.attributes.length;
                            for(a=0; a<alen; a++) {
                                name = div.attributes[a].name;
                                value = div.attributes[a].value;
                                $KD.setAttr(li, name, value);
                            }

                            $KD.html(li, html);
                            $KD.remove(div);
                            $KD.add(el.tabs, li);
                        }, this);

                        if(old === constants.TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW) {
                            if(!_.tabs.length) {
                                if(prop.activeTabs.length) {
                                    prop.activeTabs = [];
                                }
                            } else {
                                if(!prop.activeTabs.length) {
                                    prop.activeTabs = [0];
                                } else if(prop.activeTabs.length > 1) {
                                    prop.activeTabs = [prop.activeTabs[(prop.activeTabs.length-1)]];
                                }
                            }
                        } else if(old === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                            //TODO:: prop.activeTabs
                        }
                    }

                    _handleViewReflection.call(this);
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'TabPane', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.TabPane constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var TabPane = function TabPane(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    activeFocusSkin: 'tabCanvas',
                    activeSkin: 'tabCanvas',
                    activeTabs: [0],
                    inactiveSkin: 'tabCanvasInactive',
                    onTabClick: null,
                    retainPositionInTab: false,
                    tabHeaderHeight: 64, //Might be there
                    tabHeaderTemplate: null, //Allowed widgets are, Label, Link, Richtext, Button and Image
                    viewConfig: {
                        tabViewConfig: {
                            headerPosition: constants.TAB_HEADER_POSITION_TOP
                        },
                        pageViewConfig: {
                            needPageIndicator: true,
                            pageOffDotImage: 'blackdot.gif',
                            pageOnDotImage: 'whitedot.gif'
                        },
                        collapsibleViewConfig: {
                            collapsedImage: '', expandedImage: '', toggleTabs: false,
                            imagePosition: constants.TABPANE_COLLAPSIBLE_IMAGE_POSITION_RIGHT,
                            tabNameAlignment: constants.TABPANE_COLLAPSIBLE_TABNAME_ALIGNMENT_LEFT
                        }
                    },
                    viewType: constants.TABPANE_VIEW_TYPE_TABVIEW
                };
            }

            _populateUnderscore.TabPane.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            TabPane.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.TabPane, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.TabPane.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to TabPane
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.TabPane[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.TabPane>, but not in <_valid.TabPane> namespace.');
                        } else {
                            valid = _valid.TabPane[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to TabPane
                $KU.each(_view.TabPane, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function TabPane$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.TabPane[key], 'function')) {
                            return _getter.TabPane[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function TabPane$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.TabPane[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.TabPane[key], 'function')) {
                                        _setter.TabPane[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.TabPane().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.TabPane().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.TabPane, 'function')) {
                    _postInitialization.TabPane.call(this);
                }
            }


            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(TabPane, voltmx.ui.BasicWidget);


        /**
         * Takes care of flushing out the widget reference to clean memory.
         *
         * @access      protected
         * @method      _flush
         * @memberof    voltmx.ui.TabPane
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     void
         */
        var tabpane__flush = function TabPane$_flush() {
            var $super = voltmx.ui.TabPane.base.prototype;

            _flushTabs.call(this, this._kwebfw_.tabs, true);
            $super._flush.call(this);
        };


        /**
         * Builds the view layer for voltmx.ui.TabPane widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.TabPane
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  TabPane view.
         */
        var tabpane__render = function TabPane$_render(tag) {
            var $super = voltmx.ui.TabPane.base.prototype, _ = this._kwebfw_,
                $K = voltmx.$kwebfw$, $KU = $K.utils, $KW = $K.widget, $KD = $K.dom,
                view = _.view, wrapper = null, tabs = null, viewport = null,
                scrolee = null, hScroll = null, vScroll = null, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    wrapper = $KD.create('DIV', {kr:'wrapper'});
                    tabs = $KD.create('UL', {kr:'tabs'});
                    //tabs.innerHTML = '<li>abc-01</li><li>abc-02</li><li>abc-03</li><li>abc-04</li><li>abc-05</li><li>abc-06</li><li>abc-07</li><li>abc-08</li><li>abc-09</li><li>abc-10</li><li>abc-11</li><li>abc-12</li><li>abc-13</li><li>abc-14</li><li>abc-15</li><li>abc-16</li><li>abc-17</li><li>abc-18</li><li>abc-19</li><li>abc-20</li>';
                    viewport = $KD.create('DIV', {kr:'viewport'});
                    if(_.prop.viewType === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                        $KD.style(tabs, {display:'table', margin: '0 auto'});
                        $KD.style(viewport, {display:'flex', overflowX : 'hidden', overflowY : 'auto'});

                        //To Do .. need to handle this in toggle view
                        $KD.style(wrapper, {overflowX : 'hidden', overflowY : 'hidden'});

                        $KD.add(wrapper, viewport);
                        $KD.add(wrapper, tabs); // Added tabs after viewport to have the page dots at the bottom
                    } else {
                        $KD.add(wrapper, tabs);
                        $KD.add(wrapper, viewport);
                    }

                    if($KU.scrollType() !== 'native') {
                        $KD.style(viewport, {overflowX:'hidden', overflowY:'hidden'});

                        scrolee = $KD.create('DIV', {kr:'scrolee'});
                        hScroll = $KD.create('DIV', {kr:'h-scroll'}, {display:'none'});
                        vScroll = $KD.create('DIV', {kr:'v-scroll'}, {display:'none'});

                        $KD.add(viewport, scrolee);
                        $KD.add(viewport, hScroll);
                        $KD.add(viewport, vScroll);
                    }

                    view = $super._render.call(this, tag, [wrapper]);
                    $KD.setAttr(view, 'kv', _.prop.viewType);

                    el = $KW.el(view);

                    $KU.each(_.tabs, function(tab/*, index*/) {
                        _addTabToView.call(this, tab);
                    }, this);

                    _normalizeActiveTabs.call(this);
                }

                _view[_.name].tabHeaderHeight.call(this, el, _.prop.tabHeaderHeight);
                _view[_.name].viewType.call(this, el, _.prop.viewType);
                _view[_.name].viewConfig.call(this, el, _.prop.viewConfig);

                //TODO:: $KW.accessibility(this);

                //TODO:: This IF/ELSE block should move to flex engine
                if($KW.isFixedHeight(this)) {
                    $KD.style(el.viewport, 'height', '100%');

                    if($KU.scrollType() === 'native' && _.prop.viewType !== constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                        $KD.style(el.viewport, {'overflowX':'auto', 'overflowY':'auto'});
                    }
                }

                if(_.prop.viewType === constants.TABPANE_VIEW_TYPE_PAGEVIEW) {
                    _registerSwipeGesture.call(this, el.scrolee);
                }
                _handleViewReflection.call(this);
            }

            return view;
        };


        var tabpane_addTab = function TabPane$addTab(tabId, tabName, tabImage, tabContainer) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, headtemp = null;
            if(arguments.length === 3) {
                tabContainer = tabName;
                tabName = '';
                headtemp = tabImage;
                tabImage = '';
            }

            if($KU.is(tabId, 'string') && tabId && $KU.is(tabName, 'string')
            && ($KU.is(tabImage, 'string') || $KU.is(tabImage, 'null'))
            && (($KU.is(tabContainer, 'string') && tabContainer)
            || $KU.is(tabContainer, 'widget', 'FlexContainer'))) {
                _addTab.call(this, tabId, tabName, tabImage, tabContainer, _.tabs.length, headtemp);
            } else {
                throw new Error('Invalid paramenters passed.');
            }
        };


        var tabpane_addTabAt = function TabPane$addTabAt(tabId, tabName, tabImage, tabContainer, index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, headtemp = null;
            if(arguments.length === 3) {
                tabContainer = tabName;
                tabName = '';
                headtemp = tabImage;
                tabImage = '';
            }

            if($KU.is(tabId, 'string') && tabId && $KU.is(tabName, 'string')
            && ($KU.is(tabImage, 'string') || $KU.is(tabImage, 'null'))
            && (($KU.is(tabContainer, 'string') && tabContainer)
            || $KU.is(tabContainer, 'widget', 'FlexContainer'))
            && $KU.is(index, 'integer') && index >= 0 && index < _.tabs.length) {
                _addTab.call(this, tabId, tabName, tabImage, tabContainer, index, headtemp);
            } else {
                throw new Error('Invalid paramenters passed.');
            }
        };


        var tabpane_removeTabAt = function TabPane$removeTabAt(index) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_;

            if($KU.is(index, 'integer') && index >= 0 && index < _.tabs.length) {
                _removeTab.call(this, index);
            } else {
                throw new Error('Invalid paramenter passed.');
            }
        };


        var tabpane_removeTabById = function TabPane$removeTabById(tabId) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = this._kwebfw_, index = -1;

            if($KU.is(tabId, 'string') && tabId
            && $KU.is(this[tabId], 'widget', 'FlexContainer')) {
                index = _getIndexByTabId.call(this, tabId);

                if(index >= 0 && index < _.tabs.length) {
                    _removeTab.call(this, index);
                }
            } else {
                throw new Error('Invalid paramenter passed.');
            }
        };


        $K.defVoltmxProp(TabPane.prototype, [
            {keey:'_flush', value:tabpane__flush},
            {keey:'_render', value:tabpane__render},
            {keey:'addTab', value:tabpane_addTab},
            {keey:'addTabAt', value:tabpane_addTabAt},
            {keey:'removeTabAt', value:tabpane_removeTabAt},
            {keey:'removeTabById', value:tabpane_removeTabById}
        ]);


        return TabPane;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxtextarea.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'TextArea2', value:{}, items:[
            {keey:'doLayout', value:function(/*frame*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                _autoResize.call(this, $KW.el(this));
            }},

            {keey:'onInput', value:function(evt) {
                var $K = voltmx.$kwebfw$;

                return $K.ui.TextBox2.onInput.call(this, evt);
            }},

            {keey:'onFocusIn', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                this._kwebfw_.prop.text = evt.target.value;

                $KW.fire(this, 'onFocus', this);
                $KW.fire(this, 'onBeginEditing', this);

                return false;
            }},

            {keey:'onFocusOut', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                this._kwebfw_.prop.text = evt.target.value;

                $KW.fire(this, 'onBlur', this);
                $KW.fire(this, 'onEndEditing', this);

                return false;
            }},

            {keey:'onKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    propagate = true;

                if(this.onKeyDown) {
                    propagate = false;
                    $KW.fire(this, 'onKeyDown', this, this, {
                        altKey: (evt.altKey || false),
                        ctrlKey: (evt.ctrlKey || false),
                        metaKey: (evt.metaKey || false),
                        shiftKey: (evt.shiftKey || false),
                        keyCode: $KD.keyCode(evt)
                    });
                }

                return propagate;
            }},

            {keey:'onKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    code = evt.keyCode || evt.which, propagate = true;

                //For MAC also it is ctrl+enter, not cmd+enter
                if(code === 13 && evt.ctrlKey) {
                    $KD.preventDefault(evt);
                    propagate = false;

                    $KW.fire(this, 'onDone', this);
                }

                if(this.onKeyUp) {
                    propagate = false;
                    $KW.fire(this, 'onKeyUp', this, this, {
                        altKey: (evt.altKey || false),
                        ctrlKey: (evt.ctrlKey || false),
                        metaKey: (evt.metaKey || false),
                        shiftKey: (evt.shiftKey || false),
                        keyCode: $KD.keyCode(evt)
                    });
                }

                return propagate;
            }},

            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    $KD = $K.dom, tabindex = '';

                if($KW.disabled(this)) {
                    $KD.setAttr(dom, 'disabled', 'disabled');
                    $KD.setAttr(dom, 'tabindex', -1);
                } else if(!$KW.interactable(this)) {
                    $KD.setAttr(dom, 'readonly', 'readonly');
                    $KD.setAttr(dom, 'tabindex', -1);
                } else {
                    tabindex = $KW.tabIndex(this, clone);

                    $KD.removeAttr(dom, 'disabled');
                    $KD.removeAttr(dom, 'readonly');
                    $KD.setAttr(dom, 'tabindex', tabindex);
                }
            }}
        ]}
    ]);


    //This functions will be called in the scope of widget instance
    var _autoResize = function TextArea2$_autoResize(el) {
        var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
            _ = this._kwebfw_, final = _.flex.final, cf = null,
            prevOffsetHeight = -1, offsetHeight = -1, scrollHeight = -1;

        if(_.prop.autoResize && !final.height) {
            if($KW.isRendered(this)) {
                prevOffsetHeight = el.node.offsetHeight;
                $KD.style(el.node, {height:'0px', overflowY:'hidden'});

                scrollHeight = el.node.scrollHeight;
                $KD.style(el.node, 'height', (scrollHeight+'px'));

                offsetHeight = el.node.offsetHeight;

                if(scrollHeight > offsetHeight) {
                    $KD.style(el.node, 'overflow-y', null);
                }

                if(prevOffsetHeight !== offsetHeight) {
                    $KW.markRelayout(this);
                    cf = $KW.fmodel(this);
                    cf && cf.forceLayout();
                }
            }
        } else {
            $KD.style(el.node, 'overflow-y', null);
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        TextArea2: {
            placeholder: function TextArea2$_getter_placeholder() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, placeholder = prop.placeholder;

                if(prop.i18n_placeholder) {
                    placeholder = $KU.getI18Nvalue(prop.i18n_placeholder);
                }

                return placeholder;
            },

            text: function TextArea2$_getter_text() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, text = prop.text;

                if(prop.i18n_text) {
                    text = $KU.getI18Nvalue(prop.i18n_text);
                }

                return text;
            },

            toolTip: function TextArea2$_getter_toolTip() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, toolTip = prop.toolTip;

                if(prop.i18n_toolTip) {
                    toolTip = $KU.getI18Nvalue(prop.i18n_toolTip);
                }

                return toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        TextArea2: function TextArea2$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.TextArea2', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'TextArea2', null);
                }
            }

            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        TextArea2: function TextArea2$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = this._kwebfw_, prop = _.prop;

            if($KU.is(prop.padding, 'null')) {
                prop.padding = [2, 2, 2, 2];
            }

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'defTextAreaNormal';
            }

            if(prop.i18n_placeholder) {
                prop.placeholder = prop.i18n_placeholder;
            }

            if(prop.i18n_text) {
                prop.text = prop.i18n_text;
            }

            if(prop.i18n_toolTip) {
                prop.toolTip = prop.i18n_toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        TextArea2: function TextArea2$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        TextArea2: function TextArea2$_relayoutPassiveTriggerer() {
            return [];
        }
    };

    //This functions will be called in the scope of widget instance
    var _registerCutCopyPasteEvents = function TextArea2$_registerCutCopyPasteEvents(el) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;

        $KD.on(el.node, 'copy paste cut', 'textarea', function(e) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                el = $KW.el(this), model = null, prop = null;

            if(el.node) {
                model = $KW.model(el.node);
                prop = model._kwebfw_.prop;

                if(!prop.textCopyable) {
                    $KD.preventDefault(e);
                }
            }
        }, {passive:false});
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        TextArea2: {
            placeholder: function TextArea2$_setter_placeholder(/*old*/) {
                this._kwebfw_.prop.i18n_placeholder = '';
            },

            text: function TextArea2$_setter_text(/*old*/) {
                this._kwebfw_.prop.i18n_text = '';
            },

            toolTip: function TextArea2$_setter_toolTip(/*old*/) {
                this._kwebfw_.prop.i18n_toolTip = '';
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        TextArea2: {
            autoCapitalize: function TextArea2$_valid_autoCapitalize(value) {
                var options = [
                        constants.TEXTAREA_AUTO_CAPITALIZE_ALL,
                        constants.TEXTAREA_AUTO_CAPITALIZE_NONE,
                        constants.TEXTAREA_AUTO_CAPITALIZE_SENTENCES,
                        constants.TEXTAREA_AUTO_CAPITALIZE_WORDS
                    ], flag = (options.indexOf(value) >= 0);

                return flag;
            },

            autoComplete: function TextArea2$_valid_autoComplete(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                } else if($KU.is(value, 'string') && value) {
                    flag = true;
                }

                return flag;
            },

            autoCorrect: function TextArea2$_valid_autoCorrect(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            autoResize: function TextArea2$_valid_autoResize(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            i18n_placeholder: function TextArea2$_valid_i18n_placeholder(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            i18n_text: function TextArea2$_valid_i18n_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            i18n_toolTip: function TextArea2$_valid_i18n_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            isSensitiveText: function TextArea2$_valid_isSensitiveText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            keyBoardStyle: function TextArea2$_valid_keyBoardStyle(value) {
                var options = [
                        constants.TEXTAREA_KEY_BOARD_STYLE_CHAT,
                        constants.TEXTAREA_KEY_BOARD_STYLE_DECIMAL,
                        constants.TEXTAREA_KEY_BOARD_STYLE_DEFAULT,
                        constants.TEXTAREA_KEY_BOARD_STYLE_EMAIL,
                        constants.TEXTAREA_KEY_BOARD_STYLE_NONE,
                        constants.TEXTAREA_KEY_BOARD_STYLE_NUMBER_PAD,
                        constants.TEXTAREA_KEY_BOARD_STYLE_PHONE_PAD,
                        constants.TEXTAREA_KEY_BOARD_STYLE_SEARCH,
                        constants.TEXTAREA_KEY_BOARD_STYLE_URL
                    ], flag = (options.indexOf(value) >= 0);

                return flag;
            },

            maxTextLength: function TextArea2$_valid_maxTextLength(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if(($KU.is(value, 'integer') && value >= 0) || value === '') {
                    flag = true;
                }

                return flag;
            },

            onBeginEditing: function TextArea2$_valid_onBeginEditing(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onDone: function TextArea2$_valid_onDone(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onEndEditing: function TextArea2$_valid_onEndEditing(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onKeyDown: function TextArea2$_valid_onKeyDown(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onKeyUp: function TextArea2$_valid_onKeyUp(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onTextChange: function TextArea2$_valid_onTextChange(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            placeholder: function TextArea2$_valid_placeholder(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            placeholderSkin: function TextArea2$_valid_placeholderSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            restrictCharactersSet: function TextArea2$_valid_restrictCharactersSet(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            text: function TextArea2$_valid_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            textCopyable: function TextArea2$_valid_textCopyable(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            textInputMode: function TextArea2$_valid_textInputMode(value) {
                var options = [
                        constants.TEXTAREA_INPUT_MODE_ANY,
                        constants.TEXTAREA_INPUT_MODE_NUMERIC,
                        constants.TEXTAREA_INPUT_MODE_PASSWORD
                    ], flag = (options.indexOf(value) >= 0);

                return flag;
            },

            toolTip: function TextArea2$_valid_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        TextArea2: {
            autoCapitalize: function TextArea2$_view_autoCapitalize(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, value = '';

                if(this.autoCapitalize === 'words') {
                    value = 'capitalize';
                } else if(this.autoCapitalize === 'characters') {
                    value = 'uppercase';
                }
                value && $KD.style(el.node, 'text-transform', value);
                $KD.setAttr(el.node, 'autocapitalize', this.autoCapitalize);
            },

            autoComplete: false,

            autoCorrect: function TextArea2$_view_autoCorrect(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.setAttr(el.node, 'spellcheck', this.autoCorrect.toString());
            },

            autoResize: true,

            i18n_placeholder: false,

            i18n_text: false,

            i18n_toolTip: false,

            isSensitiveText: true,

            keyBoardStyle: function TextArea2$_view_keyBoardStyle(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    ks = this.keyBoardStyle, ipmode = '';

                if(ks === constants.TEXTAREA_KEY_BOARD_STYLE_CHAT) {
                    ipmode = 'text';
                } else {
                    ipmode = ks;
                }

                $KD.setAttr(el.node, 'inputmode', ipmode);
            },

            maxTextLength: function TextArea2$_view_maxTextLength(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.maxTextLength === '') {
                    $KD.removeAttr(el.node, 'maxlength');
                } else {
                    $KD.setAttr(el.node, 'maxlength', this.maxTextLength);
                }
            },

            onBeginEditing: true,

            onDone: true,

            onEndEditing: true,

            onKeyDown: true,

            onKeyUp: true,

            onTextChange: true,

            placeholder: function TextArea2$_view_placeholder(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;
                $KD.setAttr(el.node, 'placeholder', this.placeholder);
            },

            placeholderSkin: function TextArea2$_view_placeholderSkin(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;
                $KD.setAttr(el.node, 'kplaceholderSkin', this.placeholderSkin);
            },

            restrictCharactersSet: true,

            text: function TextArea2$_view_text(el/*, old*/) {
                el.node.value = this.text;
                _autoResize.call(this, el);
            },

            textCopyable: true,

            textInputMode: true,

            toolTip: function TextArea2$_view_toolTip(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.toolTip) {
                    $KD.setAttr(el.node, 'title', this.toolTip);
                } else {
                    $KD.removeAttr(el.node, 'title');
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'TextArea2', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.TextArea2 constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var TextArea2 = function TextArea2(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    autoCapitalize: constants.TEXTAREA_AUTO_CAPITALIZE_NONE,
                    autoComplete: false,
                    autoCorrect: false,
                    autoResize: false,
                    i18n_placeholder: '',
                    i18n_text: '',
                    i18n_toolTip: '',
                    isSensitiveText: false,
                    keyBoardStyle: constants.TEXTAREA_KEY_BOARD_STYLE_DEFAULT,
                    maxTextLength: '',
                    onBeginEditing: null,
                    onDone: null,
                    onEndEditing: null,
                    onKeyDown: null,
                    onKeyUp: null,
                    onTextChange: null,
                    placeholder: '',
                    placeholderSkin: '',
                    restrictCharactersSet: '',
                    text: '',
                    textCopyable: true,
                    textInputMode: constants.TEXTAREA_INPUT_MODE_ANY,
                    toolTip: ''
                };
            }

            _populateUnderscore.TextArea2.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            TextArea2.base.call(this, bconfig, lconfig, pspconfig);

            if($KU.is(_dependentPropertiesValidationMessage.TextArea2, 'function')) {
                dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.TextArea2.call(this, prop, bconfig, lconfig, pspconfig);
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                //Defaulting to platfom values specific to TextArea2
                $KU.each(prop, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils,
                        $KW = $K.widget, valid = false, message = '';

                    if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                        bconfig[key] = value;
                    } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                        throw new Error('<'+key+'> is a non-constructor property of <'+self._kwebfw_.ns+'> class.');
                    } else if(!$KU.is(_valid.TextArea2[key], 'function')) {
                        throw new Error('<'+key+'> is available in default widget properties of <voltmx.ui.TextArea2>, but not in <_valid.TextArea2> namespace.');
                    } else {
                        valid = _valid.TextArea2[key].call(self, bconfig[key]);
                        if($KU.is(valid, 'array')) {
                            bconfig[key] = valid[0]; valid = valid[1];
                        }

                        if(valid === false || ($KU.is(valid, 'string') && valid)) {
                            message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                            if($KU.is(valid, 'string')) {
                                message += ('\n' + valid);
                            }

                            throw new Error(message);
                        }
                    }
                });

                //Defining Getters/Setters specific to TextArea2
                $KU.each(_view.TextArea2, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function TextArea2$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.TextArea2[key], 'function')) {
                            return _getter.TextArea2[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function TextArea2$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.TextArea2[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.TextArea2[key], 'function')) {
                                        _setter.TextArea2[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.TextArea2().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.TextArea2().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.TextArea2, 'function')) {
                    _postInitialization.TextArea2.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(TextArea2, voltmx.ui.BasicWidget);


        /**
         * Builds the view layer for voltmx.ui.TextArea2 widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.TextArea2
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  TextArea2 view.
         */
        var textarea2__render = function TextArea2$_render(/*tag*/) {
            var $super = voltmx.ui.TextArea2.base.prototype, ac = '',
                _ = this._kwebfw_, view = _.view, $K = voltmx.$kwebfw$,
                $KW = $K.widget, $KD = $K.dom, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, 'TEXTAREA');
                    el = $KW.el(view);

                    $KD.setAttr(view, 'kwh-focusin', 'onFocusIn');
                    $KD.setAttr(view, 'kwh-focusout', 'onFocusOut');
                    $KD.setAttr(view, 'kwh-input', 'onInput');
                    $KD.setAttr(view, 'kwh-keydown', 'onKeyDown');
                    $KD.setAttr(view, 'kwh-keyup', 'onKeyUp');

                    if(this.autoComplete === true) {
                        ac = 'on';
                    } else if(this.autoComplete === false) {
                        ac = 'off';
                    } else {
                        ac = this.autoComplete;
                    }
                    $KD.setAttr(view, 'autocomplete', ac);

                    _registerCutCopyPasteEvents.call(this, el);

                    _view.TextArea2.autoCapitalize.call(this, el, this.autoCapitalize);
                    _view.TextArea2.autoCorrect.call(this, el, this.autoCorrect);
                    _view.TextArea2.maxTextLength.call(this, el, this.maxTextLength);
                    _view.TextArea2.placeholderSkin.call(this, el, this.placeholderSkin);
                }

                _view.TextArea2.placeholder.call(this, el, this.placeholder);
                _view.TextArea2.text.call(this, el, this.text);
                _view.TextArea2.toolTip.call(this, el, this.toolTip);

                $KW.accessibility(this);
            }

            return view;
        };


        var textarea2_getSelection = function TextArea2$getSelection() {
            return voltmx.ui.TextBox2.prototype.getSelection.call(this);
        };


        var textarea2_setFocus = function TextArea2$setFocus(value) {
            voltmx.ui.TextBox2.prototype.setFocus.call(this, value);
        };


        var textarea2_setSelection = function TextArea2$setSelection(startIndex, endIndex) {
            voltmx.ui.TextBox2.prototype.setSelection.call(this, startIndex, endIndex);
        };


        $K.defVoltmxProp(TextArea2.prototype, [
            {keey:'_render', value:textarea2__render},
            {keey:'getSelection', value:textarea2_getSelection},
            {keey:'setFocus', value:textarea2_setFocus},
            {keey:'setSelection', value:textarea2_setSelection}
        ]);


        return TextArea2;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxtextbox.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'TextBox2', value:{}, items:[
            {keey:'onInput', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_,
                    prop = _.prop, restrictCharSet = prop.restrictCharactersSet,
                    target = null, value = null, text = '', caret = -1;

                if(!restrictCharSet) {
                    text = evt.target.value;
                } else {
                    target = evt.target;
                    caret = target.selectionStart;
                    value = target.value;
                    text = value[(caret-1)];

                    if(restrictCharSet.indexOf(text) === -1) {
                        text = value;
                    } else {
                        text = value.slice(0, (caret-1));
                        text += value.slice(caret, value.length);
                        target.value = text; //This line is important
                        target.selectionStart = target.selectionEnd = (caret - 1);
                    }
                }

                if(prop.text !== text) {
                    this.text = text;
                    $KW.fire(this, 'onTextChange', this);
                }

                return false;
            }},

            {keey:'onFocusIn', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                this._kwebfw_.prop.text = evt.target.value;

                $K.apm.send(this, 'Touch', {type:(this._kwebfw_.name+'_Edit')});
                $KW.fire(this, 'onFocus', this);
                $KW.fire(this, 'onBeginEditing', this);

                return false;
            }},

            {keey:'onFocusOut', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget;

                this._kwebfw_.prop.text = evt.target.value;

                $KW.fire(this, 'onBlur', this);
                $KW.fire(this, 'onEndEditing', this);

                return false;
            }},

            {keey:'onKeyDown', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    propagate = true;

                if(this.onKeyDown) {
                    propagate = false;

                    $KW.fire(this, 'onKeyDown', this, {
                        altKey: (evt.altKey || false),
                        ctrlKey: (evt.ctrlKey || false),
                        metaKey: (evt.metaKey || false),
                        shiftKey: (evt.shiftKey || false),
                        keyCode: $KD.keyCode(evt)
                    });
                }

                return propagate;
            }},

            {keey:'onKeyUp', value:function(evt) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget, $KD = $K.dom,
                    code = evt.keyCode || evt.which, propagate = true;

                if(code === 13) {
                    $KD.preventDefault(evt);
                    propagate = false;

                    if(code === 13) {
                        $KW.fire(this, 'onDone', this);
                    }
                }

                if(this.onKeyUp) {
                    propagate = false;
                    $KW.fire(this, 'onKeyUp', this, this, {
                        altKey: (evt.altKey || false),
                        ctrlKey: (evt.ctrlKey || false),
                        metaKey: (evt.metaKey || false),
                        shiftKey: (evt.shiftKey || false),
                        keyCode: $KD.keyCode(evt)
                    });
                }

                return propagate;
            }},

            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    $KD = $K.dom, tabindex = '';

                if($KW.disabled(this)) {
                    $KD.setAttr(dom, 'disabled', 'disabled');
                    $KD.setAttr(dom, 'tabindex', -1);
                } else if(!$KW.interactable(this)) {
                    $KD.setAttr(dom, 'readonly', 'readonly');
                    $KD.setAttr(dom, 'tabindex', -1);
                } else {
                    tabindex = $KW.tabIndex(this, clone);

                    $KD.removeAttr(dom, 'disabled');
                    $KD.removeAttr(dom, 'readonly');
                    $KD.setAttr(dom, 'tabindex', tabindex);
                }
            }}
        ]}
    ]);


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        TextBox2: {
            placeholder: function TextBox2$_getter_placeholder() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, placeholder = prop.placeholder;

                if(prop.i18n_placeholder) {
                    placeholder = $KU.getI18Nvalue(prop.i18n_placeholder);
                }

                return placeholder;
            },

            text: function TextBox2$_getter_text() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, text = prop.text;

                if(prop.i18n_text) {
                    text = $KU.getI18Nvalue(prop.i18n_text);
                }

                return text;
            },

            toolTip: function TextBox2$_getter_toolTip() {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    prop = this._kwebfw_.prop, toolTip = prop.toolTip;

                if(prop.i18n_toolTip) {
                    toolTip = $KU.getI18Nvalue(prop.i18n_toolTip);
                }

                return toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        TextBox2: function TextBox2$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.TextBox2', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'TextBox2', null);
                }
            }

            if(typeof _.tabIndex !== 'number') {
                $KU.defineProperty(_, 'tabIndex', 0, true);
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        TextBox2: function TextBox2$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = this._kwebfw_, prop = _.prop;

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'defTextBoxNormal';
            }

            if($KU.is(prop.padding, 'null')) {
                prop.padding = [0, 0, 0, 0];
            }

            if(prop.i18n_placeholder) {
                prop.placeholder = prop.i18n_placeholder;
            }

            if(prop.i18n_text) {
                prop.text = prop.i18n_text;
            }

            if(prop.i18n_toolTip) {
                prop.toolTip = prop.i18n_toolTip;
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        TextBox2: function TextBox2$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        TextBox2: function TextBox2$_relayoutPassiveTriggerer() {
            return [];
        }
    };

    //This functions will be called in the scope of widget instance
    var _registerCutCopyPasteEvents = function TextBox2$_registerCutCopyPasteEvents(el) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;

        $KD.on(el.node, 'copy paste cut', 'textbox', function(e) {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                widget = $KW.el(this), prop = null;

            if(widget.node) {
                widget = $KW.model(widget.node);
                prop = widget._kwebfw_.prop;
                if(!prop.textCopyable) {
                    $KD.preventDefault(e);
                }
            }
        }, {passive:false});
    };


    //This functions will be called in the scope of widget instance
    var _setInputType = function TextBox2$_setInputType(input) {
        var $K = voltmx.$kwebfw$, $KD = $K.dom;

        if(this.secureTextEntry) {
            $KD.setAttr(input, 'type', 'password');
        } else if(this.textInputMode === constants.TEXTBOX_INPUT_MODE_NUMERIC) {
            $KD.setAttr(input, 'type', 'number');
        } else {
            $KD.setAttr(input, 'type', 'text');
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        TextBox2: {
            placeholder: function TextBox2$_setter_placeholder(/* old */) {
                this._kwebfw_.prop.i18n_placeholder = '';
            },

            text: function TextBox2$_setter_text(/* old */) {
                this._kwebfw_.prop.i18n_text = '';
            },

            toolTip: function TextBox2$_setter_toolTip(/* old */) {
                this._kwebfw_.prop.i18n_toolTip = '';
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        TextBox2: {
            autoCapitalize: function TextBox2$_valid_autoCapitalize(value) {
                var options = [
                        constants.TEXTBOX_AUTO_CAPITALIZE_ALL,
                        constants.TEXTBOX_AUTO_CAPITALIZE_NONE,
                        constants.TEXTBOX_AUTO_CAPITALIZE_SENTENCES,
                        constants.TEXTBOX_AUTO_CAPITALIZE_WORDS
                    ], flag = (options.indexOf(value) >= 0);

                return flag;
            },

            autoComplete: function TextBox2$_valid_autoComplete(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                } else if($KU.is(value, 'string') && value) {
                    flag = true;
                }

                return flag;
            },

            autoCorrect: function TextBox2$_valid_autoCorrect(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            i18n_placeholder: function TextBox2$_valid_i18n_placeholder(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            i18n_text: function TextBox2$_valid_i18n_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            i18n_toolTip: function TextBox2$_valid_i18n_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    if(!value) {
                        flag = true;
                    } else if(value.toLowerCase().indexOf('voltmx.i18n.getlocalizedstring') === 0) {
                        flag = true;
                    }
                }

                return flag;
            },

            isSensitiveText: function TextBox2$_valid_isSensitiveText(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            keyBoardStyle: function TextBox2$_valid_keyBoardStyle(value) {
                var options = [
                        constants.TEXTBOX_KEY_BOARD_STYLE_CHAT,
                        constants.TEXTBOX_KEY_BOARD_STYLE_DECIMAL,
                        constants.TEXTBOX_KEY_BOARD_STYLE_DEFAULT,
                        constants.TEXTBOX_KEY_BOARD_STYLE_EMAIL,
                        constants.TEXTBOX_KEY_BOARD_STYLE_NONE,
                        constants.TEXTBOX_KEY_BOARD_STYLE_NUMBER_PAD,
                        constants.TEXTBOX_KEY_BOARD_STYLE_PHONE_PAD,
                        constants.TEXTBOX_KEY_BOARD_STYLE_SEARCH,
                        constants.TEXTBOX_KEY_BOARD_STYLE_URL
                    ], flag = (options.indexOf(value) >= 0);

                return flag;
            },

            maxTextLength: function TextBox2$_valid_maxTextLength(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if(($KU.is(value, 'integer') && value >= 0) || value === '') {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'null')) {
                        flag = ['', true];
                    }
                }

                return flag;
            },

            onBeginEditing: function TextBox2$_valid_onBeginEditing(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onDone: function TextBox2$_valid_onDone(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onEndEditing: function TextBox2$_valid_onEndEditing(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onKeyDown: function TextBox2$_valid_onKeyDown(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onKeyUp: function TextBox2$_valid_onKeyUp(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            onTextChange: function TextBox2$_valid_onTextChange(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'function') || $KU.is(value, 'null')) {
                    flag = true;
                }

                if(!flag && $K.F.EIWP) {
                    if($KU.is(value, 'undefined')) {
                        flag = [null, true];
                    }
                }

                return flag;
            },

            pattern: function TextBox2$_valid_pattern(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            placeholder: function TextBox2$_valid_placeholder(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            placeholderSkin: function TextBox2$_valid_placeholderSkin(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'object')
                || ($KU.is(value, 'string') && value.split(' ').length === 1)) {
                    flag = true;
                }

                return flag;
            },

            restrictCharactersSet: function TextBox2$_valid_restrictCharactersSet(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            secureTextEntry: function TextBox2$_valid_secureTextEntry(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            text: function TextBox2$_valid_text(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            textCopyable: function TextBox2$_valid_textCopyable(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            textInputMode: function TextBox2$_valid_textInputMode(value) {
                var options = [
                        constants.TEXTBOX_INPUT_MODE_ANY,
                        constants.TEXTBOX_INPUT_MODE_NUMERIC,
                        constants.TEXTBOX_INPUT_MODE_PASSWORD
                    ], flag = (options.indexOf(value) >= 0);

                return flag;
            },

            toolTip: function TextBox2$_valid_toolTip(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        TextBox2: {
            autoCapitalize: function TextBox2$_view_autoCapitalize(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, value = '';

                if(this.autoCapitalize === 'words') {
                    value = 'capitalize';
                } else if(this.autoCapitalize === 'characters') {
                    value = 'uppercase';
                }
                value && $KD.style(el.node, 'text-transform', value);
                $KD.setAttr(el.node, 'autocapitalize', this.autoCapitalize);
            },

            autoComplete: false,

            autoCorrect: function TextBox2$_view_autoCorrect(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.setAttr(el.node, 'autocorrect', (this.autoCorrect ? 'on' : 'off'));
            },

            i18n_placeholder: false,

            i18n_text: false,

            i18n_toolTip: false,

            isSensitiveText: true,

            keyBoardStyle: function TextBox2$_view_keyBoardStyle(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    ks = this.keyBoardStyle, ipmode = '';

                if(ks === constants.TEXTBOX_KEY_BOARD_STYLE_CHAT) {
                    ipmode = 'text';
                } else {
                    ipmode = ks;
                }

                $KD.setAttr(el.node, 'inputmode', ipmode);
            },

            maxTextLength: function TextBox2$_view_maxTextLength(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.maxTextLength === '') {
                    $KD.removeAttr(el.node, 'maxlength');
                } else {
                    $KD.setAttr(el.node, 'maxlength', this.maxTextLength);
                }
            },

            onBeginEditing: true,

            onDone: true,

            onEndEditing: true,

            onKeyDown: true,

            onKeyUp: true,

            onTextChange: true,

            pattern: function TextBox2$_view_pattern(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.pattern) {
                    $KD.setAttr(el.node, 'pattern', this.pattern);
                } else {
                    $KD.removeAttr(el.node, 'pattern');
                }
            },

            placeholder: function TextBox2$_view_placeholder(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                $KD.setAttr(el.node, 'placeholder', this.placeholder);
            },

            placeholderSkin: function TextBox2$_view_placeholderSkin(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;
                $KD.setAttr(el.node, 'kplaceholderSkin', this.placeholderSkin);
            },

            restrictCharactersSet: true,

            secureTextEntry: function TextBox2$_view_secureTextEntry(el/* , old */) {
                _setInputType.call(this, el.node);
            },

            text: function TextBox2$_view_text(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom,
                    value = $KD.getAttr(el.node, 'value');

                //This if condition handles setting of same text to the node value onInput(onTextChange) event
                if(value !== this.text) {
                    $KD.setAttr(el.node, 'value', this.text);
                }
            },

            textCopyable: true,

            textInputMode: function TextBox2$_view_textInputMode(el/* , old */) {
                _setInputType.call(this, el.node);
            },

            toolTip: function TextBox2$_view_toolTip(el/* , old */) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom;

                if(this.toolTip) {
                    $KD.setAttr(el.node, 'title', this.toolTip);
                } else {
                    $KD.removeAttr(el.node, 'title');
                }
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'TextBox2', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.TextBox2 constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var TextBox2 = function TextBox2(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    autoCapitalize: constants.TEXTBOX_AUTO_CAPITALIZE_NONE,
                    autoComplete: false,
                    autoCorrect: false,
                    i18n_placeholder: '',
                    i18n_text: '',
                    i18n_toolTip: '',
                    isSensitiveText: false,
                    keyBoardStyle: constants.TEXTBOX_KEY_BOARD_STYLE_DEFAULT,
                    maxTextLength: '',
                    onBeginEditing: null,
                    onDone: null,
                    onEndEditing: null,
                    onKeyDown: null,
                    onKeyUp: null,
                    onTextChange: null,
                    pattern: '',
                    placeholder: '',
                    placeholderSkin: '',
                    restrictCharactersSet: '',
                    secureTextEntry: false,
                    text: '',
                    textCopyable: true,
                    textInputMode: constants.TEXTBOX_INPUT_MODE_ANY,
                    toolTip: ''
                };
            }

            _populateUnderscore.TextBox2.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            TextBox2.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.TextBox2, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.TextBox2.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to TextBox2
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.TextBox2[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.TextBox2>, but not in <_valid.TextBox2> namespace.');
                        } else {
                            valid = _valid.TextBox2[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to TextBox2
                $KU.each(_view.TextBox2, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function TextBox2$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.TextBox2[key], 'function')) {
                            return _getter.TextBox2[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function TextBox2$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.TextBox2[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.TextBox2[key], 'function')) {
                                        _setter.TextBox2[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.TextBox2().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.TextBox2().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.TextBox2, 'function')) {
                    _postInitialization.TextBox2.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(TextBox2, voltmx.ui.BasicWidget);


        /**
         * Builds the view layer for voltmx.ui.TextBox2 widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.TextBox2
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  TextBox2 view.
         */
        var textbox2__render = function TextBox2$_render(/* tag */) {
            var $super = voltmx.ui.TextBox2.base.prototype, ac = '',
                _ = this._kwebfw_, view = _.view, $K = voltmx.$kwebfw$,
                $KW = $K.widget, $KD = $K.dom, el = $KW.el(view);

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    view = $super._render.call(this, 'INPUT');
                    el = $KW.el(view);

                    $KD.setAttr(view, 'kwh-focusin', 'onFocusIn');
                    $KD.setAttr(view, 'kwh-focusout', 'onFocusOut');
                    $KD.setAttr(view, 'kwh-input', 'onInput');
                    $KD.setAttr(view, 'kwh-keydown', 'onKeyDown');
                    $KD.setAttr(view, 'kwh-keyup', 'onKeyUp');

                    if(this.autoComplete === true) {
                        ac = 'on';
                    } else if(this.autoComplete === false) {
                        ac = 'off';
                    } else {
                        ac = this.autoComplete;
                    }
                    $KD.setAttr(view, 'autocomplete', ac);

                    _setInputType.call(this, view);
                    _registerCutCopyPasteEvents.call(this, el);

                    _view.TextBox2.autoCapitalize.call(this, el, this.autoCapitalize);
                    _view.TextBox2.autoCorrect.call(this, el, this.autoCorrect);
                    _view.TextBox2.maxTextLength.call(this, el, this.maxTextLength);
                    _view.TextBox2.pattern.call(this, el, this.pattern);
                    _view.TextBox2.placeholderSkin.call(this, el, this.placeholderSkin);
                }

                _view.TextBox2.placeholder.call(this, el, this.placeholder);
                _view.TextBox2.text.call(this, el, this.text);
                _view.TextBox2.keyBoardStyle.call(this, el, this.keyBoardStyle);
                _view.TextBox2.toolTip.call(this, el, this.toolTip);

                $KW.accessibility(this);
            }

            return view;
        };


        var textbox2_getSelection = function TextBox2$getSelection() {
            var $K = voltmx.$kwebfw$, $KD = $K.dom, $KW = $K.widget,
                view = this._kwebfw_.view, selection = null;

            if($KW.isRendered(this)) {
                if(view === $KD.active()) {
                    selection = {
                        startIndex: view.selectionStart,
                        endIndex: view.selectionEnd
                    };
                } else {
                    selection = {startIndex:0, endIndex:0};
                }
            }

            return selection;
        };


        var textbox2_setFocus = function TextBox2$setFocus(value) {
            var $super = voltmx.ui.TextBox2.base.prototype, $K = voltmx.$kwebfw$,
                $KU = $K.utils, $KW = $K.widget, $KD = $K.dom, el = $KW.el(this);

            if($KU.is(value, 'boolean') && el.node) {
                if(value === true) {
                    $super.setFocus.call(this, value);
                    $KD.focus(el.node);
                } else {
                    $KD.blur(el.node);
                }
            }
        };


        var textbox2_setSelection = function TextBox2$setSelection(startIndex, endIndex) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom,
                $KW = $K.widget, view = this._kwebfw_.view;

            if($KW.isRendered(this) && $KU.is(startIndex, 'integer')) {
                if(startIndex < 0) startIndex = 0;
                else if(startIndex > this.text.length) startIndex = this.text.length;

                if(!$KU.is(endIndex, 'integer')) endIndex = startIndex;
                else if(endIndex < 0) endIndex = 0;

                if(endIndex > startIndex) endIndex = startIndex;

                this.setFocus();
                $KD.focus(view);
                view.setSelectionRange(startIndex, endIndex);
            }
        };


        $K.defVoltmxProp(TextBox2.prototype, [
            {keey:'_render', value:textbox2__render},
            {keey:'getSelection', value:textbox2_getSelection},
            {keey:'setFocus', value:textbox2_setFocus},
            {keey:'setSelection', value:textbox2_setSelection}
        ]);


        return TextBox2;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxvideo.js' */
(function() {
    var $K = voltmx.$kwebfw$;

    $K.defVoltmxProp($K.ui, [
        {keey:'Video', value:{}, items:[
            {keey:'onClick', value:function(/*evt*/) {
                var $K = voltmx.$kwebfw$, $KW = $K.widget,
                    _ = this._kwebfw_, el = $KW.el(this);

                if(el && el.video) {
                    if(el.video.paused || el.video.ended) {
                        _.playstate = true;
                    } else {
                        _.playstate = false;
                    }
                }
                return false;
            }},

            {keey:'setupUIInteraction', value:function(dom, clone) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils,
                    $KW = $K.widget, $KD = $K.dom, tabindex = '';

                if(!$KW.interactable(this)) {
                    if($KW.disabled(this)) {
                        $KD.setAttr(dom, 'aria-disabled', true);
                    }

                    $KD.setAttr(dom, 'tabindex', -1);
                    $KD.addCls(this._kwebfw_.view, '-voltmx-blocker');
                } else {
                    tabindex = $KW.tabIndex(this, clone);
                    $KD.removeAttr(dom, 'aria-disabled');
                    $KD.removeCls(this._kwebfw_.view, '-voltmx-blocker');

                    if($KU.is(tabindex, 'integer')) {
                        $KD.setAttr(dom, 'tabindex', tabindex);
                    } else {
                        $KD.removeAttr(dom, 'tabindex');
                    }
                }
            }}
        ]}
    ]);


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _dependentPropertiesValidationMessage = {};


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _getter = {
        Video: {
            source: function Video$_getter_source(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils;

                return $KU.clone(value);
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _populateUnderscore = {
        Video: function Video$_populateUnderscore() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, _ = null;

            if(!$KU.is(this._kwebfw_, 'object')) {
                $KU.defineProperty(this, '_kwebfw_', {}, null);
            }
            _ = this._kwebfw_;

            //NOTE:: Any changes to _ (underscore) may need a change in
            //       _cleanUnderscore function of voltmxui.js file.
            if(!_.ns) {
                if($KU.is(this.__$kwebfw$ns__, 'string') && this.__$kwebfw$ns__) {
                    $KU.defineProperty(_, 'ns', this.__$kwebfw$ns__, null);
                } else {
                    $KU.defineProperty(_, 'ns', 'voltmx.ui.Video', null);
                }
            }
            if(!_.name) {
                if($KU.is(this.__$kwebfw$name__, 'string') && this.__$kwebfw$name__) {
                    $KU.defineProperty(_, 'name', this.__$kwebfw$name__, null);
                } else {
                    $KU.defineProperty(_, 'name', 'Video', null);
                }
            }
        }
    };


    //All widget file must have this variable
    //This function will be called in the scope of widget instance
    var _postInitialization = {
        Video: function Video$_postInitialization() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils,
                _ = this._kwebfw_, prop = _.prop;

            if($KU.is(prop.skin, 'null')) {
                prop.skin = 'slVideo';
            }
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutActiveTriggerer = {
        Video: function Video$_relayoutActiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //This functions will be called in the scope of widget instance
    var _relayoutPassiveTriggerer = {
        Video: function Video$_relayoutPassiveTriggerer() {
            return [];
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    var _setter = {
        Video: {
            source : function Video$_setter_Source(/*old*/) {
                this._kwebfw_.prop.tracks = null;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //These function should always return a boolean value
    var _valid = {
        Video: {
            controls: function Video$_valid_controls(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            enableCaptions : function Video$_valid_enableCaptions(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'boolean')) {
                    flag = true;
                }

                return flag;
            },

            poster: function Video$_valid_poster(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'string')) {
                    flag = true;
                }

                return flag;
            },

            source: function Video$_valid_source(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'object')
                && ($KU.is(value.mp4, 'string')
                || $KU.is(value.ogg, 'string')
                || $KU.is(value.webm, 'string'))) {
                    flag = true;
                }

                return flag;
            },

            tracks : function Video$_valid_tracks(value) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, flag = false;

                if($KU.is(value, 'null')) {
                    flag = true;
                } else if($KU.is(value, 'array')) {
                    flag = true;

                    $KU.each(value, function(item) {
                        if(!$KU.is(item, 'object')
                        || !$KU.is(item.src, 'string')) {
                            flag = false;
                            return true;
                        }
                    });
                }

                return flag;
            }
        }
    };


    //All widget file must have this variable
    //All the functions will be called in the scope of widget instance
    //Any property here, which is set to "false", will not create a setter
    var _view = {
        Video: {
            controls: false,

            poster: false,

            source: function Video$_view_source(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KU = $K.utils, $KD = $K.dom;

                $KD.html(el.video, '');

                $KU.each(this._kwebfw_.prop.source, function(url, type) {
                    var $K = voltmx.$kwebfw$, $KD = $K.dom, source = null;

                    source = $KD.create('SOURCE', {src:$KU.getResourceURL(url), type:('video/'+type)});
                    $KD.add(this, source); //Here scope of "this" points to el.video
                    el.video.load();
                }, el.video);
            },

            tracks : function Video$_view_tracks(el/*, old*/) {
                var $K = voltmx.$kwebfw$, $KD = $K.dom, $KU = $K.utils,
                    tracks = $KD.find(el.video, 'TRACK'), prop = this._kwebfw_.prop;

                //Remove Existing tracks
                $KU.each(tracks, function(track) {
                    $KD.remove(track);
                });

                //Adding new tracks
                $KU.each(prop.tracks, function(track/*, index*/) {
                    var trackNode = null;

                    trackNode = $KD.create('TRACK', {src:$KU.getImageURL(track.src), kind: 'subtitles'});

                    //Setting display name
                    if(track.displayName) {
                        $KD.setAttr(trackNode, 'label', track.displayName);
                    }

                    //setting source language
                    if(track.srclang) {
                        $KD.setAttr(trackNode, 'srclang', track.srclang);
                    }

                    $KD.add(this, trackNode);
                }, el.video);

                _setEnableCaptions.call(this, el);
            },

            enableCaptions : function Video$_view_enableCaptions(el/*, old*/) {
                _setEnableCaptions.call(this, el);
            }
        }
    };

    var _setEnableCaptions = function Video$_setEnableCaptions(el) {
        var defaultIndex = 0, index = 0, prop = this._kwebfw_.prop,
            textTracks = el.video.textTracks, tracks = prop.tracks;

        if(textTracks && textTracks.length > 0) {
            for(index = 0; index < textTracks.length; index++) {
                if(tracks[index].default) {
                    defaultIndex = index;
                }
                textTracks[index].mode = 'hidden';
            }

            if(prop.enableCaptions) {
                textTracks[defaultIndex].mode = 'showing';
            }
        }
    };


    Object.defineProperty(voltmx.ui, 'Video', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;


        /**
         * voltmx.ui.Video constructor.
         *
         * @class
         * @namespace   voltmx.ui
         * @extends     voltmx.ui.BasicWidget
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @param       {object} bconfig - An object with basic properties.
         * @param       {object} lconfig - An object with layout properties.
         * @param       {object} pspconfig - An object with platform specific properties.
         *
         * @throws      {InvalidArgumentException} - Invalid argument is passed.
         * @throws      {InvalidPropertyException} - Invalid property or invalid value of a property is passed.
         *
         * @classdesc   A brief description about the class.
         *              -
         *              -
         *
         * @todo        Anything that thought for but not yet implemented.
         *              -
         *              -
         */
        var Video = function Video(bconfig, lconfig, pspconfig) {
            var $K = voltmx.$kwebfw$, $KU = $K.utils, self = this,
                dependentPropertiesValidationMessage = '', prop = null;

            if(!$KU.is(bconfig, 'object')) bconfig = {};

            if(!bconfig.isPreValidated) {
                prop = {
                    controls: true,
                    poster: 'defvideoposter.png',
                    source: null,
                    tracks: null,
                    enableCaptions: true
                };
            }

            _populateUnderscore.Video.call(this);

            if(!$KU.is(bconfig.id, 'string') || !bconfig.id) {
                bconfig.id = (this._kwebfw_.name + $KU.uid());
            }

            Video.base.call(this, bconfig, lconfig, pspconfig);

            if(!bconfig.isPreValidated) {
                if($KU.is(_dependentPropertiesValidationMessage.Video, 'function')) {
                    dependentPropertiesValidationMessage = _dependentPropertiesValidationMessage.Video.call(this, prop, bconfig, lconfig, pspconfig);
                }
            }

            if(dependentPropertiesValidationMessage) {
                throw new Error(dependentPropertiesValidationMessage);
            } else {
                if(!bconfig.isPreValidated) {
                    //Defaulting to platfom values specific to Video
                    $KU.each(prop, function(value, key) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils,
                            $KW = $K.widget, valid = false, message = '';

                        if(!Object.prototype.hasOwnProperty.call(bconfig, key)) {
                            bconfig[key] = value;
                        } else if($KW.getNonConstructorProperties(self._kwebfw_.name).indexOf(key) >= 0) {
                            throw new Error('<' + key + '> is a non-constructor property of <' + self._kwebfw_.ns + '> class.');
                        } else if(!$KU.is(_valid.Video[key], 'function')) {
                            throw new Error('<' + key + '> is available in default widget properties of <voltmx.ui.Video>, but not in <_valid.Video> namespace.');
                        } else {
                            valid = _valid.Video[key].call(self, bconfig[key]);
                            if($KU.is(valid, 'array')) {
                                bconfig[key] = valid[0]; valid = valid[1];
                            }

                            if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                message = ('Invalid value passed to property <' + key + '> of widget <' + self._kwebfw_.ns + '>.');

                                if($KU.is(valid, 'string')) {
                                    message += ('\n' + valid);
                                }

                                throw new Error(message);
                            }
                        }
                    });
                }

                //Defining Getters/Setters specific to Video
                $KU.each(_view.Video, function(value, key) {
                    var $K = voltmx.$kwebfw$, $KU = $K.utils;

                    $KU.defineProperty(self._kwebfw_.prop, key, bconfig[key], {configurable:false, enumerable:true, writable:true});

                    $KU.defineGetter(self, key, function Video$_getter() {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils;

                        if($KU.is(_getter.Video[key], 'function')) {
                            return _getter.Video[key].call(this, this._kwebfw_.prop[key]);
                        }
                        return this._kwebfw_.prop[key];
                    }, true);

                    $KU.defineSetter(self, key, function Video$_setter(val) {
                        var $K = voltmx.$kwebfw$, $KU = $K.utils, old = null,
                            valid = false, $KW = $K.widget, rmodel = null,
                            final = null, message = '', el = null;

                        if(value === false) {
                            throw new Error('<'+key+'> is a readonly property of <'+this._kwebfw_.ns+'> widget.');
                        } else if(this._kwebfw_.prop[key] !== val) {
                            rmodel = $KW.rmodel(this);

                            if(rmodel && rmodel._kwebfw_.is.template && !rmodel._kwebfw_.is.cloned) {
                                throw new Error('Cannot set any value of a widget, which is either a raw template or any of its widget.');
                            } else {
                                valid = _valid.Video[key].call(this, val);
                                if($KU.is(valid, 'array')) {
                                    val = valid[0]; valid = valid[1];
                                }

                                if(valid === false || ($KU.is(valid, 'string') && valid)) {
                                    message = ('Invalid value passed to property <'+key+'> of widget <'+self._kwebfw_.ns+'>.');

                                    if($KU.is(valid, 'string')) {
                                        message += ('\n' + valid);
                                    }

                                    throw new Error(message);
                                } else {
                                    old = this._kwebfw_.prop[key];
                                    this._kwebfw_.prop[key] = val;

                                    if($KU.is(_setter.Video[key], 'function')) {
                                        _setter.Video[key].call(this, old);
                                    }

                                    if(_relayoutActiveTriggerer.Video().indexOf(key) >= 0) {
                                        $KW.markRelayout(this);
                                    }

                                    if(_relayoutPassiveTriggerer.Video().indexOf(key) >= 0) {
                                        final = this._kwebfw_.flex.final;

                                        if(!(final.height && final.width)) {
                                            $KW.markRelayout(this);
                                        }
                                    }

                                    $KW.onPropertyChange(this, key, old);

                                    if($KU.is(value, 'function')) {
                                        el = $KW.el(this);
                                        el.node && value.call(this, el, old);
                                    }
                                }
                            }
                        }
                    }, false);
                });

                if($KU.is(_postInitialization.Video, 'function')) {
                    _postInitialization.Video.call(this);
                }
            }

            pspconfig = lconfig = bconfig = null; //For GC
        };


        $K.utils.inherits(Video, voltmx.ui.BasicWidget);


        /**
         * Builds the view layer for voltmx.ui.Video widget.
         *
         * @override
         * @access      protected
         * @method      _render
         * @memberof    voltmx.ui.Video
         * @author      Goutam Sahu <goutam.sahu@voltmx.com>
         *
         * @returns     {HTMLElement}  Video view.
         */
        var video__render = function Video$_render(tag) {
            var $super = voltmx.ui.Video.base.prototype, _ = this._kwebfw_,
                view = _.view, $K = voltmx.$kwebfw$, $KU = $K.utils,
                $KW = $K.widget, $KD = $K.dom, el = null, video = null;

            if(this.isVisible || $K.F.RIVW) {
                if(!view) {
                    video = $KD.create('VIDEO', {});
                    view = $super._render.call(this, tag, [video]);

                    el = $KW.el(view);

                    $KD.setAttr(video, 'kwh-click', 'onClick');
                    $KD.setAttr(video, 'preload', 'none'); //Indicates that the video should not be preloaded.
                    this.controls && $KD.setAttr(video, 'controls', 'controls');
                    this.poster && $KD.setAttr(video, 'poster', $KU.getImageURL(this.poster));

                    _view.Video.source.call(this, el, this._kwebfw_.prop.source);
                    _view.Video.tracks.call(this, el, this._kwebfw_.prop.tracks);
                }

                $KW.accessibility(this);
            }

            return view;
        };


        var video_getBufferPercentage = function Video$getBufferPercentage() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this),
                duration = 0, buffer = 0, bufferDuration = 0, b = 0, blen = 0;

            if(el.video) {
                duration = el.video.duration;
                blen = el.video.buffered.length;

                for(b=0; b<blen; b++) {
                    bufferDuration = bufferDuration + el.video.buffered.end(b) - el.video.buffered.start(b);
                }

                buffer = ((100 * bufferDuration) / duration);
            }

            return buffer;
        };


        var video_getCurrentPosition = function Video$getCurrentPosition() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget,
                el = $KW.el(this), position = 0;

            if(el.video) {
                position = el.video.currentTime;
            }

            return position;
        };


        var video_getDuration = function Video$getDuration() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget,
                el = $KW.el(this), duration = 0;

            if(el.video) {
                duration = el.video.duration;
            }

            return duration;
        };


        var video_isPlaying = function Video$isPlaying() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget,
                el = $KW.el(this), playing = false;

            if(el.video) {
                playing = (!el.video.paused && !el.video.ended);
            }

            return playing;
        };


        var video_pause = function Video$pause() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_,
                el = $KW.el(this);

            if(el.video && $KW.visible(this)) {
                el.video.pause();
            }
            _.playstate = false;
        };


        var video_play = function Video$play() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_,
                el = $KW.el(this);

            if(el.video && $KW.visible(this)) {
                el.video.currentTime = 0;
                el.video.play();
                _.playstate = true;
            }
        };


        var video_resume = function Video$resume() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_,
                el = $KW.el(this);

            if(el.video && $KW.visible(this)) {
                el.video.play();
                _.playstate = true;
            }
        };


        var video_seekTo = function Video$seekTo(time) {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, el = $KW.el(this);

            if(el.video && $KW.visible(this)) {
                el.video.pause();
                el.video.currentTime = time;
                el.video.play();
            }
        };


        var video_setSource = function Video$setSource(source) {
            this.source = source;
        };

        var video_setTracks = function Video$setTracks(source) {
            this.tracks = source;
        };

        var video_stop = function Video$stop() {
            var $K = voltmx.$kwebfw$, $KW = $K.widget, _ = this._kwebfw_,
                el = $KW.el(this);

            if(el.video && $KW.visible(this)) {
                el.video.pause();
                el.video.currentTime = 0;
                _.playstate = false;
            }
        };


        $K.defVoltmxProp(Video.prototype, [
            {keey:'_render', value:video__render},
            {keey:'getBufferPercentage', value:video_getBufferPercentage},
            {keey:'getCurrentPosition', value:video_getCurrentPosition},
            {keey:'getDuration', value:video_getDuration},
            {keey:'isPlaying', value:video_isPlaying},
            {keey:'pause', value:video_pause},
            {keey:'play', value:video_play},
            {keey:'resume', value:video_resume},
            {keey:'seekTo', value:video_seekTo},
            {keey:'setSource', value:video_setSource},
            {keey: 'setTracks', value:video_setTracks},
            {keey:'stop', value:video_stop}
        ]);


        return Video;
    }())});
}());


/* FILE PATH :: 'lib/widgets/voltmxunsupported.js' */


(function() {
    var $K = voltmx.$kwebfw$;


    Object.defineProperty(voltmx.ui, 'ActionItem', {configurable:false, enumerable:false, writable:$K.defWritable(), value:(function() {
        var $K = voltmx.$kwebfw$;

        var ActionItem = function ActionItem() {};
        $K.utils.inherits(ActionItem, voltmx.ui.BasicWidget);

        var actionitem__render = function ActionItem$_render(tag) {
            var $super = voltmx.ui.FlexContainer.base.prototype,
                $K = voltmx.$kwebfw$, $KU = $K.utils, view = null;

            if(this.isVisible || $K.F.RIVW) {
                view = $super._render.call(this, tag);

                if(!this._kwebfw_.view && this._kwebfw_.ns === 'voltmx.ui.ActionItem') {
                    $KU.defineProperty(this._kwebfw_, 'view', view);
                }
            }

            return view;
        };

        var actionitem_addAction = function ActionItem$addAction() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.Toast().addAction');
        };

        var actionitem_setAnchorConfiguration = function ActionItem$setAnchorConfiguration() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.Toast().setAnchorConfiguration');
        };

        var actionitem_show = function ActionItem$show() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.Toast().show');
        };

        $K.defVoltmxProp(ActionItem.prototype, [
            {keey:'_render', value:actionitem__render},
            {keey:'addAction', value:actionitem_addAction},
            {keey:'setAnchorConfiguration', value:actionitem_setAnchorConfiguration},
            {keey:'show', value:actionitem_show}
        ]);

        return ActionItem;
    }())});


    Object.defineProperty(voltmx.ui, 'BottomSheet', {configurable:false, enumerable:false, writable:$K.defWritable(), value:(function() {
        var $K = voltmx.$kwebfw$;

        var BottomSheet = function BottomSheet() {};
        $K.utils.inherits(BottomSheet, voltmx.ui.BasicWidget);

        var bottomsheet__render = function BottomSheet$_render(tag) {
            var $super = voltmx.ui.FlexContainer.base.prototype,
                $K = voltmx.$kwebfw$, $KU = $K.utils, view = null;

            if(this.isVisible || $K.F.RIVW) {
                view = $super._render.call(this, tag);

                if(!this._kwebfw_.view && this._kwebfw_.ns === 'voltmx.ui.BottomSheet') {
                    $KU.defineProperty(this._kwebfw_, 'view', view);
                }
            }

            return view;
        };

        var bottomsheet_destroy = function BottomSheet$destroy() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.BottomSheet().destroy');
        };

        var bottomsheet_dismiss = function BottomSheet$dismiss() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.BottomSheet().dismiss');
        };

        var bottomsheet_show = function BottomSheet$show() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.BottomSheet().show');
        };

        var bottomsheet_setState = function BottomSheet$setState() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.BottomSheet().setState');
        };

        $K.defVoltmxProp(BottomSheet.prototype, [
            {keey:'_render', value:bottomsheet__render},
            {keey:'destroy', value:bottomsheet_destroy},
            {keey:'dismiss', value:bottomsheet_dismiss},
            {keey:'show', value:bottomsheet_show},
            {keey:'setState', value:bottomsheet_setState}
        ]);

        return BottomSheet;
    }())});


    Object.defineProperty(voltmx.ui, 'CordovaBrowser', {configurable:false, enumerable:false, writable:$K.defWritable(), value:(function() {
        var $K = voltmx.$kwebfw$;

        var CordovaBrowser = function CordovaBrowser() {};
        $K.utils.inherits(CordovaBrowser, voltmx.ui.BasicWidget);

        var cordovabrowser__render = function CordovaBrowser$_render(tag) {
            var $super = voltmx.ui.FlexContainer.base.prototype,
                $K = voltmx.$kwebfw$, $KU = $K.utils, view = null;

            if(this.isVisible || $K.F.RIVW) {
                view = $super._render.call(this, tag);

                if(!this._kwebfw_.view && this._kwebfw_.ns === 'voltmx.ui.CordovaBrowser') {
                    $KU.defineProperty(this._kwebfw_, 'view', view);
                }
            }

            return view;
        };

        var cordovabrowser_canGoBack = function CordovaBrowser$canGoBack() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().canGoBack');
        };

        var cordovabrowser_canGoForward = function CordovaBrowser$canGoForward() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().canGoForward');
        };

        var cordovabrowser_clearHistory = function CordovaBrowser$clearHistory() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().clearHistory');
        };

        var cordovabrowser_evaluateJavaScript = function CordovaBrowser$evaluateJavaScript() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().evaluateJavaScript');
        };

        var cordovabrowser_getHTMLFilesInWebFolder = function CordovaBrowser$getHTMLFilesInWebFolder() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().getHTMLFilesInWebFolder');
        };

        var cordovabrowser_goBack = function CordovaBrowser$goBack() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().goBack');
        };

        var cordovabrowser_goForward = function CordovaBrowser$goForward() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().goForward');
        };

        var cordovabrowser_isCordovaAppsEnabled = function CordovaBrowser$isCordovaAppsEnabled() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().isCordovaAppsEnabled');
        };

        var cordovabrowser_isHtmlPreviewEnabled = function CordovaBrowser$isHtmlPreviewEnabled() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().isHtmlPreviewEnabled');
        };

        var cordovabrowser_isWebAppDevelopmentEnabled = function CordovaBrowser$isWebAppDevelopmentEnabled() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().isWebAppDevelopmentEnabled');
        };

        var cordovabrowser_loadData = function CordovaBrowser$loadData() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().loadData');
        };

        var cordovabrowser_registerForPeekandPop = function CordovaBrowser$registerForPeekandPop() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().registerForPeekandPop');
        };

        var cordovabrowser_reload = function CordovaBrowser$reload() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().reload');
        };

        var cordovabrowser_setOnPeek = function CordovaBrowser$setOnPeek() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().setOnPeek');
        };

        var cordovabrowser_setOnPop = function CordovaBrowser$setOnPop() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().setOnPop');
        };

        var cordovabrowser_unregisterForPeekandPop = function CordovaBrowser$unregisterForPeekandPop() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.CordovaBrowser().unregisterForPeekandPop');
        };

        $K.defVoltmxProp(CordovaBrowser.prototype, [
            {keey:'_render', value:cordovabrowser__render},
            {keey:'canGoBack', value:cordovabrowser_canGoBack},
            {keey:'canGoForward', value:cordovabrowser_canGoForward},
            {keey:'clearHistory', value:cordovabrowser_clearHistory},
            {keey:'evaluateJavaScript', value:cordovabrowser_evaluateJavaScript},
            {keey:'getHTMLFilesInWebFolder', value:cordovabrowser_getHTMLFilesInWebFolder},
            {keey:'goBack', value:cordovabrowser_goBack},
            {keey:'goForward', value:cordovabrowser_goForward},
            {keey:'isCordovaAppsEnabled', value:cordovabrowser_isCordovaAppsEnabled},
            {keey:'isHtmlPreviewEnabled', value:cordovabrowser_isHtmlPreviewEnabled},
            {keey:'isWebAppDevelopmentEnabled', value:cordovabrowser_isWebAppDevelopmentEnabled},
            {keey:'loadData', value:cordovabrowser_loadData},
            {keey:'registerForPeekandPop', value:cordovabrowser_registerForPeekandPop},
            {keey:'reload', value:cordovabrowser_reload},
            {keey:'setOnPeek', value:cordovabrowser_setOnPeek},
            {keey:'setOnPop', value:cordovabrowser_setOnPop},
            {keey:'unregisterForPeekandPop', value:cordovabrowser_unregisterForPeekandPop}
        ]);

        return CordovaBrowser;
    }())});


    Object.defineProperty(voltmx.ui, 'NativeContainer', {configurable:false, enumerable:false, writable:$K.defWritable(), value:(function() {
        var $K = voltmx.$kwebfw$;

        var NativeContainer = function NativeContainer() {};
        $K.utils.inherits(NativeContainer, voltmx.ui.BasicWidget);

        var nativecontainer__render = function NativeContainer$_render(tag) {
            var $super = voltmx.ui.FlexContainer.base.prototype,
                $K = voltmx.$kwebfw$, $KU = $K.utils, view = null;

            if(this.isVisible || $K.F.RIVW) {
                view = $super._render.call(this, tag);

                if(!this._kwebfw_.view && this._kwebfw_.ns === 'voltmx.ui.NativeContainer') {
                    $KU.defineProperty(this._kwebfw_, 'view', view);
                }
            }

            return view;
        };

        var nativecontainer_getContainerView = function NativeContainer$getContainerView() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.NativeContainer().getContainerView');
        };

        var nativecontainer_registerForPeekandPop = function NativeContainer$registerForPeekandPop() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.NativeContainer().registerForPeekandPop');
        };

        var nativecontainer_setOnPeek = function NativeContainer$setOnPeek() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.NativeContainer().setOnPeek');
        };

        var nativecontainer_setOnPop = function NativeContainer$setOnPop() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.NativeContainer().setOnPop');
        };

        var nativecontainer_unregisterForPeekandPop = function NativeContainer$unregisterForPeekandPop() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.NativeContainer().unregisterForPeekandPop');
        };

        $K.defVoltmxProp(NativeContainer.prototype, [
            {keey:'_render', value:nativecontainer__render},
            {keey:'getContainerView', value:nativecontainer_getContainerView},
            {keey:'registerForPeekandPop', value:nativecontainer_registerForPeekandPop},
            {keey:'setOnPeek', value:nativecontainer_setOnPeek},
            {keey:'setOnPop', value:nativecontainer_setOnPop},
            {keey:'unregisterForPeekandPop', value:nativecontainer_unregisterForPeekandPop}
        ]);

        return NativeContainer;
    }())});


    Object.defineProperty(voltmx.ui, 'ReactNativeContainer', {configurable:false, enumerable:false, writable:$K.defWritable(), value:(function() {
        var $K = voltmx.$kwebfw$;

        var ReactNativeContainer = function ReactNativeContainer() {};
        $K.utils.inherits(ReactNativeContainer, voltmx.ui.BasicWidget);

        var reactnativecontainer__render = function ReactNativeContainer$_render(tag) {
            var $super = voltmx.ui.FlexContainer.base.prototype,
                $K = voltmx.$kwebfw$, $KU = $K.utils, view = null;

            if(this.isVisible || $K.F.RIVW) {
                view = $super._render.call(this, tag);

                if(!this._kwebfw_.view && this._kwebfw_.ns === 'voltmx.ui.ReactNativeContainer') {
                    $KU.defineProperty(this._kwebfw_, 'view', view);
                }
            }

            return view;
        };

        $K.defVoltmxProp(ReactNativeContainer.prototype, [
            {keey:'_render', value:reactnativecontainer__render}
        ]);

        return ReactNativeContainer;
    }())});


    Object.defineProperty(voltmx.ui, 'Toast', {configurable:false, enumerable:false, writable:$K.defWritable(), value:(function() {
        var $K = voltmx.$kwebfw$;

        var Toast = function Toast() {};
        $K.utils.inherits(Toast, voltmx.ui.BasicWidget);

        var toast__render = function Toast$_render(tag) {
            var $super = voltmx.ui.FlexContainer.base.prototype,
                $K = voltmx.$kwebfw$, $KU = $K.utils, view = null;

            if(this.isVisible || $K.F.RIVW) {
                view = $super._render.call(this, tag);

                if(!this._kwebfw_.view && this._kwebfw_.ns === 'voltmx.ui.Toast') {
                    $KU.defineProperty(this._kwebfw_, 'view', view);
                }
            }

            return view;
        };

        var toast_show = function Toast$show() {
            var $K = voltmx.$kwebfw$, $KU = $K.utils;

            $KU.unsupportedAPI('new voltmx.ui.Toast().show');
        };

        $K.defVoltmxProp(Toast.prototype, [
            {keey:'_render', value:toast__render},
            {keey:'show', value:toast_show}
        ]);

        return Toast;
    }())});


    /*
    Object.defineProperty(voltmx.ui, 'UnsupportedWidget01', {configurable:false, enumerable:false, writable:$K.defWritable(), value:(function() {
        var $K = voltmx.$kwebfw$;

        var UnsupportedWidget01 = function UnsupportedWidget01() {};
        $K.utils.inherits(UnsupportedWidget01, voltmx.ui.BasicWidget);

        var unsupported01__render = function UnsupportedWidget01$_render(tag) {
            var $super = voltmx.ui.FlexContainer.base.prototype,
                $K = voltmx.$kwebfw$, $KU = $K.utils, view = null;

            if(this.isVisible || $K.F.RIVW) {
                view = $super._render.call(this, tag);

                if(!this._kwebfw_.view && this._kwebfw_.ns === 'voltmx.ui.UnsupportedWidget01') {
                    $KU.defineProperty(this._kwebfw_, 'view', view);
                }
            }

            return view;
        };

        $K.defVoltmxProp(UnsupportedWidget01.prototype, [
            {key:'_render', value:unsupported01__render}
        ]);

        return UnsupportedWidget01;
    }())});


    Object.defineProperty(voltmx.ui, 'UnsupportedWidget02', {configurable:false, enumerable:false, writable:false, value:(function() {
        var $K = voltmx.$kwebfw$;

        var UnsupportedWidget02 = function UnsupportedWidget02() {};
        $K.utils.inherits(UnsupportedWidget02, voltmx.ui.BasicWidget);

        var unsupported02__render = function UnsupportedWidget02$_render(tag) {
            var $super = voltmx.ui.FlexContainer.base.prototype,
                $K = voltmx.$kwebfw$, $KU = $K.utils, view = null;

            if(this.isVisible || $K.F.RIVW) {
                view = $super._render.call(this, tag);

                if(!this._kwebfw_.view && this._kwebfw_.ns === 'voltmx.ui.UnsupportedWidget02') {
                    $KU.defineProperty(this._kwebfw_, 'view', view);
                }
            }

            return view;
        };

        $K.defVoltmxProp(UnsupportedWidget02.prototype, [
            {key:'_render', value:unsupported02__render}
        ]);

        return UnsupportedWidget02;
    }())});
    //*/
}());


/* FILE PATH :: 'lib/utils/voltmxmvc.js' */
_voltmx.mvc = {
    Form2: function(bconfig, lconfig, pspconfig) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils, formInstance = null;

        if(!bconfig._voltmxControllerName) {
            $KU.log('warn', 'This API is applicable only for MVC projects.');
        } else {
            if(arguments.length < 3) {
                formInstance = new voltmx.ui.Form2(bconfig);
            } else {
                formInstance = new voltmx.ui.Form2(bconfig, lconfig, pspconfig);
            }

            return formInstance;
        }
    },

    showForm: function(formModel) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'_voltmx.mvc.showForm', enter:true});

        if(formModel._voltmxControllerName) {
            formModel.show({forced:true});
            $KU.log({api:'_voltmx.mvc.showForm', exit:true});
        } else {
            $KU.log('warn', 'This API is applicable only for MVC projects.');
        }
    },

    destroyForm: function(formModel) {
        var $K = voltmx.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'_voltmx.mvc.destroyForm', enter:true});

        if(formModel._voltmxControllerName && formModel) {
            formModel.destroy({forced:true});
            $KU.log({api:'_voltmx.mvc.destroyForm', exit:true});
        } else {
            $KU.log('warn', 'This API is applicable only for MVC projects.');
        }
    }
};


/* FILE PATH :: 'lib/tparty/voltmxmvc_sdk.js' */
voltmx.mvc = voltmx.mvc || {};
_voltmx = _voltmx || {};
_voltmx.mvc = _voltmx.mvc || {};
Object.defineProperty(_voltmx, "def", {
    configurable: false,
    enumerable: false,
    writable: true,
    value: function() {
        return function(target, keey, value) {
            Object.defineProperty(target, keey, {
                configurable: false,
                enumerable: false,
                value: value,
                writable: true
            })
        }
    }()
});
(function() {
    var _appContextMap = {},
        _currentAppName = null;
    var _setAppData = function(userDataConfig) {
        if (_isValidData(userDataConfig)) {
            _setOrUpdateData(userDataConfig.appName, userDataConfig.context)
        } else {
            throw new Error("Passed Invalid context to this API.")
        }
    };
    var _isValidData = function(userDataConfig) {
        var flag = false;
        if (userDataConfig.appName && typeof userDataConfig.context === "object") {
            flag = true
        }
        return flag
    };
    var _setOrUpdateData = function(appName, data) {
        var key = null;
        if (!_appContextMap[appName]) {
            _appContextMap[appName] = data
        } else {
            for (key in data) {
                if (data.hasOwnProperty(key)) {
                    _appContextMap[appName][key] = data[key]
                }
            }
        }
    };
    var _getCurrentAppData = function() {
        return _appContextMap[_currentAppName]
    };
    var _getCurrentAppName = function() {
        return _currentAppName || appConfig.appName
    };
    var _appManager = function() {
        var _ns = {};
        _voltmx.def(_ns, "getCurrentAppContext", _getCurrentAppData);
        _voltmx.def(_ns, "setAppContext", _setAppData);
        _voltmx.def(_ns, "getCurrentAppName", _getCurrentAppName);
        _voltmx.def(_ns, "isCompositeApp", _voltmx.mvc.isCompositeApp);
        return _ns
    };
    Object.defineProperty(voltmx.mvc, "getApplicationManager", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: function() {
            return _appManager
        }()
    });
    var _getAppData = function(appName) {
        return _appContextMap[appName]
    };
    var _setCurrentAppName = function(appName) {
        _currentAppName = appName
    };
    _voltmx.def(_voltmx.mvc, "setCurrentAppName", _setCurrentAppName);
    _voltmx.def(_voltmx.mvc, "getCurrentAppName", _getCurrentAppName);
    _voltmx.def(_voltmx.mvc, "getAppData", _getAppData)
})();
voltmx.mvc = voltmx.mvc || {};
_kony = _voltmx = _voltmx || {};
voltmx.mvc.BaseController = function() {
    function BaseController(viewId1) {
        this.viewId = viewId1;
        var viewModel;
        defineGetter(this, "view", function() {
            if (viewModel === undefined) {
                viewModel = this.__initializeView(this);
                if (Object.prototype.hasOwnProperty.call(this, "onViewCreated")) {
                    this["onViewCreated"].apply(this)
                }
            }
            return viewModel
        });
        defineSetter(this, "view", function(val) {
            viewModel = val
        })
    }
    BaseController.prototype.destroy = function() {
        if (this.onDestroy) {
            this.onDestroy()
        }
        this.view = null;
        this.viewId = null
    };
    return BaseController
}();
_voltmx.mvc.ModelController = function() {
    function ModelController() {}
    return ModelController
}();
(function() {
    var _resolveNameFromContextMap = {},
        _ctrlname2ControllerMap = {},
        _viewId2ControllerNameMap = {},
        _viewName2viewId = {},
        _isCompositeApp = false,
        _tmAppsList = [],
        _isInitializeRegistriesDone = false;
    var _initializeRuntimeRegistries = function(isCompositeFlag) {
        var apps, appName, microApps;
        if (typeof isCompositeFlag === "boolean") {
            _isCompositeApp = isCompositeFlag
        }
        if (appConfig) {
            if (appConfig.appName) {
                _voltmx.mvc.setCurrentAppName(appConfig.appName);
                _tmAppsList.push(appConfig.appName)
            }
            microApps = appConfig.microApps
        }
        if (microApps && _isCompositeApp) {
            for (apps in microApps) {
                appName = microApps[apps].appName;
                if (appName) {
                    _ctrlname2ControllerMap[appName] = {};
                    _viewId2ControllerNameMap[appName] = {};
                    _viewName2viewId[appName] = {};
                    _tmAppsList.push(appName)
                } else {
                    throw new Error("Invalid appName in appConfig for MicroApps")
                }
            }
        }
        _voltmx.mvc.initializeRegistries(_tmAppsList, _isCompositeApp)
    };
    _voltmx.def(_voltmx.mvc, "getAppsList", function() {
        return _tmAppsList
    });
    Object.defineProperty(_voltmx.mvc, "initCompositeApp", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: function() {
            return function(isCompositeFlag) {
                if (!_isInitializeRegistriesDone) {
                    _initializeRuntimeRegistries(isCompositeFlag);
                    _isInitializeRegistriesDone = true
                }
            }
        }()
    });
    Object.defineProperty(_voltmx.mvc, "isCompositeApp", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: function() {
            return function() {
                return _isCompositeApp
            }
        }()
    });
    _voltmx.mvc.getViewId2ControllerNameMap = function(appName) {
        var ret;
        if (_isCompositeApp) {
            appName = appName || _voltmx.mvc.getCurrentAppName();
            ret = _viewId2ControllerNameMap[appName]
        }
        return ret || _viewId2ControllerNameMap
    };
    _voltmx.mvc.getControllerName2ControllerMap = function(appName) {
        var ret;
        if (_isCompositeApp) {
            appName = appName || _voltmx.mvc.getCurrentAppName();
            ret = _ctrlname2ControllerMap[appName]
        }
        return ret || _ctrlname2ControllerMap
    };
    _voltmx.mvc.getViewName2viewIdMap = function(appName) {
        var ret;
        if (_isCompositeApp) {
            appName = appName || _voltmx.mvc.getCurrentAppName();
            ret = _viewName2viewId[appName]
        }
        return ret || _viewName2viewId
    };
    var _getFriendlyNameById = function(id, appName) {
        var friendlyName = null,
            viewIdctrlMap, ctrl;
        if (_isCompositeApp) {
            appName = appName || _voltmx.mvc.getCurrentAppName();
            viewIdctrlMap = _viewId2ControllerNameMap[appName][id];
            ctrl = _ctrlname2ControllerMap[appName][viewIdctrlMap]
        } else {
            viewIdctrlMap = _viewId2ControllerNameMap[id];
            ctrl = _ctrlname2ControllerMap[viewIdctrlMap]
        }
        if (ctrl) friendlyName = ctrl.formFriendlyName;
        return friendlyName
    };
    _voltmx.mvc.getPath = function(fileName, appName) {
        if (!(typeof fileName === "string")) return;
        if (_isCompositeApp) fileName = appName + "/" + fileName;
        return fileName
    };
    _voltmx.mvc.getNameSpacedValue = function(fileName, appName) {
        if (_isCompositeApp) {
            if (!appName) appName = _voltmx.mvc.getCurrentAppName();
            fileName = appName + "_" + fileName
        }
        return fileName
    };
    var _getResolvedFilePath = function(fileName, appName) {
        var navConfig, path = _voltmx.mvc.getPath(fileName, appName);
        if (!_resolveNameFromContextMap[path]) {
            navConfig = {
                friendlyName: fileName,
                appName: appName
            };
            _resolveNameFromContextMap[path] = navConfig
        }
        return path
    };
    var _getResolvedNameFromMap = function(path) {
        return _resolveNameFromContextMap[path]
    };
    _voltmx.mvc.getControllerFromViewID = function(viewID, appName) {
        var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
        var viewId2ControllerNameMap = _voltmx.mvc.getViewId2ControllerNameMap(appName);
        var controllerName = viewId2ControllerNameMap[viewID];
        return ctrlName2ControllerMap[controllerName]
    };
    Object.defineProperty(voltmx.mvc, "resolveNameFromContext", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: function() {
            return function(configObj) {
                var pathStr, appName, friendlyName;
                if (typeof configObj === "object" && configObj.appName && configObj.friendlyName) {
                    appName = configObj.appName;
                    friendlyName = configObj.friendlyName;
                    if (_tmAppsList.indexOf(appName) === -1) {
                        throw new Error("Invalid appName for resolveNameFromContext API !!!")
                    }
                    if (!_voltmx.mvc.getFormRegistryInfo(friendlyName, appName)) {
                        throw new Error("Invalid name for resolveNameFromContext API !!!")
                    }
                    pathStr = _getResolvedFilePath(friendlyName, appName)
                } else {
                    throw new Error("Mandatory parameters missing for resolveNameFromContext API !!!")
                }
                return pathStr
            }
        }()
    });
    Object.defineProperty(_voltmx.mvc, "navigate", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: function() {
            return function(idOrPath, appName) {
                var friendlyName, deeplinkFormNav, navConfig = _getResolvedNameFromMap(idOrPath);
                if (!navConfig) {
                    navConfig = idOrPath;
                    friendlyName = _getFriendlyNameById(idOrPath, appName);
                    if (friendlyName) {
                        navConfig = {
                            friendlyName: friendlyName,
                            appName: appName
                        }
                    }
                }
                deeplinkFormNav = new voltmx.mvc.Navigation(navConfig);
                deeplinkFormNav.navigate()
            }
        }()
    });
    _voltmx.mvc.initializeSubViewController = function(nameOrPath, appName) {
        var appName = appName || _voltmx.mvc.getCurrentAppName(),
            friendlyName = nameOrPath,
            resolvedMap = _getResolvedNameFromMap(nameOrPath),
            tmpController = null;
        if (resolvedMap) {
            appName = resolvedMap.appName;
            friendlyName = resolvedMap.friendlyName
        }
        tmpController = _voltmx.mvc.GetController(friendlyName, false, {
            appName: appName
        });
        return tmpController.view
    };
    _voltmx.mvc.initializeFormViewController = function(nameOrPath) {
        var appName = _voltmx.mvc.getCurrentAppName(),
            friendlyName = nameOrPath,
            resolvedMap = _getResolvedNameFromMap(nameOrPath),
            tmpController = null;
        if (resolvedMap) {
            appName = resolvedMap.appName;
            friendlyName = resolvedMap.friendlyName
        }
        tmpController = _voltmx.mvc.GetController(friendlyName, true, {
            appName: appName
        });
        return tmpController.view
    };
    var _web = {
        componentInSegment: function(controllerID, appName) {
            var ctrl;
            if (_isCompositeApp) {
                appName = appName || _voltmx.mvc.getCurrentAppName();
                ctrl = _ctrlname2ControllerMap[appName][controllerID]
            } else {
                ctrl = _ctrlname2ControllerMap[controllerID]
            }
            return ctrl
        }
    };
    _voltmx.def(_voltmx.mvc, "getComponentController", function(controllerID, appName) {
        return _web.componentInSegment(controllerID, appName)
    });
    var _webHotReload = {
        deleteRuntimeRegistries: function(formID, appName) {
            var info = {},
                friendlyName, viewIdctrlMap, ctrl, formName, registryInfo;
            if (!appConfig.hotReloadURL) throw new Error("This API not supported !!!");
            if (appConfig.isDebug) {
                if (_isCompositeApp) {
                    appName = appName || _voltmx.mvc.getCurrentAppName();
                    viewIdctrlMap = _viewId2ControllerNameMap[appName][formID];
                    ctrl = _ctrlname2ControllerMap[appName][viewIdctrlMap];
                    if (ctrl) {
                        friendlyName = ctrl.formFriendlyName;
                        formName = ctrl.viewId;
                        delete _viewId2ControllerNameMap[appName][formID];
                        delete _ctrlname2ControllerMap[appName][viewIdctrlMap];
                        delete _viewName2viewId[appName][formName]
                    }
                } else {
                    viewIdctrlMap = _viewId2ControllerNameMap[formID];
                    ctrl = _ctrlname2ControllerMap[viewIdctrlMap];
                    if (ctrl) {
                        friendlyName = ctrl.formFriendlyName;
                        formName = ctrl.viewId;
                        delete _viewId2ControllerNameMap[formID];
                        delete _ctrlname2ControllerMap[viewIdctrlMap];
                        delete _viewName2viewId[formName]
                    }
                }
                info.navigationObject = {
                    friendlyName: friendlyName,
                    appName: appName
                };
                registryInfo = _voltmx.mvc.getFormRegistryInfo(friendlyName, appName);
                if (registryInfo) {
                    info.registryInfo = JSON.parse(JSON.stringify(registryInfo))
                }
            }
            return info
        }
    };
    _voltmx.def(_voltmx.mvc, "resetBookKeepersAndGetFormInfo", function(formID, appName) {
        return _webHotReload.deleteRuntimeRegistries(formID, appName)
    })
})();
voltmx.mvc = voltmx.mvc || {};
inheritsFrom = function(child, parent) {
    child.prototype = Object.create(parent.prototype)
};
voltmx.mvc.FormController = function() {
    function FormController(viewId1) {
        var navContext;
        this.navigationMode = 0;
        this.__initializeView = function(objController) {
            var retForm = null;
            var viewFileName = objController.viewId;
            var appName = objController.appName;
            var viewName2viewIdMap = _voltmx.mvc.getViewName2viewIdMap(appName);
            var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
            var viewId2ControllerNameMap = _voltmx.mvc.getViewId2ControllerNameMap(appName);
            if (Object.prototype.hasOwnProperty.call(this, "onCreateView")) {
                viewFileName = this["onCreateView"].apply(this, null);
                if (typeof viewFileName === "object" && Object.prototype.hasOwnProperty.call(viewFileName, "id")) {
                    retForm = viewFileName
                } else {
                    var path = _voltmx.mvc.getPath(viewFileName, objController.appName);
                    formCreateFunc = voltmx.utils.LoadJSFile(path);
                    if (!formCreateFunc) {
                        throw new Error("Invalid file : " + path)
                    }
                    var formConfig = formCreateFunc(objController);
                    if (Object.prototype.toString.call(formConfig) === "[object Array]") {
                        formConfig[0]._voltmxControllerName = objController.Name;
                        retForm = new _voltmx.mvc.Form2(formConfig[0], formConfig[1], formConfig[2])
                    } else {
                        formConfig._voltmxControllerName = objController.Name;
                        retForm = new _voltmx.mvc.Form2(formConfig)
                    }
                }
            } else {
                var path = _voltmx.mvc.getPath(viewFileName, objController.appName);
                formCreateFunc = voltmx.utils.LoadJSFile(path);
                if (!formCreateFunc) {
                    throw new Error("Invalid file : " + path)
                }
                var formConfig = formCreateFunc(objController);
                if (Object.prototype.toString.call(formConfig) === "[object Array]") {
                    formConfig[0]._voltmxControllerName = objController.Name;
                    retForm = new _voltmx.mvc.Form2(formConfig[0], formConfig[1], formConfig[2])
                } else {
                    formConfig._voltmxControllerName = objController.Name;
                    retForm = new _voltmx.mvc.Form2(formConfig)
                }
            }
            retForm.mvcInitializeView = false;
            retForm._appName = appName;
            retForm._voltmxControllerName = objController.Name;
            ctrlName2ControllerMap[retForm._voltmxControllerName] = objController;
            viewId2ControllerNameMap[retForm.id] = objController.Name;
            viewName2viewIdMap[objController.viewId] = retForm.id;
            retForm.mvcInitializeView = true;
            return retForm
        };
        this.__showView = function(param) {
            if (null != this.view) {
                navContext = param;
                _voltmx.mvc.showForm(this.view)
            }
        };
        defineGetter(this, "navigationContext", function() {
            return navContext
        });
        defineSetter(this, "navigationContext", function(val) {
            throw new Error("Setter for Navigation context is not allowed.")
        });
        voltmx.mvc.BaseController.call(this, viewId1)
    }
    inheritsFrom(FormController, voltmx.mvc.BaseController);
    FormController.prototype.pauseNavigation = function() {
        if (this.navigationMode == 1) {
            this.navigationMode = 2
        } else {
            voltmx.print("No form navigation is in progress hence cannot be paused.")
        }
    };
    FormController.prototype.resumeNavigation = function() {
        if (this.navigationMode == 2) {
            this.navigationMode = 0;
            this.__showView()
        } else {
            voltmx.print("No form navigation is in paused state hence cannot be resumed.")
        }
    };
    FormController.prototype.show = function(param, isBackNavigation) {
        this.navigationMode = 1;
        if (this.onNavigate) {
            this.onNavigate.call(this, param, isBackNavigation)
        }
        if (this.navigationMode == 1) {
            this.navigationMode = 0;
            this.__showView(param)
        }
    };
    FormController.prototype.getPreviousForm = function() {
        var prevForm = voltmx.application.getPreviousForm();
        if (null != prevForm) {
            if (prevForm._voltmxControllerName) return prevForm.id;
            else return prevForm
        }
        return null
    };
    FormController.prototype.getPreviousFormFriendlyName = function() {
        var prevForm = voltmx.application.getPreviousForm();
        if (null != prevForm) {
            var appName = _voltmx.mvc.getCurrentAppName();
            var controller = _voltmx.mvc.getControllerFromViewID(prevForm.id, appName);
            var fName = voltmx.mvc.registry.getFriendlyName(controller.viewId, appName);
            if (null != fName) return fName;
            else return prevForm.id
        }
        return null
    };
    FormController.prototype.getCurrentForm = function() {
        var currForm = voltmx.application.getCurrentForm();
        if (null != currForm) {
            if (currForm._voltmxControllerName) return currForm.id;
            else return currForm
        }
        return null
    };
    FormController.prototype.getCurrentFormFriendlyName = function() {
        var currForm = voltmx.application.getCurrentForm();
        var appName = _voltmx.mvc.getCurrentAppName();
        var controller = _voltmx.mvc.getControllerFromViewID(currForm.id, appName);
        var fName = voltmx.mvc.registry.getFriendlyName(controller.viewId, appName);
        if (null != fName) return fName;
        else return currForm.id;
        return null
    };
    FormController.prototype.destroy = function() {
        if (null != this.view) {
            if (this.view.onDestroy) {
                var destroyFunc = this.view.onDestroy;
                this.view.onDestroy = null;
                destroyFunc.call(this)
            }
            _voltmx.mvc.destroyForm(this.view)
        }
        voltmx.mvc.BaseController.prototype.destroy.call(this)
    };
    FormController.prototype.executeOnAppLevelWidget = function(paramsObject) {
        if (paramsObject == null || paramsObject == undefined || paramsObject.container == null || paramsObject.container == undefined || paramsObject.eventName == null || paramsObject.eventName == undefined) {
            return false
        }
        var widgetName = paramsObject.container;
        var appName = _voltmx.mvc.getCurrentAppName();
        var tmpWidgetName = voltmx.mvc.registry.get(widgetName, appName);
        if (null != tmpWidgetName) {
            widgetName = tmpWidgetName
        }
        var controller = _voltmx.mvc.appLevelWidget2Controller[widgetName];
        if (controller == null || controller == undefined) {
            return false
        }
        if (Object.prototype.hasOwnProperty.call(controller, paramsObject.eventName)) {
            return controller[paramsObject.eventName].call(controller, paramsObject.params)
        }
        return false
    };
    return FormController
}();
_voltmx = _voltmx || {};
_voltmx.mvc = _voltmx.mvc || {};
voltmx.mvc = voltmx.mvc || {};
voltmx.utils = voltmx.utils || {};

function accessorDescriptor(field, fun) {
    var desc = {
        enumerable: true,
        configurable: true
    };
    desc[field] = fun;
    return desc
}

function defineGetter(obj, prop, get) {
    if (Object.defineProperty) return Object.defineProperty(obj, prop, accessorDescriptor("get", get));
    if (Object.prototype.__defineGetter__) return obj.__defineGetter__(prop, get);
    throw new Error("browser does not support getters")
}

function defineSetter(obj, prop, set) {
    if (Object.defineProperty) return Object.defineProperty(obj, prop, accessorDescriptor("set", set));
    if (Object.prototype.__defineSetter__) return obj.__defineSetter__(prop, set);
    throw new Error("browser does not support setters")
}
inheritsFrom = function(child, parent) {
    child.prototype = Object.create(parent.prototype)
};
_voltmx.mvc.ctrlname2ControllerMap = {};
_voltmx.mvc.viewId2ControllerNameMap = {};
_voltmx.mvc.formNavigateInProgress = [];
_voltmx.mvc.formNavigateCounter = 0;
_voltmx.mvc.viewName2viewId = {};
_voltmx.mvc.appLevelWidget2Controller = {};
voltmx.utils.LoadJSFile = function(fileName) {
    var retForm = null;
    controllerConfig = require(fileName); {
        retForm = controllerConfig
    }
    return retForm
};
voltmx.mvc.isControllerAvailable = function(formFriendlyName, appName) {
    var ctrlName = null,
        tmpFormName = null,
        formID = formFriendlyName,
        returnFlag = false;
    var viewName2viewIdMap = _voltmx.mvc.getViewName2viewIdMap(appName);
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    var viewId2ControllerNameMap = _voltmx.mvc.getViewId2ControllerNameMap(appName);
    tmpFormName = voltmx.mvc.registry.get(formID, appName);
    if (null != tmpFormName) formID = tmpFormName;
    if (formID in viewName2viewIdMap) {
        formID = viewName2viewIdMap[formID]
    }
    if (null != formID) {
        if (formID in viewId2ControllerNameMap) {
            ctrlName = viewId2ControllerNameMap[formID];
            if (ctrlName in ctrlName2ControllerMap) {
                returnFlag = true
            }
        }
    }
    return returnFlag
};
voltmx.application.setAppLevelWidget = function(paramsObject) {
    if (paramsObject == null || paramsObject == undefined) {
        return 8001
    }
    if (paramsObject.container == null || paramsObject.container == undefined) {
        return 8003
    }
    var appName;
    if (!paramsObject.appName) {
        appName = _voltmx.mvc.getCurrentAppName()
    } else {
        appName = paramsObject.appName
    }
    var widget = paramsObject.container;
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    if (typeof widget === "string" || widget instanceof String) {
        var tmpWidget = voltmx.mvc.registry.get(widget, appName);
        if (null != tmpWidget) {
            widget = tmpWidget
        }
        var controller = _voltmx.mvc.appLevelWidget2Controller[widget];
        var view;
        if (controller == null || controller == undefined) {
            if (!voltmx.mvc.registry.getFriendlyName(widget, appName)) {
                return 8004
            }
            view = _voltmx.mvc.initializeSubViewController(widget, appName);
            controller = ctrlName2ControllerMap[view._voltmxControllerName];
            _voltmx.mvc.appLevelWidget2Controller[widget] = controller;
            controller.executeOnCurrentForm = function(paramsObject) {
                if (paramsObject == null || paramsObject == undefined || paramsObject.eventName == null || paramsObject.eventName == undefined) {
                    return false
                }
                var currentFormControllerName = voltmx.application.getCurrentForm()._voltmxControllerName;
                var currentFormController = ctrlName2ControllerMap[currentFormControllerName];
                if (Object.prototype.hasOwnProperty.call(currentFormController, paramsObject.eventName)) return currentFormController[paramsObject.eventName].call(currentFormController, paramsObject.params);
                return false
            }
        } else {
            view = controller.view
        }
        paramsObject.container = view
    }
    return _voltmx.mvc.setAppLevelWidget(paramsObject)
};
voltmx.application.destroyForm = function(params) {
    var tmpController = null;
    var formID;
    var appName;
    if (typeof params == "object") {
        formID = params.friendlyName;
        appName = params.appName
    } else {
        formID = params;
        appName = _voltmx.mvc.getCurrentAppName()
    }
    var viewName2viewId = _voltmx.mvc.getViewName2viewIdMap(appName);
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    var viewId2ControllerNameMap = _voltmx.mvc.getViewId2ControllerNameMap(appName);
    var tmpFormName = voltmx.mvc.registry.get(formID, appName);
    if (null != tmpFormName) {
        formID = tmpFormName
    }
    var fileName = formID;
    if (formID in viewName2viewId) {
        formID = viewName2viewId[formID]
    }
    if (null != formID) {
        if (formID in viewId2ControllerNameMap) {
            var ctrlName = viewId2ControllerNameMap[formID];
            if (ctrlName in ctrlName2ControllerMap) {
                tmpController = ctrlName2ControllerMap[ctrlName];
                if (null != tmpController) tmpController.destroy();
                delete ctrlName2ControllerMap[ctrlName];
                delete viewId2ControllerNameMap[formID];
                if (fileName in viewName2viewId) {
                    delete viewName2viewId[fileName]
                }
            }
        }
    }
};
_voltmx.mvc.destroyController = function(voltmxControllerName) {
    var tmpController = null;
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap();
    if (voltmxControllerName in ctrlName2ControllerMap) {
        tmpController = ctrlName2ControllerMap[voltmxControllerName];
        if (null != tmpController) {
            tmpController.destroy()
        }
        tmpController = null;
        delete ctrlName2ControllerMap[voltmxControllerName]
    }
};
_voltmx.mvc.executeInJsContext = function(templateView, functionName, subargs) {
    var appName = templateView._appName ? templateView._appName : _voltmx.mvc.getCurrentAppName();
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    if (templateView._voltmxControllerName in ctrlName2ControllerMap) {
        var viewName = templateView._voltmxControllerName;
        var tmpController = ctrlName2ControllerMap[viewName];
        if (null != tmpController) {
            if (typeof functionName === "string" || functionName instanceof String) {
                tmpController[functionName].apply(tmpController, subargs)
            } else {
                functionName.apply(tmpController, subargs)
            }
        }
    } else {
        var eventobject = null;
        if (subargs.length > 0) {
            var tempCallerObject = subargs[0];
            if (typeof tempCallerObject === "object" && Object.prototype.hasOwnProperty.call(tempCallerObject, "id")) {
                eventobject = tempCallerObject;
                subargs.shift()
            }
        }
        if (null != eventobject) {
            functionName.apply(eventobject, subargs)
        } else {
            if (typeof templateView === "object" && Object.prototype.hasOwnProperty.call(templateView, "id")) {
                functionName.apply(templateView, subargs)
            } else {
                subargs.unshift(templateView);
                functionName.apply(null, subargs)
            }
        }
    }
};
_voltmx.mvc.assignFunctions2Controller = function(tmpController, controllers) {
    if (controllers.length > 1) {
        var allFunctions = {};
        for (var i = 0; i < controllers.length; i++) {
            var extensionLevel = "extensionLevel" + i;
            tmpController[extensionLevel] = {};
            if (i == 0) tmpController["parent"] = {};
            for (var key in controllers[i]) {
                if (i < controllers.length && _voltmx.mvc.isValidControllerKey(key)) {
                    if (typeof controllers[i][key] === "function") {
                        tmpController[extensionLevel][key] = controllers[i][key].bind(tmpController);
                        if (i == 0) tmpController["parent"][key] = controllers[i][key].bind(tmpController)
                    } else {
                        tmpController[extensionLevel][key] = controllers[i][key];
                        if (i == 0) tmpController["parent"][key] = controllers[i][key]
                    }
                }
                allFunctions[key] = controllers[i][key]
            }
        }
        for (var key in allFunctions) {
            if (_voltmx.mvc.isValidControllerKey(key)) {
                if (typeof allFunctions[key] === "function") {
                    tmpController[key] = allFunctions[key].bind(tmpController)
                } else {
                    tmpController[key] = allFunctions[key]
                }
            }
        }
    } else {
        var config2 = controllers[0];
        for (var key in config2) {
            if (_voltmx.mvc.isValidControllerKey(key) && typeof config2 === "object" && Object.prototype.hasOwnProperty.call(config2, key)) {
                if (typeof config2[key] === "function") {
                    tmpController[key] = config2[key].bind(tmpController)
                } else {
                    tmpController[key] = config2[key]
                }
            }
        }
    }
};
_voltmx.mvc.isValidControllerKey = function(key) {
    return key != "prototype" && key != "view" && key != "viewId" && key != "userWidgetName" && key != "__initializeView" && key != "name"
};
_voltmxControllerCounter = 0;
globalObj = this;
var stringToFunction = function(str) {
    var arr = str.split(".");
    var fn = globalObj || this;
    for (var i = 0, len = arr.length; i < len; i++) {
        fn = fn[arr[i]]
    }
    if (typeof fn !== "function") {
        throw new Error("function not found")
    }
    return fn
};
_voltmx.mvc.GetControllerAsync = function(formFriendlyName, context, successCallBack, errorCallback) {
    var tmpController = null,
        ctrlName = null,
        levels = null,
        i = 0,
        formID = formFriendlyName,
        requireFileList = [],
        controllerTypePath = null,
        tmpControllerName = null,
        controllerType = null,
        controllerTypeFile = null,
        extensionControllersList = null;
    var appName = context.appName;
    var tmpFormName = voltmx.mvc.registry.get(formID, appName);
    var viewName2viewIdMap = _voltmx.mvc.getViewName2viewIdMap(appName);
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    var viewId2ControllerNameMap = _voltmx.mvc.getViewId2ControllerNameMap(appName);
    if (null != tmpFormName) {
        formID = tmpFormName
    }
    var formName = formID;
    if (formID in viewName2viewIdMap) {
        formID = viewName2viewIdMap[formID]
    }
    if (null != formID) {
        if (formID in viewId2ControllerNameMap) {
            ctrlName = viewId2ControllerNameMap[formID];
            if (ctrlName in ctrlName2ControllerMap) {
                tmpController = ctrlName2ControllerMap[ctrlName]
            }
            successCallBack(tmpController)
        } else {
            requireFileList = [];
            tmpControllerName = voltmx.mvc.registry.getControllerName(formFriendlyName, appName);
            controllerType = voltmx.mvc.registry.getControllerType(formFriendlyName, appName);
            controllerTypeFile = voltmx.mvc.registry.getControllerTypeFile(formFriendlyName, appName);
            extensionControllersList = voltmx.mvc.registry.getControllerExtName(formFriendlyName, appName);
            if (null == tmpControllerName) {
                tmpControllerName = formID + "Controller"
            }
            requireFileList.push(_voltmx.mvc.getPath(tmpControllerName, appName));
            if (null != controllerType) {
                if (null == controllerTypeFile) {
                    controllerTypePath = controllerType.replace(/\./g, "/")
                } else {
                    controllerTypePath = controllerTypeFile.replace(/\./g, "/")
                }
                requireFileList.push(controllerTypePath)
            }
            if (null != extensionControllersList) {
                if (typeof extensionControllersList === "string") {
                    requireFileList.push(extensionControllersList, appName)
                } else {
                    levels = extensionControllersList.length;
                    for (i = 0; i < levels; i++) {
                        if (null != extensionControllersList[i]) {
                            requireFileList.push(_voltmx.mvc.getPath(extensionControllersList[i], appName))
                        } else {
                            break
                        }
                    }
                }
            }
            requireFileList.push(_voltmx.mvc.getPath(formID, appName));
            require(requireFileList, function(config) {
                var ctor = null;
                if (null == controllerType) {
                    tmpController = new voltmx.mvc.FormController(formName)
                } else {
                    ctor = stringToFunction(controllerType);
                    tmpController = new ctor(formName)
                }
                tmpController.appName = appName;
                tmpController.formFriendlyName = formFriendlyName;
                tmpController.Name = tmpControllerName + "_" + (++_voltmxControllerCounter).toString();
                _voltmx.mvc.loadAllExtensionControllers(tmpController, config, formFriendlyName);
                successCallBack(tmpController)
            }, function(err) {
                errorCallback(err)
            })
        }
    }
};
_voltmx.mvc.GetController = function(formFriendlyName, isForm, metaObj) {
    if (!metaObj) {
        metaObj = {
            appName: _voltmx.mvc.getCurrentAppName()
        }
    }
    var tmpController = _voltmx.mvc.GetControllerWithoutView(formFriendlyName, isForm, metaObj);
    var x = tmpController.view;
    return tmpController
};
_voltmx.mvc.GetControllerWithoutView = function(formFriendlyName, isForm, metaObj) {
    var tmpController = null;
    var formID = formFriendlyName;
    var appName = metaObj.appName;
    var viewName2viewIdMap = _voltmx.mvc.getViewName2viewIdMap(appName);
    var viewId2ControllerNameMap = _voltmx.mvc.getViewId2ControllerNameMap(appName);
    var ctrlname2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    var tmpFormName = voltmx.mvc.registry.get(formID, appName);
    if (null != tmpFormName) {
        formID = tmpFormName
    }
    var formName = formID;
    if (formID in viewName2viewIdMap) {
        formID = viewName2viewIdMap[formID]
    }
    if (null != formID) {
        if (isForm && formID in viewId2ControllerNameMap) {
            var ctrlName = viewId2ControllerNameMap[formID];
            if (ctrlName in ctrlname2ControllerMap) {
                tmpController = ctrlname2ControllerMap[ctrlName]
            }
        } else {
            var tmpControllerName = voltmx.mvc.registry.getControllerName(formFriendlyName, appName);
            if (null == tmpControllerName) {
                tmpControllerName = formID + "Controller"
            }
            var path = _voltmx.mvc.getPath(tmpControllerName, appName);
            var config = voltmx.utils.LoadJSFile(path);
            if (isForm) {
                var controllerType = voltmx.mvc.registry.getControllerType(formFriendlyName, appName);
                if (null == controllerType) {
                    tmpController = new voltmx.mvc.FormController(formName)
                } else {
                    var controllerTypeFile = voltmx.mvc.registry.getControllerTypeFile(formFriendlyName, appName);
                    var controllerTypePath = null;
                    if (null == controllerTypeFile) {
                        controllerTypePath = controllerType.replace(/\./g, "/")
                    } else {
                        controllerTypePath = controllerTypeFile.replace(/\./g, "/")
                    }
                    var path = controllerTypePath;
                    voltmx.utils.LoadJSFile(path);
                    var ctor = stringToFunction(controllerType);
                    tmpController = new ctor(formID)
                }
            } else {
                var controllerType = voltmx.mvc.registry.getControllerType(formFriendlyName, appName);
                if (null == controllerType) {
                    tmpController = new voltmx.mvc.TemplateController(formName)
                } else {
                    var controllerTypeFile = voltmx.mvc.registry.getControllerTypeFile(formFriendlyName, appName);
                    var controllerTypePath = null;
                    if (null == controllerTypeFile) {
                        controllerTypePath = controllerType.replace(/\./g, "/")
                    } else {
                        controllerTypePath = controllerTypeFile.replace(/\./g, "/")
                    }
                    voltmx.utils.LoadJSFile(controllerTypePath);
                    var ctor = stringToFunction(controllerType);
                    tmpController = new ctor(formName)
                }
            }
            tmpController.appName = appName;
            tmpController.formFriendlyName = formFriendlyName;
            tmpController.Name = tmpControllerName + "_" + (++_voltmxControllerCounter).toString();
            _voltmx.mvc.loadAllExtensionControllers(tmpController, config, formFriendlyName)
        }
    }
    return tmpController
};
_voltmx.mvc.loadAllExtensionControllers = function(tmpController, config, friendlyName) {
    var controllers = [];
    controllers.push(config);
    var config2 = {};
    var appName = tmpController.appName;
    var tmpControllerName2 = voltmx.mvc.registry.getControllerExtName(friendlyName, appName);
    if (null != tmpControllerName2) {
        if (typeof tmpControllerName2 === "string") {
            var uwPath = friendlyName.replace(/\./g, "/");
            config2 = voltmx.utils.LoadJSFile(uwPath + "/" + tmpControllerName2);
            controllers.push(config2)
        } else {
            var levels = tmpControllerName2.length;
            var path;
            for (var i = 0; i < levels; i++) {
                if (null != tmpControllerName2[i]) {
                    if (tmpController.masterType) {
                        path = tmpControllerName2[i]
                    } else {
                        path = _voltmx.mvc.getPath(tmpControllerName2[i], appName)
                    }
                    config2 = voltmx.utils.LoadJSFile(path);
                    controllers.push(config2)
                } else {
                    break
                }
            }
        }
    }
    _voltmx.mvc.assignFunctions2Controller(tmpController, controllers)
};
_voltmx.mvc.CreateMasterWidgetController = function(userWidgetName, uwInstanceName, args, hasMultipleViews) {
    var appName = _voltmx.mvc.getCurrentAppName();
    if (args[0]) {
        appName = args[0].appName || appName
    }
    var tmpController = null;
    var formID = userWidgetName;
    var tmpFormName = voltmx.mvc.registry.get(formID, appName);
    if (null != tmpFormName) {
        formID = tmpFormName
    }
    if (null != formID) {
        var tmpControllerName = voltmx.mvc.registry.getControllerName(userWidgetName, appName);
        if (null == tmpControllerName) {
            tmpControllerName = formID + "Controller"
        }
        var uwPath = userWidgetName.replace(/\./g, "/");
        if (hasMultipleViews) uwPath = uwPath.substring(0, uwPath.lastIndexOf("/"));
        var config = voltmx.utils.LoadJSFile(uwPath + "/" + tmpControllerName);
        var controllerType = voltmx.mvc.registry.getControllerType(userWidgetName, appName);
        if (null == controllerType) {
            tmpController = new voltmx.mvc.MasterController(userWidgetName, formID, uwInstanceName)
        } else {
            var path = getControllerTypeFile(userWidgetName, appName);
            var controllerTypeFile = path;
            var controllerTypePath = null;
            if (null == controllerTypeFile) {
                controllerTypePath = controllerType.replace(/\./g, "/")
            } else {
                controllerTypePath = controllerTypeFile.replace(/\./g, "/")
            }
            voltmx.utils.LoadJSFile(controllerTypePath);
            var ctor = stringToFunction(controllerType);
            tmpController = new ctor(userWidgetName, formID, uwInstanceName)
        }
        tmpController.args = args;
        tmpController.Name = tmpControllerName + "_" + (++_voltmxControllerCounter).toString();
        var masterType = constants.MASTER_TYPE_USERWIDGET;
        if (Object.prototype.toString.call(args) === "[object Array]") {
            if (null != args[0]["masterType"]) {
                masterType = args[0]["masterType"]
            }
        } else {
            masterType = args["masterType"]
        }
        tmpController.masterType = masterType;
        tmpController.appName = appName;
        if (masterType == constants.MASTER_TYPE_USERWIDGET) {
            _voltmx.mvc.loadAllExtensionControllers(tmpController, config, userWidgetName)
        } else {
            var controllers = [];
            controllers.push(config);
            _voltmx.mvc.assignFunctions2Controller(tmpController, controllers)
        }
        if (tmpController.initializeProperties) {
            tmpController.initializeProperties()
        }
        if (Object.prototype.hasOwnProperty.call(tmpController, "constructor")) {
            tmpController["constructor"].apply(tmpController, args)
        }
    }
    return tmpController
};
_voltmx.mvc.initializeViewController = function(viewController, modelController) {
    if (modelController) {
        viewController._baseUserWidgetName = modelController._baseUserWidgetName;
        viewController.controller = modelController;
        viewController.controller.onPropertyChanged = function(propName, val) {
            var propChangedCallbackName = "on_" + propName + "_Changed";
            if (this[propChangedCallbackName] !== undefined) {
                this[propChangedCallbackName].call(this, val)
            }
        }.bind(viewController);
        viewController.createVNProperty = function(Prop1) {
            var num1 = this.controller[Prop1];
            defineSetter(this.controller, Prop1, function(val) {
                num1 = val;
                if (this.controller.onPropertyChanged !== undefined) {
                    this.controller.onPropertyChanged(Prop1, val)
                }
            }.bind(viewController));
            defineGetter(this.controller, Prop1, function() {
                return num1
            })
        }
    }
};
_voltmx.mvc.initializeModelController = function(modelController) {
    if (modelController && Object.prototype.hasOwnProperty.call(modelController, "constructor")) {
        modelController["constructor"].apply(modelController)
    }
};
_voltmx.mvc.initializeMasterController = function(userWidgetName, uwInstanceName, args) {
    var appName = _voltmx.mvc.getCurrentAppName();
    if (args[0]) {
        appName = args[0].appName || appName
    }
    if (typeof voltmx.mvc.registry.get(userWidgetName, appName) == "object") {
        var modelController = _voltmx.mvc.createModelController(userWidgetName, appName);
        var viewName;
        if (modelController && modelController.hasOwnProperty("onCreateView")) {
            viewName = modelController.onCreateView(args)
        } else if (args != null && args != undefined && args[0] != null && args[0] != undefined && args[0].viewType != null && args[0].viewType != undefined) {
            viewName = args[0].viewType
        }
        if (viewName == null || viewName == undefined) {
            voltmx.print("Undefined/Null viewName");
            return
        }
        var viewController = _voltmx.mvc.CreateMasterWidgetController(userWidgetName + "." + viewName, uwInstanceName, args, true);
        if (!viewController) {
            voltmx.print("Undefined/Null _voltmx.mvc.CreateMasterWidgetController() value");
            return
        }
        _voltmx.mvc.initializeViewController(viewController, modelController);
        _voltmx.mvc.initializeModelController(modelController);
        return viewController.view
    } else {
        var tmpController = _voltmx.mvc.CreateMasterWidgetController(userWidgetName, uwInstanceName, args, false);
        return tmpController.view
    }
};
_voltmx = _voltmx || {};
_voltmx.mvc = _voltmx.mvc || {};
_voltmx.mvc.setData2UserWidget = function(userWidgetInstance, newClonedRowView, data, isSetViewProps) {
    var controllerName = userWidgetInstance._voltmxControllerName;
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap();
    if (controllerName in ctrlName2ControllerMap) {
        var tmpController = ctrlName2ControllerMap[controllerName];
        if (null == tmpController) return;
        var tempView = tmpController.view;
        tmpController.view = newClonedRowView;
        var xx = tmpController.view.bottom;
        if (typeof data === "object") {
            for (var m in data) {
                if (Object.prototype.hasOwnProperty.call(tmpController, m)) {
                    tmpController[m] = data[m]
                } else if (isSetViewProps) {
                    tempView[m] = data[m]
                }
            }
        }
        tmpController.view = tempView
    }
};
_voltmx.mvc.setMasterWidgetContract = function(userWidgetInstance, tmpController) {
    var lstFunctions = Object.getOwnPropertyNames(tmpController).filter(function(p) {
        return typeof tmpController[p] === "function" && p != "__initializeView"
    });
    _voltmx.mvc.setFunctions(userWidgetInstance, lstFunctions, tmpController);
    var lstProperties = Object.getOwnPropertyNames(tmpController).filter(function(p) {
        return typeof tmpController[p] != "function" && p != "masterType" && p != "viewId" && p != "view" && p != "userWidgetName" && p != "appName"
    });
    _voltmx.mvc.setProperties(userWidgetInstance, lstProperties, tmpController);
    var view111 = tmpController.view;
    var lstFunctionsOnMaster = _voltmx.mvc.getMethods(userWidgetInstance);
    var lstFunctions = _voltmx.mvc.getMethods(view111).filter(function(p) {
        return lstFunctionsOnMaster.indexOf(p) <= -1
    });
    _voltmx.mvc.setFunctions(userWidgetInstance, lstFunctions, view111, true);
    var lstPropertiesOnMaster = _voltmx.mvc.getProperties(userWidgetInstance);
    var lstProperties = _voltmx.mvc.getProperties(view111).filter(function(p) {
        return lstPropertiesOnMaster.indexOf(p) <= -1
    });
    _voltmx.mvc.setProperties(userWidgetInstance, lstProperties, view111);
    var children = _voltmx.mvc.getAllChildren(view111);
    _voltmx.mvc.setProperties(userWidgetInstance, children, view111)
};
_voltmx.mvc.getAllChildren = function(viewInstance) {
    var childIds = [];
    if (viewInstance.widgets) {
        var children = viewInstance.widgets();
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            childIds.push(child.id);
            if (child._voltmxControllerName == null) {
                var grandChildren = _voltmx.mvc.getAllChildren(child);
                for (var j = 0; j < grandChildren.length; j++) {
                    childIds.push(grandChildren[j])
                }
            }
        }
    }
    return childIds
};
_voltmx.mvc.getMethods = function(obj) {
    var res = Object.getOwnPropertyNames(obj).filter(function(p) {
        return typeof obj[p] === "function"
    });
    for (var m in obj) {
        if (typeof obj[m] == "function") {
            res.push(m)
        }
    }
    return res
};
_voltmx.mvc.getProperties = function(obj) {
    var res = Object.getOwnPropertyNames(obj).filter(function(p) {
        return typeof obj[p] != "function"
    });
    for (var m in obj) {
        if (typeof obj[m] != "function") {
            res.push(m)
        }
    }
    return res
};
_voltmx.mvc.getClonedController = function(templateView) {
    var appName = templateView.appName || _voltmx.mvc.getCurrentAppName();
    var tmpController = _voltmx.mvc.GetControllerWithoutView(templateView.id, false, {
        appName: appName
    });
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    tmpController.view = templateView;
    ctrlName2ControllerMap[tmpController.Name] = tmpController;
    return tmpController
};
_voltmx.mvc.getClonedMasterController = function(masterView) {
    var appName = masterView.appName || _voltmx.mvc.getCurrentAppName();
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    var tmpController = ctrlName2ControllerMap[masterView._voltmxControllerName];
    var tmpController = _voltmx.mvc.CreateMasterWidgetController(tmpController.userWidgetName, tmpController.viewId, [{
        masterType: tmpController.masterType,
        appName: appName
    }]);
    tmpController.view = masterView;
    ctrlName2ControllerMap[tmpController.Name] = tmpController;
    return tmpController
};
_voltmx.mvc.createModelController = function(baseUserWidgetName, appName) {
    var modelControllerName = voltmx.mvc.registry.getControllerName(baseUserWidgetName, appName);
    if (!modelControllerName) {
        voltmx.print("Undefined/Null Controller Name in registry");
        return
    }
    var uwPath = baseUserWidgetName.replace(/\./g, "/");
    var config = voltmx.utils.LoadJSFile(uwPath + "/" + modelControllerName);
    if (!config) {
        voltmx.print("Requiring Model controller failed.");
        return
    }
    var modelController = new _voltmx.mvc.ModelController(baseUserWidgetName);
    modelController._baseUserWidgetName = baseUserWidgetName;
    modelController.Name = modelControllerName + "_" + (++_voltmxControllerCounter).toString();
    modelController.appName = appName;
    _voltmx.mvc.ctrlname2ControllerMap[modelController.Name] = modelController;
    _voltmx.mvc.loadAllExtensionControllers(modelController, config, baseUserWidgetName);
    return modelController
};
_voltmx.mvc.bindController = function(masterView) {
    var appName = masterView.appName || _voltmx.mvc.getCurrentAppName();
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    var tmpController = ctrlName2ControllerMap[masterView.controller.Name];
    tmpController.view = masterView;
    masterView._voltmxControllerName = tmpController.Name;
    tmpController.onDestroy = null
};
_voltmx.mvc.bindMasterController = function(userwidget, masterView, controllerName) {
    var appName = userwidget.appName || _voltmx.mvc.getCurrentAppName();
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    var tmpController = ctrlName2ControllerMap[controllerName];
    masterView._voltmxControllerName = tmpController.Name;
    userwidget._voltmxControllerName = tmpController.Name;
    tmpController.view = masterView;
    userwidget._voltmxInitialized = false;
    if (tmpController.initializeProperties) {
        tmpController.initializeProperties()
    }
    _voltmx.mvc.setMasterContract(userwidget);
    tmpController.onDestroy = null
};
_voltmx.mvc.setMasterContract = function(userWidgetInstance) {
    var config = {};
    if (null == userWidgetInstance || userWidgetInstance._voltmxInitialized) return;
    var usInstanceName = userWidgetInstance._voltmxControllerName;
    var appName = userWidgetInstance.appName || _voltmx.mvc.getCurrentAppName();
    var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
    if (usInstanceName in ctrlName2ControllerMap) {
        var tmpController = ctrlName2ControllerMap[usInstanceName];
        if (null == tmpController) return;
        var xx = tmpController.view.bottom;
        if (tmpController.masterType == constants.MASTER_TYPE_USERWIDGET) {
            if (appConfig && appConfig.testAutomation && appConfig.testAutomation.scriptsURL) {
                _voltmx.mvc.setMasterWidgetContract(userWidgetInstance, tmpController)
            }
            _voltmx.mvc.setUserWidgetContract(userWidgetInstance, tmpController)
        } else {
            _voltmx.mvc.setMasterWidgetContract(userWidgetInstance, tmpController)
        }
        userWidgetInstance._voltmxInitialized = true
    }
};
_voltmx.mvc.setUserWidgetContract = function(userWidgetInstance, tmpController) {
    var userWidgetName = tmpController.userWidgetName;
    var uwPath = userWidgetName;
    var n = userWidgetName.lastIndexOf(".");
    var configFileName = userWidgetName + "Config";
    if (n >= 0) {
        configFileName = configFileName.substring(n + 1);
        uwPath = userWidgetName.replace(/\./g, "/")
    }
    var configFileName = uwPath + "/" + configFileName;
    var master = require(configFileName);
    if (null == master) return;
    if (null != master["properties"]) {
        var propertiesOnMaster = master["properties"];
        _voltmx.mvc.setProperties(userWidgetInstance, propertiesOnMaster, tmpController)
    }
    if (null != master["apis"]) {
        var apisOnMaster = master["apis"];
        _voltmx.mvc.setFunctions(userWidgetInstance, apisOnMaster, tmpController)
    }
    if (null != master["events"]) {
        var eventsOnMaster = master["events"];
        _voltmx.mvc.setEvents(userWidgetInstance, eventsOnMaster, tmpController)
    }
    return
};
_voltmx.mvc.setProperties = function(userWidgetInstance, properties, tmpController) {
    if (null == properties || null == userWidgetInstance || null == tmpController) return;
    if (userWidgetInstance === tmpController) return;
    for (i = 0; i < properties.length; i++) {
        var oneProperty = properties[i];
        if (typeof oneProperty === "string") {
            oneProperty = {
                name: oneProperty,
                writable: true,
                enumerable: true,
                configurable: true
            }
        }
        var propName = oneProperty["name"];
        defineGetter(userWidgetInstance, propName, function(propertyName) {
            return function() {
                return tmpController[propertyName]
            }
        }(propName));
        if (null != oneProperty["writable"] && oneProperty["writable"]) {
            defineSetter(userWidgetInstance, propName, function(propertyName) {
                return function(val) {
                    tmpController[propertyName] = val
                }
            }(propName))
        }
    }
};
_voltmx.mvc.setFunctions = function(userWidgetInstance, lstAPIs, tmpController, isView) {
    if (null == lstAPIs || null == userWidgetInstance || null == tmpController) return;
    for (i = 0; i < lstAPIs.length; i++) {
        var propName = lstAPIs[i];
        if (isView) {
            userWidgetInstance[propName] = function(propertyName) {
                return function() {
                    tmpController[propertyName].apply(tmpController, arguments)
                }
            }(propName)
        } else {
            userWidgetInstance[propName] = tmpController[propName].bind(tmpController)
        }
    }
};
_voltmx.mvc.setEvents = function(userWidgetInstance, lstEvents, tmpController) {
    if (null == lstEvents || null == userWidgetInstance || null == tmpController) return;
    if (userWidgetInstance === tmpController) return;
    for (i = 0; i < lstEvents.length; i++) {
        var propName = lstEvents[i];
        defineGetter(userWidgetInstance, propName, function(propertyName) {
            return function() {
                return tmpController[propertyName]
            }
        }(propName));
        defineSetter(userWidgetInstance, propName, function(propertyName) {
            return function(val) {
                tmpController[propertyName] = val
            }
        }(propName))
    }
};
voltmx.mvc = voltmx.mvc || {};
voltmx.utils = voltmx.utils || {};
voltmx.mvc.Navigation = function() {
    var isPathResolved = false;
    var appName;

    function Navigation(formname, objModel) {
        var model = objModel;
        this.getModel = function() {
            if (null == model) {
                var controller = _voltmx.mvc.GetController(formFriendlyName, true);
                if (!controller) {
                    voltmx.print("########## No controller is found to navigate #####");
                    throw "Controller Not Found"
                }
                if (controller.getModel) model = controller.getModel()
            }
            return model
        };
        this.setModel = function(objModel) {
            model = objModel
        };
        var formFriendlyName = formname;
        appName = _voltmx.mvc.getCurrentAppName();
        if (typeof formname == "object") {
            formFriendlyName = formname.friendlyName;
            if (formname.appName != appName) {
                appName = formname.appName;
                _voltmx.mvc.setCurrentAppName(appName)
            }
        } else {
            formFriendlyName = formname
        }
        this.navigate = function(param) {
            var context = {
                appName: appName
            };
            if (_voltmx.mvc.isSyncLoad()) {
                var controller = _voltmx.mvc.GetController(formFriendlyName, true, context);
                if (!controller) {
                    voltmx.print("########## No controller is found to navigate for form " + formFriendlyNamePath);
                    throw "Controller Not Found"
                }
                if (null == model) {
                    if (controller.getModel) model = controller.getModel.call(controller)
                }
                if (controller.setModel) controller.setModel.call(controller, model);
                controller.show.call(controller, param, false)
            } else {
                var len = _voltmx.mvc.formNavigateInProgress.length;
                if (len == 0) {
                    _voltmx.mvc.formNavigateCounter = 0
                } else {
                    _voltmx.mvc.formNavigateCounter++
                }
                _voltmx.mvc.formNavigateInProgress.push("Form" + _voltmx.mvc.formNavigateCounter);
                if (_voltmx.mvc.formNavigateCounter == 0) {
                    navigateCallback(formFriendlyName, param, _voltmx.mvc.formNavigateCounter, context)
                } else {
                    scheduleNavigateTimer(formFriendlyName, param, _voltmx.mvc.formNavigateCounter, context)
                }
            }
        };
        var scheduleNavigateTimer = function(formFriendlyName, param, navigateCounter, context) {
            voltmx.timer.schedule("Form" + navigateCounter, function() {
                if (_voltmx.mvc.formNavigateInProgress.indexOf("Form" + (navigateCounter - 1)) < 0) {
                    voltmx.timer.cancel("Form" + navigateCounter);
                    navigateCallback(formFriendlyName, param, navigateCounter, context)
                }
            }, .01, true)
        };
        var navigateCallback = function(formFriendlyName, param, navigateCounter, context) {
            _voltmx.mvc.GetControllerAsync(formFriendlyName, context, function(controller) {
                var index;
                if (!controller) {
                    voltmx.print("########## No controller is found to navigate for form " + formFriendlyName);
                    throw "Controller Not Found"
                }
                if (null == model) {
                    if (controller.getModel) model = controller.getModel.call(controller)
                }
                if (controller.setModel) controller.setModel.call(controller, model);
                controller.show.call(controller, param, false);
                index = _voltmx.mvc.formNavigateInProgress.indexOf("Form" + navigateCounter);
                _voltmx.mvc.formNavigateInProgress.splice(index, 1)
            }, function(err) {
                voltmx.print("Error: Unable to load Form Controller -" + err);
                throw "Controller or Form Not Found"
            })
        }
    }
    return Navigation
}();
(function() {
    var _navigationManagerMap = {},
        _isSyncFlow = null;
    var _loader = {
        appNavigationManager: function(config) {
            var controllerFile = _loader.navManagerFilePath.call(this, "NavigationController"),
                modelFile = _loader.navManagerFilePath.call(this, "NavigationModel");
            config = config || {};
            if (_isSyncLoad()) {
                _loader.syncLoad.call(this, controllerFile, modelFile, config)
            } else {
                _loader.asyncLoad.call(this, controllerFile, modelFile, config)
            }
        },
        syncLoad: function(controllerFile, modelFile, config) {
            var controller = null,
                model = null;
            controller = require(controllerFile);
            model = require(modelFile);
            _loader.callback.call(this, controller, model, config)
        },
        asyncLoad: function(controllerFile, modelFile, config) {
            var self = this;
            require([controllerFile, modelFile], function(controller, model) {
                _loader.callback.call(self, controller, model, config)
            }, function(err) {
                voltmx.print("Fail to load navigation manager for " + self.appName)
            })
        },
        callback: function(controller, model, config) {
            this._.controller = controller;
            this._.model = model;
            _navigationManagerMap[this.appName] = this;
            if (config.userNavigate) {
                _navManager.userNavigate.call(this, config.navConfig)
            } else if (config.resumeNavigate) {
                _navManager.resumeNavigate.call(config.currentContext, config.targetFormInfo)
            }
        },
        navManagerFilePath: function(fileName) {
            var path = "";
            if (_voltmx.mvc.isCompositeApp()) path = this.appName + "/";
            return path + "navigation/" + fileName
        }
    };
    var _conditions = {
        applicationPreconditionsValidator: function(targetFormInfo) {
            var preConditions = _navManager.getApplicationPrecondtions(targetFormInfo),
                targetAppData, flag = true;
            if (Array.isArray(preConditions) && preConditions.length > 0) {
                targetAppData = _voltmx.mvc.getAppData(targetFormInfo.appName);
                flag = _conditions.checkSrcOnTarget(preConditions, targetAppData)
            }
            return flag
        },
        checkSrcOnTarget: function(sourceArr, targetObj) {
            var i, flag = true,
                len = sourceArr.length;
            if (!targetObj) flag = false;
            for (i = 0; flag && i < len; i++) {
                if (!targetObj.hasOwnProperty(sourceArr[i])) {
                    flag = false
                }
            }
            return flag
        },
        formPreconditionsValidator: function(targetFormInfo) {
            var flag = true,
                preConditions = _navManager.getFormPrecondtions(targetFormInfo);
            if (Array.isArray(preConditions) && preConditions.length > 0) {
                flag = _conditions.checkSrcOnTarget(preConditions, targetFormInfo.params)
            }
            return flag
        },
        isValidCBFormOnTargetFormsConfig: function(targetFormInfo, targetFormsList) {
            var i, flag = false,
                len = 0;
            if (Array.isArray(targetFormsList)) len = targetFormsList.length;
            for (i = 0; !flag && i < len; i++) {
                if (targetFormsList[i].friendlyName === targetFormInfo.friendlyName) {
                    flag = true
                }
            }
            return flag
        }
    };
    var _navManager = {
        userNavigate: function(config) {
            var destinationConfig = _sourceConfig.getUserDestinationConfig.call(this, config.context),
                targetFormInfo = null;
            if (!destinationConfig) {
                throw new Error("Current Form destinationConfig not available.")
            }
            targetFormInfo = _sourceConfig.getTargetFormInfo.call(this, destinationConfig, config);
            targetFormInfo.params = config.params;
            if (targetFormInfo.appName === _voltmx.mvc.getCurrentAppName()) {
                _navManager.targetFormNavigate.call(this, targetFormInfo)
            } else {
                var appsList = _voltmx.mvc.getAppsList();
                if (appsList.indexOf(targetFormInfo.appName) === -1) {
                    throw new Error("Invalid App Name in Navigation Manager : " + targetFormInfo.appName)
                }
                if (_navigationManagerMap[targetFormInfo.appName]) {
                    _navManager.appPreConditions.call(this, targetFormInfo)
                } else {
                    _navManager.pauseNavigate.call(this, targetFormInfo)
                }
            }
        },
        appPreConditions: function(targetFormInfo) {
            var isPassed = _conditions.applicationPreconditionsValidator(targetFormInfo);
            if (!isPassed) throw new Error("Application preConditions not met.");
            _navManager.targetFormNavigate.call(this, targetFormInfo)
        },
        resumeNavigate: function(targetFormInfo) {
            _navManager.appPreConditions.call(this, targetFormInfo)
        },
        pauseNavigate: function(targetFormInfo) {
            return new NavigationManager(targetFormInfo.appName, {
                targetFormInfo: targetFormInfo,
                currentContext: this,
                resumeNavigate: true
            })
        },
        getApplicationPrecondtions: function(targetFormInfo) {
            var navManager = _navigationManagerMap[targetFormInfo.appName],
                application = navManager._.model.Application,
                ret = null;
            if (application) ret = application.preConditionConfig;
            return ret
        },
        getFormPrecondtions: function(targetFormInfo) {
            var navManager = _navigationManagerMap[targetFormInfo.appName],
                forms = navManager._.model.Forms,
                formConfig = null,
                ret = null;
            if (forms) formConfig = forms[targetFormInfo.friendlyName];
            if (formConfig) ret = formConfig.preConditionConfig;
            return ret
        },
        targetFormNavigate: function(targetFormInfo) {
            var isPassed = false,
                manager = null,
                params = targetFormInfo.params;
            isPassed = _conditions.formPreconditionsValidator(targetFormInfo);
            if (!isPassed) throw new Error("Mandatory params not passed to Target Form.");
            targetFormInfo.params = null;
            manager = new voltmx.mvc.Navigation(targetFormInfo);
            manager.navigate(params)
        }
    };
    var _sourceConfig = {
        getUserDestinationConfig: function(context) {
            var destinations = null,
                tempObj = null,
                destinationConfig = null;
            if (context instanceof voltmx.mvc.FormController) {
                tempObj = this._.model.Forms
            } else {
                tempObj = this._.model.UIModules
            }
            if (tempObj) destinations = tempObj[context.formFriendlyName];
            if (destinations) destinationConfig = destinations.destinationConfig;
            return destinationConfig
        },
        isValidateUserContext: function(context) {
            var flag = false;
            if (context instanceof voltmx.mvc.FormController || context instanceof voltmx.mvc.Presentation.BasePresenter) {
                flag = true
            }
            return flag
        },
        getTargetFormInfo: function(destinationConfig, navConfig) {
            var targetFormInfo = null;
            if (destinationConfig.friendlyName) {
                targetFormInfo = destinationConfig
            } else if (destinationConfig.callback) {
                targetFormInfo = _sourceConfig.getFormFromUserCallback.call(this, destinationConfig, navConfig)
            } else {
                throw new Error("Current Form destinationConfig value is not proper.")
            }
            targetFormInfo.appName = targetFormInfo.appName || _voltmx.mvc.getCurrentAppName();
            return targetFormInfo
        },
        getFormFromUserCallback: function(destinationConfig, navConfig) {
            var controller = this._.controller,
                flag = false,
                destinationCallback = controller[destinationConfig.callback],
                targetNavFormInfo = null;
            if (typeof destinationCallback !== "function") {
                throw new Error("Current Form destination callback is not a function")
            }
            targetNavFormInfo = destinationCallback.call(this, navConfig.callbackModelConfig);
            if (targetNavFormInfo && targetNavFormInfo.friendlyName) {
                flag = _conditions.isValidCBFormOnTargetFormsConfig.call(this, targetNavFormInfo, destinationConfig.targetForms)
            }
            if (!flag) {
                throw new Error("Not a valid target friendlyName or targetForms not available for callback.")
            }
            return targetNavFormInfo
        }
    };
    var NavigationManager = function(appName, config) {
        this.appName = appName;
        this._ = {};
        if (!_navigationManagerMap[this.appName]) {
            _loader.appNavigationManager.call(this, config)
        }
    };
    var _navigate = function(config) {
        var navConfig = null,
            flag = _sourceConfig.isValidateUserContext(config.context);
        if (!flag) throw new Error("Invalid Context Param passed to navigate.");
        if (_navigationManagerMap[this.appName]) {
            _navManager.userNavigate.call(this, config)
        } else {
            navConfig = {
                navConfig: config,
                userNavigate: true
            };
            _loader.appNavigationManager.call(this, navConfig)
        }
    };
    _voltmx.def(NavigationManager.prototype, "navigate", _navigate);
    Object.defineProperty(voltmx.mvc, "getNavigationManager", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: function() {
            return function() {
                var appName = _voltmx.mvc.getCurrentAppName(),
                    navManager = _navigationManagerMap[appName];
                if (!navManager) {
                    navManager = new NavigationManager(appName)
                }
                return navManager
            }
        }()
    });
    var _isSyncLoad = function() {
        var sync;
        if (_isSyncFlow === null) {
            sync = voltmx.application.getApplicationBehavior("FormControllerSyncLoad");
            if (undefined === sync || null === sync || sync) _isSyncFlow = true;
            else _isSyncFlow = false
        }
        return _isSyncFlow
    };
    Object.defineProperty(_voltmx.mvc, "isSyncLoad", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: function() {
            return _isSyncLoad
        }()
    })
})();
voltmx.mvc = voltmx.mvc || {};
inheritsFrom = function(child, parent) {
    child.prototype = Object.create(parent.prototype)
};
voltmx.mvc.TemplateController = function(viewId1) {
    this.__initializeView = function(objController) {
        var retForm = null;
        var viewFileName = objController.viewId;
        if (Object.prototype.hasOwnProperty.call(this, "onCreateView")) {
            viewFileName = this["onCreateView"].apply(this, null);
            if (typeof viewFileName === "object" && Object.prototype.hasOwnProperty.call(viewFileName, "id")) {
                retForm = viewFileName
            } else {
                var path = _voltmx.mvc.getPath(viewFileName, objController.appName);
                formCreateFunc = require(path);
                retForm = formCreateFunc(objController)
            }
        } else {
            var path = _voltmx.mvc.getPath(viewFileName, objController.appName);
            formCreateFunc = voltmx.utils.LoadJSFile(path);
            retForm = formCreateFunc(objController)
        }
        retForm._voltmxControllerName = objController.Name;
        var appName = objController.appName;
        var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
        ctrlName2ControllerMap[retForm._voltmxControllerName] = objController;
        var viewName2viewId = _voltmx.mvc.getViewName2viewIdMap(appName);
        var viewId2ControllerNameMap = _voltmx.mvc.getViewId2ControllerNameMap(appName);
        viewId2ControllerNameMap[retForm.id] = objController.Name;
        viewName2viewId[objController.viewId] = retForm.id;
        retForm._appName = appName;
        return retForm
    };
    voltmx.mvc.BaseController.call(this, viewId1);
    this.executeOnParent = function(callback, args) {
        this.view.executeOnParent(callback, args)
    };
    this.getCurrentView = function(childWidget) {
        while (childWidget.parent != null) {
            if (childWidget.id == this.view.id) break;
            childWidget = childWidget.parent
        }
        return childWidget
    }
};
inheritsFrom(voltmx.mvc.TemplateController, voltmx.mvc.BaseController);
voltmx.mvc.MasterController = function(uwName, viewId1, newID) {
    this.__initializeView = function(objController) {
        var retForm = null;
        var uwPath = this.userWidgetName.replace(/\./g, "/");
        var viewFileName = objController.viewId;
        var appName = objController.appName;
        var viewName2viewIdMap = _voltmx.mvc.getViewName2viewIdMap(appName);
        var viewId2ControllerNameMap = _voltmx.mvc.getViewId2ControllerNameMap(appName);
        var ctrlName2ControllerMap = _voltmx.mvc.getControllerName2ControllerMap(appName);
        if (Object.prototype.hasOwnProperty.call(this, "onCreateView")) {
            viewFileName = this["onCreateView"].apply(this, null);
            if (typeof viewFileName === "object" && Object.prototype.hasOwnProperty.call(viewFileName, "id")) {
                retForm = viewFileName
            } else if (typeof viewFileName === "string" && viewFileName.length > 0) {
                viewFileName = viewFileName.replace(/\./g, "/");
                var formCreateFunc = voltmx.utils.LoadJSFile(viewFileName);
                retForm = formCreateFunc(objController)
            } else {
                var formCreateFunc = voltmx.utils.LoadJSFile(uwPath + "/" + viewFileName);
                retForm = formCreateFunc(objController)
            }
        } else {
            var formCreateFunc = voltmx.utils.LoadJSFile(uwPath + "/" + viewFileName);
            retForm = formCreateFunc(objController)
        }
        retForm._voltmxControllerName = objController.Name;
        retForm._appName = appName;
        ctrlName2ControllerMap[retForm._voltmxControllerName] = objController;
        if (newID != null) {
            viewId2ControllerNameMap[newID] = objController.Name;
            viewName2viewIdMap[objController.viewId] = newID
        } else {
            viewId2ControllerNameMap[retForm.id] = objController.Name;
            viewName2viewIdMap[objController.viewId] = retForm.id
        }
        return retForm
    };
    this.userWidgetName = uwName;
    this.getCurrentView = function(childWidget) {
        while (childWidget.parent != null) {
            if (childWidget.id == this.view.id) break;
            childWidget = childWidget.parent
        }
        return childWidget
    };
    voltmx.mvc.BaseController.call(this, viewId1)
};
inheritsFrom(voltmx.mvc.MasterController, voltmx.mvc.BaseController);
_voltmx = _voltmx || {};
_voltmx.mvc = _voltmx.mvc || {};
if (voltmx.mvc == undefined) voltmx.mvc = {};
if (voltmx.mvc.registry == undefined) voltmx.mvc.registry = {};
(function() {
    var _registryMap = {},
        _isCompositeApp = false,
        _isInitializeRegistriesDone = false;
    var _initializeRegistries = function(microAppsList, isCompositeFlag) {
        if (!_isInitializeRegistriesDone) {
            _isInitializeRegistriesDone = true
        } else {
            throw new Error("Registries initialized already !!!")
        }
        _isCompositeApp = isCompositeFlag;
        if (microAppsList && _isCompositeApp) {
            for (var i = 0; i < microAppsList.length; i++) {
                _registryMap[microAppsList[i]] = {}
            }
        }
    };
    _voltmx.def(_voltmx.mvc, "initializeRegistries", _initializeRegistries);
    var _getRegistryFromObject = function(context) {
        var _ret;
        if (_isCompositeApp) {
            var appName = _voltmx.mvc.getCurrentAppName();
            if (typeof context === "object") {
                appName = context.appName
            }
            _ret = _registryMap[appName];
            if (!_ret) throw new Error("Invalid entry in registry add API.")
        }
        return _ret || _registryMap
    };
    var _getRegistry = function(appName) {
        var _ret;
        if (_isCompositeApp) {
            appName = appName || _voltmx.mvc.getCurrentAppName();
            _ret = _registryMap[appName]
        }
        return _ret || _registryMap
    };
    var _isOldNotation4RegistryAdd = function(context) {
        if (typeof context === "string" || Array.isArray(context)) return true;
        else return false
    };
    var _getFormRegistryInfo = function(friendlyName, appName) {
        var _ret, registryMap = _getRegistry(appName),
            formProps = registryMap[friendlyName];
        if (formProps) _ret = formProps;
        return _ret
    };
    _voltmx.def(_voltmx.mvc, "getFormRegistryInfo", _getFormRegistryInfo);
    voltmx.mvc.registry.add = function(friendlyName, formid, formCtrllrName, contextORcontrollerExtName) {
        if (_isOldNotation4RegistryAdd(formid)) {
            var registryMap = _getRegistryFromObject(contextORcontrollerExtName);
            var formCtrllrExtName;
            if (friendlyName in registryMap) {
                voltmx.print("########## A form with friendly name " + friendlyName + " is already exists in registry.")
            } else {
                var formProps = {};
                formProps["name"] = formid;
                if (typeof formCtrllrName === "string") {
                    formProps["controllerName"] = formCtrllrName;
                    if (typeof contextORcontrollerExtName === "string") formProps["controllerExtName"] = contextORcontrollerExtName
                } else {
                    for (var propName in formCtrllrName) {
                        if (propName != "name") {
                            formProps[propName] = formCtrllrName[propName]
                        }
                    }
                }
                registryMap[friendlyName] = formProps
            }
        } else {
            var registryMap = _getRegistryFromObject(formid);
            var formProps = {};
            for (var propName in formid) {
                if (propName != "viewName") {
                    formProps[propName] = formid[propName]
                } else {
                    formProps["name"] = formid["viewName"]
                }
            }
            registryMap[friendlyName] = formProps
        }
    };
    voltmx.mvc.registry.remove = function(friendlyName, context) {
        var registryMap = _getRegistryFromObject(context);
        if (friendlyName in registryMap) {
            delete registryMap[friendlyName]
        } else {
            voltmx.print("########## No form with friendly name " + friendlyName + " is found in registry")
        }
    };
    voltmx.mvc.registry.get = function(friendlyName, appName) {
        var registryMap = _getRegistry(appName);
        if (friendlyName in registryMap) {
            var formProps = registryMap[friendlyName];
            if (null != formProps) {
                return formProps["name"]
            }
        } else {
            voltmx.print("########## No form with friendly name " + friendlyName + " is found in registry");
            return null
        }
    };
    voltmx.mvc.registry.getFriendlyName = function(formID, appName) {
        var registryMap = _getRegistry(appName);
        for (var friendlyName in registryMap) {
            if (registryMap.hasOwnProperty(friendlyName)) {
                var formProps = registryMap[friendlyName];
                if (null != formProps) {
                    if (formID == formProps["name"]) return friendlyName
                }
            }
        }
        return null
    };
    voltmx.mvc.registry.getControllerName = function(friendlyName, appName) {
        var registryMap = _getRegistry(appName);
        if (friendlyName in registryMap) {
            var formProps = registryMap[friendlyName];
            if (null != formProps) {
                return formProps["controllerName"]
            }
        } else {
            voltmx.print("########## No form with friendly name " + friendlyName + " is found in registry");
            return null
        }
    };
    voltmx.mvc.registry.getControllerType = function(friendlyName, appName) {
        var registryMap = _getRegistry(appName);
        if (friendlyName in registryMap) {
            var formProps = registryMap[friendlyName];
            if (null != formProps) {
                return formProps["controllerType"]
            }
        } else {
            voltmx.print("########## No form with friendly name " + friendlyName + " is found in registry");
            return null
        }
    };
    voltmx.mvc.registry.getControllerTypeFile = function(friendlyName, appName) {
        var registryMap = _getRegistry(appName);
        if (friendlyName in registryMap) {
            var formProps = registryMap[friendlyName];
            if (null != formProps) {
                return formProps["controllerTypeFileName"]
            }
        } else {
            voltmx.print("########## No form with friendly name " + friendlyName + " is found in registry");
            return null
        }
    };
    voltmx.mvc.registry.getControllerExtName = function(friendlyName, appName) {
        var registryMap = _getRegistry(appName);
        if (friendlyName in registryMap) {
            var formProps = registryMap[friendlyName];
            if (null != formProps) {
                return formProps["controllerExtName"]
            }
        } else {
            voltmx.print("########## No form with friendly name " + friendlyName + " is found in registry");
            return null
        }
    }
})();
voltmx = voltmx || {};
voltmx.model = voltmx.model || {};
voltmx.model.Util = voltmx.model.Util || {};
voltmx.model.Util.perfStats = [];
voltmx.model.Util.perftimecal = function(startTag, endTag, startTS, endTS) {
    if (voltmx.model.Util.isPerfTestReq === false) return;
    var formattedStartTS = startTS.getMinutes() + ":" + startTS.getSeconds() + ":" + startTS.getMilliseconds();
    var formattedEndTS = endTS.getMinutes() + ":" + endTS.getSeconds() + ":" + endTS.getMilliseconds();
    var starttime = startTS.getTime();
    var endtime = endTS.getTime();
    var res = endtime - starttime;
    var caliculatedTS = new Date;
    caliculatedTS.setTime(res);
    var formattedCalicutedTS = caliculatedTS.getUTCMinutes() + ":" + caliculatedTS.getUTCSeconds() + ":" + caliculatedTS.getUTCMilliseconds();
    voltmx.model.Util.perfStats.push(startTag + " " + formattedStartTS);
    voltmx.model.Util.perfStats.push(endTag + " " + formattedEndTS);
    voltmx.model.Util.perfStats.push("Total time taken is >> " + formattedCalicutedTS)
};
voltmx.model.Util.perlogout = function() {
    if (voltmx.model.Util.isPerfTestReq === false) return;
    for (var i = 0; i < voltmx.model.Util.perfStats.length; i++) {
        voltmx.model.log.info("[PERF][INFO] :" + voltmx.model.Util.perfStats[i])
    }
    voltmx.model.Util.perfStats = []
};
voltmx.model.Util.matchIgnoreCase = function(string1, string2) {
    if (string1 === null || string2 === null || string1 === undefined || string2 === undefined) {
        return false
    } else if (string1.toUpperCase() === string2.toUpperCase()) {
        return true
    } else {
        return false
    }
};
voltmx.model.Util.clone = function(src) {
    return clone(src);

    function clone(src) {
        function mixin(dest, source, copyFunc) {
            var name, s, i, empty = {};
            for (name in source) {
                s = source[name];
                if (!(name in dest) || dest[name] !== s && (!(name in empty) || empty[name] !== s)) {
                    dest[name] = copyFunc ? copyFunc(s) : s
                }
            }
            return dest
        }
        if (!src || typeof src != "object" || Object.prototype.toString.call(src) === "[object Function]") {
            return src
        }
        if (src.nodeType && "cloneNode" in src) {
            return src.cloneNode(true)
        }
        if (src instanceof Date) {
            return new Date(src.getTime())
        }
        if (src instanceof RegExp) {
            return new RegExp(src)
        }
        var r, i, l;
        if (src instanceof Array) {
            r = [];
            for (i = 0, l = src.length; i < l; ++i) {
                if (i in src) {
                    r.push(clone(src[i]))
                }
            }
        } else {
            r = src.constructor ? new src.constructor : {}
        }
        return mixin(r, src, clone)
    }
};
voltmx.model.Util.mergeJSONs = function(json1, json2) {
    if (!json1) return json2;
    if (!json2) return json1;
    var result = {};
    for (var key in json1) {
        result[key] = json1[key]
    }
    for (var key in json2)
        if (!result.hasOwnProperty(key)) result[key] = json2[key];
    return result
};
voltmx = voltmx || {};
voltmx.model = voltmx.model || {};
voltmx.model.log = voltmx.model.log || {};
voltmx.model.constants = voltmx.model.constants || {};
voltmx.model.constants.isForTesting = undefined;
voltmx.model.constants.TestConstants = {};
voltmx.model.constants["picklist"] = "picklist";
voltmx.model.constants["reference"] = "reference";
voltmx.model.constants["picklistmultiselect"] = "picklistmultiselect";
voltmx.model.constants["extendedfield"] = "extendedfield";
voltmx.model.constants["entityMetadataMap"] = {};
voltmx.model.constants["INTEGER_MIN_VALUE"] = -2147483648;
voltmx.model.constants["INTEGER_MAX_VALUE"] = 2147483647;
voltmx.model.constants.credStoreUsername = "username";
voltmx.model.constants.credStorePassword = "password";
voltmx.model.constants.credStoreOptions = "options";
voltmx.model.constants.credStoreIdentityService = "identityServiceName";
voltmx.model.constants.credStoreName = "credentials";
voltmx.model.constants.OperationType = {
    NO_FILTER: 1,
    FILTER_BY_PRIMARY_KEY: 2,
    ADD: 3
};
voltmx.model.constants.ValidationType = {
    CREATE: 1,
    UPDATE: 1
};
voltmx.model.constants.MatchType = {
    EQUALS: {
        value: "=",
        name: "EQUALS"
    },
    GREATER: {
        value: ">",
        name: "GREATER"
    },
    GREATEREQUAL: {
        value: ">=",
        name: "GREATEREQUAL"
    },
    LESS: {
        value: "<",
        name: "LESS"
    },
    LESSEQUAL: {
        value: "<=",
        name: "LESSEQUAL"
    },
    STARTSWITH: {
        value: "LIKE",
        name: "STARTSWITH"
    },
    CONTAINS: {
        value: "LIKE",
        name: "CONTAINS"
    },
    LIKE: {
        value: "LIKE",
        name: "LIKE"
    },
    ENDSWITH: {
        value: "LIKE",
        name: "ENDSWITH"
    },
    NOTEQUAL: {
        value: "<>",
        name: "NOTEQUAL"
    },
    ISNULL: {
        value: "IS NULL",
        name: "ISNULL"
    },
    ISNOTNULL: {
        value: "IS NOT NULL",
        name: "ISNOTNULL"
    }
};
voltmx = voltmx || {};
voltmx.model = voltmx.model || {};
voltmx.model.DataStore = function() {
    function DataStore() {
        var inMemoryData = {};
        this.getDataByKey = function(key) {
            if (inMemoryData.hasOwnProperty(key)) return inMemoryData[key]
        };
        this.setDataByKey = function(key, data) {
            inMemoryData[key] = data
        }
    }
    DataStore.prototype.storeData = function(key, data, inMemory) {
        if (inMemory == true) this.setDataByKey(key, data);
        else voltmx.store.setItem(key, data)
    };
    DataStore.prototype.getData = function(key, inMemory) {
        if (inMemory == true) return this.getDataByKey(key);
        else return voltmx.store.getItem(key)
    };
    return DataStore
}();
voltmx.model.AuthenticationManager = function() {
    function AuthenticationManager() {}
    AuthenticationManager.prototype.authenticate = function(params, successCallback, errorCallback) {
        try {
            var appFactoryInstance = voltmx.model.ApplicationContext.getFactorySharedInstance();
            var authParams = params["authParams"];
            var options = params["options"];
            var identityServiceName = params["identityServiceName"];
            var appLoginDetails = {
                authParams: authParams,
                options: options,
                identityServiceName: identityServiceName
            };
            var dataStoreObj = voltmx.model.ApplicationContext.getFactorySharedInstance().createDataStoreObject();
            dataStoreObj.storeData("UserCredentials", appLoginDetails, true);
            voltmx.model.ApplicationContext.setUserCredentialObj(dataStoreObj);
            authenticateService()
        } catch (e) {
            voltmx.model.log.error("Error while authentication: " + e.toString());
            var exception = appFactoryInstance.createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_OFFLINE_LOGIN_FAILURE, voltmx.model.ExceptionCode.MSG_ERROR_OFFLINE_LOGIN_FAILURE);
            errorCallback(exception)
        }

        function authenticateService() {
            voltmx.model.log.info("Getting SDK IdentityService");
            var identityClient = voltmx.sdk.getCurrentInstance().getIdentityService(identityServiceName);
            voltmx.model.ApplicationContext.setIdentityService(identityClient);
            voltmx.model.log.info("Making SDK login Call");
            identityClient.login(authParams, authSuccess, authError)
        }

        function authSuccess() {
            voltmx.model.log.info("SDK login Success");
            var isAppSyncEnabled = options["access"] === "offline" ? true : false;
            voltmx.model.ApplicationContext.setOnlineStatus(!isAppSyncEnabled);
            successCallback()
        }

        function authError(err) {
            voltmx.model.log.error("SDK login Failed " + err);
            var exception = appFactoryInstance.createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_LOGIN_FAILURE, voltmx.model.ExceptionCode.MSG_ERROR_LOGIN_FAILURE, err);
            errorCallback(exception)
        }
    };
    AuthenticationManager.prototype.saveUserDetails = function() {
        var storeObj = voltmx.model.ApplicationContext.getFactorySharedInstance().createDataStoreObject();
        var credentialObj = voltmx.model.ApplicationContext.getUserCredentialObj().getData("UserCredentials", true);
        var authParams = credentialObj["authParams"];
        var username = authParams["userid"];
        var options = credentialObj["options"];
        var identityServiceName = credentialObj["identityServiceName"];
        var credentials_store = {};
        credentials_store[voltmx.model.constants.credStoreUsername] = username;
        credentials_store[voltmx.model.constants.credStoreOptions] = options;
        credentials_store[voltmx.model.constants.credStoreIdentityService] = identityServiceName;
        storeObj.storeData(voltmx.model.constants.credStoreName, credentials_store)
    };
    AuthenticationManager.prototype.getSavedUserDetails = function() {
        var storeObj = voltmx.model.ApplicationContext.getFactorySharedInstance().createDataStoreObject();
        var credentialObj = storeObj.getData(voltmx.model.constants.credStoreName);
        return credentialObj
    };
    AuthenticationManager.prototype.execute = function(params, success, error) {
        this.authenticate(params, success, error)
    };
    return AuthenticationManager
}();
voltmx = voltmx || {};
voltmx.model = voltmx.model || {};
voltmx.model.AppFactory = function() {
    function AppFactory() {}
    AppFactory.prototype.createExceptionObject = function(errCode, errMsg, errorObj) {
        return new voltmx.model.Exception(errCode, errMsg, errorObj)
    };
    AppFactory.prototype.createSyncManagerObject = function() {
        return new voltmx.model.SyncManagerMF
    };
    AppFactory.prototype.createDataObject = function(data) {
        return new voltmx.model.Data(data)
    };
    AppFactory.prototype.createModelObject = function(context, entityName, serviceName, options) {
        if (entityName) {
            var modelObj;
            var modelHandler = voltmx.model[serviceName][entityName + "Model"];
            var modelExtensionHandler = voltmx.model[serviceName][entityName + "ModelExtension"];
            var metadataStore = context.getMetadataStore();
            var entityMetadata = metadataStore.getEntityMetadata(entityName, serviceName, options);
            if (entityMetadata) {
                var configOptions = {};
                configOptions["serviceName"] = serviceName;
                configOptions["options"] = options;
                modelObj = new modelHandler(context, entityMetadata, configOptions)
            } else {
                voltmx.model.log.error("error in entity controller factory, entity meta data for " + entityName + " undefined")
            }
            if (modelExtensionHandler !== undefined && typeof modelExtensionHandler === "function") {
                modelExtensionObj = new modelExtensionHandler(modelObj);
                modelObj.setControllerExtensionObject(modelExtensionObj)
            } else {
                voltmx.model.log.error("error in entity controller factory, model Extension Object for " + entityName + " is undefined")
            }
            return modelObj
        }
    };
    AppFactory.prototype.createViewObject = function(modelConfig, voltmxForm) {
        return new voltmx.model.View(modelConfig, voltmxForm)
    };
    AppFactory.prototype.createConfigClassObject = function(configObj) {
        return new voltmx.model.ConfigClass(configObj)
    };
    AppFactory.prototype.createAuthenticationManager = function() {
        var authManager = new voltmx.model.AuthenticationManager;
        if (voltmx.model.ApplicationContext) voltmx.model.ApplicationContext.setAuthManager(authManager);
        return authManager
    };
    AppFactory.prototype.getAuthManager = function() {
        if (voltmx.model.ApplicationContext && voltmx.model.ApplicationContext.getAuthManager()) return voltmx.model.ApplicationContext.getAuthManager();
        else return this.createAuthManager()
    };
    AppFactory.prototype.createDataStoreObject = function() {
        return new voltmx.model.DataStore
    };
    AppFactory.prototype.createAppInitManagerObject = function() {
        return new voltmx.model.AppInitManager
    };
    AppFactory.prototype.createMetadataServiceManagerObject = function() {
        return new voltmx.model.MetadataServiceManagerMF
    };
    AppFactory.prototype.createSegmentFieldObject = function(widgetid, fieldInfo) {
        return new voltmx.model.SegmentField(widgetid, fieldInfo)
    };
    AppFactory.prototype.createSearchInfoObject = function(widgetid, searchVal) {
        return new voltmx.model.searchInfo(widgetid, searchVal)
    };
    AppFactory.prototype.createSegmentWidgetConfigObject = function(widgetid, widgetConfig) {
        return new voltmx.model.SegmentWidgetConfig(widgetid, widgetConfig)
    };
    AppFactory.prototype.createWidgetConfigObject = function(widgetid, widgetConfig) {
        return new voltmx.model.widgetConfig(widgetid, widgetConfig)
    };
    AppFactory.prototype.createORMControllerObject = function(appContext, options) {
        return new voltmx.model.persistent.ORMControllerMFAPP(appContext, options)
    };
    AppFactory.prototype.createORMControllerOdataObject = function(applicationContext) {
        return new voltmx.model.persistent.ORMControllerMFAPPOData(applicationContext)
    };
    AppFactory.prototype.createORMControllerOdataExpandObject = function(applicationContext) {
        return new voltmx.model.persistent.ORMControllerMFAPPODataExpand(applicationContext)
    };
    AppFactory.prototype.createORMControllerSQLObject = function(applicationContext) {
        return new voltmx.model.persistent.ORMControllerMFAPPSQL(applicationContext)
    };
    AppFactory.prototype.createGroupWidgetsContextOffline = function(config, contextData) {
        return new voltmx.model.persistent.GroupWidgetsContextOffline(config, contextData)
    };
    AppFactory.prototype.createGroupWidgetsContextOnline = function(config, contextData) {
        return new voltmx.model.persistent.GroupWidgetsContextOnline(config, contextData)
    };
    AppFactory.prototype.createGroupWidgetsContextCommon = function(config, contextData) {
        return new voltmx.model.persistent.GroupWidgetsContextCommon(config, contextData)
    };
    AppFactory.prototype.createMetadataStore = function() {
        return new voltmx.model.MetadataStore
    };
    return AppFactory
}();
voltmx = voltmx || {};
voltmx.model = voltmx.model || {};
voltmx.model.ApplicationContext = function() {
    function ApplicationContext() {
        var storedCredentialObj;
        this.formObjects = undefined;
        this.metadataStore = undefined;
        this.configParams = undefined;
        this.modelObjects = {};
        this.authManager = undefined;
        this.metadataOptions = {};
        this.setCredentialObj = function(obj) {
            storedCredentialObj = obj
        };
        this.getCredentialObj = function() {
            return storedCredentialObj
        }
    }
    var appContextInstance = new ApplicationContext;
    var factoryObj;
    var IS_ONLINE = true;
    var identityService = undefined;
    var metaDataServiceManager = undefined;
    ApplicationContext.prototype.getAppInstance = function() {
        if (!appContextInstance) appContextInstance = new ApplicationContext;
        return appContextInstance
    };
    ApplicationContext.prototype.getFactorySharedInstance = function() {
        if (!factoryObj) factoryObj = new voltmx.model.AppFactory;
        return factoryObj
    };
    ApplicationContext.prototype.getMetadataServiceManager = function() {
        if (!metaDataServiceManager) {
            metaDataServiceManager = new voltmx.model.MetadataServiceManagerMF
        }
        return metaDataServiceManager
    };
    ApplicationContext.prototype.isAppsFirstLogin = function(params) {
        var username = params["username"];
        if (!username && params["authParams"]) {
            username = params["authParams"]["userid"]
        }
        var options = params["options"];
        var identityServiceName = params["identityServiceName"];
        var credStore = voltmx.store.getItem(voltmx.model.constants.credStoreName);
        if (credStore !== null && credStore !== undefined) {
            var storedOptions = credStore[voltmx.model.constants.credStoreOptions];
            var storedIdentityServiceName = credStore[voltmx.model.constants.credStoreIdentityService];
            var storedUsername = credStore[voltmx.model.constants.credStoreUsername];
            if (storedUsername !== undefined && storedOptions !== undefined && voltmx.model.Util.matchIgnoreCase(storedUsername, username) && voltmx.model.Util.matchIgnoreCase(storedOptions.access, options.access) && voltmx.model.Util.matchIgnoreCase(storedIdentityServiceName, identityServiceName)) {
                return false
            }
        }
        return true
    };
    ApplicationContext.prototype.appServicesLogin = function(params, loginSuccessCallback, loginErrorCallback) {
        try {
            var options = params["options"];
            var syncOptions = params["syncOptions"];
            var isOffline = options["access"] === "offline" ? true : false;
            var configParams = params["configParams"];
            var metadataOptions = params["metadataOptions"];
            var syncParams = {
                syncOptions: syncOptions
            };
            var authConfig = {};
            authConfig["authParams"] = params["authParams"];
            authConfig["options"] = params["options"];
            authConfig["identityServiceName"] = params["identityServiceName"];
            authConfig["showLoadingscreen"] = true;
            var appfactoryInstance = this.getFactorySharedInstance();
            if (configParams && configParams.constructor === Object && Object.keys(configParams).length > 0) {
                voltmx.model.ApplicationContext.setConfigParams(configParams)
            }
            var initManager = appfactoryInstance.createAppInitManagerObject();
            initManager.registerService("AuthenticationServiceManager", {
                object: appfactoryInstance.createAuthenticationManager(),
                params: authConfig
            });
            initManager.registerService("MetadataServiceManager", {
                object: appfactoryInstance.createMetadataServiceManagerObject(),
                params: {
                    options: options,
                    metadataOptions: metadataOptions
                }
            });
            if (isOffline) {
                initManager.registerService("SyncManager", {
                    object: appfactoryInstance.createSyncManagerObject(),
                    params: syncParams
                })
            }
            initManager.executeRegistedServices(loginSuccessCallback, loginErrorCallback)
        } catch (err) {
            var exception;
            voltmx.model.ApplicationContext.dismissLoadingScreen();
            voltmx.model.log.error("Error while authentication: " + err.toString());
            if (err !== undefined && err !== null) {
                exception = this.getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_APP_INITIALIZATION_FAILED, voltmx.model.ExceptionCode.MSG_ERROR_APP_INITIALIZATION_FAILED)
            } else exception = this.getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_APP_INITIALIZATION_FAILED, voltmx.model.ExceptionCode.MSG_ERROR_APP_INITIALIZATION_FAILED);
            loginErrorCallback(exception)
        }
    };
    ApplicationContext.prototype.getObjectService = function(options, objectServiceName) {
        try {
            var objectService;
            if (options.hasOwnProperty("mock") && options["mock"] == true) {
                voltmx.model.log.info("Initialising mocked object service");
                voltmx.model.log.info("Getting SDK ObjectService");
                objectService = voltmx.sdk.getCurrentInstance().getObjectService(objectServiceName, {
                    access: objectServiceName
                })
            } else {
                voltmx.model.log.info("Getting SDK ObjectService");
                objectService = voltmx.sdk.getCurrentInstance().getObjectService(objectServiceName, options)
            }
            return objectService
        } catch (error) {
            throw this.getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_INITIALIZING_METADATA_PROVIDER, voltmx.model.ExceptionCode.MSG_ERROR_INITIALIZING_METADATA_PROVIDER + " -- " + error.message)
        }
    };
    ApplicationContext.prototype.logout = function(logoutSucCallback, logoutErrCallback) {
        var logoutTS = new Date;
        try {
            this.reset();
            var identityService = voltmx.model.ApplicationContext.getIdentityService();
            if (identityService) {
                identityService.logout(success, logoutErrCallback)
            } else {
                success()
            }

            function success() {
                var logoutEndTS = new Date;
                voltmx.model.Util.perftimecal("Logout >>", "Logout Ended >>", logoutTS, logoutEndTS);
                voltmx.model.Util.perlogout();
                logoutSucCallback()
            }
        } catch (err) {
            logoutErrCallback(this.getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_FAILED_TO_LOGOUT, voltmx.model.ExceptionCode.MSG_ERROR_FAILED_TO_LOGOUT + " : " + err.toString(), err))
        }
    };
    ApplicationContext.prototype.showLoadingScreen = function(text) {
        var configParams = voltmx.model.ApplicationContext.getConfigParams();
        if (configParams && configParams["ShowLoadingScreenFunction"]) {
            var userDefinedLoadingScreen = configParams["ShowLoadingScreenFunction"];
            userDefinedLoadingScreen(text)
        } else {
            text = " " + text + " \n";
            voltmx.application.showLoadingScreen(null, text, constants.LOADING_SCREEN_POSITION_ONLY_CENTER, true, true, null)
        }
    };
    ApplicationContext.prototype.showSyncLoadingScreen = function(text) {
        var configParams = voltmx.model.ApplicationContext.getConfigParams();
        if (configParams && configParams["ShowSyncLoadingScreenFunction"]) {
            var userDefinedLoadingScreen = configParams["ShowSyncLoadingScreenFunction"];
            userDefinedLoadingScreen(text)
        } else {
            text = " " + text + " \n";
            voltmx.application.showLoadingScreen(null, text, constants.LOADING_SCREEN_POSITION_ONLY_CENTER, true, true, null)
        }
    };
    ApplicationContext.prototype.dismissLoadingScreen = function() {
        var configParams = voltmx.model.ApplicationContext.getConfigParams();
        if (configParams && configParams["DismissLoadingScreenFunction"]) {
            var userDefinedLoadingScreen = configParams["DismissLoadingScreenFunction"];
            userDefinedLoadingScreen()
        } else {
            voltmx.application.dismissLoadingScreen()
        }
    };
    ApplicationContext.prototype.dismissSyncLoadingScreen = function() {
        var configParams = voltmx.model.ApplicationContext.getConfigParams();
        if (configParams && configParams["DismissSyncLoadingScreenFunction"]) {
            var userDefinedLoadingScreen = configParams["DismissSyncLoadingScreenFunction"];
            userDefinedLoadingScreen()
        } else {
            voltmx.application.dismissLoadingScreen()
        }
    };
    ApplicationContext.prototype.getAuthManager = function() {
        return this.authManager
    };
    ApplicationContext.prototype.setAuthManager = function(authManager) {
        this.authManager = authManager
    };
    ApplicationContext.prototype.setUserCredentialObj = function(obj) {
        this.setCredentialObj(obj)
    };
    ApplicationContext.prototype.getUserCredentialObj = function() {
        return this.getCredentialObj()
    };
    ApplicationContext.prototype.setOnlineStatus = function(isOnline) {
        IS_ONLINE = isOnline === true ? true : false
    };
    ApplicationContext.prototype.isAppSyncEnabled = function() {
        return IS_ONLINE === false ? true : false
    };
    ApplicationContext.prototype.getMetadataStore = function() {
        if (!this.metadataStore) this.metadataStore = new voltmx.model.MetadataStore;
        return this.metadataStore
    };
    ApplicationContext.prototype.getSyncManager = function() {
        if (!this.syncManager) this.syncManager = this.getFactorySharedInstance().createSyncManagerObject();
        return this.syncManager
    };
    ApplicationContext.prototype.reset = function() {
        this.metadataStore = undefined;
        this.formObjects = undefined
    };
    ApplicationContext.prototype.setConfigParams = function(params) {
        if (this.configParams) {
            for (var key in params) this.configParams[key] = params[key]
        } else this.configParams = params
    };
    ApplicationContext.prototype.getConfigParams = function() {
        return this.configParams
    };
    ApplicationContext.prototype.getModel = function(entityName, serviceName, options) {
        var modelName = serviceName + "." + entityName;
        if (!this.modelObjects[modelName]) {
            this.modelObjects[modelName] = this.getFactorySharedInstance().createModelObject(this, entityName, serviceName, options)
        }
        this.modelObjects[modelName].setOptions(options);
        return this.modelObjects[modelName]
    };
    ApplicationContext.prototype.setIdentityService = function(identservice) {
        identityService = identservice
    };
    ApplicationContext.prototype.getIdentityService = function() {
        return identityService
    };
    ApplicationContext.prototype.login = function(params, loginSucCallback, loginErrCallback) {
        var authenticationManager = this.getFactorySharedInstance().createAuthenticationManager();
        authenticationManager.execute(params, loginSucCallback, loginErrCallback)
    };
    ApplicationContext.prototype.createModel = function(entityName, serviceName, options, metadataOptions, successCallback, errorCallback) {
        var model = serviceName + "." + entityName;
        var scopeObj = this;
        var modelObj;
        try {
            var modelHandler = voltmx.model[serviceName][entityName + "Model"];
            var modelExtensionHandler = voltmx.model[serviceName][entityName + "ModelExtension"];
            if (metadataOptions.getFromServer) {
                voltmx.model.ApplicationContext.getMetadataServiceManager().fetchForObject(serviceName, entityName, options, metadataOptions, metadataSuccCallback.bind(this), metadataErrCallback.bind(this))
            } else {
                if (scopeObj.modelObjects.hasOwnProperty(model)) {
                    scopeObj.modelObjects[model].setOptions(options);
                    successCallback(scopeObj.modelObjects[model])
                } else {
                    var metadataStore = scopeObj.getMetadataStore();
                    try {
                        if (!metadataStore.getEntityMetadata(entityName, serviceName, options)) {
                            voltmx.model.ApplicationContext.getMetadataServiceManager().fetchForObject(serviceName, entityName, options, metadataOptions, metadataSuccCallback, metadataErrCallback)
                        } else {
                            metadataSuccCallback()
                        }
                    } catch (err) {
                        voltmx.model.log.error("Error in fetching metadata for object service : " + objServiceName, err);
                        errorCallback.call(err)
                    }
                }
            }

            function metadataSuccCallback() {
                var metadataStore = scopeObj.getMetadataStore();
                var entityMetadata = metadataStore.getEntityMetadata(entityName, serviceName, options);
                if (entityMetadata) {
                    var configOptions = {};
                    configOptions["serviceName"] = serviceName;
                    configOptions["options"] = options;
                    modelObj = new modelHandler(scopeObj, entityMetadata, configOptions)
                } else {
                    voltmx.model.log.error("error in entity controller factory, entity meta data for " + entityName + " undefined")
                }
                if (modelExtensionHandler !== undefined && typeof modelExtensionHandler === "function") {
                    modelExtensionObj = new modelExtensionHandler(modelObj);
                    modelObj.setControllerExtensionObject(modelExtensionObj)
                } else {
                    voltmx.model.log.error("error in entity controller factory, model Extension Object for " + entityName + " is undefined")
                }
                scopeObj.modelObjects[model] = modelObj;
                scopeObj.modelObjects[model].setOptions(options);
                successCallback(scopeObj.modelObjects[model])
            }

            function metadataErrCallback(err) {
                voltmx.model.log.error("Error in fetching metadata for object service : " + objServiceName);
                errorCallback(err)
            }
        } catch (err) {
            errorCallback.call(err)
        }
    };
    ApplicationContext.prototype.initializeObjectServices = function(serviceEntityMap, successCallback, errorCallback) {
        var scopeObj = this;
        var indx1 = 0;
        var services = Object.keys(serviceEntityMap);
        initialiseServices();

        function initialiseServices() {
            if (indx1 >= services.length) {
                successCallback();
                return
            }
            var indx2 = 0;
            var entities;
            var options = serviceEntityMap[services[indx1]]["options"];
            var serviceName = services[indx1];
            var serviceMetadataOptions = serviceEntityMap[services[indx1]]["metadataOptions"];
            if (serviceEntityMap[services[indx1]]["entities"]) {
                entities = Object.keys(serviceEntityMap[services[indx1]]["entities"]);
                initialiseObject()
            } else {
                initialiseService()
            }

            function initialiseObject() {
                if (indx2 >= entities.length) {
                    metaSuccess();
                    return
                }
                var entityName = entities[indx2];
                var metadataOptions = serviceEntityMap[services[indx1]]["entities"][entities[indx2]]["metadataOptions"];
                if (!metadataOptions) metadataOptions = serviceMetadataOptions;
                if (metadataOptions.getFromServer) {
                    var model = serviceName + "." + entityName;
                    scopeObj.modelObjects[model] = null
                }
                voltmx.model.ApplicationContext.getMetadataServiceManager().fetchForObject(serviceName, entityName, options, metadataOptions, successCbk, errorCbk);

                function successCbk(data) {
                    indx2++;
                    initialiseObject()
                }

                function errorCbk(err) {
                    metaError(err)
                }
            }

            function initialiseService() {
                voltmx.model.ApplicationContext.getMetadataServiceManager().fetchForObjectService(serviceName, options, serviceMetadataOptions, metaSuccess, metaError)
            }

            function metaSuccess() {
                indx1++;
                initialiseServices()
            }

            function metaError(err) {
                errorCallback(err)
            }
        }
    };
    return appContextInstance
}();
voltmx = voltmx || {};
voltmx.model = voltmx.model || {};
voltmx.model.BaseModel = function() {
    function BaseModel(applicationContext, entityMetaData, configOptions) {
        var appContext = applicationContext;
        var entityMetadata = entityMetaData;
        var fields = entityMetaData.fields;
        var columnsMap = entityMetaData.columnsMap;
        var relatedEntities = entityMetaData.relatedEntities;
        var entityDefinition = undefined;
        var controllerExtensionObject = undefined;
        var serviceName = configOptions.serviceName;
        var options = configOptions.options;
        this.getServiceName = function() {
            return serviceName
        }, this.setServiceName = function(serviceNameVal) {
            serviceName = serviceNameVal
        }, this.getOptions = function() {
            return options
        }, this.setOptions = function(optionsObj) {
            options = optionsObj
        }, this.getObjectService = function() {
            return this.getApplicationContext().getObjectService(this.getOptions(), this.getServiceName())
        }, this.getControllerExtensionObject = function() {
            return controllerExtensionObject
        };
        this.setControllerExtensionObject = function(controllerExtension) {
            controllerExtensionObject = controllerExtension
        };
        this.getApplicationContext = function() {
            return appContext
        };
        this.getEntityMetaData = function() {
            return entityMetadata
        };
        this.getFields = function() {
            return fields
        };
        this.getColumnsMap = function() {
            return columnsMap
        };
        this.getRelatedEntities = function() {
            return relatedEntities
        };
        this.getAccessType = function() {
            if (options && options.hasOwnProperty("access") && options.access.toLowerCase() === "offline") return "offline";
            else return "online"
        };
        this.getDataObjectOnline = function(columnNames, dataModel) {
            var entityName = this.getValueForProperty("name");
            var self = this;
            var columnNamesString = "*";
            var primaryKeyColumns = this.getValueForProperty("primaryKey");
            for (var i = 0; i < primaryKeyColumns.length; i++) {
                if (columnNames.indexOf(primaryKeyColumns[i]) === -1) {
                    columnNames.push(primaryKeyColumns[i])
                }
            }
            for (var column in columnNames) {
                if (columnNamesString === "*") {
                    columnNamesString = columnNames[column]
                } else {
                    columnNamesString = columnNamesString + "," + columnNames[column]
                }
            }
            var queryStr = "$select=" + columnNamesString;
            voltmx.model.log.info("columnNamesString : " + columnNamesString);
            if (dataModel) {
                voltmx.model.log.info("DataModel object --\x3e ", dataModel);
                var primaryKeyValueMap = dataModel.getPrimaryKeyValueMap();
                if (primaryKeyValueMap) {
                    queryStr = queryStr.concat("&$filter=");
                    var primaryKeyValuesArr = Object.keys(primaryKeyValueMap);
                    for (var j = 1; j < primaryKeyValuesArr.length; j++) {
                        queryStr = queryStr.concat(primaryKeyValuesArr[j - 1] + " eq " + primaryKeyValueMap[primaryKeyValuesArr[j - 1]] + " and ")
                    }
                    queryStr = queryStr.concat(primaryKeyValuesArr[j - 1] + " eq " + primaryKeyValueMap[primaryKeyValuesArr[j - 1]])
                }
            }
            var dataObject = new voltmx.sdk.dto.DataObject(self.getValueForProperty("name"));
            dataObject.setOdataUrl(queryStr);
            return dataObject
        };
        this.getDataObjectOffline = function(columnNames, dataModel) {
            var self = this;
            var entityName = this.getValueForProperty("name");
            var tblDto = new voltmx.sdk.dto.Table(entityName, entityName, false);
            var selQuery = new voltmx.sdk.dto.SelectQuery(self.getServiceName(), tblDto);
            var primaryKeyColumns = this.getValueForProperty("primaryKey");
            for (var i = 0; i < primaryKeyColumns.length; i++) {
                if (columnNames.indexOf(primaryKeyColumns[i]) === -1) {
                    columnNames.push(primaryKeyColumns[i])
                }
            }
            for (var index in columnNames) {
                var colObj = new voltmx.sdk.dto.Column(tblDto, columnNames[index]);
                selQuery.addColumn(colObj)
            }
            if (dataModel) {
                var primaryKeyValueMap = dataModel.getPrimaryKeyValueMap();
                if (primaryKeyValueMap) {
                    var primaryKeyValuesArr = Object.keys(primaryKeyValueMap);
                    for (var j = 0; j < primaryKeyValuesArr.length; j++) {
                        var colObj = new voltmx.sdk.dto.Column(tblDto, primaryKeyValuesArr[j]);
                        var crtObj = new voltmx.sdk.dto.Match(colObj, voltmx.sdk.constants.MatchType.EQUALS, primaryKeyValueMap[primaryKeyValuesArr[j]]);
                        selQuery.addCriteria(crtObj)
                    }
                }
            }
            var dataObject = new voltmx.sdk.dto.DataObject(self.getValueForProperty("name"));
            dataObject.setSelectQueryObject(selQuery);
            return dataObject
        };
        this.getRequestOptions = function(options) {
            if (options && !options.hasOwnProperty("dataObject")) {
                var newOptions = {};
                newOptions["dataObject"] = options;
                return newOptions
            } else {
                return options
            }
        }
    }
    BaseModel.prototype.getValueForColumnProperty = function(columnName, key) {
        var propertyVal = null;
        if (columnName && key) {
            propertyVal = this.getColumnInfo(columnName)[key]
        }
        return propertyVal
    };
    BaseModel.prototype.getColumnNames = function() {
        var columnNames = [];
        for (var key in this.getColumnsMap()) {
            columnNames.push(key)
        }
        return columnNames
    };
    BaseModel.prototype.getValueForProperty = function(propertyName) {
        return this.getEntityMetaData()[propertyName]
    };
    BaseModel.prototype.getColumnInfo = function(columnName) {
        return this.getColumnsMap()[columnName]
    };
    BaseModel.prototype.getFieldPickListValues = function(columnName) {
        return this.getColumnInfo(columnName)["pickListValues"]
    };
    BaseModel.prototype.getChildRelationshipList = function(successCallback, errorCallback) {
        var scopeObj = this;
        var childRelationships = this.getValueForProperty("relationshipList");
        successCallback.call(scopeObj, childRelationships)
    };
    BaseModel.prototype.getRelationshipForChildEntityName = function(childEntityName, successCallback, errorCallback) {
        var scopeObj = this;
        var relatedEntities = this.getValueForProperty("relatedEntities");
        if (relatedEntities) {
            successCallback.call(scopeObj, relatedEntities[childEntityName])
        } else {
            errorCallback.call(scopeObj, relatedEntities)
        }
    };
    BaseModel.prototype.fetchDataForColumns = function(columnNames, onSuccess, onError, dataModel) {
        try {
            var self = this;
            var dataObject;
            if (this.getAccessType() === "offline") dataObject = this.getDataObjectOffline(columnNames, dataModel);
            else dataObject = this.getDataObjectOnline(columnNames, dataModel);
            this.fetch(dataObject, success, error)
        } catch (err) {
            voltmx.model.log.error("Error fetching data for columns in entity controller");
            var exception;
            exception = self.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_FETCHING_DATA_FOR_COLUMNS, voltmx.model.ExceptionCode.MSG_ERROR_FETCHING_DATA_FOR_COLUMNS, err);
            onError(exception)
        }

        function success(response) {
            voltmx.model.log.info("Success fetching data for columns in entity controller");
            onSuccess(response)
        }

        function error(err) {
            voltmx.model.log.error("Error fetching data for columns in entity controller");
            var exception = self.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_FETCHING_DATA_FOR_COLUMNS, voltmx.model.ExceptionCode.MSG_ERROR_FETCHING_DATA_FOR_COLUMNS, err);
            onError(exception)
        }
    };
    BaseModel.prototype.fetch = function(options, onSuccess, onError) {
        this.fetchResponseWithRecords(options, success, onError);

        function success(response) {
            response = response["records"];
            onSuccess(response)
        }
    };
    BaseModel.prototype.create = function(options, onSuccess, onError) {
        try {
            var scopeObj = this;
            var requestOptions = scopeObj.getRequestOptions(options);
            if (false === this.validate(requestOptions["dataObject"], voltmx.model.constants.ValidationType.CREATE)) {
                var exception = this.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_VALIDATION_CREATE, voltmx.model.ExceptionCode.MSG_ERROR_VALIDATION_CREATE);
                throw exception
            }
            var createInEntityCntrlTS = new Date;
            voltmx.model.log.info("Making SDK create Call");
            scopeObj.getObjectService().create(requestOptions, success, error)
        } catch (e) {
            var exception = scopeObj.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_CREATE, voltmx.model.ExceptionCode.MSG_ERROR_CREATE, e);
            onError(exception)
        }

        function success(response) {
            voltmx.model.log.info("SDK create Success");
            var createEndInEntityCntrlTS = new Date;
            voltmx.model.Util.perftimecal("Create in entity controller >>", "Create in entity controller done >>", createInEntityCntrlTS, createEndInEntityCntrlTS);
            onSuccess(response)
        }

        function error(e) {
            voltmx.model.log.error("SDK create Failed " + e);
            var exception = scopeObj.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_CREATE, voltmx.model.ExceptionCode.MSG_ERROR_CREATE, e);
            onError(exception)
        }
    };
    BaseModel.prototype.update = function(options, onSuccess, onError) {
        var updateInEntityCntrlTS = new Date;
        try {
            var scopeObj = this;
            var requestOptions = scopeObj.getRequestOptions(options);
            if (false === this.validate(requestOptions["dataObject"], voltmx.model.constants.ValidationType.UPDATE)) {
                var exception = this.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_VALIDATION_UPDATE, voltmx.model.ExceptionCode.MSG_ERROR_VALIDATION_UPDATE);
                throw exception
            }
            if (this.getAccessType() === "offline") {
                voltmx.model.log.info("Making SDK update Call");
                scopeObj.getObjectService().update(requestOptions, success, error)
            } else {
                voltmx.model.log.info("Making SDK partialUpdate Call");
                scopeObj.getObjectService().partialUpdate(requestOptions, success, error)
            }
        } catch (err) {
            var exception = scopeObj.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_UPDATE, voltmx.model.ExceptionCode.MSG_ERROR_UPDATE, err);
            onError(exception)
        }

        function success(response) {
            voltmx.model.log.info("SDK update Success");
            var updateEndInEntityCntrlTS = new Date;
            voltmx.model.Util.perftimecal("Update in entity controller >>", "Update in entity controller done >>", updateInEntityCntrlTS, updateEndInEntityCntrlTS);
            onSuccess(response)
        }

        function error(err) {
            voltmx.model.log.error("SDK update Failed " + err);
            var exception = scopeObj.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_UPDATE, voltmx.model.ExceptionCode.MSG_ERROR_UPDATE, err);
            onError(exception)
        }
    };
    BaseModel.prototype.partialUpdate = function(options, onSuccess, onError) {
        var scopeObj = this;
        scopeObj.update(options, onSuccess, onError)
    };
    BaseModel.prototype.completeUpdate = function(options, onSuccess, onError) {
        var updateInEntityCntrlTS = new Date;
        try {
            var scopeObj = this;
            var requestOptions = scopeObj.getRequestOptions(options);
            if (false === this.validate(requestOptions["dataObject"], voltmx.model.constants.ValidationType.UPDATE)) {
                var exception = this.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_VALIDATION_UPDATE, voltmx.model.ExceptionCode.MSG_ERROR_VALIDATION_UPDATE);
                throw exception
            }
            voltmx.model.log.info("Making SDK update Call");
            scopeObj.getObjectService().update(requestOptions, success, error)
        } catch (err) {
            var exception = scopeObj.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_UPDATE, voltmx.model.ExceptionCode.MSG_ERROR_UPDATE, err);
            onError(exception)
        }

        function success(response) {
            voltmx.model.log.info("SDK update Success");
            var updateEndInEntityCntrlTS = new Date;
            voltmx.model.Util.perftimecal("Update in entity controller >>", "Update in entity controller done >>", updateInEntityCntrlTS, updateEndInEntityCntrlTS);
            onSuccess(response)
        }

        function error(err) {
            voltmx.model.log.error("SDK update Failed " + err);
            var exception = scopeObj.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_UPDATE, voltmx.model.ExceptionCode.MSG_ERROR_UPDATE, err);
            onError(exception)
        }
    };
    BaseModel.prototype.remove = function(options, onSuccess, onError) {
        try {
            var scopeObj = this;
            var removeInEntityCntrlTS = new Date;
            var requestOptions = scopeObj.getRequestOptions(options);
            voltmx.model.log.info("Making SDK deleteRecord Call");
            scopeObj.getObjectService().deleteRecord(requestOptions, success, error)
        } catch (err) {
            var exception = scopeObj.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_DELETE, voltmx.model.ExceptionCode.MSG_ERROR_DELETE, err);
            onError(exception)
        }

        function success(response) {
            voltmx.model.log.info("SDK deleteRecord Success");
            var removeEndInEntityCntrlTS = new Date;
            voltmx.model.Util.perftimecal("Remove in entity controller >>", "Remove in entity controller done >>", removeInEntityCntrlTS, removeEndInEntityCntrlTS);
            onSuccess(response)
        }

        function error(err) {
            voltmx.model.log.error("SDK deleteRecord Failed " + err);
            var exception = scopeObj.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_DELETE, voltmx.model.ExceptionCode.MSG_ERROR_DELETE, err);
            onError(exception)
        }
    };
    BaseModel.prototype.removeByPrimaryKey = function(primaryKeyValueMap, onSuccess, onError) {
        try {
            var scopeObj = this;
            var entityName = this.getValueForProperty("name");
            var dataObject = new voltmx.sdk.dto.DataObject(scopeObj.getValueForProperty("name"));
            dataObject.setRecord(primaryKeyValueMap);
            this.remove(dataObject, success, error)
        } catch (err) {
            var exception = scopeObj.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_DELETE_BY_PRIMARY_KEY, voltmx.model.ExceptionCode.MSG_ERROR_DELETE_BY_PRIMARY_KEY, err);
            onError(exception)
        }

        function success(response) {
            voltmx.model.log.info("Record with primaryFieldValue - " + primaryKeyValueMap + " - of entity '" + entityName + "' deleted successfully");
            onSuccess(response)
        }

        function error(err) {
            var exception = scopeObj.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_DELETE_BY_PRIMARY_KEY, voltmx.model.ExceptionCode.MSG_ERROR_DELETE_BY_PRIMARY_KEY, err);
            onError(exception)
        }
    };
    BaseModel.prototype.executeSelectQuery = function(query, succCallback, errCallback) {
        try {
            var self = this;
            voltmx.model.log.info("Making SDK executeSelectQuery Call");
            this.getObjectService().executeSelectQuery(query, success, error);

            function success(response) {
                voltmx.model.log.info("SDK executeSelectQuery Call Success");
                var primaryKeyColumns = self.getValueForProperty("primaryKey");
                if (response && response.length > 0) {
                    for (var key in response) {
                        var primaryKeyValueMap = {};
                        for (var i = 0; i < primaryKeyColumns.length; i++) {
                            if (response[key].hasOwnProperty(primaryKeyColumns[i])) {
                                primaryKeyValueMap[primaryKeyColumns[i]] = response[key][primaryKeyColumns[i]]
                            }
                        }
                        response[key]["primaryKeyValueMap"] = primaryKeyValueMap
                    }
                }
                succCallback(response)
            }

            function error(err) {
                voltmx.model.log.error("SDK executeSelectQuery Call Failed " + err);
                var exception = self.getApplicationContext().getFactorySharedInstance().createExceptionObject(-1, "Error executing executeSelectQuery", err);
                errCallback(exception)
            }
        } catch (err) {
            voltmx.model.log.error("Error fetching data for columns in entity controller");
            var exception = self.getApplicationContext().getFactorySharedInstance().createExceptionObject(-1, "Error executing executeSelectQuery", err);
            errCallback(exception)
        }
    };
    BaseModel.prototype.fetchResponse = function(options, onSuccess, onError) {
        var fetchInEntityCntrlTS = new Date;
        try {
            var self = this;
            var requestOptions = self.getRequestOptions(options);
            voltmx.model.log.info("Making SDK fetch Call");
            self.getObjectService().fetch(requestOptions, success, error)
        } catch (e) {
            var exception;
            if (e instanceof voltmx.model.Exception) exception = self.getApplicationContext().getFactorySharedInstance().createExceptionObject(e.code, e.message, e);
            else exception = self.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_FETCH, voltmx.model.ExceptionCode.MSG_ERROR_FETCH, e);
            onError(exception)
        }

        function success(response) {
            voltmx.model.log.info("SDK fetch Success");
            var records = response["records"];
            var primaryKeyColumns = self.getValueForProperty("primaryKey");
            if (records && records.length > 0) {
                for (var key in records) {
                    var primaryKeyValueMap = {};
                    for (var i = 0; i < primaryKeyColumns.length; i++) {
                        if (records[key].hasOwnProperty(primaryKeyColumns[i])) {
                            primaryKeyValueMap[primaryKeyColumns[i]] = records[key][primaryKeyColumns[i]]
                        }
                    }
                    records[key]["primaryKeyValueMap"] = primaryKeyValueMap
                }
            }
            var fetchEndInEntityCntrlTS = new Date;
            voltmx.model.Util.perftimecal("Fetch in entity controller >>", "Fetch in entity controller done >>", fetchInEntityCntrlTS, fetchEndInEntityCntrlTS);
            onSuccess(response)
        }

        function error(err) {
            voltmx.model.log.error("Error in fetching data for given query", err);
            var exception = self.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_FETCH, voltmx.model.ExceptionCode.MSG_ERROR_FETCH, err);
            onError(exception)
        }
    };
    BaseModel.prototype.fetchResponseWithRecords = function(options, onSuccess, onError) {
        var self = this;
        this.fetchResponse(options, success, onError);

        function success(response) {
            if (!response.hasOwnProperty("records")) {
                for (var key in response) {
                    if (response[key] instanceof Array) {
                        response["records"] = response[key];
                        break
                    }
                }
                var records = response["records"];
                var primaryKeyColumns = self.getValueForProperty("primaryKey");
                if (records && records.length > 0) {
                    for (var key in records) {
                        var primaryKeyValueMap = {};
                        for (var i = 0; i < primaryKeyColumns.length; i++) {
                            if (records[key].hasOwnProperty(primaryKeyColumns[i])) {
                                primaryKeyValueMap[primaryKeyColumns[i]] = records[key][primaryKeyColumns[i]]
                            }
                        }
                        records[key]["primaryKeyValueMap"] = primaryKeyValueMap
                    }
                }
            }
            onSuccess(response)
        }
    };
    BaseModel.prototype.customVerb = function(verbName, options, success, error) {
        var customVerbStartInEntityCtrlTS = new Date;
        try {
            var self = this;
            var requestOptions = self.getRequestOptions(options);
            voltmx.model.log.info("Making SDK custom verb Call");
            this.getApplicationContext().getObjectService({
                access: "online"
            }, this.getServiceName()).customVerb(verbName, options, onSuccess, onError)
        } catch (e) {
            var exception;
            if (e instanceof voltmx.model.Exception) exception = self.getApplicationContext().getFactorySharedInstance().createExceptionObject(e.code, e.message, e);
            else exception = self.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_CUSTOMVERB, voltmx.model.ExceptionCode.MSG_ERROR_CUSTOMVERB, e);
            onError(exception)
        }

        function onSuccess(response) {
            voltmx.model.log.info("SDK fetch Success");
            var records = response["records"];
            var primaryKeyColumns = self.getValueForProperty("primaryKey");
            if (records && records.length > 0) {
                for (var key in records) {
                    var primaryKeyValueMap = {};
                    for (var i = 0; i < primaryKeyColumns.length; i++) {
                        if (records[key].hasOwnProperty(primaryKeyColumns[i])) {
                            primaryKeyValueMap[primaryKeyColumns[i]] = records[key][primaryKeyColumns[i]]
                        }
                    }
                    records[key]["primaryKeyValueMap"] = primaryKeyValueMap
                }
            }
            var customVerbEndInEntityCtrlTS = new Date;
            voltmx.model.Util.perftimecal("Customverb call in entity controller >>", "CustomVerb call in entity controller done >>", customVerbStartInEntityCtrlTS, customVerbEndInEntityCtrlTS);
            success(response)
        }

        function onError(err) {
            voltmx.model.log.error("Error in custom verb call", err);
            var exception = self.getApplicationContext().getFactorySharedInstance().createExceptionObject(voltmx.model.ExceptionCode.CD_ERROR_CUSTOMVERB, voltmx.model.ExceptionCode.MSG_ERROR_CUSTOMVERB, err);
            error(exception)
        }
    };
    BaseModel.prototype.validate = function(dataObject, validationType) {
        return this.getControllerExtensionObject().validate(dataObject, validationType)
    };
    return BaseModel
}();
voltmx = voltmx || {};
voltmx.model = voltmx.model || {};
voltmx.model.MetadataServiceManagerMF = function() {
    function MetadataServiceManagerMF() {}
    MetadataServiceManagerMF.prototype.fetch = function(options, serviceName, metadataOptions, successcallback, errorCallback) {
        var objectService = voltmx.model.ApplicationContext.getObjectService(options, serviceName);
        voltmx.model.log.info("Making SDK metadata Call");
        objectService.getMetadataOfAllObjects(metadataOptions, successcallback, errorCallback)
    };
    MetadataServiceManagerMF.prototype.apply = function(response, options, serviceName, successcallback, errorCallback) {
        var entityMetaDataMap = {};
        for (var objectName in response) {
            var metadata = response[objectName];
            entityMetaDataMap[objectName] = metadata;
            var fields = metadata.columns;
            entityMetaDataMap[objectName]["columnsMap"] = {};
            for (var j = 0; j < fields.length; j++) {
                var field = fields[j];
                entityMetaDataMap[objectName]["columnsMap"][field.name] = field
            }
            setRelatedEntities(metadata);
            if (voltmx.model.ApplicationContext) {
                var metadataStore = voltmx.model.ApplicationContext.getMetadataStore();
                metadataStore.setEntityMetadata(entityMetaDataMap[objectName], objectName, serviceName, options)
            }
        }

        function setRelatedEntities(metadata) {
            var relationList = metadata["relationshipList"];
            var relatedEntities = {};
            for (var idx in relationList) {
                var relation = relationList[idx];
                var relatedEntity = {};
                relatedEntity["relationshipFields"] = relation.relationshipFields;
                relatedEntity["relationshipType"] = relation.relationshipType;
                relatedEntity["relationshipName"] = relation.relationshipName;
                relatedEntities[relation.relatedEntity] = relatedEntity
            }
            metadata["relatedEntities"] = relatedEntities
        }
        var result = {};
        result["dataModel"] = entityMetaDataMap;
        if (successcallback) successcallback(result)
    };
    MetadataServiceManagerMF.prototype.fetchForAllObjectServices = function(options, metadataOptions, success, error) {
        var self = this;

        function getAllObjectServicesFromSdk() {
            var objectServicesMapFromSdk = voltmx.model.Util.clone(voltmx.sdk.getCurrentInstance().objectsvc);
            if (voltmx.sdk.registeredobjsvcs)
                if (objectServicesMapFromSdk) objectServicesMapFromSdk = voltmx.model.Util.mergeJSONs(objectServicesMapFromSdk, voltmx.sdk.registeredobjsvcs);
                else objectServicesMapFromSdk = voltmx.sdk.registeredobjsvcs;
            var objectServicesNames = [];
            for (var key in objectServicesMapFromSdk) {
                if (key.indexOf("_metadata") === -1) {
                    objectServicesNames.push(key)
                }
            }
            return objectServicesNames
        }
        var objectServicesList = getAllObjectServicesFromSdk();
        var osvIndx = 0;
        self.fetch(options, objectServicesList[osvIndx], metadataOptions, successCbk, errorCbk);

        function successCbk(response) {
            voltmx.model.log.info("SDK metadata Call Success for ObjectService " + objectServicesList[osvIndx]);
            self.apply(response, options, objectServicesList[osvIndx]);
            osvIndx++;
            if (osvIndx >= objectServicesList.length) {
                success(response);
                return
            }
            self.fetch(options, objectServicesList[osvIndx], metadataOptions, successCbk, errorCbk)
        }

        function errorCbk(err) {
            voltmx.model.log.error("error fetching metadata" + JSON.stringify(err));
            error(err)
        }
    };
    MetadataServiceManagerMF.prototype.fetchForObjectService = function(serviceName, options, metadataOptions, success, error) {
        var self = this;
        self.fetch(options, serviceName, metadataOptions, successCbk, errorCbk);

        function successCbk(response) {
            self.apply(response, options, serviceName);
            success(response)
        }

        function errorCbk(err) {
            voltmx.model.log.error("error fetching metadata" + JSON.stringify(err));
            error(err)
        }
    };
    MetadataServiceManagerMF.prototype.fetchForObject = function(serviceName, entityName, options, metadataOptions, success, error) {
        var self = this;
        var objectService = voltmx.model.ApplicationContext.getObjectService(options, serviceName);
        voltmx.model.log.info("Making SDK metadata Call");
        objectService.getMetadataOfObject(entityName, metadataOptions, successCbk, errorCbk);

        function successCbk(response) {
            voltmx.model.log.info("SDK metadata Call Success for Object " + entityName);
            var res = {};
            res[entityName] = response;
            self.apply(res, options, serviceName);
            success(response)
        }

        function errorCbk(err) {
            voltmx.model.log.error("error fetching metadata" + JSON.stringify(err));
            error(err)
        }
    };
    MetadataServiceManagerMF.prototype.execute = function(params, success, error) {
        var scopeObj = this;
        this.fetchForAllObjectServices(params["options"], params["metadataOptions"], fetchSuccess, fetchError);

        function fetchSuccess(response) {
            success(response);
            return
        }

        function fetchError(err) {
            error(err);
            return
        }
    };
    return MetadataServiceManagerMF
}();
voltmx = voltmx || {};
voltmx.model = voltmx.model || {};
voltmx.model.MetadataStore = function() {
    function MetadataStore() {
        var serviceMetadata = {};
        this.getServiceMetadata = function(serviceName, options) {
            return serviceMetadata[serviceName]
        };
        this.setServiceMetadata = function(metadata, serviceName, options) {
            serviceMetadata[serviceName] = metadata
        }
    }
    MetadataStore.prototype.getEntityMetadata = function(entity, serviceName, options) {
        var svcMetadata = this.getServiceMetadata(serviceName, options);
        if (svcMetadata && svcMetadata[entity]) return svcMetadata[entity]
    };
    MetadataStore.prototype.setEntityMetadata = function(metadata, entity, serviceName, options) {
        var svcMetadata = this.getServiceMetadata(serviceName, options);
        if (!svcMetadata) svcMetadata = {};
        svcMetadata[entity] = metadata;
        this.setServiceMetadata(svcMetadata, serviceName, options)
    };
    return MetadataStore
}();
voltmx = voltmx || {};
voltmx.model = voltmx.model || {};
voltmx.model.log = voltmx.model.log || {};
voltmx.model.Util = voltmx.model.Util || {};
if (typeof voltmx.model.log === "undefined") {
    voltmx.model.log = {}
}
voltmx.model.log.NONE = {
    value: 0,
    name: "none",
    code: "NONE"
};
voltmx.model.log.FATAL = {
    value: 1,
    name: "fatal",
    code: "FATAL"
};
voltmx.model.log.ERROR = {
    value: 2,
    name: "error",
    code: "ERROR"
};
voltmx.model.log.WARN = {
    value: 3,
    name: "warn",
    code: "WARN"
};
voltmx.model.log.INFO = {
    value: 4,
    name: "info",
    code: "INFO"
};
voltmx.model.log.DEBUG = {
    value: 5,
    name: "debug",
    code: "DEBUG"
};
voltmx.model.log.TRACE = {
    value: 6,
    name: "trace",
    code: "TRACE"
};
voltmx.model.currentLogLevel = voltmx.model.log.INFO;
voltmx.model.log.trace = function(msg, params) {
    voltmx.model.logger(voltmx.model.log.TRACE, "MVVM", msg, params)
};
voltmx.model.log.debug = function(msg, params) {
    voltmx.model.logger(voltmx.model.log.DEBUG, "MVVM", msg, params)
};
voltmx.model.log.info = function(msg, params) {
    voltmx.model.logger(voltmx.model.log.INFO, "MVVM", msg, params)
};
voltmx.model.log.warn = function(msg, params) {
    voltmx.model.logger(voltmx.model.log.WARN, "MVVM", msg, params)
};
voltmx.model.log.error = function(msg, params) {
    voltmx.model.logger(voltmx.model.log.ERROR, "MVVM", msg, params)
};
voltmx.model.log.fatal = function(msg, params) {
    voltmx.model.logger(voltmx.model.log.FATAL, "MVVM", msg, params)
};
voltmx.model.log.setLogLevel = function(level, logSuccessCallback, logFailureCallback) {
    switch (level) {
        case voltmx.model.log.NONE:
            voltmx.model.currentLogLevel = voltmx.model.log.NONE;
            break;
        case voltmx.model.log.TRACE:
            voltmx.model.currentLogLevel = voltmx.model.log.TRACE;
            break;
        case voltmx.model.log.INFO:
            voltmx.model.currentLogLevel = voltmx.model.log.INFO;
            break;
        case voltmx.model.log.WARN:
            voltmx.model.currentLogLevel = voltmx.model.log.WARN;
            break;
        case voltmx.model.log.ERROR:
            voltmx.model.currentLogLevel = voltmx.model.log.ERROR;
            break;
        case voltmx.model.log.FATAL:
            voltmx.model.currentLogLevel = voltmx.model.log.FATAL;
            break;
        case voltmx.model.log.DEBUG:
            voltmx.model.currentLogLevel = voltmx.model.log.DEBUG;
            break;
        default:
            voltmx.model.log.error("Failed in setting log level " + level);
            logFailureCallback("Failed in setting log level " + level);
            return
    }
    voltmx.model.log.info("Log Level successfully set to " + voltmx.model.currentLogLevel.name);
    logSuccessCallback("Log Level successfully set to " + voltmx.model.currentLogLevel.name)
};
voltmx.model.log.isDebugEnabled = function() {
    return voltmx.model.currentLogLevel.value >= voltmx.model.log.DEBUG.value
};
voltmx.model.log.isTraceEnabled = function() {
    return voltmx.model.currentLogLevel.value >= voltmx.model.log.TRACE.value
};
voltmx.model.log.isInfoEnabled = function() {
    return voltmx.model.currentLogLevel.value >= voltmx.model.log.INFO.value
};
voltmx.model.log.isWarnEnabled = function() {
    return voltmx.model.currentLogLevel.value >= voltmx.model.log.WARN.value
};
voltmx.model.log.isFatalEnabled = function() {
    return voltmx.model.currentLogLevel.value >= voltmx.model.log.FATAL.value
};
voltmx.model.log.isErrorEnabled = function() {
    return voltmx.model.currentLogLevel.value >= voltmx.model.log.ERROR.value
};
voltmx.model.log.isNoneEnabled = function() {
    return voltmx.model.currentLogLevel.value === voltmx.model.log.NONE.value
};
voltmx.model.log.getCurrentLogLevel = function() {
    return voltmx.model.currentLogLevel
};
voltmx.model.Util.isNullOrUndefined = function(val) {
    if (val === null || val === undefined) {
        return true
    } else {
        return false
    }
};
voltmx.model.Util.isValidJs = function(inputTable) {
    if (voltmx.model.Util.isNullOrUndefined(inputTable)) {
        return false
    }
    return voltmx.type(inputTable) === "object" || voltmx.type(inputTable) === "Object" || voltmx.type(inputTable) === "Array"
};
voltmx.model.logger = function(logLevel, tag, msg, params) {
    if (logLevel.value <= voltmx.model.currentLogLevel.value) {
        params = typeof params === "undefined" ? "" : params;
        if (tag === undefined || tag === null) {
            tag = "AFN"
        }
        if (voltmx.model.Util.isValidJs(params)) {
            params = voltmx.model.Util.stringifyObject(params)
        }
        var date = (new Date).toLocaleDateString();
        var time = (new Date).toLocaleTimeString();
        var level = logLevel.code;
        var formattedMessage = "[" + date + "][" + time + "][" + tag + "][" + level + "] : " + msg + " " + params;
        if (voltmx.model.error_alert && logLevel.value == voltmx.model.log.ERROR.value) alert(formattedMessage);
        voltmx.print(formattedMessage)
    }
};
voltmx.model.Util.stringifyObject = function(obj) {
    var str;
    try {
        if (obj instanceof Error || obj instanceof voltmx.model.Exception) {
            str = obj.toString()
        } else {
            str = JSON.stringify(obj)
        }
    } catch (e) {
        str = ""
    }
    return str
};
voltmx.model.print = function(statement) {
    if (typeof voltmx !== "undefined" && typeof voltmx.print === "function") {
        voltmx.print(statement)
    } else if (typeof console !== "undefined" && typeof console.log === "function") {
        console.log(statement)
    }
};
voltmx = voltmx || {};
voltmx.model = voltmx.model || {};
voltmx.model.DataAccessAppsExceptionCode = {
    CD_ERROR_10000: 1e4,
    CD_ERROR_10001: 10001,
    CD_ERROR_10002: 10002,
    CD_ERROR_10003: 10003,
    CD_ERROR_10004: 10004,
    CD_ERROR_10005: 10005,
    CD_ERROR_10006: 10006,
    CD_ERROR_10007: 10007,
    CD_ERROR_10008: 10008,
    CD_ERROR_10009: 10009,
    CD_ERROR_10010: 10010,
    CD_ERROR_10011: 10011,
    CD_ERROR_10012: 10012,
    CD_ERROR_10013: 10013,
    CD_ERROR_10014: 10014,
    CD_ERROR_10015: 10015,
    CD_ERROR_10016: 10016,
    CD_ERROR_10017: 10017,
    CD_ERROR_10018: 10018,
    CD_ERROR_10019: 10019,
    CD_ERROR_10020: 10020,
    CD_ERROR_10021: 10021,
    CD_ERROR_10022: 10022,
    CD_ERROR_10023: 10023,
    CD_ERROR_10024: 10024,
    CD_ERROR_10025: 10025,
    CD_ERROR_10026: 10026,
    CD_ERROR_10027: 10027,
    CD_ERROR_10028: 10028,
    CD_ERROR_10029: 10029,
    CD_ERROR_10030: 10030,
    CD_ERROR_10031: 10031,
    CD_ERROR_10032: 10032,
    CD_ERROR_10033: 10033,
    CD_ERROR_10034: 10034,
    CD_ERROR_10035: 10035,
    CD_ERROR_10036: 10036,
    CD_ERROR_10037: 10037,
    CD_ERROR_10038: 10038,
    CD_ERROR_10039: 10039,
    CD_ERROR_10040: 10040,
    CD_ERROR_10041: 10041,
    CD_ERROR_10042: 10042,
    CD_ERROR_10043: 10043,
    CD_ERROR_10044: 10044,
    CD_ERROR_10045: 10045,
    CD_ERROR_10046: 10046,
    CD_ERROR_10047: 10047,
    CD_ERROR_10048: 10048,
    CD_ERROR_10049: 10049,
    CD_ERROR_10050: 10050,
    CD_ERROR_10051: 10051,
    CD_ERROR_10052: 10052,
    CD_ERROR_10053: 10053,
    CD_ERROR_10054: 10054,
    CD_ERROR_10055: 10055,
    CD_ERROR_10056: 10056,
    CD_ERROR_10057: 10057,
    CD_ERROR_10058: 10058,
    CD_ERROR_10059: 10059,
    CD_ERROR_10060: 10060,
    CD_ERROR_10061: 10061,
    CD_ERROR_10062: 10062,
    CD_ERROR_10063: 10063,
    CD_ERROR_10064: 10064,
    CD_ERROR_10065: 10065,
    CD_ERROR_10066: 10066,
    CD_ERROR_10067: 10067,
    CD_ERROR_10068: 10068,
    CD_ERROR_10069: 10069,
    CD_ERROR_10070: 10070,
    CD_ERROR_10071: 10071,
    CD_ERROR_10072: 10072,
    CD_ERROR_10073: 10073,
    CD_ERROR_10074: 10074,
    CD_ERROR_10075: 10075,
    CD_ERROR_10076: 10076,
    CD_ERROR_10077: 10077,
    CD_ERROR_10078: 10078,
    CD_ERROR_10079: 10079,
    CD_ERROR_10080: 10080,
    CD_ERROR_10081: 10081,
    CD_ERROR_10082: 10082,
    CD_ERROR_10083: 10083,
    CD_ERROR_10084: 10084,
    CD_ERROR_10085: 10085,
    CD_ERROR_10086: 10086,
    CD_ERROR_10087: 10087,
    CD_ERROR_10088: 10088,
    CD_ERROR_10089: 10089,
    CD_ERROR_10090: 10090,
    CD_ERROR_10091: 10091,
    CD_ERROR_10092: 10092,
    CD_ERROR_10094: 10094,
    CD_ERROR_10095: 10095,
    CD_ERROR_10096: 10096,
    CD_ERROR_10097: 10097,
    CD_ERROR_10098: 10098,
    CD_ERROR_10099: 10099,
    CD_ERROR_10100: 10100,
    CD_ERROR_10101: 10101,
    CD_ERROR_10102: 10102,
    CD_ERROR_10104: 10104,
    CD_ERROR_10105: 10105,
    CD_ERROR_10106: 10106,
    CD_ERROR_10108: 10108,
    CD_ERROR_10109: 10109,
    CD_ERROR_10110: 10110,
    CD_ERROR_10111: 10111,
    CD_ERROR_10112: 10112,
    CD_ERROR_10113: 10113,
    CD_ERROR_10114: 10114,
    CD_ERROR_10115: 10115,
    CD_ERROR_10116: 10116,
    CD_ERROR_10117: 10117,
    CD_ERROR_10118: 10118,
    CD_ERROR_10119: 10119,
    CD_ERROR_10120: 10120,
    CD_ERROR_10121: 10121,
    CD_ERROR_10122: 10122,
    CD_ERROR_10123: 10123,
    CD_ERROR_10124: 10124,
    CD_ERROR_10125: 10125,
    CD_ERROR_10126: 10126,
    CD_ERROR_10127: 10127,
    CD_ERROR_10128: 10128,
    CD_ERROR_10129: 10129,
    CD_ERROR_10130: 10130,
    CD_ERROR_10131: 10131,
    CD_ERROR_10132: 10132,
    CD_ERROR_10133: 10133,
    CD_ERROR_10134: 10134,
    CD_ERROR_10135: 10135,
    CD_ERROR_10136: 10136,
    CD_ERROR_10137: 10137,
    CD_ERROR_10138: 10138,
    CD_ERROR_10139: 10139,
    CD_ERROR_10140: 10140,
    CD_ERROR_10141: 10141,
    CD_ERROR_10142: 10142,
    CD_ERROR_10143: 10143,
    CD_ERROR_10144: 10144,
    CD_ERROR_10145: 10145,
    CD_ERROR_10146: 10146,
    CD_ERROR_10147: 10147,
    CD_ERROR_10148: 10148,
    CD_ERROR_10149: 10149,
    MSG_ERROR_10000: "Unable to execute delete query",
    MSG_ERROR_10001: "SQLLite Error occurred",
    MSG_ERROR_10002: "Invalid Table configuration in the Database",
    MSG_ERROR_10003: "Entity does not exist in the Database",
    MSG_ERROR_10004: "There is no relationship/definiton defined for the Entity in Enterprise DB",
    MSG_ERROR_10005: "Invalid column name",
    MSG_ERROR_10006: "Column does not exist in the Database",
    MSG_ERROR_10007: "Unable to execute Insert query",
    MSG_ERROR_10008: "Specified column datatype doesnot match with datatype from field mapping",
    MSG_ERROR_10009: "Unique constraint check failed as the data already exist in DB",
    MSG_ERROR_10010: "Specified foreign key is not found",
    MSG_ERROR_10011: "Unable to execute Select query",
    MSG_ERROR_10012: "Invalid Meta Column Name Usage. Correct usage is COLUMNNAME__f",
    MSG_ERROR_10013: "Invalid Meta Column Name Usage in Join Clause. Correct usage is COLUMNNAME__f",
    MSG_ERROR_10014: "Unable to execute update query",
    MSG_ERROR_10015: "No columns specified for updating",
    MSG_ERROR_10016: "Column name either null or empty in update builder",
    MSG_ERROR_10017: "Specified foreign key is not found, Rolled back transaction",
    MSG_ERROR_10018: "Value is null",
    MSG_ERROR_10019: "Column data type does not match the value",
    MSG_ERROR_10020: "No columns specified for update",
    MSG_ERROR_10021: "Invalid table name",
    MSG_ERROR_10022: "Connection NOT created from pool",
    MSG_ERROR_10023: "User id invalid",
    MSG_ERROR_10024: "Invalid arguments to com.kony.common.DataAccess.Query.Between Constructor",
    MSG_ERROR_10025: "Invalid arguments to setColumn of com.kony.common.DataAccess.Query.Between",
    MSG_ERROR_10026: "Invalid arguments to setRange of com.kony.common.DataAccess.Query.Between",
    MSG_ERROR_10027: "Invalid Column name passed to com.kony.common.DataAccess.Query.Column Constructor .\nExpected:Table\nActual:",
    MSG_ERROR_10028: "Invalid data type for the attribute in com.kony.common.DataAccess.Query.Column Constructor",
    MSG_ERROR_10029: "Invalid ColumnName to SetName of com.kony.common.DataAccess.Query.Column",
    MSG_ERROR_10030: "Invalid arguments to setTable of com.kony.common.DataAccess.Query.Column",
    MSG_ERROR_10031: "Invalid arguments to com.kony.common.DataAccess.Query.Range.DateRange Constructor",
    MSG_ERROR_10032: "Invalid arguments to setEnd of com.kony.common.DataAccess.Query.Range.DateRange",
    MSG_ERROR_10033: "Invalid arguments to setStart of com.kony.common.DataAccess.Query.Range.DateRange",
    MSG_ERROR_10034: "Invalid arguments to com.kony.common.DataAccess.Query.Range.DecimalRange Constructor",
    MSG_ERROR_10035: "Invalid arguments to setEnd of com.kony.common.DataAccess.Query.Range.DecimalRange",
    MSG_ERROR_10036: "Invalid arguments to setStart of com.kony.common.DataAccess.Query.Range.DecimalRange",
    MSG_ERROR_10037: "Invalid data type for the attribute subSelect in com.kony.common.DataAccess.Query.Exists Constructor \nExpected:SelectQuery\nActual:",
    MSG_ERROR_10038: "Invalid data type for the attribute subSelect in com.kony.common.DataAccess.Query.Exists.prototype.setSubSelect \nExpected:SelectQuery\nActual:",
    MSG_ERROR_10039: "Invalid arguments to com.kony.common.DataAccess.Query.Expression Constructor",
    MSG_ERROR_10040: "Invalid number of arguments to com.kony.common.DataAccess.Query.Expression",
    MSG_ERROR_10041: "Invalid Operator type passed to com.kony.common.DataAccess.Query.Expression",
    MSG_ERROR_10042: "Invalid arguments for the attribute com.kony.common.DataAccess.Query.Expression initExpression",
    MSG_ERROR_10043: "Invalid arguments for the attribute com.kony.common.DataAccess.Query.Expression setExpression",
    MSG_ERROR_10044: "Invalid arguments for the attribute com.kony.common.DataAccess.Query.Expression setTerm",
    MSG_ERROR_10045: "Invalid arguments to setEnd of com.kony.common.DataAccess.Query.Range.FloatRange",
    MSG_ERROR_10046: "Invalid arguments to setStart of com.kony.common.DataAccess.Query.Range.FloatRange",
    MSG_ERROR_10047: "Invalid argument for the attribute in com.kony.common.DataAccess.Query.Group",
    MSG_ERROR_10048: "Invalid arguments for the attribute in com.kony.common.DataAccess.Query.Group.prototype.setColumn",
    MSG_ERROR_10049: "Invalid number of arguments passed to com.kony.common.DataAccess.Query.InCriteria",
    MSG_ERROR_10050: "Invalid arguments for getInCriteriaByTableAndCollection in com.kony.common.DataAccess.Query.InCriteria",
    MSG_ERROR_10051: "Invalid arguments for getInCriteriaByColumnAndCollection in com.kony.common.DataAccess.Query.InCriteria",
    MSG_ERROR_10052: "Invalid arguments for getColumnForTable in com.kony.common.DataAccess.Query.InCriteria",
    MSG_ERROR_10053: "Invalid arguments to com.kony.common.DataAccess.Query.Range.IntegerRange Constructor",
    MSG_ERROR_10054: "Invalid arguments to setEnd of com.kony.common.DataAccess.Query.Range.IntegerRange",
    MSG_ERROR_10055: "Invalid arguments to setStart of com.kony.common.DataAccess.Query.Range.IntegerRange",
    MSG_ERROR_10056: "Invalid arguments passed for  com.kony.common.DataAccess.Query.Join",
    MSG_ERROR_10057: "Invalid arguments passed for the method in com.kony.common.DataAccess.Query.Join",
    MSG_ERROR_10058: "Invalid arguments passed for the method setCriteria in com.kony.common.DataAccess.Query.Join",
    MSG_ERROR_10059: "Invalid arguments passed for the method setTable in com.kony.common.DataAccess.Query.Join",
    MSG_ERROR_10060: "Invalid arguments passed for the method setJoinType in com.kony.common.DataAccess.Query.Join",
    MSG_ERROR_10061: "Invalid arguments passed for the method initCriteria in com.kony.common.DataAccess.Query.Join",
    MSG_ERROR_10062: "Insufficient input passed to com.kony.common.DataAccess.Query.And Constructor",
    MSG_ERROR_10063: "Invalid data type for com.kony.common.DataAccess.Query.And Expected value Criteria",
    MSG_ERROR_10064: "Insufficient input passed to com.kony.common.DataAccess.Query.Or Constructor",
    MSG_ERROR_10065: "Invalid data type for com.kony.common.DataAccess.Query.Or Expected value Criteria",
    MSG_ERROR_10066: "Insufficient input passed to com.kony.common.DataAccess.Query.Not Constructor",
    MSG_ERROR_10067: "Invalid data type for com.kony.common.DataAccess.Query.Not Expected value Criteria",
    MSG_ERROR_10068: "Invalid match type passed in com.kony.common.DataAccess.Query.Match.prototype.initMatchByColumn",
    MSG_ERROR_10069: "Invalid value passed in com.kony.common.DataAccess.Query.Match.prototype.initMatchByColumn",
    MSG_ERROR_10070: "Invalid arguments passed for the method initMatchByColumn in com.kony.common.DataAccess.Query.Match.prototype.initMatchByColumn.",
    MSG_ERROR_10071: "Invalid match type passed in com.kony.common.DataAccess.Query.Match.prototype.initMatchByTableAndColName",
    MSG_ERROR_10072: "Invalid value passed in com.kony.common.DataAccess.Query.Match.prototype.initMatchByTableAndColName",
    MSG_ERROR_10073: "Invalid columnName passed in com.kony.common.DataAccess.Query.Match.prototype.initMatchByTableAndColName",
    MSG_ERROR_10074: "Invalid arguments passed for the method initMatchByTableAndColName in com.kony.common.DataAccess.Query.Match",
    MSG_ERROR_10075: "Match object not initialized properly  in com.kony.common.DataAccess.Query.Match",
    MSG_ERROR_10076: "Invalid arguments passed for the constructor in com.kony.common.DataAccess.Query.Order",
    MSG_ERROR_10077: "Invalid arguments for the method setColumn in com.kony.common.DataAccess.Query.Order",
    MSG_ERROR_10078: "Invalid arguments to com.kony.common.DataAccess.Query.Range.StringRange Constructor",
    MSG_ERROR_10079: "Invalid arguments to setEnd of com.kony.common.DataAccess.Query.Range.StringRange",
    MSG_ERROR_10080: "Invalid arguments to setStart of com.kony.common.DataAccess.Query.Range.StringRange",
    MSG_ERROR_10081: "Invalid Arguments passed to DeleteBuilder.addCriteria",
    MSG_ERROR_10082: "Invalid data type for the attribute in DeleteBuilder.addCriteria. Expected: Criteria | Actual:",
    MSG_ERROR_10083: "Invalid data type for the attribute in DeleteBuilder . Expected: Table | Actual:",
    MSG_ERROR_10084: "Invalid data type for the attribute in com.kony.common.DataAccess.Query.InsertQuery .\nExpected:Table\nActual:",
    MSG_ERROR_10085: "Invalid data type for the attribute in com.kony.common.DataAccess.Query.InsertQuery.prototype.addColumn .\nExpected:Column\nActual:",
    MSG_ERROR_10086: "Invalid data type for the attribute in com.kony.common.DataAccess.Query.InsertQuery.prototype.addColumnToTable .\nExpected:String\nActual:",
    MSG_ERROR_10087: "Invalid data type for the attribute in com.kony.common.DataAccess.Query.InsertQuery.prototype.addColumnToTable .\nExpected:Table\nActual:",
    MSG_ERROR_10088: "Invalid data type for the attribute in com.kony.common.DataAccess.Query.InsertQuery.prototype.removeColumn .\nExpected:Table\nActual:",
    MSG_ERROR_10089: "Invalid Arguments passed to SelectBuilder",
    MSG_ERROR_10090: "Invalid data type for the attribute in SelectBuilder .\nExpected:Table\nActual:",
    MSG_ERROR_10091: "Invalid Arguments passed to selectBuilder.addColumn",
    MSG_ERROR_10092: "Invalid data type for the attribute in selectBuilder.addColumn .\nExpected:Column\nActual:",
    MSG_ERROR_10094: "Invalid data type for the attribute in SelectBuilder.\nExpected:Table\nActual:",
    MSG_ERROR_10095: "Invalid Arguments of Alias passed to selectBuilder ",
    MSG_ERROR_10096: "Invalid data type for the attribute in selectBuilder.\nExpected:Table\nActual:",
    MSG_ERROR_10097: "Invalid Arguments passed to selectBuilder.addCriteria",
    MSG_ERROR_10098: "Invalid data type for the attribute in selectBuilder.addCriteria .\nExpected:Criteria\nActual:",
    MSG_ERROR_10099: "Invalid Arguments passed to selectBuilder.addGroup",
    MSG_ERROR_10100: "Invalid data type for the attribute in selectBuilder.addGroup .\nExpected:Group\nActual:",
    MSG_ERROR_10101: "Invalid Arguments passed to selectBuilder.addJoin",
    MSG_ERROR_10102: "Invalid data type for the attribute in SelectBuilder.addJoin .\nExpected:Criteria\nActual:",
    MSG_ERROR_10104: "Invalid data type for the attribute in SelectBuilder",
    MSG_ERROR_10105: "Invalid Arguments passed to selectBuilder.addOrder",
    MSG_ERROR_10106: "Invalid data type for the attribute in selectBuilder.addOrder \nExpected:Order\nActual:",
    MSG_ERROR_10108: "Invalid data type for the attribute in SelectBuilder \nExpected:Table\nActual:",
    MSG_ERROR_10109: "Invalid Arguments passed to selectBuilder.removeColumn",
    MSG_ERROR_10110: "Invalid data type for the attribute in selectBuilder.removeColumn \nExpected:Column\nActual:",
    MSG_ERROR_10111: "Invalid Arguments passed to selectBuilder.removeCriteria",
    MSG_ERROR_10112: "Invalid data type for the attribute in selectBuilder.removeCriteria \nExpected:Criteria\nActual:",
    MSG_ERROR_10113: "Invalid Arguments passed to selectBuilder.removeGroup",
    MSG_ERROR_10114: "Invalid data type for the attribute in selectBuilder.removeGroup \nExpected:Group\nActual:",
    MSG_ERROR_10115: "Invalid Arguments passed to selectBuilder.removeJoin",
    MSG_ERROR_10116: "Invalid data type for the attribute in selectBuilder.removeJoin \nExpected:Group\nActual:",
    MSG_ERROR_10117: "Invalid data type for the attribute in SelectBuilder \nExpected:Group\nActual:",
    MSG_ERROR_10118: "Invalid Arguments passed to UpdateQuery",
    MSG_ERROR_10119: "Invalid data type for the attribute in UpdateQuery .\nExpected:Table\nActual:",
    MSG_ERROR_10120: "Invalid Arguments passed to UpdateBuilder.addColumn method",
    MSG_ERROR_10121: "Invalid data type for the attribute in UpdateBuilder.addColumn method",
    MSG_ERROR_10122: "Invalid Arguments passed to UpdateBuilder.addColumnByColumnNameAndValue",
    MSG_ERROR_10123: "Invalid data type for the attribute in UpdateBuilder.addColumnByColumnNameAndValue",
    MSG_ERROR_10124: "Invalid Arguments passed to UpdateBuilder.addCriteria",
    MSG_ERROR_10125: "Invalid data type for the attribute in UpdateBuilder.addCriteria .\nExpected:Criteria\nActual:",
    MSG_ERROR_10126: "Invalid Arguments passed to UpdateBuilder.removeCriteria",
    MSG_ERROR_10127: "Invalid data type for the attribute in UpdateBuilder.removeCriteria .\nExpected:Criteria\nActual:",
    MSG_ERROR_10128: "Invalid Arguments passed to UpdateBuilder",
    MSG_ERROR_10129: "Invalid data type for the attribute in UpdateBuilder .\nExpected:Table\nActual:",
    MSG_ERROR_10130: "Invalid number of arguments to com.kony.common.DataAccess.Query.InsertQuery.prototype.addColumn",
    MSG_ERROR_10131: "unknown database error occured. please verify the table and columns names.",
    MSG_ERROR_10132: "No parent keys found.",
    MSG_ERROR_10133: "field object is empty",
    MSG_ERROR_10134: "Given JoinType doesn't support",
    MSG_ERROR_10135: "Cannot insert record as the integrity failed with",
    MSG_ERROR_10136: "error occurred during language fetch",
    MSG_ERROR_10137: "No logical fields exist for the table",
    MSG_ERROR_10138: "unknown database error occured. please verify the table and column names/values.",
    MSG_ERROR_10139: "Invalid number of arguments to com.kony.common.DataAccess.Query.Match",
    MSG_ERROR_10140: "Invalid number of arguments to com.kony.common.DataAccess.Query.Join",
    MSG_ERROR_10141: "Entity with name doesn't exist",
    MSG_ERROR_10142: "Invalid Meta Column Name Usage, Correct usage COLUMNNAME__f",
    MSG_ERROR_10143: "Table does not exist in the database",
    MSG_ERROR_10144: "Column does not exist in table",
    MSG_ERROR_10145: "Table is undefined.Please provide valid table name",
    MSG_ERROR_10146: "Invalid Arguments passed to DeleteBuilder",
    MSG_ERROR_10147: "Invalid Arguments passed to InsertBuilder",
    MSG_ERROR_10148: "No data found to update with the selected criteria",
    MSG_ERROR_10149: "The request could not be completed."
};
voltmx.model.Exception = function() {
    function toStringRecursive(exception, output) {
        var intermOutput;
        if (exception == undefined) return output.append("");
        if (exception.getErrorObj()) {
            if (exception.getErrorObj().name && exception.getErrorObj().message) output.append(exception.getErrorObj().name + ": " + exception.getErrorObj().message + ": " + exception.getErrorObj().sourceURL);
            else output.append(JSON.stringify(exception.getErrorObj()));
            output.append("\n");
            return output.append(exception.code + ":" + exception.message + "\n")
        }
        intermOutput = toStringRecursive(exception.exceptionObj, output);
        intermOutput.append(exception.code + ":" + exception.message);
        intermOutput.append("\n");
        return intermOutput
    }

    function getRootErrObj(exception) {
        if (exception && exception.exceptionObj != undefined && exception.getErrorObj() == undefined) {
            var intermErrObj = getRootErrObj(exception.exceptionObj);
            return intermErrObj
        } else if (exception && exception.exceptionObj == undefined && exception.getErrorObj() != undefined) {
            return exception.getErrorObj()
        } else {
            return undefined
        }
    }

    function Exception(code, message, exceptionObj) {
        this.code = typeof code === "number" ? code : -1;
        this.message = typeof message === "string" ? message : "";
        this.name = "Exception";
        var actualErrorObj;
        if (exceptionObj instanceof voltmx.model.Exception) {
            this.exceptionObj = exceptionObj;
            actualErrorObj = undefined
        } else {
            actualErrorObj = exceptionObj;
            this.exceptionObj = undefined
        }
        this.getErrorObj = function() {
            return actualErrorObj
        };
        this.getParentException = function() {
            return this.exceptionObj
        }
    }
    inheritsFrom(Exception, Error);
    Exception.prototype.toString = function() {
        var output = new voltmx.model.Util.StringBuffer;
        output = toStringRecursive(this, output);
        return output.toString()
    };
    Exception.prototype.alert = function(full) {
        if (full === true) {
            var output = new voltmx.model.Util.StringBuffer;
            output = toStringRecursive(this, output);
            alert(output.toString())
        } else alert(this.code + ":" + this.name + ":" + this.message)
    };
    Exception.prototype.setSyncResponse = function(response) {
        this.syncresponse = response
    };
    Exception.prototype.getRootErrorObj = function() {
        var rootErrObj = getRootErrObj(this);
        return rootErrObj
    };
    return Exception
}();
voltmx.model.ExceptionCode = {
    CD_ERROR_LOADING_TEMPLATES: 3,
    CD_ERROR_FAILED_TO_CREATE_RECORD: 9,
    CD_ERROR_FAILED_TO_UPDATE_RECORD: 10,
    CD_ERROR_CALLBACK_NOT_A_FUNCTION: 11,
    CD_ERROR_LOGIN_FAILURE: 12,
    CD_ERROR_SESSION_TOKEN_INVALID: 13,
    CD_ERROR_FAILED_TO_SAVE_FORM: 14,
    CD_ERROR_FAILED_TO_FETCH_DATA: 15,
    CD_ERROR_FAILED_TO_INITIALIZE_FORM: 16,
    CD_ERROR_FETCHING_METADATA: 17,
    CD_ERROR_MORE_RECORDS_FOUND: 18,
    CD_ERROR_FETCHING_TEMPLATES: 19,
    CD_ERROR_FETCHING_FORMS: 20,
    CD_ERROR_INITIALIZING_UI_CONFIG_DATA_PROVIDER: 21,
    CD_ERROR_INITIALIZING_METADATA_PROVIDER: 22,
    CD_ERROR_INITIALIZING_DATA_PROVIDER: 23,
    CD_ERROR_FAILED_TO_LOAD_APPLICATION: 24,
    CD_ERROR_APP_INITIALIZATION_FAILED: 25,
    CD_ERROR_INITIALIZING_SAAS_APP: 26,
    CD_ERROR_FORMVIEWCONTROLLER_NOT_FOUND: 27,
    CD_ERROR_NAVIGATION_STACK_EMPTY: 28,
    CD_ERROR_FORM_NOT_FOUND: 29,
    CD_ERROR_METADATA_FOR_ENTITY_NOT_FOUND: 30,
    CD_ERROR_NO_FIELDS_MODIFIED_UPDATE_FAILED: 31,
    CD_ERROR_PRIMARY_FIELD_VALUE_NOT_FOUND: 32,
    CD_ERROR_UNDEFINED_WIDGET_CONTROLLER: 33,
    CD_ERROR_FAILED_TO_LOGOUT: 35,
    CD_ERROR_FAILED_LOADING_MASTER_DATA: 36,
    CD_ERROR_FAILED_TO_NAVIGATE_TO_FORM: 37,
    CD_ERROR_PARSING_JSONS: 38,
    CD_ERROR_FAILED_LOADING_FORMS: 39,
    CD_ERROR_FAILED_FORM_INIT_WHILE_CALLBACK: 40,
    CD_ERROR_KONY_FORM_OBJECT_UNDEFINED: 41,
    CD_ERROR_SAVE_CANNOT_SET_PRIMARY_KEY: 42,
    CD_ERROR_FETCH_FAILED_FOR_CHILD_ENTITY: 43,
    CD_ERROR_GET_NEXT_LIST: 44,
    CD_ERROR_UNSUPPORTED_SEGMENT_TYPE: 45,
    CD_ERROR_NOT_INHERITING_VIEW_CONTROLLER: 46,
    CD_ERROR_NOT_INHERITING_WIDGET_CONTROLLER: 47,
    CD_ERROR_FAILED_BINDING_DATA_TO_WIDGET: 48,
    CD_ERROR_PAGINATION_NOT_ENABLED_FOR_SEGMENT: 49,
    CD_ERROR_PARAM_VALUE_NOT_DEFINED_IN_QUERYPARAM: 50,
    CD_ERROR_BRACES_ARE_NOT_DEFINED_PROPERLY: 51,
    CD_ERROR_ADDITIONAL_FIELDS_ARE_NOT_DEFINED_PROPERLY: 52,
    CD_ERROR_QUERY_NOT_DEFINED_PROPERLY: 53,
    CD_ERROR_QUERYPARAMS_NOT_DEFINED_PROPERLY: 54,
    CD_ERROR_MATCHOPERATOR_NOT_DEFINED_PROPERLY: 55,
    CD_ERROR_DATA_VALIDATION_FIELD_NOT_CREATEABLE: 56,
    CD_ERROR_DATA_VALIDATION_FIELD_NOT_UPDATEABLE: 57,
    CD_ERROR_DATA_VALIDATION_FIELD_NOT_NULLABLE: 58,
    CD_ERROR_DATA_VALIDATION_INVALID_INPUT_DATA: 59,
    CD_ERROR_DATA_VALIDATION_INVALID_MODEL: 60,
    CD_ERROR_DATA_VALIDATION_INVALID_ENTITY: 61,
    CD_ERROR_DATA_VALIDATION_ENTITYMETADATA_NOTFOUND: 62,
    CD_ERROR_CREATING_APPMENU: 63,
    CD_ERROR_FETCHING_APPMENU_DATA: 64,
    CD_ERROR_FIELD_NOT_PRESENT: 65,
    cd_ERROR_ENITTY_NOT_PRESENT: 66,
    CD_TENANT_NOT_SYNC_ENABLED: 67,
    CD_INVALID_QUERY: 68,
    CD_ERROR_FETCH_USER_PROFILE_FAILURE: 69,
    CD_RESOURCE_NO_CREATE_PERMISSION: 74,
    CD_RESOURCE_NO_READ_PERMISSION: 75,
    CD_RESOURCE_NO_UPDATE_PERMISSION: 76,
    CD_RESOURCE_NO_DELETE_PERMISSION: 77,
    CD_ERROR_OFFLINE_LOGIN_FAILURE: 70,
    CD_ERROR_UNABLE_TO_SYNC: 71,
    CD_ERROR_UNABLE_TO_GET_SYNC_CONFIG: 72,
    CD_ERROR_UNABLE_TO_RESET_SYNC: 73,
    CD_ERROR_NO_RESPONSE_RECEIVED: 78,
    CD_ERROR_NETWORK_UNAVAILABLE: 79,
    CD_ERROR_IN_SET_ADDITIONAL_FIELDS: 80,
    CD_ERROR_IN_SET_QUERY: 81,
    CD_ERROR_IN_SET_QUERY_PARAMS: 82,
    CD_ERROR_ENTER_VALID_TENANT_NAME: 83,
    CD_ERROR_NAVIGATION_CONTROLLER_NOT_DEFINED: 84,
    CD_ERROR_ENTITY_NOT_SPECIFIED: 85,
    CD_ERROR_FORMTYPE_NOT_SPECIFIED: 86,
    CD_ERROR_FORM_NOT_DEFINED_FOR_RECORDTYPE: 87,
    CD_ERROR_RECORDTYPES_NOT_AVAILABLE: 88,
    CD_ERROR_FORMSFORRECORDTYPES_MAP_NOT_DEFINED: 89,
    CD_ERROR_SAAS_INSTANCE_NOTDEFINED: 90,
    CD_ERROR_INVALID_ENTITY: 91,
    CD_VERSION_UNSUPPORTED_ERROR: 92,
    CD_ERROR_ASSOCIATING_RECORD: 93,
    CD_ERROR_DISOCIATING_RECORD: 94,
    CD_ERROR_NOT_INSTANCE_OF_CUSTOMINFO: 95,
    CD_ERROR_FORM_ENTITY_NOT_FOUND: 96,
    CD_ERROR_FORM_PRIMARY_FIELDVALUE_NOT_FOUND: 97,
    CD_ERROR_CANNOT_ASSOCIATE_DISSOCIATE_OF_SAME_ENTITY: 98,
    CD_ERROR_SAVING_MULTI_ENTITY_LABEL: 99,
    CD_ERROR_SAVING_CHILD_CONTAINER: 100,
    CD_ERROR_DECODING_BASE64_FORMJS: 102,
    CD_ERROR_BATCH_INSERT: 103,
    CD_ERROR_LOCAL_DB_CONNECTION: 104,
    CD_ERROR_EXECUTE_SINGLE_SQL_QUERY: 105,
    CD_UPGRADE_UNAVAILABLE: 106,
    CD_ERROR_I18N: 107,
    CD_INVALID_LOGIN_HANDLER_RESPONSE: 108,
    CD_ERROR_FAILED_TO_QUERY_DATA: 109,
    CD_ERROR_LOADING_THEME: 110,
    CD_ERROR_SETTING_THEME: 111,
    CD_ERROR_FETCHING_THEME: 112,
    CD_ERROR_MULTIPLE_DEFAULT_THEME: 113,
    CD_ERROR_CREATING_THEME: 114,
    CD_ERROR_METHOD_INVALID: 115,
    CD_ERROR_INVALID_HTTPCUSTOMREQUEST_INPUT: 116,
    CD_ERROR_INVALID_INPUT: 117,
    CD_ERROR_INVALID_INPUT_TYPE: 118,
    CD_ERROR_INVALID_PAYLOAD: 119,
    CD_ERROR_INVALID_DATAPROVIDER_TYPE: 120,
    CD_ERROR_DATAPROVIDER_NOT_INTIALIZED: 121,
    CD_ERROR_INVALID_CUSTOMSERVICE_INPUT_PARAM: 122,
    CD_ERROR_UNEXPECTED_CUSTOMRESPONSE: 123,
    CD_CLOUD_UNAUTHORISED_FOR_DATAPROVIDER: 124,
    CD_CREDSTORE_NOT_FOUND: 125,
    CD_CREDENTIAL_MISMATCH_WITH_CREDSTORE: 126,
    CD_ERROR_TENANT_NOT_SPECIFIED: 50003,
    CD_ERROR_UNABLE_TO_CONNECT: 50004,
    CD_ERROR_SYNC_FAILURE: 50005,
    CD_ERROR_LANDING_PAGE_NOT_DEFINED: 50007,
    CD_ERROR_INVALID_PARAM1: 50008,
    CD_ERROR_ENTITY_CONTROLLER_NOT_DEFINED: 10001,
    CD_ERROR_IN_ENTITY_DEFINITION: 10002,
    CD_ERROR_IN_RETREIVNING_CHILD_RELATIONSHIPLIST: 10003,
    CD_ERROR_FETCHING_DATA_FOR_COLUMNS: 10004,
    CD_ERROR_FETCHING_CHILD_RELATIONSHP_FOR_ENTITY: 10005,
    CD_ERROR_PROCESSING_CHILD_RELATIONSHIPLIST: 10006,
    CD_ERROR_FETCH: 10007,
    CD_ERROR_CREATE: 10008,
    CD_ERROR_UPDATE: 10009,
    CD_ERROR_UPDATE_BY_PRIMARY_KEY: 10010,
    CD_ERROR_DELETE: 10011,
    CD_ERROR_DELETE_BY_PRIMARY_KEY: 10012,
    CD_ERROR_VALIDATION_UPDATE: 10013,
    CD_ERROR_VALIDATION_CREATE: 10014,
    CD_ERROR_GET_WIDGET_DATA_FORMMODEL: 20001,
    CD_ERROR_SET_WIDGET_DATA_FORMMODEL: 20002,
    CD_ERROR_FORMMODEL_PROPERTY_VALUE_CHANGED: 20003,
    CD_ERROR_FORMMODEL_CLEAR: 20004,
    CD_ERROR_FORMMODEL_DESTROY: 20005,
    CD_ERROR_FORMMODEL_UPDATE: 20006,
    CD_ERROR_FORMMODEL_SHOWVIEW: 20007,
    CD_ERROR_FORMMODEL_SET_MASTERDATA: 20008,
    CD_ERROR_FORMMODEL_GET_MASTERDATA: 20009,
    CD_ERROR_FORMMODEL_SET_VIEW_ATTRIBUTE: 20010,
    CD_ERROR_FORMMODEL_GET_VIEW_ATTRIBUTE: 20011,
    CD_ERROR_FORMMODEL_PERFORM_ACTION_ONVIEW: 20012,
    CD_ERROR_FORMMODEL_PERFORM_ACTION: 20013,
    CD_ERROR_NOTIFYING_OBSERVERS: 20014,
    CD_ERROR_FORMMODEL_PROPERTIES_INIT: 20015,
    CD_ERROR_FETCH_IN_CONTROLLER: 30001,
    CD_ERROR_BIND_IN_CONTROLLER: 30002,
    CD_ERROR_SAVE_IN_CONTROLLER: 30003,
    CD_ERROR_DELETE_IN_CONTROLLER: 30004,
    CD_ERROR_LOADDATA_SHOWFORM_CONTROLLER: 30005,
    CD_ERROR_GETTING_ENTITY_CONTROLLER: 30006,
    CD_ERROR_GETTING_ENTITY_METADATA: 30007,
    CD_ERROR_FETCH_IN_BASE_CONTROLLER_EXTENSION: 30008,
    CD_ERROR_BIND_IN_BASE_CONTROLLER_EXTENSION: 30009,
    CD_ERROR_SAVE_IN_BASE_CONTROLLER_EXTENSION: 30010,
    CD_ERROR_ACTION_NOT_FOUND_IN_CONTROLLER: 30011,
    CD_ERROR_FORMATDATA_IN_BASE_CONTROLLER_EXTENSION: 30012,
    CD_ERROR_FORMATDATA_IN_CONTROLLER: 30013,
    CD_ERROR_DELETE_IN_BASE_CONTROLLER_EXTENSION: 30014,
    CD_ERROR_GENERATE_RECORDS_IN_BASE_CONTROLLER_EXTENSION: 30015,
    CD_ERROR_FETCH_IN_CONTROLLER_EXTENSION: 40013,
    CD_ERROR_BINDDATA_IN_CONTROLLER_EXTENSION: 40014,
    CD_ERROR_SAVEDATA_IN_CONTROLLER_EXTENSION: 40015,
    CD_ERROR_DELETEDATA_IN_CONTROLLER_EXTENSION: 40016,
    CD_ERROR_PROCESSDATA_IN_CONTROLLER_EXTENSION: 40017,
    CD_ERROR_SHOWFORM_IN_CONTROLLER_EXTENSION: 40018,
    CD_ERROR_GET_DATA_WIDGETS_OF_FORM: 60001,
    CD_ERROR_GETTING_QUERY_WIDGETS_MAPPING: 60002,
    CD_ERROR_ORM_CONTROLLER_FETCH_RECORDS: 70001,
    CD_ERROR_ORM_CONTROLLER_FETCH_RECORDS_QUERIES_NOT_DEFINED: 70002,
    CD_ERROR_ORM_CONTROLLER_FETCH_RECORD_PK_NOT_DEFINED: 70003,
    CD_ERROR_ORM_CONTROLLER_FETCH_RECORD_PK: 70004,
    CD_ERROR_ORM_CONTROLLER_FETCH_RECORDS_BY_NATIVE_QUERY: 70005,
    CD_ERROR_ORM_CONTROLLER_FETCH_RECORDS_BY_COLUMN_DEFINITION: 70006,
    CD_ERROR_ORM_CONTROLLER_SAVE_RECORD: 70007,
    CD_ERROR_ORM_CONTROLLER_SAVE_RECORDS: 70008,
    CD_ERROR_ORM_CONTROLLER_REMOVE_RECORD: 70009,
    CD_ERROR_ORM_CONTROLLER_REMOVE_RECORDS: 70010,
    CD_ERROR_ORM_CONTROLLER_FETCH_CHILD_RELATIONSHIP: 70011,
    CD_ERROR_ORM_CONTROLLER_RESULTSET_TO_OBJECT_CONVERSION: 70012,
    CD_ERROR_ORM_CONTROLLER_PREPARE_FETCH_QUERY: 70013,
    CD_ERROR_ORM_CONTROLLER_UNMARSHALL_TO_MODEL_OBJECT: 70014,
    CD_ERROR_ORM_CONTROLLER_FETCH_AND_BIND_DATA_STRATEGY: 70015,
    CD_ERROR_PREPARING_QUERY_STRING: 90001,
    CD_ERROR_APP_INIT_FORMS: 90002,
    CD_ERROR_INVALID_DATA_OBJECT: 90003,
    CD_ERROR_CUSTOMVERB: 90004,
    MSG_ERROR_CUSTOMVERB: "Error while invoking custom verb",
    MSG_ERROR_SAAS_INSTANCE_NOTDEFINED: "voltmx.model.ApplicationContext.INSTANCE is not defined",
    MSG_ERROR_FORMSFORRECORDTYPES_MAP_NOT_DEFINED: "FormsForRecordTypes map is not defined or it has no entities",
    MSG_ERROR_RECORDTYPES_NOT_AVAILABLE: "No record types available from service",
    MSG_ERROR_FORM_NOT_DEFINED_FOR_RECORDTYPE: "no default forms for given formType ",
    MSG_ERROR_FORMTYPE_NOT_SPECIFIED: "Please specify formType for record type",
    MSG_ERROR_ENTITY_NOT_SPECIFIED: "Please specify entity to get record types",
    MSG_ERROR_MATCHOPERATOR_NOT_DEFINED_PROPERLY: "Match Operator is not mentioned properly in the query",
    MSG_ERROR_QUERYPARAMS_NOT_DEFINED_PROPERLY: "Queryparams are not defined properly",
    MSG_ERROR_QUERY_NOT_DEFINED_PROPERLY: "Query is not defined properly",
    MSG_ERROR_ADDITIONAL_FIELDS_ARE_NOT_DEFINED_PROPERLY: "Additinal Fields should be described in an Array Format Only",
    MSG_ERROR_BRACES_ARE_NOT_DEFINED_PROPERLY: "Braces are not defined properly in the query",
    MSG_ERROR_PARAM_VALUE_NOT_DEFINED_IN_QUERYPARAM: "Parameter value is not defined for this parameter",
    MSG_ERROR_DATA_VALIDATION_FIELD_NOT_CREATEABLE: "Form Validation Error- Field is not createable",
    MSG_ERROR_DATA_VALIDATION_FIELD_NOT_UPDATEABLE: "Form Validation Error - Field is not updateable",
    MSG_ERROR_DATA_VALIDATION_FIELD_NOT_NULLABLE: "Form Validation Error - Field is not nullable",
    MSG_ERROR_DATA_VALIDATION_INVALID_INPUT_DATA: "Form Validation Error - Invalid input data",
    MSG_ERROR_DATA_VALIDATION_INVALID_MODEL: "Form Validation Error - Invalid Model",
    MSG_ERROR_DATA_VALIDATION_INVALID_ENTITY: "Form Validation Error - Invalid Entity",
    MSG_ERROR_DATA_VALIDATION_ENTITYMETADATA_NOTFOUND: "Form Validation Error - EntityMetaData Not Found",
    MSG_ERROR_FETCHING_APPMENU_DATA: "Error fetching data for app menu",
    MSG_ERROR_CREATING_APPMENU: "Error creating app menu",
    CD_ERROR_WIDGETID_NOT_DEFINED: 50,
    CD_ERROR_PROCESSING_FORMCONFIG: 51,
    CD_ERROR_TAGNAME_NOTVALID: 52,
    CD_ERROR_EVENTNAME_NOT_DEFINED: 53,
    CD_ERROR_WIDGET_INSTANCE_NOT: 54,
    CD_ERROR_WHILE_PROCESSING_WIDGETCONFIG: 55,
    CD_ERROR_PRESAVECALLBACK_NOT_A_FUNCTION: 56,
    CD_ERROR_IN_DATACALLBACK: 57,
    CD_ERROR_IN_PRESAVECALLBACK: 58,
    CD_ERROR_NOT_MODEL_INSTANCE: 59,
    MSG_ERROR_NOT_MODEL_INSTANCE: "result of callback is not a model instance",
    MSG_ERROR_IN_PRESAVECALLBACK: "PreSave callback execution got failed",
    MSG_ERROR_IN_DATACALLBACK: "Data Call Back Execution got failed",
    MSG_ERROR_PRESAVECALLBACK_NOT_A_FUNCTION: "presave call back is not a function",
    MSG_ERROR_WHILE_PROCESSING_WIDGETCONFIG: "error while processing widget config of ",
    MSG_ERROR_WIDGET_INSTANCE_NOT: "it should be instance of voltmx.model.widgetConfig",
    MSG_ERROR_EVENTNAME_NOT_DEFINED: "event name is not defined",
    MSG_ERROR_WIDGETID_NOT_DEFINED: "Widget id is not specifed",
    MSG_ERROR_PROCESSING_FORMCONFIG: "error while processing form config",
    MSG_ERROR_TAGNAME_NOTVALID: "specified tag name not valid ",
    MSG_ERROR_PAGINATION_NOT_ENABLED_FOR_SEGMENT: "Pagination not enabled for this segment",
    MSG_ERROR_FAILED_BINDING_DATA_TO_WIDGET: "Failed to bind data to widget",
    MSG_ERROR_NOT_INHERITING_WIDGET_CONTROLLER: "Does not inherit WidgetController class ",
    MSG_ERROR_NOT_INHERITING_VIEW_CONTROLLER: "Does not inherit ViewController class ",
    MSG_ERROR_UNSUPPORTED_SEGMENT_TYPE: "segment widget type is not yet supported",
    MSG_ERROR_GET_NEXT_LIST: "Get next list error - Data Records recieved < 0 ",
    MSG_ERROR_FETCH_FAILED_FOR_CHILD_ENTITY: "failed to get data for child entity",
    MSG_ERROR_SAVE_CANNOT_SET_PRIMARY_KEY: "cannot save form, cannot explicitly set primary key value",
    MSG_ERROR_KONY_FORM_OBJECT_UNDEFINED: "Volt MX form object is undefined",
    MSG_ERROR_FAILED_FORM_INIT_WHILE_CALLBACK: "failed to initilaize the form while executing datacallback",
    MSG_ERROR_FAILED_LOADING_FORMS: "Failed to load form",
    MSG_ERROR_PARSING_JSONS: "Error while parsing forms JSON",
    MSG_ERROR_FAILED_TO_NAVIGATE_TO_FORM: "failed to navigate to form ",
    MSG_ERROR_FAILED_LOADING_MASTER_DATA: "failed to laod master data",
    MSG_ERROR_FAILED_TO_LOGOUT: "Failed to logout",
    MSG_ERROR_UNDEFINED_WIDGET_CONTROLLER: "Undefined widget controller",
    MSG_ERROR_PRIMARY_FIELD_VALUE_NOT_FOUND: "cannot save form, primary field value not found",
    MSG_ERROR_NO_FIELDS_MODIFIED_UPDATE_FAILED: "Cannot save form, no fields are modified",
    MSG_ERROR_METADATA_FOR_ENTITY_NOT_FOUND: "metadata could not found for entity ",
    MSG_ERROR_FORM_NOT_FOUND: "Form not found",
    MSG_ERROR_EXPECTED_BOOLEAN: "First parameter must be boolean",
    MSG_ERROR_NAVIGATION_STACK_EMPTY: "Navigation stack is empty",
    MSG_ERROR_FORMVIEWCONTROLLER_NOT_FOUND: "form view controller not found",
    MSG_ERROR_INITIALIZING_SAAS_APP: "Error Initializing SaaS Application",
    MSG_ERROR_APP_INITIALIZATION_FAILED: "Application initialization failed",
    MSG_ERROR_FAILED_TO_LOAD_APPLICATION: "Failed to Load Application",
    MSG_ERROR_INITIALIZING_DATA_PROVIDER: "Unable to initialize data provider",
    MSG_ERROR_INITIALIZING_METADATA_PROVIDER: "Unable to initialize meta data provider",
    MSG_ERROR_INITIALIZING_UI_CONFIG_DATA_PROVIDER: "Unable to initialize UI Config data provider",
    MSG_ERROR_FETCHING_FORMS: "Error fetching forms",
    MSG_ERROR_FETCHING_TEMPLATES: "Error fetching templates",
    MSG_ERROR_MORE_RECORDS_FOUND: "Expected one record but found more than one",
    MSG_ERROR_FETCHING_METADATA: "Error fetching metadata for entity",
    MSG_ERROR_FAILED_TO_INITIALIZE_FORM: "Failed to initialize form",
    MSG_ERROR_FAILED_TO_FETCH_DATA: "Failed to fetch data for form",
    MSG_ERROR_FAILED_TO_SAVE_FORM: "Failed to save form",
    MSG_ERROR_SESSION_TOKEN_INVALID: "Invalid session token",
    MSG_ERROR_LOGIN_FAILURE: "Login failure",
    MSG_ERROR_OFFLINE_LOGIN_FAILURE: "Login failure in offline mode",
    MSG_ERROR_CALLBACK_NOT_A_FUNCTION: "Callbacks not a function",
    MSG_ERROR_FAILED_TO_CREATE_RECORD: "Failed to create record",
    MSG_ERROR_FAILED_TO_UPDATE_RECORD: "Failed to update record",
    MSG_ERROR_LOADING_TEMPLATES: "Error loading templates",
    MSG_ERROR_FIELD_NOT_PRESENT: "Invalid field mapped",
    MSG_ERROR_ENITTY_NOT_PRESENT: "Invalid Entity mapped",
    MSG_TENANT_NOT_SYNC_ENABLED: "Cloud is not sync enabled",
    MSG_INVALID_QUERY: "Query framed is invalid",
    MSG_ERROR_FETCH_USER_PROFILE_FAILURE: "Unable to fetch the user profile",
    MSG_ERROR_UNABLE_TO_SYNC: "Sync failed",
    MSG_ERROR_UNABLE_TO_GET_SYNC_CONFIG: "Unable to get sync configuration",
    MSG_ERROR_NETWORK_UNAVAILABLE: "Device is not connected to network. Please check your connection and try again.",
    MSG_ERROR_UNABLE_TO_RESET_SYNC: "Sync reset failed",
    MSG_HAMBURGER_MENU_WRONG_CONFIG: "Wrong Hamburger Menu config",
    MSG_HAMBURGER_MENU_INITIALIZATION_FAILED: "Failed to initialize Hamburger Menu",
    MSG_HAMBURGER_MENU_WRONG_FORM_TYPE: "Hamburger Menu wrong form type",
    MSG_HAMBURGER_MENU_WRONG_SKIN: "Main flex form skin is not provided with form bg color",
    MSG_RESOURCE_NO_CREATE_PERMISSION: "User does not have permission to create {}",
    MSG_RESOURCE_NO_READ_PERMISSION: "User does not have permission to read{}",
    MSG_RESOURCE_NO_UPDATE_PERMISSION: "User does not have permission to update {}",
    MSG_RESOURCE_NO_DELETE_PERMISSION: "User does not have permission to delete {}",
    MSG_NETWORK_UNAVAILABLE: "Network unavailable or disconnected",
    MSG_ERROR_NO_RESPONSE_RECEIVED: "No response received",
    MSG_ERROR_IN_SET_ADDITIONAL_FIELDS: "Error in setAdditionalFields",
    MSG_ERROR_IN_SET_QUERY: "Error in setQuery",
    MSG_ERROR_IN_SET_QUERY_PARAMS: "Error in setQueryParams",
    MSG_ERROR_ENTER_VALID_TENANT_NAME: "Enter a valid cloud name",
    MSG_ERROR_NAVIGATION_CONTROLLER_NOT_DEFINED: "Navigation controller not defined",
    MSG_ERROR_INVALID_ENTITY: "Invalid Entity Name",
    MSG_VERSION_UNSUPPORTED_ERROR: " You are trying to connect to older version of the Volt MX Foundry App Services. This app requires Volt MX Foundry App Services version to be $VERSION or greater ",
    MSG_ERROR_ASSOCIATING_RECORD: "Error associating record",
    MSG_ERROR_DISOCIATING_RECORD: "Error dissociating record",
    MSG_ERROR_NOT_INSTANCE_OF_CUSTOMINFO: "info object not an instance of voltmx.model.CustomInfo class",
    MSG_ERROR_FORM_ENTITY_NOT_FOUND: "Entity of form not found",
    MSG_ERROR_FORM_PRIMARY_FIELDVALUE_NOT_FOUND: "Primary field value for form is not found",
    MSG_ERROR_CANNOT_ASSOCIATE_DISSOCIATE_OF_SAME_ENTITY: "Cannot associate/dissociate records of same entity",
    MSG_ERROR_SAVING_MULTI_ENTITY_LABEL: "Error saving mutli entity label data",
    MSG_ERROR_SAVING_CHILD_CONTAINER: "Error saving child container data",
    MSG_UPGRADE_UNAVAILABLE: "upgraded version of this cloud is not available, please try diabling connect to upgraded version",
    MSG_ERROR_I18N: "I18n Error ",
    MSG_INVALID_LOGIN_HANDLER_RESPONSE: "invalid response object returned by login handler",
    MSG_ERROR_FAILED_TO_QUERY_DATA: "failed to query data for the widget",
    MSG_ERROR_BATCH_INSERT: "Exception occurred while batchInsert",
    MSG_ERROR_LOCAL_DB_CONNECTION: "Error in getting localdb connection",
    MSG_ERROR_EXECUTE_SINGLE_SQL_QUERY: "Exception occurred while executeSingleSqlQuery",
    MSG_ERROR_DECODING_BASE64_FORMJS: "Error while decoding base64 formJS",
    MSG_ERROR_LOADING_THEME: "error loading theme",
    MSG_ERROR_SETTING_THEME: "error setting theme to the application",
    MSG_ERROR_FETCHING_THEME: "error fetching theme from datasource",
    MSG_ERROR_MULTIPLE_DEFAULT_THEME: "error, more than once default themes returned",
    MSG_ERROR_CREATING_THEME: "error while creating theme",
    MSG_ERROR_METHOD_INVALID: "method type invalid , should be either GET/POST/PUT/DELETE",
    MSG_ERROR_INVALID_HTTPCUSTOMREQUEST_INPUT: "method type expected, httpcustomrequest accepts a string parameter of the method type",
    MSG_ERROR_INVALID_INPUT: "expected two string inputs",
    MSG_ERROR_INVALID_INPUT_TYPE: "expected string type as input",
    MSG_ERROR_INVALID_PAYLOAD: "invalid payload, expected only one parameter",
    MSG_ERROR_INVALID_DATAPROVIDER_TYPE: "expected rest dataprovider object",
    MSG_ERROR_DATAPROVIDER_NOT_INTIALIZED: "dataprovider object not intialized",
    MSG_ERROR_INVALID_CUSTOMSERVICE_INPUT_PARAM: "expected httpcustomrequest input param",
    MSG_ERROR_UNEXPECTED_CUSTOMRESPONSE: "expected customresponse key in response",
    MSG_CLOUD_UNAUTHORISED_FOR_DATAPROVIDER: "Invalid dataProviderKey or Present cloud is not authorised for the suggested data provider",
    MSG_CREDSTORE_NOT_FOUND: "Login failure in offline mode. CredStore is not created yet",
    MSG_CREDENTIAL_MISMATCH_WITH_CREDSTORE: "Login failure in offline mode. User Credentials did not match with credStore",
    MSG_ERROR_IN_ENTITY_DEFINITION: "Error in getting entity definition in model",
    MSG_ERROR_IN_RETREIVNING_CHILD_RELATIONSHIPLIST: "Error in retreiving child relationship list in model",
    MSG_ERROR_FETCHING_DATA_FOR_COLUMNS: "Error fetching data for columns in model",
    MSG_ERROR_FETCHING_CHILD_RELATIONSHP_FOR_ENTITY: "Error fetching relationship for child entity in model",
    MSG_ERROR_PROCESSING_CHILD_RELATIONSHIPLIST: "Error processing child relationship list in getRelationshipForChildEntityName in model",
    MSG_ERROR_FETCH: "Error in fetching data in model",
    MSG_ERROR_CREATE: "Error in create in model",
    MSG_ERROR_UPDATE: "Error in update in model",
    MSG_ERROR_UPDATE_BY_PRIMARY_KEY: "Error in update by primarykey in model",
    MSG_ERROR_DELETE: "Error in delete in model",
    MSG_ERROR_DELETE_BY_PRIMARY_KEY: "Error in delete by primarykey in model",
    MSG_ERROR_FETCH_IN_CONTROLLER_EXTENSION: "Error in fetch in controller extension",
    MSG_ERROR_BINDDATA_IN_CONTROLLER_EXTENSION: "Error in bindData in controller extension",
    MSG_ERROR_SAVEDATA_IN_CONTROLLER_EXTENSION: "Error in saveData in controller extension",
    MSG_ERROR_DELETEDATA_IN_CONTROLLER_EXTENSION: "Error in deleteData in controller extension",
    MSG_ERROR_ENTITY_CONTROLLER_NOT_DEFINED: "Model is not defined",
    MSG_ERROR_FETCH_IN_BASE_CONTROLLER_EXTENSION: "Error in fetchData of BaseControllerExtension",
    MSG_ERROR_BIND_IN_BASE_CONTROLLER_EXTENSION: "Error in bindData of BaseControllerExtension",
    MSG_ERROR_SAVE_IN_BASE_CONTROLLER_EXTENSION: "Error in saveData of BaseControllerExtension",
    MSG_ERROR_DELETE_IN_BASE_CONTROLLER_EXTENSION: "Error in saveData of BaseControllerExtension",
    MSG_ERROR_GENERATE_RECORDS_IN_BASE_CONTROLLER_EXTENSION: "Error in generateRecords of BaseControllerExtension",
    MSG_ERROR_ACTION_NOT_FOUND_IN_CONTROLLER: "Error action not found in controller for actionName",
    MSG_ERROR_APP_INIT_FORMS: "Error in application init forms",
    MSG_ERROR_ORM_CONTROLLER_FETCH_RECORDS: "Error in persistent controller's fetch records",
    MSG_ERROR_ORM_CONTROLLER_FETCH_RECORDS_QUERIES_NOT_DEFINED: "Error in persistent controller's fetch records, odata queries not defined",
    MSG_ERROR_ORM_CONTROLLER_FETCH_RECORD_PK_NOT_DEFINED: "Error in persistent controller's fetch by PK, PK not defined",
    MSG_ERROR_ORM_CONTROLLER_FETCH_RECORD_PK: "Error in persistent controller's fetch by PK",
    MSG_ERROR_ORM_CONTROLLER_FETCH_RECORDS_BY_NATIVE_QUERY: "Error in persistent controller's fetch with native query",
    MSG_ERROR_ORM_CONTROLLER_FETCH_RECORDS_BY_COLUMN_DEFINITION: "Error in persistent controller's fetch by columns",
    MSG_ERROR_ORM_CONTROLLER_SAVE_RECORD: "Error in persistent controller's save record",
    MSG_ERROR_ORM_CONTROLLER_SAVE_RECORDS: "Error in persistent controller's save records",
    MSG_ERROR_ORM_CONTROLLER_REMOVE_RECORD: "Error in persistent controller's remove record",
    MSG_ERROR_ORM_CONTROLLER_REMOVE_RECORDS: "Error in persistent controller's remove records",
    MSG_ERROR_ORM_CONTROLLER_FETCH_CHILD_RELATIONSHIP: "Error in persistent controller's fetch child relationship",
    MSG_ERROR_ORM_CONTROLLER_RESULTSET_TO_OBJECT_CONVERSION: "Error in persistent controller's resultset to record object conversion",
    MSG_ERROR_ORM_CONTROLLER_PREPARE_FETCH_QUERY: "Error in persistent controller's prepare fetch query",
    MSG_ERROR_ORM_CONTROLLER_UNMARSHALL_TO_MODEL_OBJECT: "Error in persistent controller's unmarshall record object to form model object",
    MSG_ERROR_ORM_CONTROLLER_FETCH_AND_BIND_DATA_STRATEGY: "Error in persistent controller's fetch and bind data strategy",
    MSG_ERROR_GET_DATA_WIDGETS_OF_FORM: "Error getting data widgets of form",
    MSG_ERROR_GETTING_QUERY_WIDGETS_MAPPING: "Error getting queryWidgetsMapping",
    MSG_ERROR_PREPARING_QUERY_STRING: "Error in preparing query string",
    MSG_ERROR_NOTIFYING_OBSERVERS: "Error notifying observers of formmodel",
    MSG_ERROR_GET_WIDGET_DATA_FORMMODEL: "Error getting widget data of formmodel",
    MSG_ERROR_SET_WIDGET_DATA_FORMMODEL: "Error setting widget data of formmodel",
    MSG_ERROR_FORMMODEL_PROPERTY_VALUE_CHANGED: "Error in propertyValueChanged of formmodel",
    MSG_ERROR_FORMMODEL_CLEAR: "Error in clear of formmodel",
    MSG_ERROR_FORMMODEL_DESTROY: "Error in destroy of formmodel",
    MSG_ERROR_FORMMODEL_UPDATE: "Error in update of formmodel",
    MSG_ERROR_FORMMODEL_SET_MASTERDATA: "Error in setMasterData of formmodel",
    MSG_ERROR_FORMMODEL_GET_MASTERDATA: "Error in getMasterData of formmodel",
    MSG_ERROR_FORMMODEL_SET_VIEW_ATTRIBUTE: "Error settingView attribute by property in formmodel",
    MSG_ERROR_FORMMODEL_GET_VIEW_ATTRIBUTE: "Error gettingView attribute by property in formmodel",
    MSG_ERROR_FORMMODEL_PERFORM_ACTION_ONVIEW: "Error in performActionOnView of formmodel",
    MSG_ERROR_FORMMODEL_PERFORM_ACTION: "Error in performAction of formmodel",
    MSG_ERROR_FORMMODEL_PROPERTIES_INIT: "Error in initialization of formmodel properties",
    MSG_ERROR_FETCH_IN_CONTROLLER: "Error in fetch of controller",
    MSG_ERROR_BIND_IN_CONTROLLER: "Error in bind of controller",
    MSG_ERROR_SAVE_IN_CONTROLLER: "Error in save of controller",
    MSG_ERROR_DELETE_IN_CONTROLLER: "Error in delete of controller",
    MSG_ERROR_LOADDATA_SHOWFORM_CONTROLLER: "Error in load data and show form of controller",
    MSG_ERROR_GETTING_ENTITY_CONTROLLER: "Error getting model from formcontroller",
    MSG_ERROR_GETTING_ENTITY_METADATA: "Error getting entity metadata from formcontroller",
    MSG_ERROR_INVALID_DATA_OBJECT: "Error while reading data, expected data object",
    MSG_ERROR_PROCESSDATA_IN_CONTROLLER_EXTENSION: "Error while formatting data in controller extension",
    MSG_ERROR_FORMATDATA_IN_BASE_CONTROLLER_EXTENSION: "Error while formatting data in base controller extension",
    MSG_ERROR_FORMATDATA_IN_CONTROLLER: "Error while formatting data in controller",
    MSG_ERROR_VALIDATION_UPDATE: "Error validating data in update model",
    MSG_ERROR_VALIDATION_CREATE: "Error validating data in create model",
    MSG_ERROR_SHOWFORM_IN_CONTROLLER_EXTENSION: "Error in showForm in controller extension"
};

/* FILE PATH :: 'lib/tparty/voltmxlicense.js' */
/*
 *
 *  File      : license.js
 *  Version   : 9.5.0.1
 *  TimeStamp : 21-11-2022 06:56:33 IST
 *
 */

kony = voltmx;

voltmx.license = {};
var appConfig = undefined;
voltmx.license.disableMetricReporting = function() {
    voltmx.ds.save(["true"], "LicenseDisableFlag");
}

voltmx.licensevar = {};
voltmx.licensevar.didAppWentInBackground = false;
voltmx.license.timeoutValue = 14400 ;
voltmx.license.version = "9.5.0.1";
voltmx.licensevar.currentSessionId = "";
voltmx.licensevar.latestSessionCreationTimestamp = "";
voltmx.licensevar.maxSessionCountLimit = 100;
voltmx.licensevar.changeHandlers = [];
voltmx.licensevar.isLicenseUrlAvailable = true;
voltmx.licensevar.isISTNetworkCallProcessingInProgress = false;
voltmx.licensevar.deferredNewSessionsCounter = 0;
voltmx.licensevar.isInteractive = false;
voltmx.licensevar.isPostAppInitCalled = false;
voltmx.licensevar.timesAppBecomeInteractive = 0;
voltmx.licensevar.maxDeferSessionCount = 15;
voltmx.licensevar.appLaunch = "appLaunch";

voltmx.licensevar.appStateCallbackFunction = function () {
    voltmx.licensevar.timesAppBecomeInteractive++;
    voltmx.license.log("appStateCallbackFunction:: isPostAppInitCalled :" + voltmx.licensevar.isPostAppInitCalled + " ,isInteractive :" + voltmx.licensevar.isInteractive);
    if (voltmx.licensevar.isInteractive === false) {
        voltmx.licensevar.isInteractive = true;
        voltmx.license.log("App is in interactive state");
        if (voltmx.licensevar.isPostAppInitCalled === true) {
            /* Create a new interactive session if app got launched in silent mode and later comes to postappinit due to user
            action such as clicking the notification (isAppLaunchedForInteraction callback is invoked later)*/
            voltmx.license.log("Creating and sending a new interactive session details.");
            voltmx.license.sendNewIST();
        }
    }
    else {
        voltmx.license.log("Warning: appStateCallbackFunction is called "+voltmx.licensevar.timesAppBecomeInteractive+" times, ignoring the interactive app state event");
    }
};

voltmx.licensevar.callbacksObjList = {};
voltmx.licensevar.callbacksObjList.isAppLaunchedForInteraction = {};
voltmx.licensevar.callbacksObjList.isAppLaunchedForInteraction.appStateCallbackFunction = voltmx.licensevar.appStateCallbackFunction;

voltmx.license.maxWaitTimeToHandleMultipleNewSessions = 60;

voltmx.license.constants = {};
voltmx.license.constants.THIN_CLIENT = "thinclient";
voltmx.license.constants.LAUNCH_PARAMS = "launchparams";
voltmx.license.constants.REUSABLE_SESSION_ID = "reusable_session_id";
voltmx.license.constants.KEY_KONY_LICENSE_TIMEOUT = "konyLicenseTimeout";

/*
 *  Name      : voltmx.license.setLogging
 *  Purpose   : The API enables the logs for license.js. 
 *              It should be called via devloper who is intented to debug the license flow. It can be called in the app code or through developer tools.
 *  Scenarios : i) If voltmx.license.setLogging is invoked with boolean value true , the logs will be enabled for current launch and further launch of the app
 *              ii) If voltmx.license.setLogging is invoked with boolean value false , the logs will be disabled for current launch and further launch of the app
 */
voltmx.license.setLogging = function(boolValue){
    if(boolValue === true){
        voltmx.ds.save([true], "LicenseLoggingFlag");
    }else{
        voltmx.ds.save([false], "LicenseLoggingFlag");
    }
}

voltmx.license.log = function(msg){
    try{
        var logCondition = voltmx.ds.read("LicenseLoggingFlag");
    }catch(e){
        //This might get into exception in case of SPA due to a limitaion in implementation of FTR MADPSPA-394
    }
    if (logCondition != undefined && logCondition[0] != undefined && logCondition[0]!=null && logCondition[0]===true) {
        voltmx.print("[License] :"+msg);
    }
}

voltmx.license.isLicenseUrlAvailable = function() {
    return voltmx.licensevar.isLicenseUrlAvailable;
}

voltmx.license.setIsLicenseUrlAvailable = function(value) {
    voltmx.licensevar.isLicenseUrlAvailable = value;
}

voltmx.license.getSessionId = function() {
    return voltmx.licensevar.currentSessionId;
}

/*
  voltmxUserID encrypted and saved in datastore.Used in reporting params.
 */
var voltmxUserID = function () {

    var dataStorekeys = {};
    dataStorekeys.encryptedVoltmxuserId = "voltmxUserID_ENC";
    dataStorekeys.voltmxuserId = "voltmxUserID";
    var encryptionSalt = "voltmxUserID_ENC";
    var encryptionAlgo = "aes";

    /*
     *  Name      : get
     *  Purpose   : Returns array with one element encrypted userID.
     *              Removes old key "voltmxUserID" and add new key with encrypted userid to data store for migration from old version.
     *
     *  Scenarios : i) UserID must be encrypted and saved with key voltmxUserID_ENC.
     *              ii) For upagrade to 8.4 check if all both encrypted and non-encrpyted data are going to Mf
     */
    var getVoltmxUserID = function () {
        var userInfo = new Array();
        var userId = voltmx.ds.read(dataStorekeys.encryptedVoltmxuserId);
        if (userId === undefined || userId === null || userId[0] === undefined) {
            userId = voltmx.ds.read(dataStorekeys.voltmxuserId);
            if (userId != undefined && userId != null && userId[0] != undefined) {
                userId = userId[0];
                setVoltmxUserID(userId);
                voltmx.ds.remove(dataStorekeys.voltmxuserId);
            }
            else {
                return null;
            }

        }
        else {
            userId = decryptText(userId[0], encryptionSalt, encryptionAlgo);
        }

        userInfo.push(userId);
        return userInfo;
    };

    /*
     *  Name      : set
     *  Purpose   : Saves encrypted userID in datastore
     *
     *  Scenarios : i) UserID must be encrypted and saved with key voltmxUserID_ENC
     *              ii) For upagrade to 8.4 check if all both encrypted and non-encrpyted data are going to Mf
     */
    var setVoltmxUserID = function (userId) {
        if (userId == undefined || userId == null || typeof userId !== 'string') {
            return;
        }

        var userId = encryptText(userId, encryptionSalt, encryptionAlgo);
        var userInfo = new Array();
        userInfo.push(userId);
        voltmx.ds.save(userInfo, dataStorekeys.encryptedVoltmxuserId);
    };

    /**
     * Name     : generateSecureKeyFromText
     * Purpose  : Generates key for encryption.
     */
    function generateSecureKeyFromText(salt) {
        var secureKey = salt;

        if (salt != undefined || salt != null) {
            secureKey = voltmx.crypto.newKey("passphrase", 128, {
                passphrasetext: salt,
                subalgo: encryptionAlgo,
                passphrasehashalgo: "md5"
            });
        }
        return secureKey;
    }

    /**
     * Name     : encryptText
     * Purpose  : Encrypts text with the given salt and encryptionAlgo.
     *            Channel specific  behaviour:
     *            SPA     : Saving encrypted object to DS, as convertToRawbytes not supported in SPA
     */
    function encryptText(text, salt, encryptionAlgo) {
        var channel = voltmx.os.deviceInfo().name.toString().toLowerCase();
        var secureSalt = generateSecureKeyFromText([ salt ]);
        var encryptedText = voltmx.crypto.encrypt(encryptionAlgo, secureSalt, text, {});
        if(channel !== "thinclient") {
            encryptedText = voltmx.convertToBase64(encryptedText);
        }
        return encryptedText;
    }

    /**
     * Name     : decryptText
     * Purpose  : Decrypts text with the given salt and encryptionAlgo.
     */
    function decryptText(text, salt, decryptionAlgo) {
        var channel = voltmx.os.deviceInfo().name.toString().toLowerCase();
        var secureSalt = generateSecureKeyFromText([ salt ]);
        var rawBytes = text;
        if(channel !== "thinclient") {
            rawBytes = voltmx.convertToRawBytes(text);
        }

        var decryptText =voltmx.crypto.decrypt(decryptionAlgo, secureSalt, rawBytes, {});
        return decryptText;
    }

    return {"set": setVoltmxUserID, "get": getVoltmxUserID};
}

voltmx.license.registerChangeListener = function(changeHandler) {

    if (!changeHandler) {
        return;
    }
    // We give the initial values once
    var changes = {};
    var userId = voltmxUserID().get.call(this)
    changes["sessionId"] = voltmx.licensevar.currentSessionId;
    if (userId != undefined && userId[0] != undefined && userId[0]!=null) {
        changes["userId"] = userId[0];
    }

    // Add to my listeners first and then call changeHandler with any changes
    voltmx.licensevar.changeHandlers.push(changeHandler);

    if (!voltmx.license.isNullOrUndefined(voltmx.licensevar.currentSessionId)) {
        try {
            changeHandler(changes);
        } catch (e) {
            voltmx.license.log("exception caught while calling changeHandler with changes-" + JSON.stringify(changes));
        }
    }
};

voltmx.license.notifyChangesToListeners = function() {
    for (var i = 0; i < voltmx.licensevar.changeHandlers.length; i++) {
        var changes = {};
        var userId = voltmxUserID().get.call(this);
        changes["sessionId"] = voltmx.licensevar.currentSessionId;
        if (userId != undefined && userId[0] != undefined && userId[0]!=null) {
            changes["userId"] = userId[0];
        }
        var changeHandler = voltmx.licensevar.changeHandlers[i];
        changeHandler(changes);
    }
};

/*
*  Name      : processDeferredNewSessions
*  Author    : None
*  Purpose   : Helper method to process deferred new sessions
*/

voltmx.license.processDeferredNewSessions = function () {
    voltmx.license.log("sending deferred launch date - "+voltmx.licensevar.currentSessionId);
    voltmx.licensevar.isISTNetworkCallProcessingInProgress = false;
    voltmx.licensevar.deferredNewSessionsCounter = 0;
    voltmx.license.pushVoltmxSessionsToServer(true);
}

/**
 * This function takes a value as input to check for undefined or null
 * @param value
 * @returns {boolean}
 */
 voltmx.license.isNullOrUndefined = function (value) {
    var isNullOrUndefined = false;
    if (value === undefined || value === null) {
        isNullOrUndefined = true;
    }
    return isNullOrUndefined;
}

/*
 *  Name      : voltmx.license.startLicenseService
 *  Author    : None
 *  Purpose   : Single global function which contains definitions of all required functions for session tracking.
 */
voltmx.license.startLicenseService = function() {
        "use strict";
        var deviceInfo = voltmx.os.deviceInfo();
        voltmx.license.log("startLicenseService deviceInfo " + JSON.stringify(deviceInfo));
        /*
         *  Name      : getLicenseUrl
         *  Author    : None
         *  Purpose   : Internal function to get the appropriate IST url for session calls
         */

        function getLicenseUrl() {
            var url = "";
            if (appConfig.isturlbase) {
                url = appConfig.isturlbase + "/IST";
            } else if (appConfig.secureurl) {
                url = getFromServerUrl(appConfig.secureurl, "IST");
            } else if (appConfig.url) {
                url = getFromServerUrl(appConfig.url, "IST");
            }
            return url;
        }

       
        /*
         *  Name      : getFromServerUrl
         *  Author    : None
         *  Purpose   : Helper method to form a proper url
         */

        function getFromServerUrl(url, path) {
            if (!url) {
                return null;
            }
            // ServerURL for non-mf has /mwservlet appended after the context path.
            // We need to remove it to get the base server url
            voltmx.license.log("Entering into getfromserverurl when IST-base url is not defined");
            if (deviceInfo.name === "thinclient") {
                url = url.replace(/mwservlet\/*$/i, "");
                return url + path;
            } else {
                var exactSubString = url.match(/mwservlet/i);
                var newUrl = null;
                if (exactSubString) {
                    var exactSubStringLength = "mwservlet".length;
                    var lastSubStringIndex = url.lastIndexOf(exactSubString);
                    var subString = url.slice(0, lastSubStringIndex);
                    var index = (lastSubStringIndex + exactSubStringLength);
                    var subString2 = url.slice(index, url.length);
                    var has = /[a-zA-Z0-9]/.test(subString2);
                    if (!has) {
                        newUrl = subString;
                    } else {
                        newUrl = url;
                    }
                } else {
                    newUrl = url;
                }
                return newUrl + path;
            }
        }

        function getApplicationType(name) {
            if (name === "thinclient") {
                return "spa";
            }
            var appMode = voltmx.application.getApplicationMode();
            if (appMode === constants.APPLICATION_MODE_NATIVE) {
                return "native";
            } else if (appMode === constants.APPLICATION_MODE_HYBRID) {
                return "hybrid";
            } else if (appMode === constants.APPLICATION_MODE_WRAPPER) {
                return "mixedmode";
            } else {
                return "";
            }
        }

        /*
         *  Name       : voltmx.setUserID
         *  Author     : None
         *  Purpose    : Stores the userID in device local, once set.
         *  Scenarios :  i) If voltmx.setUserID api is invoked by the developer, the userId set won't be overriden regardless 
         *                   of any number of logins.
         *               ii) If voltmx.setUserID is called from login flow, then the userId of login will be set and will 
         *                    be overriden for every subsequent login calls and direct invocation of voltmx.setUserID.
         *               iii) voltmx.setUserID api is invoked by the developer the userId for ex: 'X' will be set, again if voltmx.setUserID 
         *                    api is invoked with value ex : 'Y' then the previous value will be overriden and 
         *                    current userId will be set to 'Y'.
         */

        voltmx.setUserID = function(userId,fromLoginFlag) {
            /* fromLoginFlag is introduced to know whether the call is made from
               login flow or directly voltmx.setUserID api is invoked */
			if(fromLoginFlag == undefined || fromLoginFlag == null){
				fromLoginFlag = false;
			}

            var userIDflagGet = voltmx.ds.read("userIDFromLicenseFlag");
             /* If userIDflagGet is true ie. it is being set by invoking voltmx.setUserID directly and this function 
               is invoked from login flow, then no need to override, just return */
            if(userIDflagGet && (userIDflagGet[0] == "true") && fromLoginFlag) {
                return;
            }

            /* If the invocation is directly through calling api and not through login flow,
               set userIDFromLicenseFlag key to true so that it is not overriden by any other invocations from login flow*/

            /* userIDFromLicenseFlag is set to true only when voltmx.setUserID api is directly invoked by the developer */
            if(!fromLoginFlag) {
                var userIDflagSet = new Array;
                userIDflagSet.push("true");
                voltmx.ds.save(userIDflagSet,"userIDFromLicenseFlag");
            }

            /* sets userID in device local */
            voltmxUserID().set.call(this, userId);
            voltmx.license.notifyChangesToListeners();
        }

        voltmx.license.generateUUID = function() {
                var S4 = function() {
                    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
                };
                return (new Date().getTime() + '-' + S4() + '-' + S4() + '-' + S4());
        }
        /*
         *  Name      : voltmx.license.isCloud
         *  Author    : None
         *  Purpose   : Returns true if it is cloud enviroment, else returns false.
         */
        voltmx.license.isCloud = function() {
                //starting 6.0 the licensing approach is also applicable for On-Prem customers.Hence the license usage posting 
                //will be enabled for on-prem customers as well. So removing the check for the Kony Cloud URLs.

                var isLicenseEnabled = true;
                var LicenseCheck = voltmx.ds.read("LicenseDisableFlag");
                if (LicenseCheck && (LicenseCheck[0] === "true" || LicenseCheck === "true" ))  {
                    isLicenseEnabled = false;
                }
                if (voltmx.license.isLicenseUrlAvailable() === false) {
                    isLicenseEnabled = false;
                }
                return isLicenseEnabled;
        }

        /*
         *  Name      : voltmx.license.getCurrentDateTime
         *  Author    : None
         *  Purpose   : Returns current date and time details in required string format for service input.
         */
        voltmx.license.getCurrentDateTime = function() {
                voltmx.license.log("getCurrentDateTime..");
                var nowDate, month, formatDate;
                nowDate = new Date();
                month = nowDate.getUTCMonth() + 1;
                formatDate = (("00" + nowDate.getUTCFullYear()).slice(-4)) + "-" + (("00" + month).slice(-2)) + "-" + (("00" + nowDate.getUTCDate()).slice(-2)) + " " + (("00" + nowDate.getUTCHours()).slice(-2)) + ":" + (("00" + nowDate.getUTCMinutes()).slice(-2)) + ":" + (("00" + nowDate.getUTCSeconds()).slice(-2));
                return formatDate;
        }

        /*
         *  Name      : voltmx.license.appendLicenseTrackingKeys
         *  Author    : None
         *  Purpose   : Returns input object after appending the required tracking keys for provided input object.
         */

        voltmx.license.appendLicenseTrackingKeys = function(requestType,reportData) {
                voltmx.license.log("appendLicenseTrackingKeys deviceinfo ---> " + JSON.stringify(deviceInfo));
                var inputParams = {};
                 if (voltmx.license.isCloud() === true) {
                    inputParams.plat = deviceInfo.name;
                    if (typeof(voltmx.sdk) !== "undefined"){
                        inputParams.chnl = voltmx.sdk.getChannelType();
                        inputParams.did = voltmx.sdk.getDeviceId();
                        inputParams.plat = voltmx.sdk.getPlatformName();    
                    }
                    else{
                        //In absense of sdk [ MFSDK-2377 ],since for 7.0 viz we do not package SDK, so sdk namespace won't be available
                        //We should be okay with this hardcoding because in absence of SDK, IST call also doesn't make sense
                        //We are making this fix just for Backward compatibility of Viz Starter 7.0 Apps.
                        inputParams.chnl = "fpApp";
                        inputParams.did = "fp-"+voltmx.license.generateUUID();
                        inputParams.plat = "fp";
                    }
                    
                    inputParams.aid = appConfig.appId;
                    inputParams.aver = appConfig.appVersion;
                    inputParams.aname = appConfig.appName;
                    //adding mfaid, mfaname if konyref is available.
                    if (typeof voltmxRef !== "undefined" && voltmxRef != null && voltmxRef.mainRef) {
                        inputParams.mfaid = voltmxRef.mainRef.appId;
                        inputParams.mfbaseid = voltmxRef.mainRef.baseId;
                        inputParams.mfaname = voltmxRef.mainRef.name;
                    }
                    if (voltmx.application.getCurrentForm()) {
                        var fid = voltmx.application.getCurrentForm().id;
                        if (fid) {
                            inputParams.fid = fid;
                        }
                    }
                    inputParams.atype = getApplicationType(deviceInfo.name);
                    inputParams.os = deviceInfo.version;
                    inputParams.stype = "b2c";
                    inputParams.dm = deviceInfo.model;
                    inputParams.ua = voltmx.os.userAgent();
                    inputParams.sessiontype = voltmx.licensevar.isInteractive === true ? "I" : "NI";
                     var userId = voltmxUserID().get.call(this);
                    if (userId !== undefined && userId !== null && userId.length > 0) {
                        inputParams.kuid = userId[0];
                    } else {
                        inputParams.kuid = "";
                    }
                    if (requestType === "session") {
                        voltmx.license.checkAndCreateSession();
                        if(voltmx.licensevar.isISTNetworkCallProcessingInProgress === true || voltmx.licensevar.deferredNewSessionsCounter > 0){
                            //In case of first app laucn the voltmx.licensevar.deferredNewSessionsCounter would be 0 , so we don't need to cancel the uncommenced timer
                            if(voltmx.licensevar.deferredNewSessionsCounter > 0) {
                                try{
                                    voltmx.license.log("cancelling the previous timer, as in span of "
                                        +voltmx.license.maxWaitTimeToHandleMultipleNewSessions+ " seconds, a new IST was fired immediately");
                                    voltmx.timer.cancel("konySession"+(voltmx.licensevar.deferredNewSessionsCounter-1));
                                } catch(erObj) {
                                    voltmx.license.log("error - "+JSON.stringify(erObj)+",  while cancelling the deferred session timer" +
                                        " to send launch dates with timer id"+(voltmx.licensevar.deferredNewSessionsCounter-1));
                                }
                            }
                            voltmx.timer.schedule(("konySession"+(voltmx.licensevar.deferredNewSessionsCounter++)),
                                voltmx.license.processDeferredNewSessions, voltmx.license.maxWaitTimeToHandleMultipleNewSessions, false);
                                voltmx.license.log("another session is in progress , we will try again");
                            return {}; //returning empty voltmxReportingParams as we dont want another IST call while one IST call is in progress
                        }
                        
                        var offlineData = voltmx.license.getStoredSession();
                        inputParams.launchDates = offlineData;
                        voltmx.licensevar.isISTNetworkCallProcessingInProgress = true;
                        inputParams.svcid = "RegisterKonySession";
                        voltmx.license.log("---------->LaunchDates : " + inputParams.launchDates);
                    } else {
                        var uuid = voltmx.ds.read("konyUUID");
                        if (uuid !== undefined && uuid !== null && uuid.length > 0) {
                            inputParams.rsid = uuid[0];
                        } else {
                            inputParams.rsid = voltmx.license.generateUUID().toString();
                        }
                    }
                }
                voltmx.license.log("input params in appendLicenseTrackingKeys are " + JSON.stringify(inputParams));
                return inputParams;
            
        }

        /*
         *  Name      : voltmx.license.checkAndCreateSession
         *  Author    : None
         *  Purpose   : creates a new session (if session is not created).
         */
        voltmx.license.checkAndCreateSession = function() {
                voltmx.license.log("check and create session..");
                var uuid = voltmx.ds.read("konyUUID");
                if (uuid !== undefined && uuid !== null && uuid.length > 0) {
                   voltmx.licensevar.currentSessionId = uuid[0];
                } else {
                   voltmx.license.createSession();
                } 
        }

        voltmx.licensevar.sdkTimerCounter = 0;
        /**
         * This function prepares timer event for 4 hour delayed license call.
         * If another timer has to be scheduled, this function takes care of cancelling previous timer.
         */
        voltmx.license.prepare4HoursTimer = function () {
            voltmx.license.log("Entering prepare4HoursTimer, counter value-" + voltmx.licensevar.sdkTimerCounter);
            //In case of first app launch the voltmx.licensevar.sdkTimerCounter would be 0 , so we don't need to cancel the uncommenced timer
            if (voltmx.licensevar.sdkTimerCounter !== 0) {
                try {
                    var timerIdToCancel = voltmx.license.constants.KEY_KONY_LICENSE_TIMEOUT + (voltmx.licensevar.sdkTimerCounter - 1);
                    voltmx.timer.cancel(timerIdToCancel);
                } catch (erObj) {
                    voltmx.license.log("the error object while cancelling the timer is" + erObj);
                }
            }
        }

        /**
         * This function takes care of creating a new timer id and scheduling a new timed event
         * for new IST session to be created after 4 hours
         */
        voltmx.license.schedule4HoursTimer = function () {
            voltmx.license.log("Entering schedule4HoursTimer, counter value-" + voltmx.licensevar.sdkTimerCounter);
            var timerIdToSchedule = voltmx.license.constants.KEY_KONY_LICENSE_TIMEOUT + (voltmx.licensevar.sdkTimerCounter++);
            voltmx.timer.schedule(timerIdToSchedule, voltmx.license.sendNewIST, voltmx.license.timeoutValue, false);
        }

        /*
         *  Name      : voltmx.license.createSession
         *  Author    : None
         *  Purpose   : creates a new session (if session is not created) and sets the counter for 4hrs to call IST.
         */
        voltmx.license.createSession = function() {
            voltmx.license.prepare4HoursTimer();
            var uuid = new Array();
            voltmx.licensevar.currentSessionId = voltmx.license.generateUUID().toString();
            voltmx.licensevar.latestSessionCreationTimestamp = voltmx.license.getCurrentDateTime();
            uuid.push(voltmx.licensevar.currentSessionId);
            voltmx.ds.save(uuid, "konyUUID");
            voltmx.license.storeSession();
            voltmx.license.notifyChangesToListeners();
            voltmx.license.schedule4HoursTimer();
        }

        voltmx.license.storeSession = function(){
            var uuid = voltmx.licensevar.currentSessionId;
            var offlineData = voltmx.license.getStoredSession();
            if (offlineData === undefined || offlineData === null) {
                offlineData = new Array();
            }
            var currentSession = new Array();
            currentSession.push(uuid);
            currentSession.push(voltmx.licensevar.latestSessionCreationTimestamp);
            var sessionType = voltmx.licensevar.isInteractive === true ? "I" : "NI";
            currentSession.push(sessionType);

            if(offlineData.length === 0 || offlineData[(offlineData.length-1)][0] !== currentSession[0]){
                if(offlineData.length > 0 && voltmx.licensevar.deferredNewSessionsCounter > 0){
                    //we are dropping rapidly created sessions while already a network call is in progress. We will send only recent session.
                    offlineData.pop();
                }
                offlineData.push(currentSession);
            }else{
                voltmx.license.log("Ignoring duplicate session: "+JSON.stringify(currentSession));
                offlineData[offlineData.length - 1][2] = voltmx.licensevar.isInteractive.toString();
            }
            if(offlineData.length > voltmx.licensevar.maxSessionCountLimit){
                voltmx.license.log("Trimming to latest " + voltmx.licensevar.maxSessionCountLimit + " records, total records found - " + offlineData.length);
                var sliceValue = offlineData.length - voltmx.licensevar.maxSessionCountLimit;
                offlineData = offlineData.slice(sliceValue);
            }
            voltmx.ds.save(offlineData, "konyOfflineAccessData");
            voltmx.license.log("offlineData saved");
        };

        voltmx.license.getStoredSession = function(){
            return voltmx.ds.read("konyOfflineAccessData");
        };
            
        voltmx.license.sendNewIST = function() {
            voltmx.license.createSession();
            voltmx.license.pushVoltmxSessionsToServer(true);           
        }

        /*
         *  Name      : voltmx.license.handleISTInvocation
         *  Author    : KH2293
         *  Purpose   : handles whether or not to invoke the IST call based on session type and other parameters
         */
        voltmx.license.handleISTInvocation = function(sessionURL, input, options) {
                var storedSessions = voltmx.license.getStoredSession();
                if((!voltmx.licensevar.isInteractive && storedSessions && (storedSessions.length >= voltmx.licensevar.maxDeferSessionCount)) || voltmx.licensevar.isInteractive) {
                   voltmx.license.invokeIST(sessionURL, input, voltmx.license.licenseUsageServiceSuccessCallback, voltmx.license.licenseUsageServiceFailureCallback, options);
                } else {
                   voltmx.licensevar.isISTNetworkCallProcessingInProgress = false;
                }
        }

        /*
         *  Name      : voltmx.license.licenseUsageServiceSuccessCallback
         *  Author    : KH2321
         *  Purpose   : handles the success behaviour of IST call and clear the offline stored failed sid
         */
        voltmx.license.licenseUsageServiceSuccessCallback = function (result){
                voltmx.licensevar.isISTNetworkCallProcessingInProgress = false;
                voltmx.license.log("launch dates sent successfully. result - "+JSON.stringify(result));
                //If launchDetails are successfully logged at server. Removing offline access details.
                voltmx.ds.remove("konyOfflineAccessData");
                voltmx.ds.remove("konyOfflineSessionsCount");
        }

        /*
         *  Name      : voltmx.license.licenseUsageServiceFailureCallback
         *  Author    : KH2321
         *  Purpose   : handles the error behaviour of IST call and stores failed sid
         */
        voltmx.license.licenseUsageServiceFailureCallback = function(result)
        {       
                voltmx.licensevar.isISTNetworkCallProcessingInProgress = false;
                voltmx.license.log("launch dates weren't sent successfully. result - "+JSON.stringify(result));
                //Storing offline access time details in case of network/service issues.
                var count, offlineCount;
                //Storing the offline sessions count.
                offlineCount = voltmx.ds.read("konyOfflineSessionsCount");
                if (offlineCount === undefined || offlineCount === null || offlineCount.length < 1) {
                    offlineCount = new Array();
                    offlineCount.push(1);
                } else if (!(offlineCount[0] >= 500)) {
                    //Stop updating the count if greater than 500
                    count = offlineCount[0] + 1;
                    offlineCount[0] = count;
                }
                voltmx.ds.save(offlineCount, "konyOfflineSessionsCount");
            }

        voltmx.license.captureVoltmxLicenseUsage = function(newLaunch) {
            // we are maintaining this for FP app made on earlier release for backward compatibility
            voltmx.license.pushVoltmxSessionsToServer(newLaunch);
        }

        /*
         *  Name      : voltmx.license.pushVoltmxSessionsToServer
         *  Author    : None
         *  Purpose   : Makes service call for session tracking if the app is built with cloud environment and last access is made 30 minutes ago.
         *              Sends required tracking keys for the service.
         */
        voltmx.license.pushVoltmxSessionsToServer = function(newLaunch) {
                voltmx.license.log("capturing license information..");
                //Count session only if the time difference between last access and current access is more than 1 minute (30 minutes)
                var nowDate, lastDate, diff, sessionURL;
                var timeCheck = 1800000;
                var isNewSession = true;
                if (newLaunch === undefined || newLaunch === null) {
                    newLaunch = false;
                } else if (newLaunch !== true) {
                    newLaunch = false;
                }
                if (voltmx.license.isCloud() === false) {
                    voltmx.license.log("session tracking is turned off");
                    isNewSession = false;
                }
                if (voltmx.ds.read("konyLastAccessTime") !== undefined && voltmx.ds.read("konyLastAccessTime") !== null) {
                    nowDate = new Date();
                    lastDate = new Date(voltmx.ds.read("konyLastAccessTime")[0]);
                    diff = nowDate.getTime() - lastDate.getTime();
                    if (diff < timeCheck && newLaunch === false) {
                        isNewSession = false;
                    } else {
                        voltmx.ds.remove("konyLastAccessTime");
                    }
                }

                if (isNewSession === true) {
                    var input = {};
                    var options = {};
                    if (deviceInfo.name !== "thinclient") {
                        options["httpRequestOptions"] = [];
                        options["httpRequestOptions"]["timeoutIntervalForRequest"]=60;  
                    }
                    sessionURL = getLicenseUrl();
                    input.konyreportingparams = JSON.stringify(voltmx.license.appendLicenseTrackingKeys("session"),null);
                    options["disableIntegrity"] = true;
                    if(input.konyreportingparams !== "{}"){
                    	voltmx.license.handleISTInvocation(sessionURL, input, options);
                    }
                }
        }

        /*
         *  Name      : voltmx.license.backgroundTimeCapture
         *  Author    : None
         *  Purpose   : Stores the time stamp when app is sent to background.
         */
        voltmx.license.backgroundTimeCapture = function() {
                voltmx.license.log("app is going to background..");
                if (voltmx.license.isCloud() === true) {
                    var accessDetails = new Array();
                    accessDetails.push(new Date().toString());
                    voltmx.ds.save(accessDetails, "konyLastAccessTime");
                }
        }

        /*
         *  Name      : voltmx.license.clearLastAccess
         *  Author    : None
         *  Purpose   : Clears last access details on the termination of app.
         */
        voltmx.license.clearLastAccess = function() {
                voltmx.license.log("clear last access..");
                if (voltmx.license.isCloud() === true) {
                    voltmx.ds.remove("konyLastAccessTime");
                }
        }

        /*
         *  Name      : voltmx.license.setAppCallbacksOverride
         *  Author    : None
         *  Purpose   : Overrides the API setApplicationCallbacks. Prepends onforeground, onbackground and onappterminate events with required
         *              session tracking methods.
         */
        voltmx.license.setAppCallbacksOverride = function() {
                voltmx.license.log("overriding voltmx.application.setApplicationCallbacks..");
                var oldImplementation = voltmx.application.setApplicationCallbacks;

                function newImplementation(eventsDefinition) {
                    if (voltmx.license.isCloud() === true) {
                        if (eventsDefinition !== undefined && eventsDefinition !== null) {
                            if (eventsDefinition.onforeground !== undefined && eventsDefinition.onforeground !== null) {
                                var userForeFunction = eventsDefinition.onforeground;
                                var newForeFunction = function() {
                                    if(voltmx.licensevar.didAppWentInBackground === true){
                                        voltmx.license.pushVoltmxSessionsToServer(false);
                                    }
                                    if (deviceInfo.name !== "thinclient " && typeof(voltmx.sync) !== "undefined") {
                                        voltmx.sync.isAppInBackground = false;
                                    }
                                    voltmx.licensevar.didAppWentInBackground = false;
                                    userForeFunction();
                                };
                                eventsDefinition.onforeground = newForeFunction;
                            }
                            if (eventsDefinition.onbackground !== undefined && eventsDefinition.onbackground !== null) {
                                var userBackFunction = eventsDefinition.onbackground;
                                var newBackFunction = function() {
                                    voltmx.licensevar.didAppWentInBackground = true;
                                    voltmx.license.backgroundTimeCapture();
                                    if (typeof(voltmx.sdk) !== "undefined" && typeof(voltmx.sdk.metric) !== "undefined") {
                                        voltmx.sdk.metric.saveInDS();
                                    }
                                    if (deviceInfo.name !== "thinclient " && typeof(voltmx.sync) !== "undefined") {
                                        voltmx.sync.isAppInBackground = true;
                                    }
                                    userBackFunction();
                                };
                                eventsDefinition.onbackground = newBackFunction;
                            }
                            if (eventsDefinition.onappterminate !== undefined && eventsDefinition.onappterminate !== null) {
                                var userTerminateFunction = eventsDefinition.onappterminate;
                                var newTerminateFunction = function() {
                                    voltmx.license.clearLastAccess();
                                    if (typeof(voltmx.sdk) !== "undefined" && typeof(voltmx.sdk.metric) !== "undefined") {
                                        voltmx.sdk.metric.saveInDS();
                                    }
                                    userTerminateFunction();
                                };
                                eventsDefinition.onappterminate = newTerminateFunction;
                            }
                        }
                    }
                    return oldImplementation(eventsDefinition);
                }
                voltmx.application.setApplicationCallbacks = newImplementation;
                if (deviceInfo.name !== "thinclient ") {
                    var callbackEvents = {
                        onforeground: function() {},
                        onbackground: function() {},
                        onappterminate: function() {}
                    };

                    voltmx.application.setApplicationCallbacks(callbackEvents);
                }
        }

        /*
         *  Name      : voltmx.license.invokeServiceAsyncOverride
         *  Author    : None
         *  Purpose   : Overrides the API invokeServiceAsync. Appends tracking keys to the input param.
         */
        voltmx.license.invokeServiceAsyncOverride = function() {
                voltmx.license.log("overriding voltmx.net.invokeServiceAsync..");
                var oldImplementation = voltmx.net.invokeServiceAsync;

                function newImplementation(url, input, callback, config, requestType, reportData) {
                    if (voltmx.license.isCloud() === true) {
                        if (input === undefined || input === null) {
                            input = {};
                        }
                        if (input !== undefined && input !== null && !isGetRequest(input)) {
                            if (requestType !== undefined && requestType !== null) {
                                input.konyreportingparams = processVoltmxReportingParams(input.konyreportingparams, requestType, reportData);
                            } else {
                                input.konyreportingparams = processVoltmxReportingParams(input.konyreportingparams, null, null);
                            }
                        }
                    }
                    return oldImplementation(url, input, callback, config);

                    function processVoltmxReportingParams(params, requestType, reportData) {
                        var params2 = voltmx.license.appendLicenseTrackingKeys(requestType, reportData);
                        if (!params) {
                            return JSON.stringify(params2);
                        } else {
                            try {
                                if (typeof(params) === "string") {
                                    params = JSON.parse(params);
                                }
                                for (var key in params2) {
                                    if (typeof(params[key]) === "undefined") {
                                        params[key] = params2[key];
                                    }
                                }
                                return JSON.stringify(params);
                            } catch (e) {
                                voltmx.license.log("unable to parse params " + params);
                                return JSON.stringify(params2);
                            }


                        }
                    }

                    function isGetRequest(inputParams) {
                        if (inputParams && inputParams.httpconfig && inputParams.httpconfig.method && inputParams.httpconfig.method === "get") {
                            return true;
                        }
                        return false;
                    }
                }
                voltmx.net.invokeServiceAsync = newImplementation;
        }

        /*
         *  Name      : voltmx.license.invokeServiceSyncOverride
         *  Author    : None
         *  Purpose   : Overrides the API invokeServiceSync. Appends tracking keys to the input param.
         */
        voltmx.license.invokeServiceSyncOverride = function() {
                voltmx.license.log("overriding voltmx.net.invokeServiceSync..");
                var oldImplementation = voltmx.net.invokeServiceSync;

                function newImplementation(url, input, isblocking) {
                    if (voltmx.license.isCloud() === true) {
                        if (input === undefined || input === null) {
                            input = {};
                        }
                        if (input !== undefined && input !== null) {
                            input.konyreportingparams = JSON.stringify(voltmx.license.appendLicenseTrackingKeys(null));
                        }
                    }
                    return oldImplementation(url, input, isblocking);
                }
                voltmx.net.invokeServiceSync = newImplementation;
        }

        //The below function gets defined only in thinclient channels due to APPPLT-7291
        if (voltmx.os.deviceInfo().name === voltmx.license.constants.THIN_CLIENT) {
            /**
             * This function reads post app init argument and tries to find
             * for availability of code in params for recovery against last session.
             * In case of non-availability , this function cleans any stored resuable session
             * @param eventObject
             * @returns {boolean}
             */
            voltmx.license.doesLaunchParamsHaveCode = function (eventObject) {
                voltmx.license.log("Entering doesLaunchParamsHaveCode");
                var isCodePresentInQueryParams = !voltmx.license.isNullOrUndefined(eventObject)
                                                 && !voltmx.license.isNullOrUndefined(eventObject[voltmx.license.constants.LAUNCH_PARAMS])
                                                 && !voltmx.license.isNullOrUndefined(eventObject[voltmx.license.constants.LAUNCH_PARAMS].code);

                if (!isCodePresentInQueryParams) {
                    voltmx.license.log("code was not present in launch params");
                    voltmx.license.removeReusableSession();
                }

                voltmx.license.log("code was present in launch params");
                return isCodePresentInQueryParams;
            }

            /**
             * This function saves current session to be used in next continued app launch for login
             */
            voltmx.license.saveCurrentSessionForReuse = function () {
                voltmx.license.log("Entering saveCurrentSessionForReuse");
                var singleStoredSession = [voltmx.licensevar.currentSessionId];
                voltmx.ds.save(singleStoredSession, voltmx.license.constants.REUSABLE_SESSION_ID);
            }

            /**
             * This function does following function
             * 1.consume previously saved session in last launch & notify all listeners with this session
             * always cleans any stored resuable session
             * @returns {boolean} returns true if session was restored successfully
             */
            voltmx.license.reuseLastSession = function () {
                voltmx.license.log("Entering reuseLastSession");
                var wasAbleToReuseLastSession = false;
                var singleStoredSession = voltmx.ds.read(voltmx.license.constants.REUSABLE_SESSION_ID);

                if (!voltmx.license.isNullOrUndefined(singleStoredSession)
                    && !voltmx.license.isNullOrUndefined(singleStoredSession[0]))
                {
                    voltmx.license.log("successfully reused session");
                    voltmx.license.prepare4HoursTimer();
                    voltmx.licensevar.currentSessionId = singleStoredSession[0];
                    voltmx.license.notifyChangesToListeners();
                    wasAbleToReuseLastSession = true;
                    voltmx.license.schedule4HoursTimer();
                }

                voltmx.license.removeReusableSession();
                return wasAbleToReuseLastSession;
            }

            /**
             * This function removes single stored session from storage for clean up
             */
            voltmx.license.removeReusableSession = function (){
                voltmx.license.log("removing reusable session");
                voltmx.ds.remove(voltmx.license.constants.REUSABLE_SESSION_ID);
            }
        }


        /**
         * This function primarily sets session id & capture app launch event
         * @param postAppInitArgument
         */
        voltmx.license.prepareLicenseSessionOnPostAppInit = function (postAppInitArgument) {
            voltmx.license.log("Entering prepareLicenseSessionOnPostAppInit");
            /* MFSDK-4266 Saving app launch key-value to detect
            application launch to reset locks on application reload
            */
            voltmx.ds.save([true], voltmx.licensevar.appLaunch);

            //only for thinclient channels e.g SPA,DW
            if (voltmx.os.deviceInfo().name === voltmx.license.constants.THIN_CLIENT
                && voltmx.license.doesLaunchParamsHaveCode(postAppInitArgument))
            {
                var wasAbleToReuseLastSession =  voltmx.license.reuseLastSession();
                if(wasAbleToReuseLastSession){
                    voltmx.license.log("last session reused inside postappinit");
                    return;
                }
            }

            //sdk will not create session any more since we have to avoid creating session when SPA app is relaunched for single window login
            //license will be self sufficient to create session on post-app init from now on
            voltmx.license.log("creating new session inside postappinit");
            voltmx.license.createSession();
            
            voltmx.license.pushVoltmxSessionsToServer(true);
        }

        /*
         *  Name      : voltmx.license.setAppInitializationEventsOverride
         *  Author    : None
         *  Purpose   : Overrides the API setApplicationInitializationEvents. Prepends postappinit event with required session tracking method.
         *              If postappinit is undefiend, sets postappinit with required session tracking method.
         */
        voltmx.license.setAppInitializationEventsOverride = function() {
                var oldImplementation = voltmx.application.setApplicationInitializationEvents;
                function newImplementation(eventsDefinition) {
                    voltmx.license.log("setApplicationInitializationEvents events " + eventsDefinition);
                    voltmx.licensevar.isPostAppInitCalled = true;
                    if (voltmx.license.isCloud() === true) {
                        if (eventsDefinition !== undefined && eventsDefinition !== null) {
                            var userFunction = eventsDefinition.postappinit;
                            if (!voltmx.license.isNullOrUndefined(userFunction)) {
                                var wrapperPostAppInit = function (postAppInitArgument) {
                                    voltmx.license.prepareLicenseSessionOnPostAppInit(postAppInitArgument);
                                    var userForm = userFunction.apply(this,arguments);
                                    if (userForm !== undefined || userForm !== null) {
                                        return userForm;
                                    }
                                };
                                eventsDefinition.postappinit = wrapperPostAppInit;
                            } else {
                                eventsDefinition.postappinit = voltmx.license.prepareLicenseSessionOnPostAppInit;
                            }
                            
                            /*The below function gets defined only in thinclient channels due to APPPLT-7291
                            Below function defines appServiceAsync function, the license.js will be able to know
                            whether app was launched with code as launch params, and will ask sdk to do login.
                            The sdk will perform login and send result to license.
                            License would append login result in appServiceAsync eventObject
                             */
                            if (voltmx.os.deviceInfo().name === voltmx.license.constants.THIN_CLIENT) {
                                function doLoginWithCode(appServiceEventObjectArgument, doneCallback) {
                                    voltmx.license.log("Entering doLoginWithCode");
                                    if (!voltmx.license.doesLaunchParamsHaveCode(appServiceEventObjectArgument)) {
                                        voltmx.license.log("no code launch param found, skipping login for same window login");
                                        doneCallback();
                                    } else {
                                        voltmx.license.log("code launch param found, requesting sdk to complete login");
                                        var code = appServiceEventObjectArgument[voltmx.license.constants.LAUNCH_PARAMS].code;
                                        voltmx.sdk.completeSingleWindowLogin(code, doneCallback);
                                    }
                                }

                                var appServiceAsyncFunction = function (appServiceEventObjectArgument, callback) {
                                    voltmx.license.log("Entering appServiceAsyncFunction");
                                    doLoginWithCode(appServiceEventObjectArgument, function (loginResponse) {
                                        if (!voltmx.license.isNullOrUndefined(loginResponse)) {
                                            voltmx.license.log("appending loginResponse in eventObject");
                                            appServiceEventObjectArgument.loginResponse = loginResponse;
                                        }

                                        voltmx.license.log("Exiting appServiceAsyncFunction");
                                        callback(appServiceEventObjectArgument);
                                    })
                                };
                                
                                eventsDefinition.appServiceAsync = appServiceAsyncFunction;
                            }
                        }
                    }
                    return oldImplementation(eventsDefinition);
                }
                voltmx.application.setApplicationInitializationEvents = newImplementation;
        }
        /*
         *  Name      : voltmx.license.apiOverride
         *  Author    : None
         *  Purpose   : Sets initial application callbacks. Calls the API overriding functions
         */
       voltmx.license.apiOverride =function() {
                voltmx.license.log("Entering apiOverride..");
                //Overriding APIs
                if (deviceInfo.name !== "thinclient") {
                    voltmx.license.setAppCallbacksOverride();
                } else {
                    //in SPA/DW voltmx.application.addApplicationCallbacks function is a stub.
                    voltmx.licensevar.isInteractive = true;
                }
                voltmx.license.invokeServiceAsyncOverride();
                voltmx.license.invokeServiceSyncOverride();
                voltmx.license.setAppInitializationEventsOverride();
        }

        voltmx.license.apiOverride();
        voltmx.application.addApplicationCallbacks(voltmx.licensevar.callbacksObjList);
        if (deviceInfo.name !== "thinclient") {
            Object.seal(voltmx.license);
            Object.freeze(voltmx.license);
        }
        voltmx.license.log("license loading completed");
}

//License Network Layer
voltmx.license.invokeIST = function(url, params, successCallback, failureCallback, options) {
    if(typeof(url)==="undefined" || url === undefined || url === null || url === ""){
        failureCallback("license url can't be null or empty");
        return;
    }

    var headers = {"Content-Type":"application/x-www-form-urlencoded"};
    //voltmx.sdk can be undefined in case where sdk is absent in project eg.(fp apps of 7.x versions) or unable to load
    if(voltmx.hasOwnProperty("sdk") && voltmx.sdk.getCurrentInstance && voltmx.sdk.getCurrentInstance()){
        url = voltmx.sdk.getCurrentInstance().appendGlobalParams(url, headers, params);
    }

    var httpRequest = new voltmx.net.HttpRequest();
    if(options && options["httpRequestOptions"] && options["httpRequestOptions"] instanceof Object && options["httpRequestOptions"]["timeoutIntervalForRequest"]){
        httpRequest.timeout = options["httpRequestOptions"]["timeoutIntervalForRequest"] * 1000;
    }
    httpRequest.open("POST", url);

    function localRequestCallback(result) {
        var readyState = Number(httpRequest.readyState.toString());
        var status = Number(httpRequest.status.toString());
        voltmx.license.log("localRequestCallback in state :"+readyState+" with status :"+status);
        var response = null;
        if (readyState === 4) {
            var isFailure = true;
            if ((status >= 200 && status < 300)|| status === 504) {
                if (status!== 504){
                    try{
                        response = JSON.parse(JSON.stringify(httpRequest.response)); //copying response
                        if(typeof(response) === "string"){
                            response = JSON.parse(response);	
                        }
                        response.url = url;
                        if(response && (typeof(response.opstatus) === "undefined" || response.opstatus == 0)){
                            isFailure = false;
                        }
                    } catch (e){
                        voltmx.license.log("error while extracting response :"+e);
                    } 
                } else{
                    isFailure = false;
                }
            }
            if( isFailure === true){
                var errorResponse = {
                    "error": "failure in sending IST call with status as :" + status,
                    "url" : url
                };
                failureCallback(errorResponse);
            } else{
                successCallback(response);
            }
        }
    }

    //setting params
    paramsTable = new voltmx.net.FormData();
    for (var key in params) {
        if (typeof(params[key]) != "undefined") {
            if (typeof(params[key]) !== "string") {
                params[key] = JSON.stringify(params[key]);
            }
            paramsTable.append((key), (params[key]));
        }
    }
    voltmx.license.log("paramsTable formed is "+paramsTable.toString());
    //setting headers
    for (var headerKey in headers ) {
        if(headers.hasOwnProperty(headerKey)){
            httpRequest.setRequestHeader(headerKey , headers[headerKey]);
        }
    }   
    //setting listener
    httpRequest.onReadyStateChange = localRequestCallback;
    //disabling integrity as integrity is never supported in IST,
    //for consistency we should also not send req headers containing integrity headers even though the headers will be ignored by MW
    //This should have been done as a part of MFSDK-4957
    if (httpRequest.hasOwnProperty("disableIntegrityCheck")) {
        httpRequest.disableIntegrityCheck = true;
    }
    //sending IST
    httpRequest.send(paramsTable);
    
}


function cloudSessionCallback() {
    voltmx.license.log("Cloud session timed out.");
    voltmx.ds.remove("konyLastAccessTime");
    voltmx.ds.remove("konyUUID");
    voltmx.ds.remove("konyCustomReportData");
    voltmx.ds.remove("konyOfflineAccessData");
    voltmx.license.pushVoltmxSessionsToServer();
    voltmx.cloud.appevents.unregisterforidletimeout();
    voltmx.cloud.appevents.registerforidletimeout(30, cloudSessionCallback);
}

voltmx.license.startLicenseService();


